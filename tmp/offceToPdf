# excel_print_debug.ps1
# ------------------------------------------------------------------------------------
# 目的:
#   既存アプリが行っている Excel -> PDF 変換時のレイアウト調整ロジックを
#   PowerShell 単体で再現し、デバッグ用に直接実行できるようにするスクリプトです。
#
# 機能:
#   - Excel を COM (Excel.Application) で起動
#   - A4／余白極小／ヘッダフッタ削除／UsedRange からコンテンツ実寸を取得
#   - 縦横それぞれの印刷可能領域に対する縮小率を計算し、より大きく出せる向きを自動選択
#   - 1シート=1ページ（FitToPagesWide=1, FitToPagesTall=1）
#   - PDF 出力 または そのまま印刷 を選択可能（処理ロジックは共通）
#
# 使い方(例):
#   PDF出力:
#     powershell -NoProfile -ExecutionPolicy Bypass -File .\excel_print_debug.ps1 `
#       -InputPath "C:\path\sample.xlsx" -OutputPath "C:\temp\out.pdf" -Action Pdf -Verbose
#
#   そのまま印刷(既定プリンター):
#     powershell -NoProfile -ExecutionPolicy Bypass -File .\excel_print_debug.ps1 `
#       -InputPath "C:\path\sample.xlsx" -Action Print -Verbose
#
# 注意:
#   - Windows + Microsoft Excel がインストールされた環境が必要です。
#   - 印刷時は既定プリンターに出ます（-PrinterName を明示指定可）。
# ------------------------------------------------------------------------------------

[CmdletBinding()]
param(
  # 入力する Excel ブック（.xls/.xlsx）
  [Parameter(Mandatory=$true)]
  [string]$InputPath,

  # 出力する PDF パス（Action=Pdf のとき必須）
  [string]$OutputPath,

  # 実行モード: 'Pdf' または 'Print'
  [ValidateSet('Pdf','Print')]
  [string]$Action = 'Pdf',

  # 印刷時に使用するプリンター名（省略時は既定プリンター）
  [string]$PrinterName
)

# --- 形状(印刷対象)を含めた「実効コンテンツ外接矩形」と PrintArea 範囲を求めるユーティリティ ---
function Get-EffectiveContentBox {
  param(
    [Parameter(Mandatory=$true)]
    $ExcelApp,        # Excel.Application（Union呼び出し等に使う）
    [Parameter(Mandatory=$true)]
    $Worksheet        # 対象ワークシート
  )

  # 1) UsedRange（セル上のデータや書式）由来の外接矩形（pt）
  $used = $Worksheet.UsedRange
  $hasUsed = $false
  $minLeft  = [double]::PositiveInfinity
  $minTop   = [double]::PositiveInfinity
  $maxRight = [double]::NegativeInfinity
  $maxBottom= [double]::NegativeInfinity

  # PrintArea を組むためのセル範囲（後で図形のアンカーセルも取り込む）
  $printRange = $null

  if ($used -ne $null) {
    $hasUsed  = $true
    $minLeft  = [double]$used.Left
    $minTop   = [double]$used.Top
    $maxRight = [double]$used.Left  + [double]$used.Width
    $maxBottom= [double]$used.Top   + [double]$used.Height

    # UsedRange のセル矩形を起点に（Addressは後でまとめて組むので、まずはRangeオブジェクトで持つ）
    $printRange = $used
  }

  # 2) 図形（Shapes）のうち「印刷対象（PrintObject=True）かつ表示中」のものを外接に取り込む
  foreach ($shape in @($Worksheet.Shapes)) {
    try {
      # Visible は -1 が True、0 が False（msoTrue/msoFalse）
      if ($shape.PrintObject -and $shape.Visible -ne 0 -and $shape.Width -gt 0 -and $shape.Height -gt 0) {
        # 点単位の外接更新
        $minLeft   = [Math]::Min($minLeft,  [double]$shape.Left)
        $minTop    = [Math]::Min($minTop,   [double]$shape.Top)
        $maxRight  = [Math]::Max($maxRight, [double]$shape.Left + [double]$shape.Width)
        $maxBottom = [Math]::Max($maxBottom,[double]$shape.Top  + [double]$shape.Height)

        # PrintArea 用に、形状のアンカーセル範囲を UsedRange と Union
        # TopLeftCell/BottomRightCell は Range を返すので、その矩形を Union に足す
        $tl = $shape.TopLeftCell
        $br = $shape.BottomRightCell
        if ($tl -ne $null -and $br -ne $null) {
          $shapeCells = $Worksheet.Range($tl, $br)
          $printRange = if ($printRange -ne $null) {
            $ExcelApp.Union($printRange, $shapeCells)
          } else {
            $shapeCells
          }
        }
      }
    } catch {
      # 取得不可の形状タイプ等は黙ってスキップ（グループ化ShapeなどもLeft/Topは基本OK）
    }
  }

  # 3) UsedRange も図形も無い場合（完全空白シート）
  if ([double]::IsInfinity($minLeft) -or [double]::IsInfinity($minTop)) {
    return [pscustomobject]@{
      WidthPt        = 0.0
      HeightPt       = 0.0
      PrintAreaRange = $null
    }
  }

  # 4) 結果を返す
  $widthPt  = [Math]::Max(0.0, $maxRight - $minLeft)
  $heightPt = [Math]::Max(0.0, $maxBottom - $minTop)

  return [pscustomobject]@{
    WidthPt        = $widthPt
    HeightPt       = $heightPt
    PrintAreaRange = $printRange  # 後段で PageSetup.PrintArea に適用する用
  }
}


# --- 基本設定（UTF-8出力 & 例外で停止） ---
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$ErrorActionPreference = 'Stop'

# --- 前提チェック ---
if (-not (Test-Path -LiteralPath $InputPath)) {
  throw "ファイルが存在しません: $InputPath"
}
$ext = [System.IO.Path]::GetExtension($InputPath).ToLowerInvariant()
if (@('.xls','.xlsx') -notcontains $ext) {
  throw "Excel ファイルではありません（.xls/.xlsx のみ対応）: $InputPath"
}
if ($Action -eq 'Pdf' -and [string]::IsNullOrWhiteSpace($OutputPath)) {
  throw "Action=Pdf の場合は -OutputPath を指定してください。"
}

Write-Verbose "InputPath  : $InputPath"
if ($Action -eq 'Pdf') { Write-Verbose "OutputPath : $OutputPath" }
Write-Verbose "Action     : $Action"
if ($PrinterName) { Write-Verbose "Printer    : $PrinterName" }

# --- 数値・定数（Excel の単位はポイント基準。1inch=72pt） ---
# 余白( inch )
$MARGIN_IN  = 0.15
$HEADER_IN  = 0.0
$FOOTER_IN  = 0.0

# A4 (inch)
$A4WidthIn  = 8.27
$A4HeightIn = 11.69

# Excel 定数（数値）
$xlPaperA4   = 9
$xlPortrait  = 1
$xlLandscape = 2

# --- 縮小率を計算して 1.0 を超えないようにクリップする関数 ---
function Get-Scale([double]$contentW, [double]$contentH, [double]$pageW, [double]$pageH) {
  if ($contentW -le 0 -or $contentH -le 0 -or $pageW -le 0 -or $pageH -le 0) { return 0.0 }
  $scaleX = $pageW / $contentW
  $scaleY = $pageH / $contentH
  $s = [Math]::Min($scaleX, $scaleY)
  if ($s -gt 1.0) { return 1.0 } else { return $s }
}

try {
  # --- Excel 起動 ---
  $excel = New-Object -ComObject Excel.Application
  $excel.Visible = $false
  $excel.DisplayAlerts = $false

  try {
    # --- ブックを ReadOnly で開く ---
    $workbook = $excel.Workbooks.Open($InputPath, $null, $true)

    # ポイント換算
    $A4WidthPtPortrait   = $excel.InchesToPoints($A4WidthIn)
    $A4HeightPtPortrait  = $excel.InchesToPoints($A4HeightIn)
    $A4WidthPtLandscape  = $A4HeightPtPortrait
    $A4HeightPtLandscape = $A4WidthPtPortrait

    $MARGIN_PT = $excel.InchesToPoints($MARGIN_IN)
    $HEADER_PT = $excel.InchesToPoints($HEADER_IN)
    $FOOTER_PT = $excel.InchesToPoints($FOOTER_IN)

    foreach ($worksheet in $workbook.Worksheets) {
      try {
        # ワークシートのみ対象（Chart等はスキップ）
        # 既存実装と同様、Interop の列挙体を参照（環境により null になる場合は try/catch）
        if ($worksheet.Type -ne [Microsoft.Office.Interop.Excel.XlSheetType]::xlWorksheet.value__) { continue }

        $ps = $worksheet.PageSetup

        # 余白を極小に
        $ps.LeftMargin   = $MARGIN_PT
        $ps.RightMargin  = $MARGIN_PT
        $ps.TopMargin    = $MARGIN_PT
        $ps.BottomMargin = $MARGIN_PT
        $ps.HeaderMargin = $HEADER_PT
        $ps.FooterMargin = $FOOTER_PT

        # ヘッダ/フッタ文字をクリア（有効領域確保）
        $ps.LeftHeader   = ""
        $ps.CenterHeader = ""
        $ps.RightHeader  = ""
        $ps.LeftFooter   = ""
        $ps.CenterFooter = ""
        $ps.RightFooter  = ""

        # 用紙サイズは A4
        $ps.PaperSize = $xlPaperA4

        # UsedRange の実寸（ポイント）
        $box = Get-EffectiveContentBox -ExcelApp $excel -Worksheet $worksheet
        $contentWidthPt  = $box.WidthPt
        $contentHeightPt = $box.HeightPt

        # 現在の余白で印刷可能領域を算出（縦・横）
        $printableWidthPortrait   = $A4WidthPtPortrait  - $ps.LeftMargin - $ps.RightMargin
        $printableHeightPortrait  = $A4HeightPtPortrait - $ps.TopMargin  - $ps.BottomMargin - $ps.HeaderMargin - $ps.FooterMargin

        $printableWidthLandscape  = $A4WidthPtLandscape  - $ps.LeftMargin - $ps.RightMargin
        $printableHeightLandscape = $A4HeightPtLandscape - $ps.TopMargin  - $ps.BottomMargin - $ps.HeaderMargin - $ps.FooterMargin

        $scalePortrait  = Get-Scale $contentWidthPt $contentHeightPt $printableWidthPortrait  $printableHeightPortrait
        $scaleLandscape = Get-Scale $contentWidthPt $contentHeightPt $printableWidthLandscape $printableHeightLandscape

        # 縮小率が大きい方 = より大きく印字できる向きを採用
        if ($scaleLandscape -gt $scalePortrait) {
          $ps.Orientation = $xlLandscape
        } else {
          $ps.Orientation = $xlPortrait
        }

        # 1シート=1ページへ強制（Zoom 無効 + 1x1）
        $ps.Zoom = $false
        $ps.FitToPagesWide = 1
        $ps.FitToPagesTall = 5

        # 視覚的に中央寄せ（任意）
        $ps.CenterHorizontally = $true
        $ps.CenterVertically   = $false

        Write-Verbose ("End print setting sheet '{0}'" -f $worksheet.Name)
      }
      catch {
        Write-Verbose ("Skip on sheet '{0}': {1}" -f $worksheet.Name, $_.Exception.Message)
      }
    }

    if ($Action -eq 'Pdf') {
      # --- PDF として保存 (xlTypePDF = 0) ---
      $xlTypePDF = 0
      $xlQualityStandard = 0
      Write-Verbose "Exporting to PDF..."
      try {
        $workbook.ExportAsFixedFormat(
          $xlTypePDF,
          $OutputPath
          #$xlQualityStandard,
          #$true,   # IncludeDocProperties
          #$false,  # IgnorePrintAreas
          #$null,   # From
          #$null,   # To
          #$false   # OpenAfterPublish
        )
      } catch {
          $hr = if ($_.Exception -and $_.Exception.HResult) { ('0x{0:X8}' -f $_.Exception.HResult) } else { '(no HResult)' }
          throw "PDF 出力に失敗しました (HRESULT=$hr): $($_.Exception.Message)`n" +
                "主な原因: 1) 出力PDFが開きっぱなし 2) 書込権限/フォルダ無し 3) 既定プリンター不正"
      }
      Write-Verbose "Export completed."
      Write-Output "SUCCESS: Excel workbook converted to PDF -> $OutputPath"
    }
    else {
      # --- そのまま印刷（既定 or 指定プリンター） ---
      if ($PrinterName) {
        $excel.ActivePrinter = $PrinterName
      }
      # 全シートを1ページ設定で印刷
      $workbook.PrintOut()
      Write-Output "SUCCESS: Excel workbook sent to printer" + ($(if($PrinterName){" ($PrinterName)"} else {""}))
    }

    # クローズ
    $workbook.Close($false)
  }
  finally {
    if ($excel) {
      try { $excel.Quit() } catch {}
      [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null
    }
  }
}
catch {
  Write-Error ("ERROR: {0}" -f $_.Exception.Message)
  exit 1
}
finally {
  [System.GC]::Collect()
  [System.GC]::WaitForPendingFinalizers()
}
