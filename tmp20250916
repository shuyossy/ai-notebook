// (1) 行末空白の削除  — 末尾の Zs（全てのUnicode空白）と Cf（ZWSP等）を丸ごと削除
// 旧: /[ \t\u00A0\u3000]+$/u
current = current.replace(/(?:[\p{Zs}\t]|\p{Cf})+$/gu, '');

// (2) 連続空白の圧縮 — 圧縮対象を Zs（全Unicode空白）+ タブに拡張
// 旧: /[ \t\u00A0\u3000]{2,}/gu
const SPACE_RUN = /[\p{Zs}\t]{2,}/gu;
if (policy.collapseConsecutiveWhitespaces) {
  if (policy.collapsePreserveIndent) {
    const indentMatch = current.match(/^[\p{Zs}\t]*/u);   // 旧: /^[ \t\u00A0\u3000]*/u
    const indent = indentMatch ? indentMatch[0] : '';
    const rest = current.slice(indent.length);
    current = indent + rest.replace(SPACE_RUN, ' ');
  } else {
    current = current.replace(SPACE_RUN, ' ');
  }
}

// (3) カンマのみ行の削除 — Zs/Cf を無視して判定
// 旧: /^[ \t\u00A0\u3000]*(?:,[ \t\u00A0\u3000]*)+$/u
if (policy.removeCommaOnlyLines) {
  const commaOnly = /^[\p{Zs}\p{Cf}]*(?:,[\p{Zs}\p{Cf}]*)+$/u;
  if (commaOnly.test(current)) current = '';
}

// (4) 空白のみ行→空行 — Zs/Cf を空白扱いに
// 旧: /^[ \t\u00A0\u3000]+$/u
if (/^[\p{Zs}\p{Cf}]+$/u.test(current)) {
  current = '';
}
