diff --git a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl
index 6b30e8cde..58732acda 100644
Binary files a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl and b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl differ
diff --git a/.vscode/settings.json b/.vscode/settings.json
index a96c6ef9a..827aa5272 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -32,4 +32,14 @@
     "type": "on-demand",
     "coverage": true
   },
+
+  // プロジェクト同梱のTSを使う（tsconfigに従わせるための安定策）
+  "typescript.tsdk": "node_modules/typescript/lib",
+
+  // プロジェクト全体の診断を有効化（未オープンのファイルも対象）
+  // 新しめの VSCode/TS: こちら
+  "typescript.tsserver.enableProjectDiagnostics": true,
+
+  // 古い VSCode/TS の互換（どちらか片方だけでもOK）
+  "typescript.tsserver.experimental.enableProjectDiagnostics": true
 }
diff --git a/CLAUDE.md b/CLAUDE.md
index 6f951b324..18a27bcb8 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -105,15 +105,25 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
 - 環境変数とランタイム設定の分離
 
 ### その他代表的なフォルダ・ファイル
-- `src/main/types`：アプリで利用する型・zodスキーマの定義
-  - `index.ts`：アプリ全体で利用する型定義
-  - `ipc.ts`：Electron IPC通信で利用する型定義
+- `src/types`：アプリで利用する型・zodスキーマの定義
+  - `src/types/index.ts`：アプリ全体で利用する型定義のエントリーポイント（ただし、個別の機能等で型を定義する場合は各機能ディレクトリに作成しているので別途参照が必要）
+  - `src/types/ipc.ts`：Electron IPC通信で利用する型定義
+  - `src/types/eventPush.ts`: Main側からのイベントプッシュで利用する型定義
+- `src/db`: データベース定義（スキーマやDB接続情報）
+- `src/repository`: データアクセス層
 - `src/main`: Electronのメインプロセス関連のコード
   - `src/main.ts`: Electronのメインプロセスのエントリポイント、IPC通信のハンドラの具体的な処理の定義やアプリケーションの初期化処理などを含む
-  - `src/main/preload`: ElectronのPreloadスクリプト、レンダラープロセスに公開するハンドラを定義
+  - `src/main/preload.ts`: ElectronのPreloadスクリプト、レンダラープロセスに公開するハンドラを定義(rendererとの境界にあたるため、ここで一元的にエラーハンドリングを実施している)
   - `src/main/store.ts`: electron-storeを利用してアプリケーションの設定や状態の保存・取得を行う、ここではstoreの初期化や設定の定義を行う
-  - `src/main/utils`: メインプロセスで利用するユーティリティ関数
-    - `src/main/utils/fileExtractor.ts`: 登録されたソースのテキスト情報を抽出する関数
+  - `src/main/push`: Main側からのイベントプッシュ関連コード
+    - `src/main/push/InProcBroker.ts`: イベントを蓄積するBroker
+    - `src/main/push/electronPushBroker.ts`: イベント購読についてelectron固有の差異を吸収するBroker
+  - `src/main/lib`: メインプロセスで利用するライブラリ群
+    - `src/main/lib/eventPayloadHelper.ts`: イベントをpushする際のヘルパーを提供
+    - `src/main/lib/logger.ts`: アプリ内で利用するロガーを提供
+    - `src/mian/lib/error.ts`: アプリで利用するエラー定義
+    - `src/main/lib/message.ts`: アプリ内で利用するメッセージテンプレートを解決し、メッセージを提供する関数を提供（メッセージテンプレートはこちら`src/messages/ja/template.ts`）
+    - `src/main/lib/utils/fileExtractor.ts`: 登録されたソースのテキスト情報を抽出する関数
 - `src/renderer/components`：Reactコンポーネント
   - `src/renderer/components/chat`: チャット機能のコンポーネント
   - `src/renderer/components/review`: レビュー機能のコンポーネント
@@ -121,8 +131,13 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
   - `src/renderer/components/common`: アプリ共通のコンポーネント
   - `src/renderer/components/sidebar`: サイドバー共通のコンポーネント
   - `src/renderer/hooks`: フック定義をまとめたディレクトリ
-  - `src/renderer/service`: フロントエンドから利用するサービス定義をまとめたディレクトリ
+    - `src/renderer/hooks/usePushChannel.ts`: イベント購読をする際に利用するフック（コンポーネントが常時通信をSSEでデータを受け取れるようにしたい場合に利用）
+    - `src/renderer/hooks/useSettings.ts`: 設定情報を利用したい場合に利用するフック
+  - `src/renderer/service`: フロントエンドから利用するサービス層で、外部アクセスロジックもここで管理する(~Api.ts)
   - `src/renderer/stores`: zustandで管理するstate定義
+    - `src/renderer/stores/alertStore.ts`: renderer側のユーザに表示するアラートメッセージを一元管理する、addAlertを公開しており、これを利用してalertを追加するとエラーを表示できる
+  - `src/renderer/lib/ElectronPushClient.ts`: 直接イベント購読したい際に利用するクライアントクラス（`usePushChannel.ts`についても内部でこのクラスを利用している、一度だけSSEでデータを受信したい場合などにも利用）
+  - `src/renderer/lib/error.ts`: Renderer側で利用するエラーの定義
 - `src/mastra`: Mastraを利用したAI関連のコード
   - `src/mastra/agents/prompt.ts`: Mastraのエージェントのプロンプト定義を一箇所に集約（エージェントやワークフロー内で利用するプロンプトを定義）
   - `src/mastra/agents/orchestrator.ts`: 汎用チャット機能で利用するAIエージェントの定義
@@ -153,3 +168,49 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
   - テストの説明は、何をテストしているのか、どのような条件でテストが行われるのかを明確に記述すること
 - テストの書き方で不明点があれば次のディレクトリ配下のテストコードを参考にすること
   - src/__tests__/integration
+
+## 実装上の注意
+- Mastraについては実装する際はまずMCPでドキュメントや実装例を参考にしてから正確な情報やベストプラクティスに基づいてコーディングすること
+- Mastra workflowの作成時は既存のスタイルを踏襲すること
+- プロジェクト全体を把握して、全ての実装が必要箇所を正しく洗い出してから実装すること
+- 既存資源（型情報やコンポーネントなど）を積極的に活用して効率的に実装すること
+  - 既存のコードの修正は真に必要な場合に限ること
+- UIは実際に市場に投入できるくらいレベルの高いUIにすること
+- TypeScriptを利用して型安全なコードにすること
+- プロンプトは英語で記載すること
+  - プロンプトの内容は経験豊富なプロンプトエンジニアとしてベストプラクティスに基づいて実装すること
+  - 一般的で自然な英語表現にすること
+- コードのコメントは日本語で記載すること
+- Reactライブラリが使えるのであれば積極的に利用すること
+    - 特にUIについてはMUIを第一優先に使い、カスタマイズしたい場合はshadcn/uiを利用すること
+    - ライブラリを追加する際は安定稼働バージョンを採用すること
+- eslintについては単純なフォーマットエラーの場合は対応する必要はない
+- IDEからエラー内容を読み取り、必要があれば確り対応すること
+- MainプロセスでのIPC処理について、`src/main.ts`のhandleIpcにてエラーを一元管理しているため、IPCハンドラ内のサービスロジックにおいては基本的にはエラーをtry-catchしてハンドリングする必要はない
+  - ただし、ユーザにエラーメッセージを通知する必要がある場合は適切なエラーハンドリングの下、`src/mian/lib/error.ts`にて提供されているAppErrorをthrowすること
+- フロントエンドから外部（IPC）通信する場合は`src/renderer/service/~Api.ts`を経由すること
+  - 新規にサービスクラスを作成する場合は既存ロジックを参考にして作成すること
+- サーバからイベントをpushする際は`src/main/lib/eventPayloadHelper.ts`を利用すること
+- フロントエンドでイベントを購読する際は`usePushChannel`もしくは`ElectronPushClient`を利用すること
+  - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
+- フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
+- このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
+- テストについては指示されない限り、実行も修正もしなくてよい
+
+## 現在実施中のタスク
+大規模リファクタリング
+目的:
+- コード保守性・移植性向上
+※
+本アプリは将来的にwebアプリに移植する可能性があるため
+
+## 依頼タスク
+- エラー処理の見直し
+  - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されない
+    - それにも関わらず、ユーザに通知すべきエラーで生のthrow new Error(~)してしまっている場合が散見される
+    - Main側、Renderer側それぞれで、上記のようなケースを全て見つけ出し、修正してください 
+      - 見つけ出してinternalErrorビルダを利用して作成したAppError,FrontAppErrorをthrowするように修正してください
+
+## 依頼タスク実装時の注意点
+修正箇所が膨大になることが予想されます
+修正が必要な箇所を確りと全て把握して、実装を進めて下さい
diff --git a/drizzle.config.ts b/drizzle.config.ts
index cbe5d3ee4..36ebf09d3 100644
--- a/drizzle.config.ts
+++ b/drizzle.config.ts
@@ -1,6 +1,6 @@
 import type { Config } from 'drizzle-kit';
 import 'dotenv/config';
-import { toAbsoluteFileURL } from './src/main/utils/util';
+import { toAbsoluteFileURL } from './src/main/lib/util';
 
 if (!process.env.DATABASE_DIR) {
   throw new Error('DATABASE_DIR環境変数が設定されていません');
diff --git a/package-lock.json b/package-lock.json
index 46bcccd6f..8ca85c171 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -17,6 +17,7 @@
         "@gitbeaker/rest": "^42.5.0",
         "@mastra/core": "^0.14.1",
         "@mastra/libsql": "^0.13.4",
+        "@mastra/loggers": "^0.10.9",
         "@mastra/mcp": "^0.10.12",
         "@mastra/memory": "^0.13.1",
         "@mui/icons-material": "^7.0.2",
@@ -35,9 +36,10 @@
         "drizzle-kit": "^0.31.0",
         "drizzle-orm": "^0.42.0",
         "electron-debug": "^4.1.0",
-        "electron-log": "^5.3.2",
+        "electron-log": "^5.4.3",
         "electron-store": "^10.0.1",
         "electron-updater": "^6.3.9",
+        "intl-messageformat": "^10.7.16",
         "lucide-react": "^0.503.0",
         "mastra": "^0.10.23",
         "mermaid": "^11.6.0",
@@ -45,6 +47,7 @@
         "postcss": "^8.5.3",
         "react": "^19.0.0",
         "react-dom": "^19.0.0",
+        "react-error-boundary": "^6.0.0",
         "react-markdown": "^10.1.0",
         "react-router-dom": "^7.3.0",
         "react-syntax-highlighter": "^15.6.1",
@@ -4001,6 +4004,57 @@
       "integrity": "sha512-MDWhGtE+eHw5JW7lq4qhc5yRLS11ERl1c7Z6Xd0a58DozHES6EnNNwUWbMiG4J9Cgj053Bhk8zvlhFYKVhULwg==",
       "license": "MIT"
     },
+    "node_modules/@formatjs/ecma402-abstract": {
+      "version": "2.3.4",
+      "resolved": "https://registry.npmjs.org/@formatjs/ecma402-abstract/-/ecma402-abstract-2.3.4.tgz",
+      "integrity": "sha512-qrycXDeaORzIqNhBOx0btnhpD1c+/qFIHAN9znofuMJX6QBwtbrmlpWfD4oiUUD2vJUOIYFA/gYtg2KAMGG7sA==",
+      "license": "MIT",
+      "dependencies": {
+        "@formatjs/fast-memoize": "2.2.7",
+        "@formatjs/intl-localematcher": "0.6.1",
+        "decimal.js": "^10.4.3",
+        "tslib": "^2.8.0"
+      }
+    },
+    "node_modules/@formatjs/fast-memoize": {
+      "version": "2.2.7",
+      "resolved": "https://registry.npmjs.org/@formatjs/fast-memoize/-/fast-memoize-2.2.7.tgz",
+      "integrity": "sha512-Yabmi9nSvyOMrlSeGGWDiH7rf3a7sIwplbvo/dlz9WCIjzIQAfy1RMf4S0X3yG724n5Ghu2GmEl5NJIV6O9sZQ==",
+      "license": "MIT",
+      "dependencies": {
+        "tslib": "^2.8.0"
+      }
+    },
+    "node_modules/@formatjs/icu-messageformat-parser": {
+      "version": "2.11.2",
+      "resolved": "https://registry.npmjs.org/@formatjs/icu-messageformat-parser/-/icu-messageformat-parser-2.11.2.tgz",
+      "integrity": "sha512-AfiMi5NOSo2TQImsYAg8UYddsNJ/vUEv/HaNqiFjnI3ZFfWihUtD5QtuX6kHl8+H+d3qvnE/3HZrfzgdWpsLNA==",
+      "license": "MIT",
+      "dependencies": {
+        "@formatjs/ecma402-abstract": "2.3.4",
+        "@formatjs/icu-skeleton-parser": "1.8.14",
+        "tslib": "^2.8.0"
+      }
+    },
+    "node_modules/@formatjs/icu-skeleton-parser": {
+      "version": "1.8.14",
+      "resolved": "https://registry.npmjs.org/@formatjs/icu-skeleton-parser/-/icu-skeleton-parser-1.8.14.tgz",
+      "integrity": "sha512-i4q4V4qslThK4Ig8SxyD76cp3+QJ3sAqr7f6q9VVfeGtxG9OhiAk3y9XF6Q41OymsKzsGQ6OQQoJNY4/lI8TcQ==",
+      "license": "MIT",
+      "dependencies": {
+        "@formatjs/ecma402-abstract": "2.3.4",
+        "tslib": "^2.8.0"
+      }
+    },
+    "node_modules/@formatjs/intl-localematcher": {
+      "version": "0.6.1",
+      "resolved": "https://registry.npmjs.org/@formatjs/intl-localematcher/-/intl-localematcher-0.6.1.tgz",
+      "integrity": "sha512-ePEgLgVCqi2BBFnTMWPfIghu6FkbZnnBVhO2sSxvLfrdFw7wCHAHiDoM2h4NRgjbaY7+B7HgOLZGkK187pZTZg==",
+      "license": "MIT",
+      "dependencies": {
+        "tslib": "^2.8.0"
+      }
+    },
     "node_modules/@gar/promisify": {
       "version": "1.1.3",
       "resolved": "https://registry.npmjs.org/@gar/promisify/-/promisify-1.1.3.tgz",
@@ -5577,16 +5631,16 @@
       }
     },
     "node_modules/@mastra/loggers": {
-      "version": "0.10.7",
-      "resolved": "https://registry.npmjs.org/@mastra/loggers/-/loggers-0.10.7.tgz",
-      "integrity": "sha512-o9CrEdZRvy3RWaFWWMiTKke1PgRjGt1TJ3RilSoLnpqTE6Fg41XdVQ9jULwxHOACoumEScfhOwsuvb1oZTI5Sw==",
+      "version": "0.10.9",
+      "resolved": "https://registry.npmjs.org/@mastra/loggers/-/loggers-0.10.9.tgz",
+      "integrity": "sha512-uNX9bNO6wRSd8Gi8EDk8GnDjjwFc44y0ASYqQV5zZseYePaIKRm57UD4Gpaq+ic4Q3oSrJe+5K9K1fkUX/5JBA==",
       "license": "Apache-2.0",
       "dependencies": {
         "pino": "^9.7.0",
         "pino-pretty": "^13.0.0"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.10.4-0 <0.15.0-0"
+        "@mastra/core": ">=0.10.4-0 <0.16.0-0"
       }
     },
     "node_modules/@mastra/mcp": {
@@ -15628,7 +15682,6 @@
       "version": "10.4.3",
       "resolved": "https://registry.npmjs.org/decimal.js/-/decimal.js-10.4.3.tgz",
       "integrity": "sha512-VBBaLc1MgL5XpzgIP7ny5Z6Nx3UrRkIViUkPUdtl9aya5amy3De1gsUUSB1g3+3sExYNjCAsAznmukyxCb1GRA==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/decode-named-character-reference": {
@@ -16579,9 +16632,9 @@
       }
     },
     "node_modules/electron-log": {
-      "version": "5.3.2",
-      "resolved": "https://registry.npmjs.org/electron-log/-/electron-log-5.3.2.tgz",
-      "integrity": "sha512-EFI5MFFEzFJU5gyhJNpKQhfGfrRP9IWzSu0sSxrWXasWKvVAOFgBySafX8W1pbPKa/w8/DDPu2bBBtVZJdDsnw==",
+      "version": "5.4.3",
+      "resolved": "https://registry.npmjs.org/electron-log/-/electron-log-5.4.3.tgz",
+      "integrity": "sha512-sOUsM3LjZdugatazSQ/XTyNcw8dfvH1SYhXWiJyfYodAAKOZdHs0txPiLDXFzOZbhXgAgshQkshH2ccq0feyLQ==",
       "license": "MIT",
       "engines": {
         "node": ">= 14"
@@ -21047,6 +21100,18 @@
         "node": ">= 0.10"
       }
     },
+    "node_modules/intl-messageformat": {
+      "version": "10.7.16",
+      "resolved": "https://registry.npmjs.org/intl-messageformat/-/intl-messageformat-10.7.16.tgz",
+      "integrity": "sha512-UmdmHUmp5CIKKjSoE10la5yfU+AYJAaiYLsodbjL4lji83JNvgOQUjGaGhGrpFCb0Uh7sl7qfP1IyILa8Z40ug==",
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "@formatjs/ecma402-abstract": "2.3.4",
+        "@formatjs/fast-memoize": "2.2.7",
+        "@formatjs/icu-messageformat-parser": "2.11.2",
+        "tslib": "^2.8.0"
+      }
+    },
     "node_modules/ip-address": {
       "version": "9.0.5",
       "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-9.0.5.tgz",
@@ -26634,9 +26699,9 @@
       }
     },
     "node_modules/pino": {
-      "version": "9.7.0",
-      "resolved": "https://registry.npmjs.org/pino/-/pino-9.7.0.tgz",
-      "integrity": "sha512-vnMCM6xZTb1WDmLvtG2lE/2p+t9hDEIvTWJsu6FejkE62vB7gDhvzrpFR4Cw2to+9JNQxVnkAKVPA1KPB98vWg==",
+      "version": "9.9.2",
+      "resolved": "https://registry.npmjs.org/pino/-/pino-9.9.2.tgz",
+      "integrity": "sha512-nepuunEhXfRllKa5w9PsNLjWayPsfO3jc6odPuoRaaJ/rb/YEvqhazOBZFzK0gmaHIFCMggvDSqnIcH8dfcGTA==",
       "license": "MIT",
       "dependencies": {
         "atomic-sleep": "^1.0.0",
@@ -26665,9 +26730,9 @@
       }
     },
     "node_modules/pino-pretty": {
-      "version": "13.0.0",
-      "resolved": "https://registry.npmjs.org/pino-pretty/-/pino-pretty-13.0.0.tgz",
-      "integrity": "sha512-cQBBIVG3YajgoUjo1FdKVRX6t9XPxwB9lcNJVD5GCnNM4Y6T12YYx8c6zEejxQsU0wrg9TwmDulcE9LR7qcJqA==",
+      "version": "13.1.1",
+      "resolved": "https://registry.npmjs.org/pino-pretty/-/pino-pretty-13.1.1.tgz",
+      "integrity": "sha512-TNNEOg0eA0u+/WuqH0MH0Xui7uqVk9D74ESOpjtebSQYbNWJk/dIxCXIxFsNfeN53JmtWqYHP2OrIZjT/CBEnA==",
       "license": "MIT",
       "dependencies": {
         "colorette": "^2.0.7",
@@ -26680,14 +26745,42 @@
         "on-exit-leak-free": "^2.1.0",
         "pino-abstract-transport": "^2.0.0",
         "pump": "^3.0.0",
-        "secure-json-parse": "^2.4.0",
+        "secure-json-parse": "^4.0.0",
         "sonic-boom": "^4.0.1",
-        "strip-json-comments": "^3.1.1"
+        "strip-json-comments": "^5.0.2"
       },
       "bin": {
         "pino-pretty": "bin.js"
       }
     },
+    "node_modules/pino-pretty/node_modules/secure-json-parse": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/secure-json-parse/-/secure-json-parse-4.0.0.tgz",
+      "integrity": "sha512-dxtLJO6sc35jWidmLxo7ij+Eg48PM/kleBsxpC8QJE0qJICe+KawkDQmvCMZUr9u7WKVHgMW6vy3fQ7zMiFZMA==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/fastify"
+        },
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/fastify"
+        }
+      ],
+      "license": "BSD-3-Clause"
+    },
+    "node_modules/pino-pretty/node_modules/strip-json-comments": {
+      "version": "5.0.3",
+      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-5.0.3.tgz",
+      "integrity": "sha512-1tB5mhVo7U+ETBKNf92xT4hrQa3pm0MZ0PQvuDnWgAAGHDsfp4lPSpiS6psrSiet87wyGPh9ft6wmhOMQ0hDiw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=14.16"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/pino-std-serializers": {
       "version": "7.0.0",
       "resolved": "https://registry.npmjs.org/pino-std-serializers/-/pino-std-serializers-7.0.0.tgz",
@@ -28052,6 +28145,18 @@
         "react": "^19.0.0"
       }
     },
+    "node_modules/react-error-boundary": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/react-error-boundary/-/react-error-boundary-6.0.0.tgz",
+      "integrity": "sha512-gdlJjD7NWr0IfkPlaREN2d9uUZUlksrfOx7SX62VRerwXbMY6ftGCIZua1VG1aXFNOimhISsTq+Owp725b9SiA==",
+      "license": "MIT",
+      "dependencies": {
+        "@babel/runtime": "^7.12.5"
+      },
+      "peerDependencies": {
+        "react": ">=16.13.1"
+      }
+    },
     "node_modules/react-is": {
       "version": "17.0.2",
       "resolved": "https://registry.npmjs.org/react-is/-/react-is-17.0.2.tgz",
@@ -30688,6 +30793,7 @@
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
       "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
+      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=8"
@@ -31732,9 +31838,9 @@
       }
     },
     "node_modules/tslib": {
-      "version": "2.7.0",
-      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.7.0.tgz",
-      "integrity": "sha512-gLXCKdN1/j47AiHiOkJN69hJmcbGTHI0ImLmbYLHykhgeN0jVGola9yVjFgzCUklsZQMW55o+dW7IXv3RCXDzA==",
+      "version": "2.8.1",
+      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
+      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
       "license": "0BSD"
     },
     "node_modules/tsutils": {
diff --git a/package.json b/package.json
index 9d0f24ed5..e1012a7f1 100644
--- a/package.json
+++ b/package.json
@@ -94,6 +94,7 @@
     "@gitbeaker/rest": "^42.5.0",
     "@mastra/core": "^0.14.1",
     "@mastra/libsql": "^0.13.4",
+    "@mastra/loggers": "^0.10.9",
     "@mastra/mcp": "^0.10.12",
     "@mastra/memory": "^0.13.1",
     "@mui/icons-material": "^7.0.2",
@@ -112,9 +113,10 @@
     "drizzle-kit": "^0.31.0",
     "drizzle-orm": "^0.42.0",
     "electron-debug": "^4.1.0",
-    "electron-log": "^5.3.2",
+    "electron-log": "^5.4.3",
     "electron-store": "^10.0.1",
     "electron-updater": "^6.3.9",
+    "intl-messageformat": "^10.7.16",
     "lucide-react": "^0.503.0",
     "mastra": "^0.10.23",
     "mermaid": "^11.6.0",
@@ -122,6 +124,7 @@
     "postcss": "^8.5.3",
     "react": "^19.0.0",
     "react-dom": "^19.0.0",
+    "react-error-boundary": "^6.0.0",
     "react-markdown": "^10.1.0",
     "react-router-dom": "^7.3.0",
     "react-syntax-highlighter": "^15.6.1",
diff --git a/release/app/drizzle/migrations/meta/_journal.json b/release/app/drizzle/migrations/meta/_journal.json
index 6313c7bd6..7d36c29f2 100644
--- a/release/app/drizzle/migrations/meta/_journal.json
+++ b/release/app/drizzle/migrations/meta/_journal.json
@@ -29,6 +29,20 @@
       "when": 1749952232695,
       "tag": "0003_outgoing_cobalt_man",
       "breakpoints": true
+    },
+    {
+      "idx": 4,
+      "version": "6",
+      "when": 1756909323206,
+      "tag": "0004_adorable_abomination",
+      "breakpoints": true
+    },
+    {
+      "idx": 5,
+      "version": "6",
+      "when": 1756973708951,
+      "tag": "0005_workable_karen_page",
+      "breakpoints": true
     }
   ]
 }
\ No newline at end of file
diff --git a/src/__tests__/integration/SettingsModal.test.tsx b/src/__tests__/integration/SettingsModal.test.tsx
index b0ef72fdf..96994ecf5 100644
--- a/src/__tests__/integration/SettingsModal.test.tsx
+++ b/src/__tests__/integration/SettingsModal.test.tsx
@@ -46,7 +46,9 @@ describe('SettingsModal Component', () => {
 
     // データベース設定
     await waitFor(() => {
-      const dbPath = screen.getByRole('textbox', { name: 'データベース保存フォルダ' });
+      const dbPath = screen.getByRole('textbox', {
+        name: 'データベース保存フォルダ',
+      });
       expect(dbPath).toHaveValue('/test/db');
     });
 
@@ -58,7 +60,9 @@ describe('SettingsModal Component', () => {
     // API設定
     const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
     expect(apiKeyInput).toHaveValue('test-api-key');
-    expect(screen.getByLabelText('APIエンドポイントURL')).toHaveValue('https://api.test.com');
+    expect(screen.getByLabelText('APIエンドポイントURL')).toHaveValue(
+      'https://api.test.com',
+    );
     expect(screen.getByLabelText('モデル名')).toHaveValue('test-model');
 
     // Redmine設定
@@ -74,10 +78,14 @@ describe('SettingsModal Component', () => {
     expect(gitlabApiKey).toHaveValue('test-gitlab-key');
 
     // MCPサーバー設定
-    expect(screen.getByLabelText('MCPサーバー設定（JSON）')).toHaveValue('{"testMcp": {"url": "https://mcp.test.com"} }');
+    expect(screen.getByLabelText('MCPサーバー設定（JSON）')).toHaveValue(
+      '{"testMcp": {"url": "https://mcp.test.com"} }',
+    );
 
     // システムプロンプト設定
-    expect(screen.getByLabelText('システムプロンプトのカスタマイズが可能です')).toHaveValue('test system prompt');
+    expect(
+      screen.getByLabelText('システムプロンプトのカスタマイズが可能です'),
+    ).toHaveValue('test system prompt');
   });
 
   // テスト2: 設定値を更新して保存できること
@@ -154,10 +162,15 @@ describe('SettingsModal Component', () => {
       },
     };
     await user.clear(mcpConfigInput);
-    await userEvent.type(mcpConfigInput, JSON.stringify(validMcpConfig, null, 2).replace(/[{[]/g, '$&$&'));
+    await userEvent.type(
+      mcpConfigInput,
+      JSON.stringify(validMcpConfig, null, 2).replace(/[{[]/g, '$&$&'),
+    );
 
     // システムプロンプト設定の更新
-    const systemPromptInput = screen.getByLabelText('システムプロンプトのカスタマイズが可能です');
+    const systemPromptInput = screen.getByLabelText(
+      'システムプロンプトのカスタマイズが可能です',
+    );
     await user.clear(systemPromptInput);
     await user.type(systemPromptInput, 'new test system prompt');
 
@@ -271,7 +284,10 @@ describe('SettingsModal Component', () => {
 
     // 無効なJSON構文
     await user.clear(mcpConfigInput);
-    await userEvent.type(mcpConfigInput, '{ invalid json'.replace(/[{[]/g, '$&$&'));
+    await userEvent.type(
+      mcpConfigInput,
+      '{ invalid json'.replace(/[{[]/g, '$&$&'),
+    );
 
     // バリデーションエラーメッセージが表示されることを確認
     await waitFor(() => {
@@ -280,10 +296,14 @@ describe('SettingsModal Component', () => {
       expect(screen.getByText('モデル名は必須です')).toBeInTheDocument();
 
       // パスが存在しないエラー（DB,ドキュメント登録フォルダ）
-      expect(screen.getAllByText('指定されたパスが存在しません').length).toEqual(2);
+      expect(
+        screen.getAllByText('指定されたパスが存在しません').length,
+      ).toEqual(2);
 
       // 無効なURL形式のエラー
-      expect(screen.getAllByText('有効なURLを入力してください').length).toEqual(3);
+      expect(screen.getAllByText('有効なURLを入力してください').length).toEqual(
+        3,
+      );
 
       // MCPサーバー設定のエラー
       expect(screen.getByText('JSONの形式が不正です')).toBeInTheDocument();
diff --git a/src/__tests__/integration/Sidebar.test.tsx b/src/__tests__/integration/Sidebar.test.tsx
index f2950da12..00d96f758 100644
--- a/src/__tests__/integration/Sidebar.test.tsx
+++ b/src/__tests__/integration/Sidebar.test.tsx
@@ -8,14 +8,14 @@ import userEvent from '@testing-library/user-event';
 import '@testing-library/jest-dom';
 import { v4 as uuidv4 } from 'uuid';
 
-import Sidebar from '../../renderer/components/sidebar/Sidebar';
-import type { ChatRoom, ProcessStatus } from '../../main/types';
-import type { Source } from '../../db/schema';
-import { StoreSchema as Settings } from '../../main/store';
-import { createMockElectronWithOptions } from '../../__tests__/test-utils/mockElectronHandler';
-import ChatRoomList from '../../renderer/components/chat/ChatRoomList';
-import ReviewHistoryList from '../../renderer/components/review/ReviewHistoryList';
-import { ROUTES } from '../../main/types';
+import Sidebar from '@/renderer/components/sidebar/Sidebar';
+import type { ChatRoom, ProcessStatus } from '@/types';
+import type { Source } from '@/db/schema';
+import { StoreSchema as Settings } from '@/main/store';
+import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
+import ChatRoomList from '@/renderer/components/chat/ChatRoomList';
+import ReviewHistoryList from '@/renderer/components/review/ReviewHistoryList';
+import { ROUTES } from '@/types';
 
 // uuidv4をモック化
 jest.mock('uuid', () => ({
diff --git a/src/__tests__/integration/SourceListModal.test.tsx b/src/__tests__/integration/SourceListModal.test.tsx
index 7eb208241..0f470914a 100644
--- a/src/__tests__/integration/SourceListModal.test.tsx
+++ b/src/__tests__/integration/SourceListModal.test.tsx
@@ -11,10 +11,10 @@ import {
 } from '@testing-library/react';
 import '@testing-library/jest-dom';
 
-import SourceListModal from '../../renderer/components/common/SourceListModal';
-import type { Source } from '../../db/schema';
-import { ProcessStatus } from '../../main/types';
-import { createMockElectronWithOptions } from '../../__tests__/test-utils/mockElectronHandler';
+import SourceListModal from '@/renderer/components/common/SourceListModal';
+import type { Source } from '@/db/schema';
+import { ProcessStatus } from '@/types';
+import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
 
 // テスト用のモックデータ
 const mockSources: Source[] = [
diff --git a/src/__tests__/integration/chat.test.tsx b/src/__tests__/integration/chat.test.tsx
index 16ee29656..693850c53 100644
--- a/src/__tests__/integration/chat.test.tsx
+++ b/src/__tests__/integration/chat.test.tsx
@@ -15,8 +15,8 @@ import {
 } from '@testing-library/react';
 import userEvent from '@testing-library/user-event';
 import '@testing-library/jest-dom';
-import type { ChatRoom, ChatMessage } from '../../main/types';
-import ChatArea from '../../renderer/components/chat/ChatArea';
+import type { ChatRoom, ChatMessage } from '@/types';
+import ChatArea from '@/renderer/components/chat/ChatArea';
 import { createMockElectronWithOptions } from '../test-utils/mockElectronHandler';
 
 // File APIのモック
@@ -283,7 +283,9 @@ describe('ChatArea Component', () => {
 
     // ガイダンステキストが表示されることを確認
     expect(
-      screen.getByText('新規チャットを開始または既存のチャットを選択してください'),
+      screen.getByText(
+        '新規チャットを開始または既存のチャットを選択してください',
+      ),
     ).toBeInTheDocument();
   });
 
@@ -367,7 +369,9 @@ describe('ChatArea Component', () => {
     await user.click(saveButton);
 
     // 編集リクエストが送信されることを確認
-    expect(window.electron.chat.deleteMessagesBeforeSpecificId).toHaveBeenCalledWith({
+    expect(
+      window.electron.chat.deleteMessagesBeforeSpecificId,
+    ).toHaveBeenCalledWith({
       threadId: '1',
       messageId: '1',
     });
@@ -881,10 +885,12 @@ describe('ChatArea Component', () => {
             url: 'data:image/png;base64,dummybase64-3',
           },
         ],
-      }
+      },
     ];
 
-    window.electron.chat.getMessages = jest.fn().mockResolvedValue(mockMultiImageMessages);
+    window.electron.chat.getMessages = jest
+      .fn()
+      .mockResolvedValue(mockMultiImageMessages);
 
     render(<ChatArea selectedRoomId="18" />);
 
@@ -893,7 +899,10 @@ describe('ChatArea Component', () => {
       const images = screen.getAllByRole('img');
       expect(images).toHaveLength(3);
       images.forEach((img, idx) => {
-        expect(img).toHaveAttribute('alt', expect.stringMatching(new RegExp(`test${idx + 1}.png|att-${idx}`)));
+        expect(img).toHaveAttribute(
+          'alt',
+          expect.stringMatching(new RegExp(`test${idx + 1}.png|att-${idx}`)),
+        );
       });
     });
   });
@@ -911,12 +920,14 @@ describe('ChatArea Component', () => {
             name: 'test.png',
             contentType: 'image/png',
             url: 'data:image/png;base64,dummybase64',
-          }
+          },
         ],
-      }
+      },
     ];
 
-    window.electron.chat.getMessages = jest.fn().mockResolvedValue(mockImageMessage);
+    window.electron.chat.getMessages = jest
+      .fn()
+      .mockResolvedValue(mockImageMessage);
     const user = userEvent.setup();
     render(<ChatArea selectedRoomId="19" />);
 
@@ -925,6 +936,8 @@ describe('ChatArea Component', () => {
 
     // ホバー時に編集アイコンが表示されないことを確認
     await user.hover(messageText);
-    expect(screen.queryByTestId('edit-message-button-1')).not.toBeInTheDocument();
+    expect(
+      screen.queryByTestId('edit-message-button-1'),
+    ).not.toBeInTheDocument();
   });
 });
diff --git a/src/__tests__/test-utils/mockElectronHandler.ts b/src/__tests__/test-utils/mockElectronHandler.ts
index 6438820c8..688344324 100644
--- a/src/__tests__/test-utils/mockElectronHandler.ts
+++ b/src/__tests__/test-utils/mockElectronHandler.ts
@@ -1,7 +1,6 @@
-import type { ElectronHandler } from '../../main/preload';
-import type { StoreSchema as Settings } from '../../main/store';
-import type { Source } from '../../db/schema';
-import type { ChatRoom, SettingsSavingStatus } from '../../main/types';
+import type { ElectronHandler } from '@/main/preload';
+import type { Source } from '@/db/schema';
+import type { ChatRoom, SettingsSavingStatus, Settings } from '@/types';
 
 /**
  * Mockメソッドの型を定義
@@ -17,8 +16,8 @@ export type MockHandler<T> = {
   [K in keyof T]: T[K] extends (...args: any[]) => any
     ? MockFunction<T[K]>
     : T[K] extends object
-    ? MockHandler<T[K]>
-    : T[K];
+      ? MockHandler<T[K]>
+      : T[K];
 };
 
 export type ElectronMock = MockHandler<ElectronHandler>;
@@ -47,7 +46,7 @@ export const createDefaultMockSettings = (): Settings => ({
     apiKey: 'test-gitlab-key',
   },
   mcp: {
-    serverConfigText: '{"testMcp": {"url": "https://mcp.test.com"} }',
+    serverConfig: '{"testMcp": {"url": "https://mcp.test.com"} }',
   },
   systemPrompt: {
     content: 'test system prompt',
@@ -78,17 +77,23 @@ export const createMockElectronWithOptions = (
 
   const mockHandlers = {
     settings: {
-      getStatus: jest.fn().mockReturnValue(options.settingsStatus || {
-        state: 'done',
-        messages: [],
-        tools: {
-          redmine: false,
-          gitlab: false,
-          mcp: false,
+      getStatus: jest.fn().mockReturnValue(
+        options.settingsStatus || {
+          state: 'done',
+          messages: [],
+          tools: {
+            redmine: false,
+            gitlab: false,
+            mcp: false,
+          },
         },
-      }),
+      ),
       reinitialize: jest.fn().mockResolvedValue(undefined),
       removeMessage: jest.fn(),
+      getSettings: jest
+        .fn()
+        .mockResolvedValue({ success: true, data: settings }),
+      setSettings: jest.fn().mockResolvedValue({ success: true }),
     },
     fs: {
       access: jest.fn().mockResolvedValue(options.fsAccess ?? true),
@@ -106,7 +111,7 @@ export const createMockElectronWithOptions = (
       getMessages: jest.fn().mockResolvedValue([]),
       deleteRoom: jest.fn().mockResolvedValue({ success: true }),
       createThread: jest.fn().mockResolvedValue({
-        success: true
+        success: true,
       }),
       onError: jest.fn(),
       onStream: jest.fn(),
diff --git a/src/db/index.ts b/src/db/index.ts
index 0a96f5ad2..96257207e 100644
--- a/src/db/index.ts
+++ b/src/db/index.ts
@@ -4,7 +4,7 @@ import { drizzle, type LibSQLDatabase } from 'drizzle-orm/libsql';
 import { migrate } from 'drizzle-orm/libsql/migrator';
 import * as schema from './schema';
 import { getStore } from '../main/store';
-import { toAbsoluteFileURL } from '../main/utils/util';
+import { toAbsoluteFileURL } from '../main/lib/util';
 
 // データベースの型定義
 type Database = LibSQLDatabase<typeof schema>;
diff --git a/src/db/repository/repositoryError.ts b/src/db/repository/repositoryError.ts
deleted file mode 100644
index 627a4d7e8..000000000
--- a/src/db/repository/repositoryError.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * リポジトリ層で発生したエラーを表す共通クラス
- */
-export class RepositoryError extends Error {
-  public readonly originalError?: Error;
-
-  constructor(message: string, originalError?: Error) {
-    super(message);
-    this.name = 'RepositoryError';
-    this.originalError = originalError;
-    // スタックトレースを保持
-    if (originalError?.stack) {
-      this.stack = originalError.stack;
-    }
-  }
-}
diff --git a/src/db/repository/sourceRepository.ts b/src/db/repository/sourceRepository.ts
deleted file mode 100644
index e055c712a..000000000
--- a/src/db/repository/sourceRepository.ts
+++ /dev/null
@@ -1,293 +0,0 @@
-import { eq, inArray, and } from 'drizzle-orm';
-import getDb from '..';
-import type { Source, InsertSource, InsertTopic } from '../schema';
-import { sources, topics } from '../schema';
-import { ProcessStatus } from '../../main/types';
-
-export interface SourceRepository {
-  /**
-   * ソースを取得する
-   * @param sourceId ソースのID
-   * @returns ソース情報
-   */
-  getSourceById(sourceId: number): Promise<Source | null>;
-
-  /**
-   * idで指定された複数ソース取得する
-   * @returns ソースの配列
-   */
-  getSourcesByIds(sourceIds: number[]): Promise<Source[]>;
-
-  /**
-   * 同期処理中のソースを登録または更新する
-   * @param source 登録または更新するソース情報
-   * @returns 登録または更新されたソース情報
-   */
-  initializeProcessingSource(source: InsertSource): Promise<Source>;
-
-  /**
-   * ソース情報を更新する
-   * @param param 更新するソース情報
-   * @param param.id ソースのID
-   * @param param.title ソースのタイトル
-   * @param param.summary ソースの要約
-   * @param param.error エラー情報（nullの場合はエラーなし）
-   * @returns 更新されたソース情報
-   */
-  updateSource(param: {
-    id: number;
-    title: string;
-    summary: string;
-    error: string | null;
-  }): Promise<void>;
-
-  /**
-   * 同期処理情報を更新する
-   */
-  updateProcessingStatus(param: {
-    id: number;
-    status: ProcessStatus;
-    error?: string | null;
-  }): Promise<void>;
-
-  /**
-   * 全ソースの情報をMDのリスト形式で取得する
-   * @param sourceId ソースのID
-   * @returns ソース情報
-   */
-  getSourceListMarkdown(): Promise<string | null>;
-
-  /**
-   * トピックを登録する
-   */
-  registerTopic(topicList: InsertTopic[]): Promise<void>;
-
-  /**
-   * パスで指定されたソースを削除する
-   * @param path ソースのパス
-   * @returns 削除が成功した場合はtrue、存在しない場合はfalse
-   */
-  deleteSourceByPath(path: string): Promise<boolean>;
-
-  /**
-   * ソースをステータスに基づいて複数取得する
-   * @param status ソースのステータス
-   * @returns ソースの配列
-   */
-  getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]>;
-
-  /**
-   * ソースをステータスとパスに基づいて複数取得する
-   */
-  getSourceByPathInStatus(
-    path: string,
-    status: ProcessStatus[],
-  ): Promise<Source[]>;
-
-  /**
-   * ソースを全て取得する
-   */
-  getAllSources(): Promise<Source[]>;
-
-  /**
-   * ソーステーブルへのインサート
-   */
-  insertSources(sourceList: InsertSource[]): Promise<void>;
-}
-
-let sourceRepository: SourceRepository | null = null;
-
-class DrizzleSourceRepository implements SourceRepository {
-  async getSourceById(sourceId: number): Promise<Source | null> {
-    const db = await getDb();
-    const [source] = await db
-      .select()
-      .from(sources)
-      .where(eq(sources.id, sourceId))
-      .limit(1);
-    return source || null;
-  }
-
-  async getSourcesByIds(sourceIds: number[]): Promise<Source[]> {
-    const db = await getDb();
-    return db.select().from(sources).where(inArray(sources.id, sourceIds));
-  }
-
-  /**
-   * ソースを更新する
-   * @param param ソース情報
-   * @param param.path ソースのパス
-   * @param param.title ソースのタイトル
-   * @param param.summary ソースの要約
-   * @param param.error エラー情報（nullの場合はエラーなし）
-   * @returns
-   */
-  async updateSource(param: {
-    id: number;
-    title: string;
-    summary: string;
-    error: string | null;
-  }): Promise<void> {
-    const db = await getDb();
-    await db
-      .update(sources)
-      .set({
-        title: param.title,
-        summary: param.summary,
-        error: param.error,
-      })
-      .where(eq(sources.id, param.id));
-  }
-
-  /**
-   * 同期処理中のソースを登録または更新する
-   * @param source 登録または更新するソース情報
-   * @returns 登録または更新されたソース情報
-   */
-  async initializeProcessingSource(source: InsertSource): Promise<Source> {
-    const db = await getDb();
-    const [result] = await db
-      .insert(sources)
-      .values({
-        path: source.path,
-        title: '', // 一時的な空の値
-        summary: '', // 一時的な空の値
-        status: 'processing' as const,
-      })
-      .onConflictDoUpdate({
-        target: sources.path,
-        set: {
-          status: 'processing' as const,
-          error: null,
-        },
-      })
-      .returning();
-    return result;
-  }
-
-  /**
-   * データベースからソース情報を取得する
-   */
-  async getSourceListMarkdown(): Promise<string | null> {
-    const db = await getDb();
-    // 有効なソースのみ取得
-    const sourceList = await db
-      .select()
-      .from(sources)
-      .where(and(eq(sources.isEnabled, 1), eq(sources.status, 'completed')))
-      .orderBy(sources.title);
-
-    // 各ソースのトピックを取得
-    const sourceWithTopicList = await Promise.all(
-      sourceList.map(async (source) => {
-        const topicsList = await db
-          .select()
-          .from(topics)
-          .where(eq(topics.sourceId, source.id))
-          .orderBy(topics.name);
-
-        return {
-          id: source.id,
-          title: source.title,
-          path: source.path,
-          summary: source.summary,
-          topics: topicsList.map((topic) => ({
-            name: topic.name,
-            summary: topic.summary,
-          })),
-        };
-      }),
-    );
-
-    if (sourceWithTopicList.length === 0) {
-      return null; // ソースが存在しない場合はnullを返す
-    }
-
-    return sourceWithTopicList
-      .map(
-        (sourceWithTopic) => `- ID:${sourceWithTopic.id}
-      - Title:${sourceWithTopic.title}
-      - Path:${sourceWithTopic.path}
-      - Summary:${sourceWithTopic.summary}
-      - Topics:
-    ${sourceWithTopic.topics.map((topic) => `      - Topic: ${topic.name} Summary: ${topic.summary}`).join('\n')}
-  `,
-      )
-      .join('\n');
-  }
-
-  async updateProcessingStatus(param: {
-    id: number;
-    status: ProcessStatus;
-    error?: string | null;
-  }): Promise<void> {
-    const db = await getDb();
-    await db
-      .update(sources)
-      .set({
-        status: param.status,
-        error: param.error || null,
-      })
-      .where(eq(sources.id, param.id));
-  }
-
-  /**
-   * トピックを登録する
-   * @param topic 登録するトピック情報
-   * @returns 登録されたトピック情報
-   */
-  async registerTopic(topicList: InsertTopic[]): Promise<void> {
-    const db = await getDb();
-    await db.insert(topics).values(topicList);
-  }
-
-  async deleteSourceByPath(path: string): Promise<boolean> {
-    const db = await getDb();
-    const [source] = await db
-      .select()
-      .from(sources)
-      .where(eq(sources.path, path))
-      .limit(1);
-
-    if (source) {
-      await db.delete(sources).where(eq(sources.id, source.id));
-      await db.delete(topics).where(eq(topics.sourceId, source.id));
-    }
-    return !!source; // 存在した場合はtrue、存在しなかった場合はfalseを返す
-  }
-
-  async getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]> {
-    const db = await getDb();
-    return db.select().from(sources).where(inArray(sources.status, status));
-  }
-
-  async getSourceByPathInStatus(
-    path: string,
-    status: ProcessStatus[],
-  ): Promise<Source[]> {
-    const db = await getDb();
-    const sourcesInStatus = await db
-      .select()
-      .from(sources)
-      .where(and(eq(sources.path, path), inArray(sources.status, status)));
-
-    return sourcesInStatus;
-  }
-
-  async getAllSources(): Promise<Source[]> {
-    const db = await getDb();
-    return db.select().from(sources);
-  }
-
-  async insertSources(sourceList: InsertSource[]): Promise<void> {
-    const db = await getDb();
-    await db.insert(sources).values(sourceList);
-  }
-}
-
-export function getSourceRepository(): SourceRepository {
-  if (!sourceRepository) {
-    sourceRepository = new DrizzleSourceRepository();
-  }
-  return sourceRepository;
-}
diff --git a/src/db/schema.ts b/src/db/schema.ts
index 53cea8e61..ecc5e9226 100644
--- a/src/db/schema.ts
+++ b/src/db/schema.ts
@@ -7,7 +7,7 @@ import {
 } from 'drizzle-orm/sqlite-core';
 import { sql } from 'drizzle-orm';
 import { v4 as uuidv4 } from 'uuid';
-import type { ProcessStatus } from '../main/types';
+import type { ProcessStatus } from '@/types';
 
 /**
  * SQLiteのカスタム型定義
diff --git a/src/main/lib/AbortControllerManager.ts b/src/main/lib/AbortControllerManager.ts
new file mode 100644
index 000000000..ba58fff81
--- /dev/null
+++ b/src/main/lib/AbortControllerManager.ts
@@ -0,0 +1,55 @@
+// 機能ごとに割り当てたAbortControllerのMapラップして、作成や削除コマンドを提供する
+// AbortControllerを利用して機能の中断を実現したい機能で利用する
+
+import { Feature } from '@/types';
+
+export class AbortControllerManager {
+  private static instance: AbortControllerManager;
+  // ごとのAbortControllerを管理するインメモリMap
+  private userAbortControllers = new Map<
+    Feature,
+    Map<string, AbortController>
+  >();
+
+  private constructor() {}
+
+  public static getInstance(): AbortControllerManager {
+    if (!AbortControllerManager.instance) {
+      AbortControllerManager.instance = new AbortControllerManager();
+    }
+    return AbortControllerManager.instance;
+  }
+
+  /**
+   * スレッドのAbortControllerを取得または作成する
+   * @param abortId 識別子
+   * @returns AbortController
+   */
+  public getOrCreateAbortController(
+    feature: Feature,
+    abortId: string,
+  ): AbortController {
+    if (
+      !this.userAbortControllers.has(feature) ||
+      !this.userAbortControllers.get(feature)!.has(abortId)
+    ) {
+      const controller = new AbortController();
+      this.userAbortControllers.set(feature, new Map([[abortId, controller]]));
+    }
+    return this.userAbortControllers.get(feature)!.get(abortId)!;
+  }
+
+  /**
+   * スレッドのAbortControllerを削除する
+   * @param abortId 識別子
+   */
+  public deleteAbortController(feature: Feature, abortId: string): void {
+    if (
+      this.userAbortControllers.has(feature) &&
+      this.userAbortControllers.get(feature)!.has(abortId)
+    ) {
+      this.userAbortControllers.get(feature)?.get(abortId)!.abort();
+      this.userAbortControllers.get(feature)?.delete(abortId);
+    }
+  }
+}
diff --git a/src/main/lib/error.ts b/src/main/lib/error.ts
new file mode 100644
index 000000000..3d438135e
--- /dev/null
+++ b/src/main/lib/error.ts
@@ -0,0 +1,142 @@
+// lib/errors.ts
+import { ZodError } from 'zod';
+import { ErrorCode, MessageCode } from '@/types';
+import { MessageParams } from './messages';
+import { formatMessage } from './messages';
+import { AppErrorPayload } from '@/types';
+import { APICallError, RetryError } from 'ai';
+// @ts-ignore
+import { MastraError } from '@mastra/core/error';
+
+/**
+ * 例外として扱うアプリケーションエラー。
+ * - expose: true のときのみ message をクライアントに出す
+ */
+export class AppError extends Error {
+  public readonly expose: boolean;
+  public readonly errorCode: ErrorCode;
+  public readonly messageCode: MessageCode;
+  public readonly messageParams: MessageParams;
+  // ログに出すための追加情報
+  public readonly couse?: unknown;
+
+  constructor(
+    errorCode: ErrorCode,
+    options?: {
+      expose?: boolean;
+      cause?: unknown;
+      messageCode?: MessageCode;
+      messageParams?: MessageParams;
+    },
+  ) {
+    const message = formatMessage(
+      options?.messageCode ?? 'UNKNOWN_ERROR',
+      options?.messageParams ?? {},
+    );
+    super(message);
+    this.name = 'AppError';
+    this.errorCode = errorCode;
+    this.expose = options?.expose ?? false;
+    this.couse = options?.cause;
+    this.messageCode = options?.messageCode ?? 'UNKNOWN_ERROR';
+    this.messageParams = options?.messageParams ?? {};
+  }
+
+  override get message(): string {
+    return this.expose ? super.message : formatMessage('UNKNOWN_ERROR');
+  }
+}
+
+// よく使うビルダー
+export const internalError = (options?: {
+  expose?: boolean;
+  cause?: unknown;
+  messageCode?: MessageCode;
+  messageParams?: MessageParams;
+}) => new AppError('INTERNAL', options);
+
+/**
+ * Zod のエラー → クライアントに安全に出せる形へ
+ */
+export function zodToAppError(e: ZodError) {
+  let detail = '';
+  for (const issue of e.issues) {
+    detail += `・${issue.message}\n`;
+  }
+
+  return new AppError('VALIDATION', {
+    expose: true,
+    messageCode: 'VALIDATION_ERROR',
+    cause: e,
+    messageParams: { detail },
+  });
+}
+
+/**
+ * 予期しない例外を AppError に正規化。
+ * - 既に AppError → そのまま
+ * - ZodError → VALIDATION に変換
+ * - それ以外 → INTERNAL に丸める
+ */
+export function normalizeUnknownError(err: unknown): AppError {
+  if (err instanceof AppError) return err;
+  if (err instanceof ZodError) return zodToAppError(err);
+  const aiApiSafeError = extractAIAPISafeError(err);
+  if (aiApiSafeError) {
+    return new AppError('AI_API', {
+      expose: true,
+      cause: err,
+      messageCode: 'AI_API_ERROR',
+      messageParams: { detail: aiApiSafeError.message },
+    });
+  }
+  return internalError({
+    expose: false,
+    cause: err,
+  });
+}
+
+export function normalizeUnknownIpcError(
+  err: unknown,
+  ipcName?: string,
+): AppError {
+  const normalizedError = normalizeUnknownError(err);
+  const hasDetail =
+    normalizedError.expose &&
+    normalizedError.message.trim() !== formatMessage('UNKNOWN_ERROR');
+  const detail = hasDetail ? normalizedError.message : undefined;
+  return internalError({
+    expose: true,
+    cause: err,
+    messageCode: 'IPC_ERROR',
+    messageParams: {
+      hasIpcName: !!ipcName,
+      ipcName: ipcName ?? '',
+      hasDetail,
+      detail,
+    },
+  });
+}
+
+export function extractAIAPISafeError(error: unknown): Error | null {
+  if (APICallError.isInstance(error)) return error;
+  if (error instanceof MastraError) {
+    if (APICallError.isInstance(error.cause)) return error.cause;
+    if (RetryError.isInstance(error.cause)) {
+      for (const e of error.cause.errors) {
+        if (APICallError.isInstance(e)) return e;
+      }
+    }
+  }
+  return null;
+}
+
+/**
+ * AppError をクライアントに返せるプレーン JSON へ
+ */
+export function toPayload(e: AppError): AppErrorPayload {
+  return {
+    code: e.errorCode,
+    message: e.message,
+  };
+}
diff --git a/src/main/lib/eventPayloadHelper.ts b/src/main/lib/eventPayloadHelper.ts
new file mode 100644
index 000000000..edf9ec272
--- /dev/null
+++ b/src/main/lib/eventPayloadHelper.ts
@@ -0,0 +1,36 @@
+import type { EventChannel, IpcEventPayloadMap, PushEvent } from '@/types';
+import { broker } from '@/main/push/electronPushBroker';
+
+/**
+ * イベント送信用のペイロードを作成するヘルパー関数
+ * @param channel イベントチャンネル
+ * @param payload ペイロードデータ
+ * @param options オプション（タイムスタンプなど）
+ * @returns 作成されたイベントペイロード
+ */
+export function createEventPayload<C extends EventChannel>(
+  channel: C,
+  payload: IpcEventPayloadMap[C],
+  options?: { timestamp?: number },
+): PushEvent<C> {
+  return {
+    channel,
+    payload,
+    ts: options?.timestamp ?? Date.now(),
+  };
+}
+
+/**
+ * イベントを送信するヘルパー関数
+ * @param channel イベントチャンネル
+ * @param payload ペイロードデータ
+ * @param options オプション（タイムスタンプなど）
+ */
+export function publishEvent<C extends EventChannel>(
+  channel: C,
+  payload: IpcEventPayloadMap[C],
+  options?: { timestamp?: number },
+): void {
+  const eventPayload = createEventPayload(channel, payload, options);
+  broker.publish(channel, eventPayload);
+}
diff --git a/src/main/utils/fileExtractor.ts b/src/main/lib/fileExtractor.ts
similarity index 89%
rename from src/main/utils/fileExtractor.ts
rename to src/main/lib/fileExtractor.ts
index 4f6215238..7a6fd6c2a 100644
--- a/src/main/utils/fileExtractor.ts
+++ b/src/main/lib/fileExtractor.ts
@@ -13,6 +13,8 @@ import type { TextItem } from 'pdfjs-dist/types/src/display/api';
 // その際、動的にrequire("@napi-rs/canvas")が実行されるが、本番環境だとモジュールが見つけられないエラーになる
 // releaseディレクトリに@napi-rs/canvasを追加して解決を試みたが、それでも同様にモジュールが見つけられないエラーが発生するため、予め@napi-rs/canvasを呼び出してpolyfillを実行しておく
 import canvas from '@napi-rs/canvas';
+import { getMainLogger } from './logger';
+import { internalError } from './error';
 
 (globalThis as any).DOMMatrix = canvas.DOMMatrix;
 (globalThis as any).ImageData = canvas.ImageData;
@@ -20,6 +22,8 @@ import canvas from '@napi-rs/canvas';
 
 const execFileP = promisify(execFile);
 
+const logger = getMainLogger();
+
 /** キャッシュ対象となるファイルの拡張子 */
 const CACHE_TARGET_EXTENSIONS = [
   '.doc',
@@ -42,13 +46,6 @@ export interface ExtractionResult {
   };
 }
 
-/** ファイル抽出エラーの型定義 */
-interface FileExtractionError extends Error {
-  code: string;
-  filePath: string;
-  fileType: string;
-}
-
 /** 多様なファイル形式からテキストを抽出するユーティリティクラス */
 export default class FileExtractor {
   /**
@@ -78,8 +75,13 @@ export default class FileExtractor {
    * 指定されたファイルがキャッシュ対象かどうかを判定
    */
   public static isCacheTarget(filePath: string): boolean {
-    const ext = path.extname(filePath).toLowerCase();
-    return CACHE_TARGET_EXTENSIONS.includes(ext);
+    try {
+      const ext = path.extname(filePath).toLowerCase();
+      return CACHE_TARGET_EXTENSIONS.includes(ext);
+    } catch (error) {
+      logger.error(error, 'ファイルの拡張子の取得に失敗しました');
+      return false;
+    }
   }
 
   /**
@@ -90,8 +92,10 @@ export default class FileExtractor {
       const cachePath = this.getCacheFilePath(filePath);
       await fs.unlink(cachePath);
     } catch (error) {
+      // キャッシュが削除できない場合は大きな問題にならないのでエラーは握りつぶす
+      // ファイルが存在するが、取り出せない場合(≠ENOENT)はログに出す
       if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
-        console.error('キャッシュの削除に失敗しました:', error);
+        logger.error(error, 'キャッシュの削除に失敗しました');
       }
     }
   }
@@ -105,8 +109,10 @@ export default class FileExtractor {
       const content = await fs.readFile(cachePath, 'utf-8');
       return content;
     } catch (error) {
+      // ファイルが存在しない場合は null を返す
+      // ファイルが存在するが、取り出せない場合(≠ENOENT)はログに出す
       if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
-        console.error('キャッシュの読み込みに失敗しました:', error);
+        logger.error({ error, filePath }, 'キャッシュの読み込みに失敗しました');
       }
       return null;
     }
@@ -123,7 +129,8 @@ export default class FileExtractor {
       const cachePath = this.getCacheFilePath(filePath);
       await fs.writeFile(cachePath, content, 'utf-8');
     } catch (error) {
-      console.error('キャッシュの保存に失敗しました:', error);
+      // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
+      logger.error({ error, filePath }, 'キャッシュの保存に失敗しました');
     }
   }
 
@@ -190,12 +197,13 @@ export default class FileExtractor {
         },
       };
     } catch (error) {
-      throw this.createError(
-        'extraction_failed',
-        `${filePath} のテキスト抽出に失敗しました: ${(error as Error).message}`,
-        filePath,
-        extension,
-      );
+      logger.error({ error, filePath }, 'ファイルのテキスト抽出に失敗しました');
+      throw internalError({
+        expose: true,
+        messageCode: 'FILE_TEXT_EXTRACTION_ERROR',
+        messageParams: { path: filePath },
+        cause: error,
+      });
     }
   }
 
@@ -229,12 +237,16 @@ export default class FileExtractor {
     try {
       return await fs.readFile(filePath, 'utf-8');
     } catch (error) {
-      throw this.createError(
-        'txt_extraction_failed',
-        `テキストファイルの読み込みに失敗しました: ${(error as Error).message}`,
-        filePath,
-        '.txt',
+      logger.error(
+        { error, filePath },
+        'テキストファイルの読み込みに失敗しました',
       );
+      throw internalError({
+        expose: true,
+        messageCode: 'FILE_TEXT_EXTRACTION_ERROR',
+        messageParams: { path: filePath },
+        cause: error,
+      });
     }
   }
 
@@ -449,22 +461,4 @@ try {
     await pdf.destroy();
     return result.trim();
   }
-
-  /* ------------------------------------------------------------------ */
-  /*  共通エラーヘルパ                                                  */
-  /* ------------------------------------------------------------------ */
-
-  private static createError(
-    code: string,
-    message: string,
-    filePath: string,
-    fileType: string,
-  ): FileExtractionError {
-    const err = new Error(message) as FileExtractionError;
-    err.code = code;
-    err.filePath = filePath;
-    err.fileType = fileType;
-    err.name = 'FileExtractionError';
-    return err;
-  }
 }
diff --git a/src/main/lib/logger.ts b/src/main/lib/logger.ts
new file mode 100644
index 000000000..ee7b2ef8d
--- /dev/null
+++ b/src/main/lib/logger.ts
@@ -0,0 +1,29 @@
+import Logger from 'electron-log';
+import log from 'electron-log/main';
+
+const logLevel = getLogLevel();
+log.transports.file.level = logLevel;
+log.transports.console.level = logLevel;
+
+// シングルトン変数
+let _mainLogger: Logger.MainLogger | null = null;
+
+export function getMainLogger() {
+  if (!_mainLogger) {
+    log.initialize();
+    _mainLogger = log;
+  }
+  return _mainLogger;
+}
+
+export function getLogLevel() {
+  let logLevel: 'debug' | 'info';
+  if (process.env.AIKATA_LOG_DEBUG !== undefined) {
+    // 環境変数が設定されていれば強制 debug
+    logLevel = 'debug';
+  } else {
+    // 通常は NODE_ENV で切り替え
+    logLevel = process.env.NODE_ENV === 'production' ? 'info' : 'debug';
+  }
+  return logLevel;
+}
diff --git a/src/main/lib/messages.ts b/src/main/lib/messages.ts
new file mode 100644
index 000000000..a717c0eb8
--- /dev/null
+++ b/src/main/lib/messages.ts
@@ -0,0 +1,22 @@
+import { IntlMessageFormat } from 'intl-messageformat';
+import { MessageCode } from '@/types';
+import { template } from '@/messages/ja/template';
+
+export type MessageParams = Record<string, unknown>;
+
+export function formatMessage(
+  code: MessageCode,
+  params: MessageParams = {},
+): string {
+  const message = template[code];
+
+  // 未定義IDは安全にフォールバック
+  if (!template) {
+    // TODO: 本番ではログに記録して、ユーザには無難な文言を返す
+    return template['UNKNOWN_ERROR'] ?? '予期せぬエラーが発生しました。';
+  }
+
+  // ICUメッセージを解釈してレンダリング
+  const mf = new IntlMessageFormat(message, 'ja');
+  return mf.format(params) as string;
+}
diff --git a/src/main/utils/util.ts b/src/main/lib/util.ts
similarity index 79%
rename from src/main/utils/util.ts
rename to src/main/lib/util.ts
index 9b6b49c09..e3c43a641 100644
--- a/src/main/utils/util.ts
+++ b/src/main/lib/util.ts
@@ -2,6 +2,7 @@
 import { URL, pathToFileURL } from 'url';
 import path from 'path';
 import fs from 'fs';
+import { internalError } from './error';
 
 export function resolveHtmlPath(htmlFileName: string) {
   if (process.env.NODE_ENV === 'development') {
@@ -28,9 +29,11 @@ export function toAbsolutePath(dirOrPath: string, fileName?: string): string {
   if (fileName !== undefined) {
     // 第一引数に拡張子があれば「ファイル名＋fileName の二重指定」とみなして例外
     if (path.extname(dirOrPath) !== '') {
-      throw new Error(
-        `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。`,
-      );
+      throw internalError({
+        expose: false,
+        messageCode: 'VALIDATION_ERROR',
+        messageParams: { detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。` },
+      });
     }
     // ディレクトリ部を取り出して結合
     return path.join(basePath, fileName);
@@ -62,8 +65,10 @@ export function isPathExists(dirOrPath: string): boolean {
     const absolutePath = toAbsolutePath(dirOrPath);
     return fs.existsSync(absolutePath);
   } catch (error) {
-    throw new Error(
-      `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
-    );
+    throw internalError({
+      expose: true,
+      messageCode: 'VALIDATION_ERROR',
+      messageParams: { detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}` },
+    });
   }
 }
diff --git a/src/main/main.ts b/src/main/main.ts
index 38fae4b3a..fcf7ae124 100644
--- a/src/main/main.ts
+++ b/src/main/main.ts
@@ -17,37 +17,40 @@ import {
   ipcMain,
   crashReporter,
   dialog,
+  IpcMainInvokeEvent,
 } from 'electron';
 import { autoUpdater } from 'electron-updater';
 import log from 'electron-log';
-import { createDataStream, APICallError } from 'ai';
-import { eq } from 'drizzle-orm';
 import {
   ReadableStream,
   WritableStream,
   TransformStream,
 } from 'node:stream/web';
-// @ts-ignore
-import { MastraError } from '@mastra/core/error';
-import { getStore } from './store';
-import type { Source } from '../db/schema';
+import type { Source } from '@/db/schema';
 import {
   IpcChannels,
   IpcResponsePayloadMap,
   IpcRequestPayloadMap,
-} from './types/ipc';
-import { sources } from '../db/schema';
-import getDb from '../db';
+  IpcResult,
+  RequestChannel,
+  IpcChannel,
+  IpcNameMap,
+} from '@/types/ipc';
 import SourceRegistrationManager from '../mastra/workflows/sourceRegistration/sourceRegistrationManager';
 import SourceReviewManager from '../mastra/workflows/sourceReview/sourceReviewManager';
 import MenuBuilder from './menu';
-import { resolveHtmlPath } from './utils/util';
+import { resolveHtmlPath } from './lib/util';
 import { ReviewService } from './service/reviewService';
 import { SettingsService } from './service/settingsService';
 import { ChatService } from './service/chatService';
-import { getReviewRepository } from '../db/repository/reviewRepository';
-import { mastra } from '../mastra';
-import { judgeFinishReason } from '../mastra/agents/lib';
+import { getMainLogger } from './lib/logger';
+import { internalError, normalizeUnknownError, toPayload } from './lib/error';
+import { formatMessage } from './lib/messages';
+import { SourceService } from './service/sourceService';
+import { ZodSchema } from 'zod';
+import { normalizeUnknownIpcError } from './lib/error';
+import { setupElectronPushBroker } from './push/electronPushBroker';
+import { publishEvent } from './lib/eventPayloadHelper';
 
 class AppUpdater {
   constructor() {
@@ -63,710 +66,418 @@ class AppUpdater {
 (globalThis as any).WritableStream = WritableStream;
 (globalThis as any).TransformStream = TransformStream;
 
+// IpcResponsePayloadMap[C] が IpcResult<T> なら T を取り出す
+type DataOf<C extends keyof IpcResponsePayloadMap> =
+  IpcResponsePayloadMap[C] extends IpcResult<infer T> ? T : never;
+
+type Handler<C extends RequestChannel> = (
+  args: IpcRequestPayloadMap[C],
+  ctx: {
+    event: IpcMainInvokeEvent;
+  },
+) => Promise<DataOf<C>> | DataOf<C>;
+
+type Options<C extends RequestChannel> = {
+  /** 引数バリデーション (任意) */
+  schema?: ZodSchema<IpcRequestPayloadMap[C]>;
+  /** 成功/失敗ログに付けたい追加メタデータ (任意) */
+  meta?: Record<string, unknown>;
+  /** 例外をログするか (デフォルト: true) */
+  printErrorLog?: boolean;
+  /** 成功時もログするか (デフォルト: false) */
+  printSuccessLog?: boolean;
+};
+
+/**
+ * 型安全な ipcMain.handle ラッパ
+ * - handler は「成功データ(DataOf<C>)のみ」返す
+ * - 例外はここで握って IpcResult に変換
+ *  - renderer 側では try/catch は基本不要
+ *  - ただし、メッセージにユーザー向けの文言を含めたい場合は適切な例外処理の上、AppError をthrowすること
+ * - Zod スキーマがあれば入力で parse
+ */
+export function handleIpc<C extends RequestChannel>(
+  channel: C,
+  handler: Handler<C>,
+  opts: Options<C> = {},
+) {
+  const { schema, meta, printErrorLog = true, printSuccessLog = false } = opts;
+
+  ipcMain.handle(
+    channel as IpcChannel,
+    async (event, raw): Promise<IpcResponsePayloadMap[C]> => {
+      try {
+        // 引数バリデーション（任意）
+        const args = schema
+          ? await schema.parseAsync(raw)
+          : (raw as IpcRequestPayloadMap[C]);
+
+        const data = await handler(args, { event });
+
+        if (printSuccessLog) {
+          logger.info({ channel, ...meta, ok: true }, 'ipc success');
+        }
+
+        return { success: true, data } as IpcResponsePayloadMap[C];
+      } catch (err) {
+        // normalizeUnknownError で既定フォーマットに寄せる
+        const normalized = normalizeUnknownIpcError(err, IpcNameMap[channel]);
+        console.error(normalized);
+        if (printErrorLog) {
+          logger.error(
+            JSON.stringify(normalized, null, 2),
+            `IPC ${channel} error`,
+          );
+        }
+
+        return {
+          success: false,
+          error: toPayload(normalized),
+        } as IpcResponsePayloadMap[C];
+      }
+    },
+  );
+}
+
 // ユーザは利用者のみなのでIDは固定
 const userId = 'user';
 
-const settingsService = new SettingsService();
+const settingsService = SettingsService.getInstance();
 
-const mastraMemory = mastra.getAgent('orchestrator').getMemory();
-// @ts-ignore
-let chatService: ChatService;
+const chatService = ChatService.getInstance();
 
-const reviewService = new ReviewService();
+const reviewService = ReviewService.getInstance();
 
-mastraMemory.then((memory) => {
-  if (!memory) {
-    throw new Error('メモリが初期化されていません');
-  }
-  chatService = new ChatService(memory);
-});
+const sourceService = SourceService.getInstance();
+
+const logger = getMainLogger();
 
 /**
  * 設定の初期化を行う関数
  */
-const initializeSettings = async (): Promise<void> => {
+const initializeAgentStatus = async (): Promise<void> => {
   try {
     // 設定の初期化
     await settingsService.initializeSettings();
-    console.log('設定の初期化が完了しました');
-  } catch (error) {
-    console.error('設定の初期化に失敗しました:', error);
+  } catch (err) {
+    logger.error(err, '設定の初期化に失敗しました');
+    const error = normalizeUnknownError(err);
   }
 };
 
-const setupStoreHandlers = () => {
-  ipcMain.handle(
-    IpcChannels.GET_STORE_VALUE,
-    async (
-      _,
-      key: string,
-    ): Promise<IpcResponsePayloadMap[typeof IpcChannels.GET_STORE_VALUE]> => {
-      const store = getStore();
-      return store.get(key);
-    },
-  );
+const setupSettingsHandlers = () => {
+  handleIpc(IpcChannels.GET_SETTINGS, async () => {
+    return await settingsService.getSettings();
+  });
 
-  ipcMain.handle(
-    IpcChannels.SET_STORE_VALUE,
-    async (
-      _,
-      key: string,
-      value: unknown,
-    ): Promise<IpcResponsePayloadMap[typeof IpcChannels.SET_STORE_VALUE]> => {
-      try {
-        const store = getStore();
-        store.set(key, value);
-        return true;
-      } catch (error) {
-        console.error('設定の保存中にエラーが発生:', error);
-        return false;
-      }
-    },
-  );
+  handleIpc(IpcChannels.SET_SETTINGS, async (settings) => {
+    await settingsService.saveSettings(settings);
+    return true;
+  });
 };
 
 /**
  * 設定状態を取得するIPCハンドラ
  */
 // 設定状態取得ハンドラ
-ipcMain.handle(
-  IpcChannels.GET_SETTINGS_STATUS,
-  (): IpcResponsePayloadMap[typeof IpcChannels.GET_SETTINGS_STATUS] =>
-    settingsService.getStatus(),
-);
+handleIpc(IpcChannels.GET_SETTINGS_STATUS, async () => {
+  return settingsService.getStatus();
+});
 
 // メッセージ削除ハンドラ
-ipcMain.handle(
-  IpcChannels.REMOVE_SETTINGS_MESSAGE,
-  (
-    _,
-    messageId: string,
-  ): IpcResponsePayloadMap[typeof IpcChannels.REMOVE_SETTINGS_MESSAGE] => {
-    let success = false;
-    let error: string | undefined;
-    try {
-      settingsService.removeMessage(messageId);
-      success = true;
-    } catch (err) {
-      success = false;
-      error = (err as Error).message;
-    }
-    return { success, error };
-  },
-);
+handleIpc(IpcChannels.REMOVE_SETTINGS_MESSAGE, async (messageId) => {
+  settingsService.removeMessage(messageId);
+  return undefined as never;
+});
 
 // 設定更新ハンドラ
-ipcMain.handle(
-  IpcChannels.REINITIALIZE_SETTINGS,
-  async (): Promise<
-    IpcResponsePayloadMap[typeof IpcChannels.REINITIALIZE_SETTINGS]
-  > => {
-    try {
-      // 設定変更時はツールを初期化
-      await settingsService.initializeSettings();
-      return { success: true };
-    } catch (error) {
-      return {
-        success: false,
-        error: (error as Error).message,
-      };
-    }
-  },
-);
+handleIpc(IpcChannels.REINITIALIZE_SETTINGS, async () => {
+  await settingsService.initializeSettings();
+  return undefined as never;
+});
 
 // チャット関連のIPCハンドラー
 const setupChatHandlers = () => {
   // チャット中断ハンドラ
-  ipcMain.handle(
-    IpcChannels.CHAT_ABORT_REQUEST,
-    async (
-      _,
-      threadId,
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.CHAT_ABORT_REQUEST]
-    > => {
-      let success = false;
-      let error: string | undefined;
-      try {
-        const controller = chatService.getOrCreateAbortController(threadId);
-        controller.abort();
-        chatService.deleteAbortController(threadId);
-        console.log(`Thread ${threadId} の生成を中断しました`);
-        success = true;
-      } catch (err) {
-        console.error('スレッドの中断中にエラーが発生:', err);
-        success = false;
-        error = (err as Error).message;
-      }
-      return { success, error };
-    },
-  );
+  handleIpc(IpcChannels.CHAT_ABORT_REQUEST, async ({ threadId }) => {
+    chatService.abortGeneration(threadId);
+    return undefined as never;
+  });
 
   // チャットメッセージ編集履歴ハンドラ
-  ipcMain.handle(
+  handleIpc(
     IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID,
-    async (
-      _,
-      {
-        threadId,
-        messageId,
-      }: IpcRequestPayloadMap[typeof IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID],
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]
-    > => {
-      try {
-        const memory = mastra.getAgent('orchestrator').getMemory();
-        if (!memory) {
-          throw new Error('メモリインスタンスが初期化されていません');
-        }
-        chatService.deleteMessagesBeforeSpecificId(threadId, messageId);
-        return { success: true };
-      } catch (error) {
-        console.error('メッセージ履歴削除中にエラーが発生:', error);
-        return { success: false, error: (error as Error).message };
-      }
+    async ({ threadId, messageId }) => {
+      chatService.deleteMessagesBeforeSpecificId(threadId, messageId);
+      return undefined as never;
     },
   );
 
   // メッセージ送信ハンドラ
-  ipcMain.handle(
+  handleIpc(
     IpcChannels.CHAT_SEND_MESSAGE,
-    async (
-      event,
-      {
-        roomId,
-        messages,
-      }: IpcRequestPayloadMap[typeof IpcChannels.CHAT_SEND_MESSAGE],
-    ): Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_SEND_MESSAGE]> => {
+    async ({ roomId, messages }, { event }) => {
       try {
-        // 新しいAbortControllerを作成
-        const controller = chatService.getOrCreateAbortController(roomId);
-
-        const orchestratorAgent = mastra.getAgent('orchestrator');
-
-        // runtimeContextを作成
-        const runtimeContext = await settingsService.getRuntimeContext();
-
-        // 利用ツールの取得
-        const toolsets = await settingsService.getToolsets();
-
-        // メッセージをストリーミングで送信
-        // const stream = await orchestratorAgent.stream(content, {
-        //   resourceId: 'user', // 固定のリソースID
-        //   toolCallStreaming: true,
-        //   instructions: await getOrchestratorSystemPrompt(
-        //     mastraStatus.tools ?? {
-        //       redmine: false,
-        //       gitlab: false,
-        //       mcp: false,
-        //     },
-        //   ),
-        //   threadId: roomId, // チャットルームIDをスレッドIDとして使用
-        //   maxSteps: 30, // ツールの利用上限
-        //   onFinish: () => {
-        //     // ストリーミングが完了したときの処理
-        //     // フロントエンドに完了通知を送信
-        //     event.sender.send(IpcChannels.CHAT_COMPLETE);
-        //   },
-        // });
-
-        // // DataStreamを生成
-        // const dataStream = createDataStream({
-        //   execute(writer) {
-        //     stream.mergeIntoDataStream(writer);
-        //   },
-        //   onError(error) {
-        //     // エラーが発生したときの処理
-        //     console.error('ストリーミング中にエラーが発生:', error);
-        //     if (error == null) return 'unknown error';
-        //     if (typeof error === 'string') return error;
-        //     if (error instanceof Error) return error.message;
-        //     return JSON.stringify(error);
-        //   },
-        // });
-
-        // DataStreamを生成
-        const dataStream = createDataStream({
-          async execute(writer) {
-            // ストリーミングの開始を通知（このデータは利用されない、あくまで通知するためだけ）
-            writer.writeMessageAnnotation({
-              type: 'status',
-              value: 'processing',
-            });
-            // streaming falseの場合のメッセージ送信処理
-            const res = await orchestratorAgent.generate(messages, {
-              runtimeContext,
-              toolsets,
-              resourceId: 'user', // 固定のリソースID
-              threadId: roomId, // チャットルームIDをスレッドIDとして使用
-              maxSteps: 30, // ツールの利用上限
-              abortSignal: controller.signal, // 中断シグナルを設定
-              onStepFinish: (stepResult) => {
-                // https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol
-                // 上記を参考にai-sdkのストリームプロトコルに従ってメッセージを送信
-                writer.write(`0:${JSON.stringify(stepResult.text)}\n`);
-                stepResult.toolCalls.forEach((toolCall) => {
-                  writer.write(`9:${JSON.stringify(toolCall)}\n`);
-                });
-                stepResult.toolResults.forEach((toolResult) => {
-                  writer.write(`a:${JSON.stringify(toolResult)}\n`);
-                });
-                writer.write(
-                  `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
-                );
-              },
-            });
-            const { success, reason } = judgeFinishReason(res.finishReason);
-            if (!success) {
-              // 正常終了でない場合はエラーを投げる
-              throw new Error(reason);
-            }
-            writer.write(
-              `d:${JSON.stringify({ finishReason: res.finishReason, ...res.usage })}\n`,
-            );
-            event.sender.send(IpcChannels.CHAT_COMPLETE);
-            // 処理が完了したらAbortControllerを削除
-            chatService.deleteAbortController(roomId);
-          },
-          onError(error) {
-            // エラーが発生したときの処理
-            console.error('テキスト生成中にエラーが発生:', error);
-            // エラー時もAbortControllerを削除
-            chatService.deleteAbortController(roomId);
-            let errorDetail: string;
-            if (
-              error instanceof MastraError &&
-              APICallError.isInstance(error.cause)
-            ) {
-              // APIコールエラーの場合はresponseBodyの内容を取得
-              errorDetail = error.cause.message;
-              if (error.cause.responseBody) {
-                errorDetail += `:\n${error.cause.responseBody}`;
-              }
-            } else if (error instanceof Error) {
-              errorDetail = error.message;
-            } else {
-              errorDetail = JSON.stringify(error);
-            }
-            return `テキスト生成中にエラーが発生しました:\n${errorDetail}`;
-          },
-        });
+        const dataStream = await chatService.generate(
+          userId,
+          roomId,
+          messages,
+          event,
+        );
 
         // テキストストリームを処理
         // @ts-ignore
         for await (const chunk of dataStream) {
           // チャンクをフロントエンドに送信
-          event.sender.send(IpcChannels.CHAT_STREAM, chunk);
+          publishEvent(IpcChannels.CHAT_STREAM, chunk);
         }
 
-        return { success: true };
+        return undefined as never;
       } catch (error) {
-        console.error('メッセージ送信中にエラーが発生:', error);
         // エラー時もAbortControllerを削除
         chatService.deleteAbortController(roomId);
-        event.sender.send(IpcChannels.CHAT_ERROR, {
-          message: `${(error as Error).message}`,
+        const normalizedError = normalizeUnknownError(error);
+        const errorMessage = formatMessage('CHAT_GENERATE_ERROR', {
+          detail: normalizedError.message,
+        });
+        publishEvent(IpcChannels.CHAT_ERROR, { message: errorMessage });
+        publishEvent(IpcChannels.CHAT_COMPLETE, undefined);
+
+        throw internalError({
+          expose: true,
+          messageCode: 'CHAT_GENERATE_ERROR',
+          messageParams: { detail: normalizedError.message },
+          cause: error,
         });
-        event.sender.send(IpcChannels.CHAT_COMPLETE);
-        return { success: false, error: (error as Error).message };
       }
     },
   );
 
   // チャットルーム一覧取得ハンドラ
-  ipcMain.handle(
-    IpcChannels.CHAT_GET_ROOMS,
-    async (): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.CHAT_GET_ROOMS]
-    > => {
-      try {
-        const threads = await chatService.getThreadList(userId);
-        return threads;
-      } catch (error) {
-        console.error('チャットルーム一覧の取得中にエラーが発生:', error);
-        return [];
-      }
-    },
-  );
+  handleIpc(IpcChannels.CHAT_GET_ROOMS, async () => {
+    const threads = await chatService.getThreadList(userId);
+    return threads;
+  });
 
   // チャットメッセージ履歴取得ハンドラ
-  ipcMain.handle(
-    IpcChannels.CHAT_GET_MESSAGES,
-    async (
-      _,
-      threadId: string,
-    ): Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_GET_MESSAGES]> => {
-      try {
-        return chatService.getThreadMessages(threadId);
-      } catch (error) {
-        console.error('チャットメッセージの取得中にエラーが発生:', error);
-        return [];
-      }
-    },
-  );
+  handleIpc(IpcChannels.CHAT_GET_MESSAGES, async (threadId) => {
+    const messages = await chatService.getThreadMessages(threadId);
+    return messages;
+  });
 
   // チャットルーム削除ハンドラ
-  ipcMain.handle(
-    IpcChannels.CHAT_DELETE_ROOM,
-    async (
-      _,
-      threadId: string,
-    ): Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_DELETE_ROOM]> => {
-      try {
-        await chatService.deleteThread(threadId);
-
-        return { success: true };
-      } catch (error) {
-        console.error('チャットルームの削除中にエラーが発生:', error);
-        return { success: false, error: (error as Error).message };
-      }
-    },
-  );
+  handleIpc(IpcChannels.CHAT_DELETE_ROOM, async (threadId) => {
+    await chatService.deleteThread(threadId);
+    return undefined as never;
+  });
 
   // スレッド作成ハンドラ
-  ipcMain.handle(
-    IpcChannels.CHAT_CREATE_THREAD,
-    async (
-      _,
-      { roomId, title },
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.CHAT_CREATE_THREAD]
-    > => {
-      try {
-        await chatService.createThread(roomId, title, userId);
-
-        return { success: true };
-      } catch (error) {
-        console.error('チャットルームの作成中にエラーが発生:', error);
-        return { success: false, error: (error as Error).message };
-      }
-    },
-  );
+  handleIpc(IpcChannels.CHAT_CREATE_THREAD, async ({ roomId, title }) => {
+    await chatService.createThread(roomId, title, userId);
+    return undefined as never;
+  });
 };
 
 // ソース関連のIPCハンドラー
 // ファイルシステム関連のIPCハンドラー
 const setupFsHandlers = () => {
-  ipcMain.handle(
-    IpcChannels.FS_CHECK_PATH_EXISTS,
-    async (_, filePath: string): Promise<boolean> => {
-      try {
-        await fs.access(filePath);
-        return true;
-      } catch {
-        return false;
-      }
-    },
-  );
+  handleIpc(IpcChannels.FS_CHECK_PATH_EXISTS, async (filePath) => {
+    try {
+      await fs.access(filePath);
+      return true;
+    } catch {
+      return false;
+    }
+  });
 
-  ipcMain.handle(
-    IpcChannels.FS_SHOW_OPEN_DIALOG,
-    async (
-      _,
-      options: {
-        title: string;
-        filters?: { name: string; extensions: string[] }[];
-        properties?: (
-          | 'openFile'
-          | 'openDirectory'
-          | 'multiSelections'
-          | 'showHiddenFiles'
-          | 'createDirectory'
-          | 'promptToCreate'
-          | 'noResolveAliases'
-          | 'treatPackageAsDirectory'
-          | 'dontAddToRecent'
-        )[];
-      },
-    ) => {
-      const result = await dialog.showOpenDialog(options);
-      return result;
-    },
-  );
-  ipcMain.handle(
-    IpcChannels.FS_READ_FILE,
-    async (_, filePath: string): Promise<Uint8Array> => {
-      try {
-        const data = await fs.readFile(filePath);
-        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
-      } catch (error) {
-        console.error('ファイルの読み込み中にエラーが発生:', error);
-        throw error;
-      }
-    },
-  );
+  handleIpc(IpcChannels.FS_SHOW_OPEN_DIALOG, async (options) => {
+    const result = await dialog.showOpenDialog(options);
+    return result;
+  });
+
+  handleIpc(IpcChannels.FS_READ_FILE, async (filePath) => {
+    const data = await fs.readFile(filePath);
+    const result = new Uint8Array(
+      data.buffer,
+      data.byteOffset,
+      data.byteLength,
+    );
+    return result;
+  });
 };
 
 const setupSourceHandlers = () => {
   // ソース再読み込みハンドラ
-  ipcMain.handle(
-    IpcChannels.SOURCE_RELOAD,
-    async (): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.SOURCE_RELOAD]
-    > => {
-      try {
-        const registrationManager = SourceRegistrationManager.getInstance();
-        await registrationManager.registerAllFiles();
-        return { success: true, message: 'ソースの再読み込みが完了しました' };
-      } catch (error) {
-        console.error('ソースの再読み込み中にエラーが発生:', error);
-        return {
-          success: false,
-          message: `エラーが発生しました: ${(error as Error).message}`,
-        };
-      }
-    },
-  );
+  handleIpc(IpcChannels.SOURCE_RELOAD, async () => {
+    const registrationManager = SourceRegistrationManager.getInstance();
+    await registrationManager.registerAllFiles();
+    return { message: 'ドキュメントの再読み込みが完了しました' };
+  });
 
   // ソース一覧取得ハンドラ
-  ipcMain.handle(
-    IpcChannels.SOURCE_GET_ALL,
-    async (): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.SOURCE_GET_ALL]
-    > => {
-      try {
-        const db = await getDb();
-        const sourcesList = await db.select().from(sources);
-        return {
-          success: true,
-          sources: sourcesList.map((source: Source) => ({
-            ...source,
-            // ISO 8601形式の日時文字列をDateオブジェクトに変換してから文字列に戻す
-            // これにより、フロントエンドで一貫した日時表示が可能になる
-            createdAt: new Date(source.createdAt).toISOString(),
-            updatedAt: new Date(source.updatedAt).toISOString(),
-          })),
-        };
-      } catch (error) {
-        console.error('ソース一覧の取得中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
-      }
-    },
-  );
+  handleIpc(IpcChannels.SOURCE_GET_ALL, async () => {
+    const allSources = await sourceService.getAllSources();
+    const data = allSources.map((source: Source) => ({
+      ...source,
+      // ISO 8601形式の日時文字列をDateオブジェクトに変換してから文字列に戻す
+      // これにより、フロントエンドで一貫した日時表示が可能になる
+      createdAt: new Date(source.createdAt).toISOString(),
+      updatedAt: new Date(source.updatedAt).toISOString(),
+    }));
+    return data;
+  });
 
   // ソースの有効/無効状態を更新するハンドラ
-  ipcMain.handle(
+  handleIpc(
     IpcChannels.SOURCE_UPDATE_ENABLED,
-    async (
-      _,
-      { sourceId, isEnabled },
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.SOURCE_UPDATE_ENABLED]
-    > => {
-      try {
-        const db = await getDb();
-        await db
-          .update(sources)
-          .set({ isEnabled })
-          .where(eq(sources.id, sourceId));
-        return { success: true };
-      } catch (error) {
-        console.error('ソースの有効/無効状態の更新中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
-      }
+    async ({ sourceId, isEnabled }) => {
+      await sourceService.updateSourceEnabled(sourceId, isEnabled);
+      return undefined as never;
     },
   );
 };
 
 const setupReviewHandlers = () => {
   // レビュー履歴の取得ハンドラ
-  ipcMain.handle(
-    IpcChannels.REVIEW_GET_HISTORIES,
-    async (): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORIES]
-    > => {
-      try {
-        const histories = await reviewService.getReviewHistories();
-
-        return {
-          success: true,
-          histories,
-        };
-      } catch (error) {
-        console.error('レビュー履歴の取得中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
-      }
-    },
-  );
+  handleIpc(IpcChannels.REVIEW_GET_HISTORIES, async () => {
+    const histories = await reviewService.getReviewHistories();
+    return histories;
+  });
 
   // チェックリストの取得ハンドラ
-  ipcMain.handle(
-    IpcChannels.REVIEW_GET_HISTORY_DETAIL,
-    async (
-      _,
-      historyId: string,
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORY_DETAIL]
-    > => {
-      try {
-        const repository = getReviewRepository();
-        const reviewHistory = await repository.getReviewHistory(historyId);
-        const checklistResults =
-          await reviewService.getReviewHistoryDetail(historyId);
+  handleIpc(IpcChannels.REVIEW_GET_HISTORY_DETAIL, async (historyId) => {
+    const detail = await reviewService.getReviewHistoryDetail(historyId);
+    return detail;
+  });
 
-        return {
-          success: true,
-          checklistResults,
-          additionalInstructions:
-            reviewHistory?.additionalInstructions || undefined,
-          commentFormat: reviewHistory?.commentFormat || undefined,
-        };
-      } catch (error) {
-        console.error('チェックリストの取得中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
-      }
-    },
-  );
+  // レビュー指示の取得ハンドラ
+  handleIpc(IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION, async (historyId) => {
+    const instruction = await reviewService.getReviewInstruction(historyId);
+    return instruction;
+  });
 
   // レビュー履歴の削除ハンドラ
-  ipcMain.handle(
-    IpcChannels.REVIEW_DELETE_HISTORY,
-    async (
-      _,
-      historyId: string,
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_DELETE_HISTORY]
-    > => {
-      try {
-        await reviewService.deleteReviewHistory(historyId);
-
-        return { success: true };
-      } catch (error) {
-        console.error('レビュー履歴の削除中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
-      }
-    },
-  );
+  handleIpc(IpcChannels.REVIEW_DELETE_HISTORY, async (historyId) => {
+    await reviewService.deleteReviewHistory(historyId);
+    return undefined as never;
+  });
 
   // チェックリスト抽出ハンドラ
-  ipcMain.handle(
+  handleIpc(
     IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL,
-    async (
-      event,
-      {
+    async ({ reviewHistoryId, files, documentType, checklistRequirements }) => {
+      const manager = SourceReviewManager.getInstance();
+      const result = manager.extractChecklistWithNotification(
         reviewHistoryId,
         files,
         documentType,
         checklistRequirements,
-      }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL],
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]
-    > => {
-      try {
-        const manager = SourceReviewManager.getInstance();
-
-        // 非同期でチェックリスト抽出処理を実行
-        const result = manager.extractChecklistWithNotification(
-          reviewHistoryId,
-          files,
-          event,
-          documentType,
-          checklistRequirements,
-        );
-
-        return result;
-      } catch (error) {
-        console.error('チェックリスト抽出処理開始時にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
+      );
+      if (!result.success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'UNKNOWN_ERROR',
+          messageParams: { detail: result.error! },
+          cause: new Error(result.error!),
+        });
       }
+      return undefined as never;
     },
   );
 
   // チェックリストの更新ハンドラ
-  ipcMain.handle(
+  handleIpc(
     IpcChannels.REVIEW_UPDATE_CHECKLIST,
-    async (
-      _,
-      {
-        reviewHistoryId,
-        checklistEdits,
-      }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_UPDATE_CHECKLIST],
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_UPDATE_CHECKLIST]
-    > => {
-      try {
-        const result = await reviewService.updateChecklists(
-          reviewHistoryId,
-          checklistEdits,
-        );
-
-        return result;
-      } catch (error) {
-        console.error('チェックリストの更新中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
-      }
+    async ({ reviewHistoryId, checklistEdits }) => {
+      await reviewService.updateChecklists(reviewHistoryId, checklistEdits);
+      return undefined as never;
     },
   );
 
   // レビュー実施ハンドラ
-  ipcMain.handle(
+  handleIpc(
     IpcChannels.REVIEW_EXECUTE_CALL,
-    async (
-      event,
-      {
+    async ({
+      reviewHistoryId,
+      files,
+      additionalInstructions,
+      commentFormat,
+    }) => {
+      reviewService.updateReviewInstruction(
+        reviewHistoryId,
+        additionalInstructions,
+        commentFormat,
+      );
+      const manager = SourceReviewManager.getInstance();
+
+      // 非同期でレビュー実行処理を実行
+      const result = manager.executeReviewWithNotification(
         reviewHistoryId,
         files,
         additionalInstructions,
         commentFormat,
-      }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL],
-    ): Promise<
-      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL]
-    > => {
-      try {
-        const manager = SourceReviewManager.getInstance();
+      );
+
+      if (!result.success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'UNKNOWN_ERROR',
+          messageParams: { detail: result.error! },
+          cause: new Error(result.error!),
+        });
+      }
 
-        // 非同期でレビュー実行処理を実行
-        manager.executeReviewWithNotification(
-          reviewHistoryId,
-          files,
-          event,
-          additionalInstructions,
-          commentFormat,
-        );
+      return undefined as never;
+    },
+  );
 
-        return { success: true };
-      } catch (error) {
-        console.error('レビュー実行処理開始中にエラーが発生:', error);
-        return {
-          success: false,
-          error: (error as Error).message,
-        };
+  // チェックリスト抽出キャンセルハンドラ
+  handleIpc(
+    IpcChannels.REVIEW_EXTRACT_CHECKLIST_ABORT,
+    async (reviewHistoryId) => {
+      const manager = SourceReviewManager.getInstance();
+      const result = manager.abortExtractChecklist(reviewHistoryId);
+      if (!result.success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'UNKNOWN_ERROR',
+          messageParams: { detail: result.error! },
+          cause: new Error(result.error!),
+        });
       }
+      return undefined as never;
     },
   );
+
+  // レビュー実行キャンセルハンドラ
+  handleIpc(IpcChannels.REVIEW_EXECUTE_ABORT, async (reviewHistoryId) => {
+    const manager = SourceReviewManager.getInstance();
+    const result = manager.abortExecuteReview(reviewHistoryId);
+    if (!result.success) {
+      throw internalError({
+        expose: true,
+        messageCode: 'UNKNOWN_ERROR',
+        messageParams: { detail: result.error! },
+        cause: new Error(result.error!),
+      });
+    }
+    return undefined as never;
+  });
 };
 
 // ソース登録処理の実行
 const initializeSourceRegistration = async () => {
-  console.log('ソースファイルの初期登録を開始します...');
+  logger.debug('ドキュメントの初期登録を開始します');
   const registrationManager = SourceRegistrationManager.getInstance();
 
   // 処理中のソースを削除
+  logger.debug(
+    '処理中及び失敗しているドキュメントの実行履歴をクリアしています',
+  );
   await registrationManager.clearProcessingSources();
-  console.log('処理中のソースを削除しました');
 
   // ソース登録を実行
+  logger.debug('ドキュメントの登録を実行しています');
   await registrationManager.registerAllFiles();
   console.log('ソースファイルの初期登録が完了しました');
 };
@@ -881,8 +592,9 @@ crashReporter.start({
 
 const initialize = async () => {
   createWindow();
-  await initializeSettings();
-  setupStoreHandlers();
+  await initializeAgentStatus();
+  setupElectronPushBroker();
+  setupSettingsHandlers();
   setupChatHandlers();
   setupFsHandlers();
   setupSourceHandlers();
diff --git a/src/main/preload.ts b/src/main/preload.ts
index 07577d2d7..ffebf42bc 100644
--- a/src/main/preload.ts
+++ b/src/main/preload.ts
@@ -3,285 +3,163 @@
 import { contextBridge, ipcRenderer, IpcRendererEvent } from 'electron';
 import {
   IpcChannels,
-  IpcResponsePayload,
-  IpcEventPayload,
-  IpcRequestPayload,
-} from './types/ipc';
+  RequestChannel,
+  ResponseChannel,
+  IpcRequestPayloadMap,
+  IpcResponsePayloadMap,
+  EventChannel,
+  IpcNameMap,
+  PushEvent,
+} from '@/types';
+import { normalizeUnknownIpcError, toPayload } from './lib/error';
+import { getRendererLogger } from '@/renderer/lib/logger';
 
 export type Channels = (typeof IpcChannels)[keyof typeof IpcChannels];
 
+/** C の引数を「undefined のときは引数なし、そうでなければ 1 引数」にする補助型 */
+type ArgOf<C extends RequestChannel> = IpcRequestPayloadMap[C] extends undefined
+  ? []
+  : [IpcRequestPayloadMap[C]];
+
+/**
+ * すべての ipcRenderer.invoke をここで一元化。
+ * どのチャンネルでも、成功は {ok:true,data}、失敗は {ok:false,error} を返す。
+ * Mainのhandler側で例外を握っているので、Renderer側でtry/catchする必要は基本的にない
+ * 起動直後でMain側がまだ準備できていない場合などに例外が発生する可能性はある
+ */
+export async function invokeIpc<C extends RequestChannel & ResponseChannel>(
+  channel: C,
+  ...args: ArgOf<C> | []
+): Promise<IpcResponsePayloadMap[C]> {
+  const logger = getRendererLogger();
+  try {
+    const res = await ipcRenderer.invoke(channel, ...(args as any[]));
+
+    // 既に IpcResult で返ってきていればそのまま
+    if (res && typeof res === 'object' && 'success' in res) {
+      return res as IpcResponsePayloadMap[C];
+    }
+    // 素の値は success: true で包む
+    return { success: true, data: res } as IpcResponsePayloadMap[C];
+  } catch (err: unknown) {
+    const error = normalizeUnknownIpcError(err, IpcNameMap[channel]);
+    logger.error(error, `IPC ${channel} error`);
+    return {
+      success: false,
+      error: toPayload(error),
+    } as IpcResponsePayloadMap[C];
+  }
+}
+
 const electronHandler = {
   settings: {
     // 設定の状態を取得する
-    getStatus: (): Promise<
-      IpcResponsePayload<typeof IpcChannels.GET_SETTINGS_STATUS>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.GET_SETTINGS_STATUS);
-    },
+    getStatus: () => invokeIpc(IpcChannels.GET_SETTINGS_STATUS),
     // 設定を再初期化する
-    reinitialize: async (): Promise<
-      IpcResponsePayload<typeof IpcChannels.REINITIALIZE_SETTINGS>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.REINITIALIZE_SETTINGS);
-    },
+    reinitialize: () => invokeIpc(IpcChannels.REINITIALIZE_SETTINGS),
     // 設定のメッセージを削除する
-    removeMessage: async (
-      messageId: string,
-    ): Promise<
-      IpcResponsePayload<typeof IpcChannels.REINITIALIZE_SETTINGS>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.REMOVE_SETTINGS_MESSAGE, messageId);
-    },
+    removeMessage: (messageId: string) =>
+      invokeIpc(IpcChannels.REMOVE_SETTINGS_MESSAGE, messageId),
+    // 設定を一括取得する
+    getSettings: () => invokeIpc(IpcChannels.GET_SETTINGS),
+    // 設定を一括保存する
+    setSettings: (
+      settings: IpcRequestPayloadMap[typeof IpcChannels.SET_SETTINGS],
+    ) => invokeIpc(IpcChannels.SET_SETTINGS, settings),
   },
   fs: {
-    access: async (path: string): Promise<boolean> => {
-      return ipcRenderer.invoke(IpcChannels.FS_CHECK_PATH_EXISTS, path);
-    },
-    showOpenDialog: async (options: {
-      title: string;
-      filters?: { name: string; extensions: string[] }[];
-      properties?: string[];
-    }) => {
-      return ipcRenderer.invoke(IpcChannels.FS_SHOW_OPEN_DIALOG, options);
-    },
-    readFile: async (filePath: string): Promise<Uint8Array> => {
-      return ipcRenderer.invoke(IpcChannels.FS_READ_FILE, filePath);
-    },
-  },
-  store: {
-    get: async (
-      key: string,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.GET_STORE_VALUE>> => {
-      return ipcRenderer.invoke(IpcChannels.GET_STORE_VALUE, key);
-    },
-    set: async (
-      key: string,
-      value: unknown,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.SET_STORE_VALUE>> => {
-      return ipcRenderer.invoke(IpcChannels.SET_STORE_VALUE, key, value);
-    },
+    /** パスが存在するか */
+    access: (path: string) => invokeIpc(IpcChannels.FS_CHECK_PATH_EXISTS, path),
+    /** ファイル選択ダイアログ */
+    showOpenDialog: (
+      options: IpcRequestPayloadMap[typeof IpcChannels.FS_SHOW_OPEN_DIALOG],
+    ) => invokeIpc(IpcChannels.FS_SHOW_OPEN_DIALOG, options),
+    /** ファイル読み込み（Uint8Array） */
+    readFile: (filePath: string) =>
+      invokeIpc(IpcChannels.FS_READ_FILE, filePath),
   },
   chat: {
-    // チャットメッセージを送信する
-    sendMessage: async (
-      params: IpcRequestPayload<typeof IpcChannels.CHAT_SEND_MESSAGE>,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.CHAT_SEND_MESSAGE>> => {
-      return ipcRenderer.invoke(IpcChannels.CHAT_SEND_MESSAGE, params);
-    },
-    // チャットルーム一覧を取得する
-    getRooms: async (): Promise<
-      IpcResponsePayload<typeof IpcChannels.CHAT_GET_ROOMS>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.CHAT_GET_ROOMS);
-    },
-    // チャットメッセージ履歴を取得する
-    getMessages: async (
-      threadId: string,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.CHAT_GET_MESSAGES>> => {
-      return ipcRenderer.invoke(IpcChannels.CHAT_GET_MESSAGES, threadId);
-    },
-    // チャットルームを削除する
-    deleteRoom: async (
-      threadId: string,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.CHAT_DELETE_ROOM>> => {
-      return ipcRenderer.invoke(IpcChannels.CHAT_DELETE_ROOM, threadId);
-    },
-    // 新規スレッドを作成する
-    createThread: (params: {
-      roomId: string;
-      title: string;
-    }): Promise<IpcResponsePayload<typeof IpcChannels.CHAT_CREATE_THREAD>> => {
-      return ipcRenderer.invoke(IpcChannels.CHAT_CREATE_THREAD, params);
-    },
-    // 生成を中断するリクエストを送信
-    requestAbort: async (
-      threadId: string,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.CHAT_ABORT_REQUEST>> => {
-      return ipcRenderer.invoke(IpcChannels.CHAT_ABORT_REQUEST, threadId);
-    },
-    // メッセージ編集時に該当indexまでの履歴を削除する
-    deleteMessagesBeforeSpecificId: async (
-      params: IpcRequestPayload<
-        typeof IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID
-      >,
-    ): Promise<
-      IpcResponsePayload<
-        typeof IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID
-      >
-    > => {
-      return ipcRenderer.invoke(
-        IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID,
-        params,
-      );
-    },
-    // AIの応答を取得する（ストリーミング）
-    onStream: (
-      callback: (
-        chunk: IpcEventPayload<typeof IpcChannels.CHAT_STREAM>,
-      ) => void,
-    ) => {
-      const subscription = (
-        _event: IpcRendererEvent,
-        chunk: IpcEventPayload<typeof IpcChannels.CHAT_STREAM>,
-      ) => {
-        callback(chunk);
-      };
-      ipcRenderer.on(IpcChannels.CHAT_STREAM, subscription);
-      return () => {
-        ipcRenderer.removeListener(IpcChannels.CHAT_STREAM, subscription);
-      };
-    },
-    // AIの応答完了イベント
-    onComplete: (callback: () => void) => {
-      // eslint-disable-next-line
-      const subscription = (_event: IpcRendererEvent) => {
-        callback();
-      };
-      ipcRenderer.on(IpcChannels.CHAT_COMPLETE, subscription);
-      return () => {
-        ipcRenderer.removeListener(IpcChannels.CHAT_COMPLETE, subscription);
-      };
-    },
-    // エラーイベント
-    onError: (
-      callback: (error: IpcEventPayload<typeof IpcChannels.CHAT_ERROR>) => void,
-    ) => {
-      const subscription = (
-        _event: IpcRendererEvent,
-        error: IpcEventPayload<typeof IpcChannels.CHAT_ERROR>,
-      ) => {
-        callback(error);
-      };
-      ipcRenderer.on(IpcChannels.CHAT_ERROR, subscription);
-      return () => {
-        ipcRenderer.removeListener(IpcChannels.CHAT_ERROR, subscription);
-      };
-    },
+    /** チャットメッセージ送信 */
+    sendMessage: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.CHAT_SEND_MESSAGE],
+    ) => invokeIpc(IpcChannels.CHAT_SEND_MESSAGE, params),
+    /** ルーム一覧取得 */
+    getRooms: () => invokeIpc(IpcChannels.CHAT_GET_ROOMS),
+    /** メッセージ履歴取得 */
+    getMessages: (threadId: string) =>
+      invokeIpc(IpcChannels.CHAT_GET_MESSAGES, threadId),
+    /** ルーム削除 */
+    deleteRoom: (threadId: string) =>
+      invokeIpc(IpcChannels.CHAT_DELETE_ROOM, threadId),
+    /** スレッド作成 */
+    createThread: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.CHAT_CREATE_THREAD],
+    ) => invokeIpc(IpcChannels.CHAT_CREATE_THREAD, params),
+    /** 中断リクエスト */
+    requestAbort: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.CHAT_ABORT_REQUEST],
+    ) => invokeIpc(IpcChannels.CHAT_ABORT_REQUEST, params),
+    /** 指定メッセージID以前を削除 */
+    deleteMessagesBeforeSpecificId: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID],
+    ) => invokeIpc(IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID, params),
   },
   source: {
-    // ソースの再読み込みを実行する
-    reloadSources: async (): Promise<
-      IpcResponsePayload<typeof IpcChannels.SOURCE_RELOAD>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.SOURCE_RELOAD);
-    },
-    // ソース一覧を取得する
-    getSources: async (): Promise<
-      IpcResponsePayload<typeof IpcChannels.SOURCE_GET_ALL>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.SOURCE_GET_ALL);
-    },
-    // ソースの有効/無効状態を更新する
-    updateSourceEnabled: async (
-      sourceId: number,
-      isEnabled: boolean,
-    ): Promise<
-      IpcResponsePayload<typeof IpcChannels.SOURCE_UPDATE_ENABLED>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.SOURCE_UPDATE_ENABLED, {
-        sourceId,
-        isEnabled,
-      });
-    },
+    /** ソース再読み込み */
+    reloadSources: () => invokeIpc(IpcChannels.SOURCE_RELOAD),
+    /** ソース一覧 */
+    getSources: () => invokeIpc(IpcChannels.SOURCE_GET_ALL),
+    /** 有効/無効更新 */
+    updateSourceEnabled: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.SOURCE_UPDATE_ENABLED],
+    ) => invokeIpc(IpcChannels.SOURCE_UPDATE_ENABLED, params),
   },
   review: {
-    // レビュー履歴一覧を取得する
-    getHistories: async (): Promise<
-      IpcResponsePayload<typeof IpcChannels.REVIEW_GET_HISTORIES>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.REVIEW_GET_HISTORIES);
-    },
-    // レビュー履歴詳細を取得する
-    getHistoryDetail: async (
-      historyId: string,
-    ): Promise<
-      IpcResponsePayload<typeof IpcChannels.REVIEW_GET_HISTORY_DETAIL>
-    > => {
-      return ipcRenderer.invoke(
-        IpcChannels.REVIEW_GET_HISTORY_DETAIL,
-        historyId,
-      );
-    },
-    // レビュー履歴を削除する
-    deleteHistory: async (
-      historyId: string,
-    ): Promise<
-      IpcResponsePayload<typeof IpcChannels.REVIEW_DELETE_HISTORY>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.REVIEW_DELETE_HISTORY, historyId);
-    },
-    // チェックリストを抽出する
-    extractChecklist: async (
-      params: IpcRequestPayload<
-        typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL
-      >,
-    ): Promise<
-      IpcResponsePayload<typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL>
-    > => {
-      return ipcRenderer.invoke(
-        IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL,
-        params,
-      );
-    },
-    // チェックリストを更新する
-    updateChecklist: async (
-      params: IpcRequestPayload<typeof IpcChannels.REVIEW_UPDATE_CHECKLIST>,
-    ): Promise<
-      IpcResponsePayload<typeof IpcChannels.REVIEW_UPDATE_CHECKLIST>
-    > => {
-      return ipcRenderer.invoke(IpcChannels.REVIEW_UPDATE_CHECKLIST, params);
-    },
-    // ドキュメントレビューを実行する
-    execute: async (
-      params: IpcRequestPayload<typeof IpcChannels.REVIEW_EXECUTE_CALL>,
-    ): Promise<IpcResponsePayload<typeof IpcChannels.REVIEW_EXECUTE_CALL>> => {
-      return ipcRenderer.invoke(IpcChannels.REVIEW_EXECUTE_CALL, params);
-    },
-    // チェックリスト抽出完了イベントを購読する
-    onExtractChecklistFinished: (
-      callback: (
-        payload: IpcEventPayload<
-          typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
-        >,
-      ) => void,
-    ) => {
-      const subscription = (
-        _event: IpcRendererEvent,
-        payload: IpcEventPayload<
-          typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
-        >,
-      ) => {
-        callback(payload);
-      };
-      ipcRenderer.on(
-        IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
-        subscription,
-      );
-      return () => {
-        ipcRenderer.removeListener(
-          IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
-          subscription,
-        );
-      };
-    },
-    // ドキュメントレビュー実行完了イベントを購読する
-    onExecuteReviewFinished: (
-      callback: (
-        payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
-      ) => void,
-    ) => {
-      const subscription = (
-        _event: IpcRendererEvent,
-        payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
-      ) => {
-        callback(payload);
-      };
-      ipcRenderer.on(IpcChannels.REVIEW_EXECUTE_FINISHED, subscription);
+    /** レビュー履歴一覧 */
+    getHistories: () => invokeIpc(IpcChannels.REVIEW_GET_HISTORIES),
+    /** 履歴詳細 */
+    getHistoryDetail: (historyId: string) =>
+      invokeIpc(IpcChannels.REVIEW_GET_HISTORY_DETAIL, historyId),
+    /** 履歴の追加指示とコメントフォーマット取得 */
+    getHistoryInstruction: (historyId: string) =>
+      invokeIpc(IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION, historyId),
+    /** 履歴削除 */
+    deleteHistory: (historyId: string) =>
+      invokeIpc(IpcChannels.REVIEW_DELETE_HISTORY, historyId),
+    /** チェックリスト抽出 */
+    extractChecklist: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL],
+    ) => invokeIpc(IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL, params),
+    /** チェックリスト抽出キャンセル */
+    abortExtractChecklist: (reviewHistoryId: string) =>
+      invokeIpc(IpcChannels.REVIEW_EXTRACT_CHECKLIST_ABORT, reviewHistoryId),
+    /** チェックリスト更新 */
+    updateChecklist: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_UPDATE_CHECKLIST],
+    ) => invokeIpc(IpcChannels.REVIEW_UPDATE_CHECKLIST, params),
+    /** レビュー実行 */
+    execute: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL],
+    ) => invokeIpc(IpcChannels.REVIEW_EXECUTE_CALL, params),
+    /** レビュー実行キャンセル */
+    abortExecute: (reviewHistoryId: string) =>
+      invokeIpc(IpcChannels.REVIEW_EXECUTE_ABORT, reviewHistoryId),
+  },
+  pushApi: {
+    async subscribe<C extends EventChannel>(
+      channel: C,
+      cb: (ev: PushEvent<C>) => void,
+    ) {
+      const { subId } = await ipcRenderer.invoke('push:subscribe', channel);
+
+      const evtName = `push:${channel}:${subId}`;
+      const listener = (_: unknown, ev: PushEvent<C>) => cb(ev);
+
+      ipcRenderer.on(evtName, listener);
+
       return () => {
-        ipcRenderer.removeListener(
-          IpcChannels.REVIEW_EXECUTE_FINISHED,
-          subscription,
-        );
+        ipcRenderer.removeListener(evtName, listener);
+        ipcRenderer.invoke('push:unsubscribe', channel, subId);
       };
     },
   },
diff --git a/src/main/push/InProcBroker.ts b/src/main/push/InProcBroker.ts
new file mode 100644
index 000000000..e879ea612
--- /dev/null
+++ b/src/main/push/InProcBroker.ts
@@ -0,0 +1,54 @@
+import { randomUUID } from 'node:crypto';
+import type { Channel, PushEvent, StreamSink, PushBroker } from '@/types';
+
+/**
+ * 単一プロセス内で使う軽量ブローカー実装。
+ * - Electron Main / Next.js(Nodeランタイム)のどちらでもそのまま使える
+ * - 将来スケールが必要なら、この1ファイルを Redis/NATS 版に置き換えればOK
+ */
+export class InProcPushBroker implements PushBroker {
+  // チャンネル -> (subscriberId -> sink)
+  private subs = new Map<Channel, Map<string, StreamSink>>();
+
+  publish<C extends Channel>(channel: C, ev: PushEvent<C>): void {
+    // 配信
+    const sinks = this.subs.get(channel);
+    if (!sinks) return;
+
+    for (const sink of sinks.values()) {
+      try {
+        (sink as StreamSink<C>).write(ev);
+      } catch {
+        try {
+          sink.close?.();
+        } finally {
+          sinks.delete(sink.id!);
+        }
+      }
+    }
+  }
+
+  registerStream<C extends Channel>(
+    channel: C,
+    sink: StreamSink<C>,
+  ): () => void {
+    const id = sink.id ?? randomUUID();
+    sink.id = id;
+
+    let set = this.subs.get(channel);
+    if (!set) {
+      set = new Map<string, StreamSink>();
+      this.subs.set(channel, set);
+    }
+    set.set(id, sink as StreamSink);
+
+    // 解除関数
+    return () => {
+      const s = this.subs.get(channel);
+      if (!s) return;
+      s.delete(id);
+      sink.close?.();
+      if (s.size === 0) this.subs.delete(channel);
+    };
+  }
+}
diff --git a/src/main/push/electronPushBroker.ts b/src/main/push/electronPushBroker.ts
new file mode 100644
index 000000000..bef99d806
--- /dev/null
+++ b/src/main/push/electronPushBroker.ts
@@ -0,0 +1,44 @@
+import { ipcMain, webContents } from 'electron';
+import { InProcPushBroker } from './InProcBroker';
+import type { Channel, PushEvent } from '@/types';
+
+export const broker = new InProcPushBroker();
+
+export const setupElectronPushBroker = () => {
+  // Rendererからの購読登録を受け付けて、Brokerに「ストリーム登録」
+  ipcMain.handle('push:subscribe', (event, channel: Channel) => {
+    const contentsId = event.sender.id;
+    const subId = crypto.randomUUID();
+
+    const sink = {
+      id: subId,
+      write: (ev: PushEvent<typeof channel>) => {
+        // 該当Rendererのみに送信（subIdでルーティング）
+        const wc = webContents.fromId(contentsId);
+        wc?.send(`push:${channel}:${subId}`, ev);
+      },
+      close: () => {
+        /* Renderer側が閉じた時の後始末があれば */
+      },
+    };
+
+    const unsubscribe = broker.registerStream(channel, sink);
+
+    // 解約テーブルに登録
+    unsubscribeMap.set(subId, unsubscribe);
+    return { subId };
+  });
+
+  ipcMain.handle(
+    'push:unsubscribe',
+    (_event, _channel: string, subId: string) => {
+      const unsub = unsubscribeMap.get(subId);
+      if (unsub) {
+        unsub();
+        unsubscribeMap.delete(subId);
+      }
+    },
+  );
+};
+
+const unsubscribeMap = new Map<string, () => void>();
diff --git a/src/main/repository/error.ts b/src/main/repository/error.ts
new file mode 100644
index 000000000..2fdbe8d49
--- /dev/null
+++ b/src/main/repository/error.ts
@@ -0,0 +1,10 @@
+import { internalError } from '@/main/lib/error';
+
+export function repositoryError(detail: string, error: unknown) {
+  return internalError({
+    expose: true,
+    messageCode: 'DATA_ACCESS_ERROR',
+    messageParams: { detail },
+    cause: error,
+  });
+}
diff --git a/src/db/repository/reviewRepository.ts b/src/main/repository/reviewRepository.ts
similarity index 76%
rename from src/db/repository/reviewRepository.ts
rename to src/main/repository/reviewRepository.ts
index e756dae65..40addf565 100644
--- a/src/db/repository/reviewRepository.ts
+++ b/src/main/repository/reviewRepository.ts
@@ -1,33 +1,33 @@
 import { eq, and } from 'drizzle-orm';
-import path from 'path';
 import type {
   ReviewHistory,
   ReviewChecklist,
   ReviewChecklistResult as DBReviewChecklistResult,
-} from '../schema';
+} from '../../db/schema';
 import {
   reviewHistories,
   reviewChecklists,
   reviewChecklistResults,
-} from '../schema';
-import getDb from '..';
+} from '../../db/schema';
+import getDb from '../../db';
 import type {
   ReviewChecklistResultDisplay,
   ReviewEvaluation,
   ReviewChecklistCreatedBy,
-} from '../../main/types';
-import { RepositoryError } from './repositoryError';
+} from '@/types';
+import { AppError } from '@/main/lib/error';
+import { repositoryError } from './error';
 
 /**
  * ドキュメントレビューで利用するDBアクセス用のインターフェース
  */
-export interface ReviewRepository {
+export interface IReviewRepository {
   // レビュー履歴
   createReviewHistory(title: string, id?: string): Promise<ReviewHistory>;
   getReviewHistory(id: string): Promise<ReviewHistory | null>;
   getAllReviewHistories(): Promise<ReviewHistory[]>;
   updateReviewHistoryTitle(id: string, title: string): Promise<void>;
-  updateReviewHistoryAdditionalData(
+  updateReviewHistoryAdditionalInstructionsAndCommentFormat(
     id: string,
     additionalInstructions?: string,
     commentFormat?: string,
@@ -68,12 +68,12 @@ export interface ReviewRepository {
   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
 }
 
-let reviewRepository: ReviewRepository | null = null;
+let reviewRepository: IReviewRepository | null = null;
 
 /**
  * Drizzle ORM を使用したレビューリポジトリの実装
  */
-class DrizzleReviewRepository implements ReviewRepository {
+class DrizzleReviewRepository implements IReviewRepository {
   /** レビュー履歴を作成 */
   async createReviewHistory(
     title: string,
@@ -87,10 +87,7 @@ class DrizzleReviewRepository implements ReviewRepository {
         .returning();
       return history;
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー履歴の作成に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の作成に失敗しました', err);
     }
   }
 
@@ -104,10 +101,7 @@ class DrizzleReviewRepository implements ReviewRepository {
         .where(eq(reviewHistories.id, id));
       return history || null;
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー履歴の取得に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の取得に失敗しました', err);
     }
   }
 
@@ -120,10 +114,7 @@ class DrizzleReviewRepository implements ReviewRepository {
         .from(reviewHistories)
         .orderBy(reviewHistories.updatedAt);
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー履歴一覧の取得に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の取得に失敗しました', err);
     }
   }
 
@@ -136,15 +127,12 @@ class DrizzleReviewRepository implements ReviewRepository {
         .set({ title })
         .where(eq(reviewHistories.id, id));
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー履歴の更新に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の更新に失敗しました', err);
     }
   }
 
-  /** レビュー履歴の追加データを更新 */
-  async updateReviewHistoryAdditionalData(
+  /** レビューの追加指示とフォーマットを更新 */
+  async updateReviewHistoryAdditionalInstructionsAndCommentFormat(
     id: string,
     additionalInstructions?: string,
     commentFormat?: string,
@@ -159,9 +147,9 @@ class DrizzleReviewRepository implements ReviewRepository {
         })
         .where(eq(reviewHistories.id, id));
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー履歴の追加データ更新に失敗しました: ${(err as Error).message}`,
-        err as Error,
+      throw repositoryError(
+        'レビューの追加指示・フォーマットの更新に失敗しました',
+        err,
       );
     }
   }
@@ -172,10 +160,7 @@ class DrizzleReviewRepository implements ReviewRepository {
       const db = await getDb();
       await db.delete(reviewHistories).where(eq(reviewHistories.id, id));
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー履歴の削除に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の削除に失敗しました', err);
     }
   }
 
@@ -193,10 +178,7 @@ class DrizzleReviewRepository implements ReviewRepository {
         .returning();
       return checklist;
     } catch (err) {
-      throw new RepositoryError(
-        `チェックリストの作成に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('チェックリストの作成に失敗しました', err);
     }
   }
 
@@ -210,10 +192,7 @@ class DrizzleReviewRepository implements ReviewRepository {
         .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
         .orderBy(reviewChecklists.updatedAt);
     } catch (err) {
-      throw new RepositoryError(
-        `チェックリストの取得に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('チェックリスト一覧の取得に失敗しました', err);
     }
   }
 
@@ -227,15 +206,12 @@ class DrizzleReviewRepository implements ReviewRepository {
         .where(eq(reviewChecklists.id, id))
         .returning();
       if (!checklist) {
-        throw new RepositoryError(`チェックリストID ${id} が見つかりません`);
+        throw repositoryError('指定されたチェックリストが存在しません', null);
       }
       return checklist;
     } catch (err) {
-      if (err instanceof RepositoryError) throw err;
-      throw new RepositoryError(
-        `チェックリストの更新に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      if (err instanceof AppError) throw err;
+      throw repositoryError('チェックリストの更新に失敗しました', err);
     }
   }
 
@@ -245,10 +221,7 @@ class DrizzleReviewRepository implements ReviewRepository {
       const db = await getDb();
       await db.delete(reviewChecklists).where(eq(reviewChecklists.id, id));
     } catch (err) {
-      throw new RepositoryError(
-        `チェックリストの削除に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('チェックリストの削除に失敗しました', err);
     }
   }
 
@@ -265,10 +238,7 @@ class DrizzleReviewRepository implements ReviewRepository {
           ),
         );
     } catch (err) {
-      throw new RepositoryError(
-        `システム作成チェックリストの削除に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('チェックリストの削除に失敗しました', err);
     }
   }
 
@@ -304,10 +274,7 @@ class DrizzleReviewRepository implements ReviewRepository {
       }
       return upsertedResults;
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー結果の作成に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の保存に失敗しました', err);
     }
   }
 
@@ -322,10 +289,7 @@ class DrizzleReviewRepository implements ReviewRepository {
         .from(reviewChecklistResults)
         .where(eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId));
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー結果の取得に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果一覧の取得に失敗しました', err);
     }
   }
 
@@ -345,10 +309,7 @@ class DrizzleReviewRepository implements ReviewRepository {
           ),
         );
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー結果の削除に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の削除に失敗しました', err);
     }
   }
 
@@ -397,10 +358,7 @@ class DrizzleReviewRepository implements ReviewRepository {
       }
       return Array.from(map.values());
     } catch (err) {
-      throw new RepositoryError(
-        `チェックリスト結果の取得に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の取得に失敗しました', err);
     }
   }
 
@@ -422,10 +380,7 @@ class DrizzleReviewRepository implements ReviewRepository {
           .where(eq(reviewChecklistResults.reviewChecklistId, id));
       }
     } catch (err) {
-      throw new RepositoryError(
-        `レビュー結果の全削除に失敗しました: ${(err as Error).message}`,
-        err as Error,
-      );
+      throw repositoryError('レビュー結果の削除に失敗しました', err);
     }
   }
 }
@@ -434,7 +389,7 @@ class DrizzleReviewRepository implements ReviewRepository {
  * ドキュメントレビュー用のリポジトリを取得
  * @returns ReviewRepositoryのインスタンス
  */
-export function getReviewRepository(): ReviewRepository {
+export function getReviewRepository(): IReviewRepository {
   if (!reviewRepository) {
     reviewRepository = new DrizzleReviewRepository();
   }
diff --git a/src/main/repository/settingsRepository.ts b/src/main/repository/settingsRepository.ts
new file mode 100644
index 000000000..144bdb864
--- /dev/null
+++ b/src/main/repository/settingsRepository.ts
@@ -0,0 +1,69 @@
+import { z } from 'zod';
+import { Settings, SettingsSchema } from '@/types';
+import { getStore } from '../store';
+import { repositoryError } from './error';
+
+export interface ISettingsRepository {
+  /**
+   * 設定を取得する
+   * @returns 設定情報
+   */
+  getSettings(): Promise<Settings>;
+
+  /**
+   * 設定を保存する
+   * @param settings 保存する設定情報
+   */
+  saveSettings(settings: Settings): Promise<void>;
+}
+
+let SettingsRepository: ISettingsRepository | null = null;
+
+export const getSettingsRepository = (): ISettingsRepository => {
+  if (!SettingsRepository) {
+    SettingsRepository = new ElectronStoreSettingsRepository();
+  }
+  return SettingsRepository;
+};
+
+/**
+ * Electron Storeを使用した設定リポジトリの実装
+ */
+class ElectronStoreSettingsRepository implements ISettingsRepository {
+  private store = getStore();
+
+  async getSettings(): Promise<Settings> {
+    try {
+      const settings = await SettingsSchema.parseAsync(this.store.store);
+      return settings;
+    } catch (err) {
+      if (err instanceof z.ZodError) {
+        throw repositoryError('設定情報の形式が不正です', err);
+      }
+      throw repositoryError('設定情報の取得に失敗しました', err);
+    }
+  }
+
+  async saveSettings(settings: Settings): Promise<void> {
+    try {
+      this.store.set('database.dir', settings.database.dir);
+      this.store.set('source.registerDir', settings.source.registerDir);
+      this.store.set('api.key', settings.api.key);
+      this.store.set('api.model', settings.api.model);
+      this.store.set('api.url', settings.api.url);
+      this.store.set('redmine.endpoint', settings.redmine.endpoint);
+      this.store.set('redmine.apiKey', settings.redmine.apiKey);
+      this.store.set('gitlab.endpoint', settings.gitlab.endpoint);
+      this.store.set('gitlab.apiKey', settings.gitlab.apiKey);
+      this.store.set('systemPrompt.content', settings.systemPrompt.content);
+      if (settings.mcp.serverConfig) {
+        this.store.set(
+          'mcp.serverConfig',
+          JSON.stringify(settings.mcp.serverConfig, null, 2),
+        );
+      }
+    } catch (err) {
+      throw repositoryError('設定情報の保存に失敗しました', err);
+    }
+  }
+}
diff --git a/src/main/repository/sourceRepository.ts b/src/main/repository/sourceRepository.ts
new file mode 100644
index 000000000..3f65acc05
--- /dev/null
+++ b/src/main/repository/sourceRepository.ts
@@ -0,0 +1,361 @@
+import { eq, inArray, and } from 'drizzle-orm';
+import getDb from '../../db';
+import type { Source, InsertSource, InsertTopic } from '../../db/schema';
+import { sources, topics } from '../../db/schema';
+import { ProcessStatus } from '@/types';
+import { repositoryError } from './error';
+
+export interface SourceRepository {
+  /**
+   * ソースを取得する
+   * @param sourceId ソースのID
+   * @returns ソース情報
+   */
+  getSourceById(sourceId: number): Promise<Source | null>;
+
+  /**
+   * idで指定された複数ソース取得する
+   * @returns ソースの配列
+   */
+  getSourcesByIds(sourceIds: number[]): Promise<Source[]>;
+
+  /**
+   * 同期処理中のソースを登録または更新する
+   * @param source 登録または更新するソース情報
+   * @returns 登録または更新されたソース情報
+   */
+  initializeProcessingSource(source: InsertSource): Promise<Source>;
+
+  /**
+   * ソース情報を更新する
+   * @param param 更新するソース情報
+   * @param param.id ソースのID
+   * @param param.title ソースのタイトル
+   * @param param.summary ソースの要約
+   * @param param.error エラー情報（nullの場合はエラーなし）
+   * @returns 更新されたソース情報
+   */
+  updateSource(param: {
+    id: number;
+    title: string;
+    summary: string;
+    error: string | null;
+  }): Promise<void>;
+
+  /**
+   * 同期処理情報を更新する
+   */
+  updateProcessingStatus(param: {
+    id: number;
+    status: ProcessStatus;
+    error?: string | null;
+  }): Promise<void>;
+
+  /**
+   * 全ソースの情報をMDのリスト形式で取得する
+   * @param sourceId ソースのID
+   * @returns ソース情報
+   */
+  getSourceListMarkdown(): Promise<string | null>;
+
+  /**
+   * トピックを登録する
+   */
+  registerTopic(topicList: InsertTopic[]): Promise<void>;
+
+  /**
+   * パスで指定されたソースを削除する
+   * @param path ソースのパス
+   * @returns 削除が成功した場合はtrue、存在しない場合はfalse
+   */
+  deleteSourceByPath(path: string): Promise<boolean>;
+
+  /**
+   * ソースをステータスに基づいて複数取得する
+   * @param status ソースのステータス
+   * @returns ソースの配列
+   */
+  getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]>;
+
+  /**
+   * ソースをステータスとパスに基づいて複数取得する
+   */
+  getSourceByPathInStatus(
+    path: string,
+    status: ProcessStatus[],
+  ): Promise<Source[]>;
+
+  /**
+   * ソースを全て取得する
+   */
+  getAllSources(): Promise<Source[]>;
+
+  /**
+   * ソーステーブルへのインサート
+   */
+  insertSources(sourceList: InsertSource[]): Promise<void>;
+
+  /**
+   * ソースの有効/無効を更新する
+   * @param sourceId ソースID
+   * @param enabled 有効/無効
+   */
+  updateSourceEnabled(sourceId: number, enabled: boolean): Promise<void>;
+}
+
+let sourceRepository: SourceRepository | null = null;
+
+class DrizzleSourceRepository implements SourceRepository {
+  async getSourceById(sourceId: number): Promise<Source | null> {
+    try {
+      const db = await getDb();
+      const [source] = await db
+        .select()
+        .from(sources)
+        .where(eq(sources.id, sourceId))
+        .limit(1);
+      return source || null;
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の取得に失敗しました', err);
+    }
+  }
+
+  async getSourcesByIds(sourceIds: number[]): Promise<Source[]> {
+    try {
+      const db = await getDb();
+      return db.select().from(sources).where(inArray(sources.id, sourceIds));
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の取得に失敗しました', err);
+    }
+  }
+
+  /**
+   * ソースを更新する
+   * @param param ソース情報
+   * @param param.path ソースのパス
+   * @param param.title ソースのタイトル
+   * @param param.summary ソースの要約
+   * @param param.error エラー情報（nullの場合はエラーなし）
+   * @returns
+   */
+  async updateSource(param: {
+    id: number;
+    title: string;
+    summary: string;
+    error: string | null;
+  }): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .update(sources)
+        .set({
+          title: param.title,
+          summary: param.summary,
+          error: param.error,
+        })
+        .where(eq(sources.id, param.id));
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の更新に失敗しました', err);
+    }
+  }
+
+  /**
+   * 同期処理中のソースを登録または更新する
+   * @param source 登録または更新するソース情報
+   * @returns 登録または更新されたソース情報
+   */
+  async initializeProcessingSource(source: InsertSource): Promise<Source> {
+    try {
+      const db = await getDb();
+      const [result] = await db
+        .insert(sources)
+        .values({
+          path: source.path,
+          title: '', // 一時的な空の値
+          summary: '', // 一時的な空の値
+          status: 'processing' as const,
+        })
+        .onConflictDoUpdate({
+          target: sources.path,
+          set: {
+            status: 'processing' as const,
+            error: null,
+          },
+        })
+        .returning();
+      return result;
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の更新に失敗しました', err);
+    }
+  }
+
+  /**
+   * データベースからソース情報を取得する
+   */
+  async getSourceListMarkdown(): Promise<string | null> {
+    try {
+      const db = await getDb();
+      // 有効なソースのみ取得
+      const sourceList = await db
+        .select()
+        .from(sources)
+        .where(and(eq(sources.isEnabled, 1), eq(sources.status, 'completed')))
+        .orderBy(sources.title);
+
+      // 各ソースのトピックを取得
+      const sourceWithTopicList = await Promise.all(
+        sourceList.map(async (source) => {
+          const topicsList = await db
+            .select()
+            .from(topics)
+            .where(eq(topics.sourceId, source.id))
+            .orderBy(topics.name);
+
+          return {
+            id: source.id,
+            title: source.title,
+            path: source.path,
+            summary: source.summary,
+            topics: topicsList.map((topic) => ({
+              name: topic.name,
+              summary: topic.summary,
+            })),
+          };
+        }),
+      );
+
+      if (sourceWithTopicList.length === 0) {
+        return null; // ソースが存在しない場合はnullを返す
+      }
+
+      return sourceWithTopicList
+        .map(
+          (sourceWithTopic) => `- ID:${sourceWithTopic.id}
+        - Title:${sourceWithTopic.title}
+        - Path:${sourceWithTopic.path}
+        - Summary:${sourceWithTopic.summary}
+        - Topics:
+      ${sourceWithTopic.topics.map((topic) => `      - Topic: ${topic.name} Summary: ${topic.summary}`).join('\n')}
+    `,
+        )
+        .join('\n');
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の取得に失敗しました', err);
+    }
+  }
+
+  async updateProcessingStatus(param: {
+    id: number;
+    status: ProcessStatus;
+    error?: string | null;
+  }): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .update(sources)
+        .set({
+          status: param.status,
+          error: param.error || null,
+        })
+        .where(eq(sources.id, param.id));
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の更新に失敗しました', err);
+    }
+  }
+
+  /**
+   * トピックを登録する
+   * @param topic 登録するトピック情報
+   * @returns 登録されたトピック情報
+   */
+  async registerTopic(topicList: InsertTopic[]): Promise<void> {
+    try {
+      const db = await getDb();
+      await db.insert(topics).values(topicList);
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の更新に失敗しました', err);
+    }
+  }
+
+  async deleteSourceByPath(path: string): Promise<boolean> {
+    try {
+      const db = await getDb();
+      const [source] = await db
+        .select()
+        .from(sources)
+        .where(eq(sources.path, path))
+        .limit(1);
+
+      if (source) {
+        await db.delete(sources).where(eq(sources.id, source.id));
+        await db.delete(topics).where(eq(topics.sourceId, source.id));
+      }
+      return !!source; // 存在した場合はtrue、存在しなかった場合はfalseを返す
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の削除に失敗しました', err);
+    }
+  }
+
+  async getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]> {
+    try {
+      const db = await getDb();
+      return db.select().from(sources).where(inArray(sources.status, status));
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の取得に失敗しました', err);
+    }
+  }
+
+  async getSourceByPathInStatus(
+    path: string,
+    status: ProcessStatus[],
+  ): Promise<Source[]> {
+    try {
+      const db = await getDb();
+      const sourcesInStatus = await db
+        .select()
+        .from(sources)
+        .where(and(eq(sources.path, path), inArray(sources.status, status)));
+
+      return sourcesInStatus;
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の取得に失敗しました', err);
+    }
+  }
+
+  async getAllSources(): Promise<Source[]> {
+    try {
+      const db = await getDb();
+      return db.select().from(sources);
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の取得に失敗しました', err);
+    }
+  }
+
+  async insertSources(sourceList: InsertSource[]): Promise<void> {
+    try {
+      const db = await getDb();
+      await db.insert(sources).values(sourceList);
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の作成に失敗しました', err);
+    }
+  }
+
+  async updateSourceEnabled(sourceId: number, enabled: boolean): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .update(sources)
+        .set({ isEnabled: enabled ? 1 : 0 })
+        .where(eq(sources.id, sourceId));
+    } catch (err) {
+      throw repositoryError('ドキュメント情報の更新に失敗しました', err);
+    }
+  }
+}
+
+export function getSourceRepository(): SourceRepository {
+  if (!sourceRepository) {
+    sourceRepository = new DrizzleSourceRepository();
+  }
+  return sourceRepository;
+}
diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
index 0ac5109b2..43df9c6a8 100644
--- a/src/main/service/chatService.ts
+++ b/src/main/service/chatService.ts
@@ -1,16 +1,68 @@
 // @ts-ignore
 import { MastraMemory, StorageThreadType } from '@mastra/core';
-import { UIMessage } from 'ai';
+import { Message, UIMessage, createDataStream } from 'ai';
+import { mastra } from '@/mastra';
+import { internalError } from '../lib/error';
+import { AbortControllerManager } from '../lib/AbortControllerManager';
+import { judgeFinishReason } from '@/mastra/lib/agentUtils';
+import { ChatMessage, Feature, IpcChannels } from '@/types';
+import { getMainLogger } from '../lib/logger';
+import { formatMessage } from '../lib/messages';
+import { SettingsService } from './settingsService';
+import { publishEvent } from '../lib/eventPayloadHelper';
+import { normalizeUnknownError } from '../lib/error';
+
+const logger = getMainLogger();
+
+const feature = 'CHAT' as Feature;
+
+export interface IChatService {
+  getThreadList(userId: string): Promise<StorageThreadType[]>;
+  deleteThread(threadId: string): Promise<void>;
+  createThread(userId: string, threadId: string, title: string): Promise<void>;
+  abortGeneration(threadId: string): void;
+  deleteMessagesBeforeSpecificId(
+    threadId: string,
+    messageId: string,
+  ): Promise<void>;
+  generate(
+    userId: string,
+    threadId: string,
+    messages: Message[],
+    event: Electron.IpcMainInvokeEvent,
+  ): Promise<ReturnType<typeof createDataStream>>;
+
+  getOrCreateAbortController(threadId: string): AbortController;
+  deleteAbortController(threadId: string): void;
+  getThreadMessages(threadId: string): Promise<UIMessage[]>;
+}
+
+export class ChatService implements IChatService {
+  // シングルトン変数
+  private static instance: ChatService;
 
-export class ChatService {
   // スレッドごとのAbortControllerを管理するMap
-  private threadAbortControllers = new Map<string, AbortController>();
+  private abortControllerManager = AbortControllerManager.getInstance();
 
-  // mastraメモリのインスタンスを保持（チャットメッセージが保存されてあるメモリ）
-  private memory: MastraMemory;
+  private settingsService = SettingsService.getInstance();
 
-  constructor(memory: MastraMemory) {
-    this.memory = memory;
+  // シングルトンインスタンスを取得
+  public static getInstance(): ChatService {
+    if (!ChatService.instance) {
+      ChatService.instance = new ChatService();
+    }
+    return ChatService.instance;
+  }
+
+  private async getMemory(): Promise<MastraMemory> {
+    const memory = await mastra.getAgent('orchestrator').getMemory();
+    if (!memory) {
+      throw internalError({
+        expose: true,
+        messageCode: 'MASTRA_MEMORY_ERROR',
+      });
+    }
+    return memory;
   }
 
   /**
@@ -18,7 +70,8 @@ export class ChatService {
    */
   public async getThreadList(userId: string): Promise<StorageThreadType[]> {
     // メモリからスレッド一覧を取得
-    const threads = await this.memory.getThreadsByResourceId({
+    const memory = await this.getMemory();
+    const threads = await memory.getThreadsByResourceId({
       resourceId: userId,
     });
     return threads;
@@ -32,8 +85,10 @@ export class ChatService {
     // スレッドのAbortControllerを削除
     this.deleteAbortController(threadId);
 
+    const memory = await this.getMemory();
+
     // メモリからスレッドを削除
-    await this.memory.storage.deleteThread({ threadId });
+    await memory.storage.deleteThread({ threadId });
   }
 
   /**
@@ -43,28 +98,150 @@ export class ChatService {
    * @returns 作成したスレッド
    */
   public async createThread(
+    userId: string,
     threadId: string,
     title: string,
-    userId: string,
   ): Promise<void> {
-    await this.memory.createThread({
+    const memory = await this.getMemory();
+    await memory.createThread({
       resourceId: userId,
       title,
       threadId,
     });
   }
 
+  public abortGeneration(threadId: string): void {
+    const controller = this.getOrCreateAbortController(threadId);
+    controller.abort();
+    this.deleteAbortController(threadId);
+  }
+
+  public async generate(
+    userId: string,
+    threadId: string,
+    messages: ChatMessage[],
+    event: Electron.IpcMainInvokeEvent,
+  ) {
+    // 新しいAbortControllerを作成
+    const controller = this.abortControllerManager.getOrCreateAbortController(
+      feature,
+      threadId,
+    );
+
+    const orchestratorAgent = mastra.getAgent('orchestrator');
+
+    // runtimeContextを作成
+    const runtimeContext = await this.settingsService.getRuntimeContext();
+
+    // 利用ツールの取得
+    const toolsets = await this.settingsService.getToolsets();
+
+    // メッセージをストリーミングで送信
+    // const stream = await orchestratorAgent.stream(content, {
+    //   resourceId: 'user', // 固定のリソースID
+    //   toolCallStreaming: true,
+    //   instructions: await getOrchestratorSystemPrompt(
+    //     mastraStatus.tools ?? {
+    //       redmine: false,
+    //       gitlab: false,
+    //       mcp: false,
+    //     },
+    //   ),
+    //   threadId: roomId, // チャットルームIDをスレッドIDとして使用
+    //   maxSteps: 30, // ツールの利用上限
+    //   onFinish: () => {
+    //     // ストリーミングが完了したときの処理
+    //     // フロントエンドに完了通知を送信
+    //     event.sender.send(IpcChannels.CHAT_COMPLETE);
+    //   },
+    // });
+
+    // // DataStreamを生成
+    // const dataStream = createDataStream({
+    //   execute(writer) {
+    //     stream.mergeIntoDataStream(writer);
+    //   },
+    //   onError(error) {
+    //     // エラーが発生したときの処理
+    //     console.error('ストリーミング中にエラーが発生:', error);
+    //     if (error == null) return 'unknown error';
+    //     if (typeof error === 'string') return error;
+    //     if (error instanceof Error) return error.message;
+    //     return JSON.stringify(error);
+    //   },
+    // });
+
+    // DataStreamを生成
+    const dataStream = createDataStream({
+      execute: async (writer) => {
+        // ストリーミングの開始を通知（このデータは利用されない、あくまで通知するためだけ）
+        writer.writeMessageAnnotation({
+          type: 'status',
+          value: 'processing',
+        });
+        // streaming falseの場合のメッセージ送信処理
+        const res = await orchestratorAgent.generate(messages, {
+          runtimeContext,
+          toolsets,
+          resourceId: userId,
+          threadId, // チャットルームIDをスレッドIDとして使用
+          maxSteps: 30, // ツールの利用上限
+          abortSignal: controller.signal, // 中断シグナルを設定
+          onStepFinish: (stepResult) => {
+            // https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol
+            // 上記を参考にai-sdkのストリームプロトコルに従ってメッセージを送信
+            writer.write(`0:${JSON.stringify(stepResult.text)}\n`);
+            stepResult.toolCalls.forEach((toolCall) => {
+              writer.write(`9:${JSON.stringify(toolCall)}\n`);
+            });
+            stepResult.toolResults.forEach((toolResult) => {
+              writer.write(`a:${JSON.stringify(toolResult)}\n`);
+            });
+            writer.write(
+              `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
+            );
+          },
+        });
+        const { success, reason } = judgeFinishReason(res.finishReason);
+        if (!success) {
+          // 正常終了でない場合はエラーを投げる
+          throw internalError({
+            expose: true,
+            messageCode: 'CHAT_GENERATE_ERROR',
+            messageParams: { reason },
+          });
+        }
+        writer.write(
+          `d:${JSON.stringify({ finishReason: res.finishReason, ...res.usage })}\n`,
+        );
+        publishEvent(IpcChannels.CHAT_COMPLETE, undefined);
+        // 処理が完了したらAbortControllerを削除
+        this.abortControllerManager.deleteAbortController(feature, threadId);
+      },
+      onError: (error) => {
+        // エラーが発生したときの処理
+        logger.error(error, 'テキスト生成中にエラーが発生');
+        // エラー時もAbortControllerを削除
+        this.deleteAbortController(threadId);
+        const normalizedError = normalizeUnknownError(error);
+        return formatMessage('CHAT_GENERATE_ERROR', {
+          detail: normalizedError.message,
+        });
+      },
+    });
+    return dataStream;
+  }
+
   /**
    * スレッドのAbortControllerを取得または作成する
    * @param threadId スレッドID
    * @returns AbortController
    */
   public getOrCreateAbortController(threadId: string): AbortController {
-    if (!this.threadAbortControllers.has(threadId)) {
-      const controller = new AbortController();
-      this.threadAbortControllers.set(threadId, controller);
-    }
-    return this.threadAbortControllers.get(threadId)!;
+    return this.abortControllerManager.getOrCreateAbortController(
+      feature,
+      threadId,
+    );
   }
 
   /**
@@ -72,10 +249,7 @@ export class ChatService {
    * @param threadId スレッドID
    */
   public deleteAbortController(threadId: string): void {
-    if (this.threadAbortControllers.has(threadId)) {
-      this.threadAbortControllers.get(threadId)?.abort();
-      this.threadAbortControllers.delete(threadId);
-    }
+    this.abortControllerManager.deleteAbortController(feature, threadId);
   }
 
   /**
@@ -89,7 +263,8 @@ export class ChatService {
     messageId: string,
   ): Promise<void> {
     // メッセージ履歴を取得
-    const messages = await this.memory.storage.getMessages({
+    const memory = await this.getMemory();
+    const messages = await memory.storage.getMessages({
       threadId,
     });
 
@@ -98,13 +273,17 @@ export class ChatService {
       (msg) => msg.id === messageId,
     );
     if (targetMessageIndex === -1) {
-      throw new Error(`メッセージが見つかりません`);
+      throw internalError({
+        expose: true,
+        messageCode: 'CHAT_EDIT_ERROR',
+        messageParams: { detail: '対象メッセージが見つかりません' },
+      });
     }
     // 最初のメッセージからmessageIdに対応するメッセージまでの履歴を取得
     const history = messages.slice(0, targetMessageIndex);
 
     // スレッドを削除
-    await this.memory.storage.deleteThread({ threadId });
+    await memory.storage.deleteThread({ threadId });
 
     // スレッドを再作成
     // await this.memory.createThread({
@@ -114,7 +293,7 @@ export class ChatService {
     // });
 
     // 取得した履歴をメモリに保存
-    await this.memory.saveMessages({
+    await memory.saveMessages({
       messages: history,
       memoryConfig: undefined,
     });
@@ -125,7 +304,8 @@ export class ChatService {
    * @param threadId スレッドID
    */
   public async getThreadMessages(threadId: string): Promise<UIMessage[]> {
-    const result = await this.memory.query({ threadId });
+    const memory = await this.getMemory();
+    const result = await memory.query({ threadId });
     if (!result) {
       return [];
     }
diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
index f859eb49c..1ba891fa3 100644
--- a/src/main/service/reviewService.ts
+++ b/src/main/service/reviewService.ts
@@ -1,8 +1,41 @@
-import { getReviewRepository } from '../../db/repository/reviewRepository';
-import { ReviewChecklistEdit } from '../types';
-import { generateReviewTitle } from '../../mastra/workflows/sourceReview/lib';
+import { getReviewRepository } from '@/main/repository/reviewRepository';
+import { ReviewChecklistEdit, ReviewChecklistResultDisplay } from '@/types';
+import { generateReviewTitle } from '@/mastra/workflows/sourceReview/lib';
+import { ReviewHistory } from '@/db/schema';
+
+export interface IReviewService {
+  getReviewHistories(): Promise<ReviewHistory[]>;
+  getReviewHistoryDetail(reviewHistoryId: string): Promise<{
+    checklistResults: ReviewChecklistResultDisplay[];
+  }>;
+  getReviewInstruction(reviewHistoryId: string): Promise<{
+    additionalInstructions?: string;
+    commentFormat?: string;
+  }>;
+  deleteReviewHistory(reviewHistoryId: string): Promise<void>;
+  updateChecklists(
+    reviewHistoryId: string,
+    checklistEdits: ReviewChecklistEdit[],
+  ): Promise<void>;
+  updateReviewInstruction(
+    reviewHistoryId: string,
+    additionalInstructions: string | undefined,
+    commentFormat: string | undefined,
+  ): Promise<void>;
+}
+
+export class ReviewService implements IReviewService {
+  // シングルトン変数
+  private static instance: ReviewService;
+
+  // シングルトンインスタンスを取得
+  public static getInstance(): ReviewService {
+    if (!ReviewService.instance) {
+      ReviewService.instance = new ReviewService();
+    }
+    return ReviewService.instance;
+  }
 
-export class ReviewService {
   private repository = getReviewRepository();
 
   /**
@@ -16,7 +49,24 @@ export class ReviewService {
    * レビュー履歴の詳細（チェックリスト結果）を取得
    */
   public async getReviewHistoryDetail(reviewHistoryId: string) {
-    return this.repository.getReviewChecklistResults(reviewHistoryId);
+    const checklistResults =
+      await this.repository.getReviewChecklistResults(reviewHistoryId);
+    return {
+      checklistResults: checklistResults,
+    };
+  }
+
+  /**
+   * レビュー履歴の追加指示とコメントフォーマットを取得
+   */
+  public async getReviewInstruction(reviewHistoryId: string) {
+    const reviewHistory =
+      await this.repository.getReviewHistory(reviewHistoryId);
+    return {
+      additionalInstructions:
+        reviewHistory?.additionalInstructions || undefined,
+      commentFormat: reviewHistory?.commentFormat || undefined,
+    };
   }
 
   /**
@@ -33,46 +83,49 @@ export class ReviewService {
     reviewHistoryId: string,
     checklistEdits: ReviewChecklistEdit[],
   ) {
-    try {
-      // レビュー履歴が存在しない場合は新規作成
-      let reviewHistory =
-        await this.repository.getReviewHistory(reviewHistoryId);
-      if (reviewHistory === null) {
-        reviewHistory = await this.repository.createReviewHistory(
-          generateReviewTitle(),
-          reviewHistoryId,
-        );
-      }
+    // レビュー履歴が存在しない場合は新規作成
+    let reviewHistory = await this.repository.getReviewHistory(reviewHistoryId);
+    if (reviewHistory === null) {
+      reviewHistory = await this.repository.createReviewHistory(
+        generateReviewTitle(),
+        reviewHistoryId,
+      );
+    }
 
-      // チェックリストの編集を実行
-      // 現状は一度に一つのチェックリスト編集しか行わない（checklistEditsの要素数は1つ）の想定なので、トランザクション制御などは行わない
-      for (const edit of checklistEdits) {
-        if (edit.id === null) {
-          // 新規作成
-          if (edit.content) {
-            await this.repository.createChecklist(
-              reviewHistoryId,
-              edit.content,
-              'user',
-            );
-          }
-        } else if (edit.delete) {
-          // 削除
-          await this.repository.deleteChecklist(edit.id);
-        } else if (edit.content) {
-          // 更新
-          await this.repository.updateChecklist(edit.id, edit.content);
+    // チェックリストの編集を実行
+    // 現状は一度に一つのチェックリスト編集しか行わない（checklistEditsの要素数は1つ）の想定なので、トランザクション制御などは行わない
+    for (const edit of checklistEdits) {
+      if (edit.id === null) {
+        // 新規作成
+        if (edit.content) {
+          await this.repository.createChecklist(
+            reviewHistoryId,
+            edit.content,
+            'user',
+          );
         }
+      } else if (edit.delete) {
+        // 削除
+        await this.repository.deleteChecklist(edit.id);
+      } else if (edit.content) {
+        // 更新
+        await this.repository.updateChecklist(edit.id, edit.content);
       }
-
-      return { success: true };
-    } catch (error) {
-      const errorMessage =
-        error instanceof Error ? error.message : '不明なエラー';
-      return {
-        success: false,
-        error: `チェックリスト更新処理でエラーが発生しました: ${errorMessage}`,
-      };
     }
   }
+
+  /**
+   * レビュー履歴の追加指示とコメントフォーマットを更新
+   */
+  public async updateReviewInstruction(
+    reviewHistoryId: string,
+    additionalInstructions: string | undefined,
+    commentFormat: string | undefined,
+  ) {
+    return this.repository.updateReviewHistoryAdditionalInstructionsAndCommentFormat(
+      reviewHistoryId,
+      additionalInstructions,
+      commentFormat,
+    );
+  }
 }
diff --git a/src/main/service/settingsService.ts b/src/main/service/settingsService.ts
index f21abeda6..51fc417e2 100644
--- a/src/main/service/settingsService.ts
+++ b/src/main/service/settingsService.ts
@@ -1,24 +1,58 @@
+// @ts-ignore
 import { ToolsetsInput } from '@mastra/core/agent';
+// @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
 import { z } from 'zod';
 import { v4 as uuid } from 'uuid';
-import { McpSchema } from '../types/schema';
 import {
   SettingsSavingStatus,
   SettingsSavingMessage,
   AgentToolStatus,
-} from '../types';
-import { getStore } from '../store';
-import { InitializeToolsConfig, initializeTools } from '../../mastra/tools';
-import { RedmineBaseInfo } from '../../mastra/tools/redmine';
-import { initializeMCPClient } from '../../mastra/tools/mcp';
-import { OrchestratorRuntimeContext } from '../../mastra/agents/orchestrator';
-import { getSourceRepository } from '../../db/repository/sourceRepository';
-import { createRuntimeContext } from '../../mastra/agents/lib';
-
-export class SettingsService {
+  Settings,
+} from '@/types';
+import { InitializeToolsConfig, initializeTools } from '@/mastra/tools';
+import { RedmineBaseInfo } from '@/mastra/tools/redmine';
+import { initializeMCPClient } from '@/mastra/tools/mcp';
+import { OrchestratorRuntimeContext } from '@/mastra/agents/orchestrator';
+import { getSourceRepository } from '@/main/repository/sourceRepository';
+import { createRuntimeContext } from '@/mastra/lib/agentUtils';
+import { getSettingsRepository } from '../repository/settingsRepository';
+import { publishEvent } from '@/main/lib/eventPayloadHelper';
+import { IpcChannels } from '@/types';
+
+export interface ISettingsService {
+  getStatus(): SettingsSavingStatus;
+  getToolsets(): ToolsetsInput;
+  updateStatus(
+    newState: SettingsSavingStatus['state'],
+    message?: SettingsSavingMessage,
+    tools?: AgentToolStatus,
+  ): void;
+  removeMessage(messageId: string): void;
+  getRuntimeContext(): Promise<RuntimeContext>;
+  initializeSettings(): Promise<void>;
+  getSettings(): Promise<Settings>;
+  saveSettings(settings: Settings): Promise<void>;
+}
+
+export class SettingsService implements ISettingsService {
+  // シングルトン変数
+  private static instance: SettingsService;
+
+  // ドキュメント関連リポジトリ
   private sourceRepository = getSourceRepository();
 
+  // ユーザ設定関連リポジトリ
+  private settingsRepository = getSettingsRepository();
+
+  // シングルトンインスタンスを取得
+  public static getInstance(): SettingsService {
+    if (!SettingsService.instance) {
+      SettingsService.instance = new SettingsService();
+    }
+    return SettingsService.instance;
+  }
+
   // 設定状態
   private status: SettingsSavingStatus = {
     state: 'saving',
@@ -101,9 +135,10 @@ export class SettingsService {
    * @returns OrchestratorRuntimeContext
    */
   public getRuntimeContext = async (): Promise<RuntimeContext> => {
-    const runtimeContext = createRuntimeContext<OrchestratorRuntimeContext>();
+    const runtimeContext =
+      await createRuntimeContext<OrchestratorRuntimeContext>();
     runtimeContext.set('toolStatus', this.status.tools);
-    const store = getStore();
+    const store = await this.settingsRepository.getSettings();
     if (this.status.tools.document) {
       const sourceListMarkdown =
         await this.sourceRepository.getSourceListMarkdown();
@@ -116,19 +151,16 @@ export class SettingsService {
     if (this.status.tools.redmine && this.redmineBaseInfo) {
       runtimeContext.set('redmine', {
         basicInfo: this.redmineBaseInfo,
-        endpoint: store.get('redmine').endpoint,
+        endpoint: store.redmine.endpoint!,
       });
     }
     if (this.status.tools.gitlab) {
       runtimeContext.set('gitlab', {
-        endpoint: store.get('gitlab').endpoint,
+        endpoint: store.gitlab.endpoint!,
       });
     }
-    if (store.get('systemPrompt').content) {
-      runtimeContext.set(
-        'additionalSystemPrompt',
-        store.get('systemPrompt').content,
-      );
+    if (store.systemPrompt.content) {
+      runtimeContext.set('additionalSystemPrompt', store.systemPrompt.content);
     }
 
     return runtimeContext;
@@ -140,17 +172,16 @@ export class SettingsService {
   public initializeSettings = async () => {
     try {
       this.initStatus();
-      const store = getStore();
       const toolsConfig: InitializeToolsConfig = {};
-      let mcpConfig: z.infer<typeof McpSchema> | null = null;
+      const store = await this.settingsRepository.getSettings();
       // ドキュメントツール
-      const documentRegisterDir = store.get('source').registerDir;
+      const documentRegisterDir = store.source.registerDir;
       if (documentRegisterDir && documentRegisterDir.trim() !== '') {
         toolsConfig.documentTool = true;
       }
       // Redmineツール
-      const redmineApiKey = store.get('redmine').apiKey;
-      const redmineEndpoint = store.get('redmine').endpoint;
+      const redmineApiKey = store.redmine.apiKey;
+      const redmineEndpoint = store.redmine.endpoint;
       if (redmineApiKey && redmineEndpoint) {
         toolsConfig.redmineTool = {
           endpoint: redmineEndpoint,
@@ -158,8 +189,8 @@ export class SettingsService {
         };
       }
       // GitLabツール
-      const gitlabApiKey = store.get('gitlab').apiKey;
-      const gitlabEndpoint = store.get('gitlab').endpoint;
+      const gitlabApiKey = store.gitlab.apiKey;
+      const gitlabEndpoint = store.gitlab.endpoint;
       if (gitlabApiKey && gitlabEndpoint) {
         toolsConfig.gitlabTool = {
           endpoint: gitlabEndpoint,
@@ -167,21 +198,7 @@ export class SettingsService {
         };
       }
       // MCP設定
-      const mcpConfigText = store.get('mcp').serverConfigText;
-      if (mcpConfigText && mcpConfigText.trim() !== '{}') {
-        try {
-          const parsedConfig = JSON.parse(mcpConfigText);
-          const validatedConfig = McpSchema.parse(parsedConfig);
-          mcpConfig = validatedConfig;
-        } catch (error) {
-          console.error('MCP設定のパースに失敗しました:', error);
-          this.status.messages.push({
-            id: uuid(),
-            type: 'error',
-            content: `MCP設定が不正な形式です\n設定を確認してください`,
-          });
-        }
-      }
+      const mcpConfig = store.mcp.serverConfig;
       // Mastra MCPの初期化
       if (mcpConfig) {
         const mcpResult = await initializeMCPClient({ mcpConfig, id: 'user' });
@@ -192,7 +209,7 @@ export class SettingsService {
           this.status.messages.push({
             id: crypto.randomUUID(),
             type: 'error',
-            content: `MCPサーバとの接続に失敗しました\nログについては${mcpResult.logPath}をご確認ください`,
+            content: `MCPサーバとの接続に失敗しました\\nログについては${mcpResult.logPath}をご確認ください`,
           });
         }
       }
@@ -210,7 +227,7 @@ export class SettingsService {
           this.status.messages.push({
             id: uuid(),
             type: 'error',
-            content: `ドキュメント検索ツールの初期化に失敗しました\n設定を確認してください\n${documentTool.error}`,
+            content: `ドキュメント検索ツールの初期化に失敗しました\\n${documentTool.error}`,
           });
         }
         if (redmineTool && redmineTool?.success === true) {
@@ -220,7 +237,7 @@ export class SettingsService {
           this.status.messages.push({
             id: uuid(),
             type: 'error',
-            content: `Redmine操作ツールの初期化に失敗しました\n設定を確認してください\n${redmineTool.error}`,
+            content: `Redmine操作ツールの初期化に失敗しました\\n${redmineTool.error}`,
           });
         }
         if (gitlabTool && gitlabTool?.success === true) {
@@ -229,21 +246,36 @@ export class SettingsService {
           this.status.messages.push({
             id: uuid(),
             type: 'error',
-            content: `GitLab操作ツールの初期化に失敗しました\n設定を確認してください\n${gitlabTool.error}`,
+            content: `GitLab操作ツールの初期化に失敗しました\\n${gitlabTool.error}`,
           });
         }
         this.toolsets.aikataOriginalTools = toolsInput;
       }
+      // 初期化完了状態に更新
+      this.status.state = 'done';
+      
+      // 設定更新完了イベントを発行（成功）
+      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: true });
     } catch (error) {
-      console.error('設定の初期化に失敗しました:', error);
-      this.status.state = 'error';
-      this.status.messages.push({
-        id: uuid(),
-        type: 'error',
-        content: `設定の初期化中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
-      });
+      // 設定更新完了イベントを発行（失敗）
+      const errorMessage = error instanceof Error ? error.message : '不明なエラーが発生しました';
+      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: false, error: errorMessage });
+      
+      // エラーを再throw
+      throw error;
     }
-    // 初期化完了状態に更新
-    this.status.state = 'done';
+  }
+  /**
+   * 設定を取得する
+   */
+  public getSettings = async (): Promise<Settings> => {
+    return await this.settingsRepository.getSettings();
+  };
+
+  /**
+   * 設定を保存する
+   */
+  public saveSettings = async (settings: Settings): Promise<void> => {
+    await this.settingsRepository.saveSettings(settings);
   };
 }
diff --git a/src/main/service/sourceService.ts b/src/main/service/sourceService.ts
new file mode 100644
index 000000000..406a8ac70
--- /dev/null
+++ b/src/main/service/sourceService.ts
@@ -0,0 +1,43 @@
+import { getSourceRepository } from '../repository/sourceRepository';
+import { Source } from '@/db/schema';
+
+export interface ISourceService {
+  getAllSources(): Promise<Source[]>;
+  updateSourceEnabled(sourceId: number, enabled: boolean): Promise<void>;
+}
+
+export class SourceService implements ISourceService {
+  // シングルトン変数
+  private static instance: SourceService;
+
+  // ドキュメント関連リポジトリ
+  private sourceRepository = getSourceRepository();
+
+  // シングルトンインスタンスを取得
+  public static getInstance(): SourceService {
+    if (!SourceService.instance) {
+      SourceService.instance = new SourceService();
+    }
+    return SourceService.instance;
+  }
+
+  /**
+   * 全てのソースを取得する
+   */
+  public async getAllSources(): Promise<Source[]> {
+    const allSources = await this.sourceRepository.getAllSources();
+    return allSources;
+  }
+
+  /**
+   * ソースの有効/無効を更新する
+   * @param sourceId ソースID
+   * @param enabled 有効/無効
+   */
+  public async updateSourceEnabled(
+    sourceId: number,
+    enabled: boolean,
+  ): Promise<void> {
+    await this.sourceRepository.updateSourceEnabled(sourceId, enabled);
+  }
+}
diff --git a/src/main/store.ts b/src/main/store.ts
index 8608c9c5d..9b6dabffe 100644
--- a/src/main/store.ts
+++ b/src/main/store.ts
@@ -8,7 +8,7 @@ export interface StoreSchema {
     dir: string;
   };
   source: {
-    registerDir: string;
+    registerDir?: string;
   };
   api: {
     key: string;
@@ -16,18 +16,18 @@ export interface StoreSchema {
     model: string;
   };
   redmine: {
-    endpoint: string;
-    apiKey: string;
+    endpoint?: string;
+    apiKey?: string;
   };
   gitlab: {
-    endpoint: string;
-    apiKey: string;
+    endpoint?: string;
+    apiKey?: string;
   };
   mcp: {
-    serverConfigText: string;
+    serverConfig?: string;
   };
   systemPrompt: {
-    content: string;
+    content?: string;
   };
 }
 
@@ -77,7 +77,7 @@ const schema = {
     properties: {
       serverConfigText: {
         type: 'string',
-        default: '{}',
+        default: '',
       },
     },
     required: [],
@@ -87,7 +87,6 @@ const schema = {
     properties: {
       content: {
         type: 'string',
-        default: '',
       },
     },
     required: [],
@@ -102,7 +101,7 @@ const schema = {
  * 3. macOS / Linux      : userData（書き込み可）
  * 4. 開発時             : プロジェクトのルート
  */
-function getConfigDir(): string {
+export function getConfigDir(): string {
   // --- ① Windows Portable (.exe 単体) --------------------------
   // electron-builder の Portable テンプレートが自動で環境変数をセット
   if (process.env.PORTABLE_EXECUTABLE_DIR) {
@@ -130,7 +129,7 @@ const defaults: StoreSchema = {
     dir: './default_data_dir',
   },
   source: {
-    registerDir: '',
+    registerDir: undefined,
   },
   api: {
     key: '',
@@ -138,18 +137,18 @@ const defaults: StoreSchema = {
     model: '',
   },
   redmine: {
-    endpoint: '',
-    apiKey: '',
+    endpoint: undefined,
+    apiKey: undefined,
   },
   gitlab: {
-    endpoint: '',
-    apiKey: '',
+    endpoint: undefined,
+    apiKey: undefined,
   },
   mcp: {
-    serverConfigText: '{}',
+    serverConfig: undefined,
   },
   systemPrompt: {
-    content: '',
+    content: undefined,
   },
 };
 
diff --git a/src/main/types/index.ts b/src/main/types/index.ts
deleted file mode 100644
index f80cd09de..000000000
--- a/src/main/types/index.ts
+++ /dev/null
@@ -1,92 +0,0 @@
-import type { AiMessageType, StorageThreadType } from '@mastra/core';
-
-/**
- * プロセス状態を表す型
- */
-export type ProcessStatus = 'idle' | 'processing' | 'completed' | 'failed';
-
-/**
- * チャットのロール型
- */
-export type ChatRole = 'user' | 'assistant' | 'system';
-
-/**
- * チャットルーム情報の型（Mastraの型を利用）
- */
-export type ChatRoom = StorageThreadType;
-
-/**
- * チャットメッセージの型（Mastraの型を利用）
- */
-export type ChatMessage = AiMessageType;
-
-// 設定状態管理用の型定義
-export type SettingsSavingState = 'saving' | 'done' | 'error';
-
-export type SettingsSavingMessage = {
-  id: string;
-  type: 'info' | 'warning' | 'error';
-  content: string;
-};
-
-/**
- * エージェントのツール状態を表す型
- */
-export type AgentToolStatus = {
-  document: boolean;
-  redmine: boolean;
-  gitlab: boolean;
-  mcp: boolean;
-};
-
-/**
- * エージェントのブート状態を表す型
- */
-export type SettingsSavingStatus = {
-  state: SettingsSavingState;
-  messages: SettingsSavingMessage[];
-  tools: AgentToolStatus;
-};
-
-// レビュー評価の型定義
-export type ReviewEvaluation = 'A' | 'B' | 'C' | '-';
-
-// チェックリストの作成元
-export type ReviewChecklistCreatedBy = 'user' | 'system';
-
-// 最終的に画面に表示するチェックリストの型
-export type ReviewChecklistResultDisplay = {
-  id: number; // チェックリストのID
-  content: string;
-  sourceEvaluations?: {
-    fileId: string;
-    fileName: string;
-    evaluation?: ReviewEvaluation;
-    comment?: string;
-  }[];
-};
-
-// チェックリストの編集内容を表す型
-export type ReviewChecklistEdit = {
-  id: number | null; // 新規作成時はnull
-  content?: string; // 削除の場合は指定不要
-  delete?: boolean; // trueの場合は削除対象
-};
-
-// パス定義
-export const ROUTES = {
-  CHAT: '/',
-  REVIEW: '/review',
-} as const;
-
-/**
- * リポジトリ操作の結果型
- */
-export type RepositoryResult<T> = {
-  success: boolean;
-  data?: T;
-  error?: string;
-};
-
-export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
-  Partial<Pick<T, K>>;
diff --git a/src/main/types/ipc.ts b/src/main/types/ipc.ts
deleted file mode 100644
index af5d9f0d5..000000000
--- a/src/main/types/ipc.ts
+++ /dev/null
@@ -1,220 +0,0 @@
-import type {
-  ChatMessage,
-  ChatRoom,
-  SettingsSavingStatus,
-  ReviewChecklistResultDisplay,
-  ReviewChecklistEdit,
-} from '.';
-import type { Source, ReviewHistory } from '../../db/schema';
-import type {
-  DocumentType,
-  UploadFile,
-} from '../../renderer/components/review/types';
-
-/**
- * IPC通信で使用するチャネル名の定義
- */
-export const IpcChannels = {
-  // Agent関連
-  GET_SETTINGS_STATUS: 'get-settings-status',
-  SETTINGS_STATUS_CHANGED: 'settings-status-changed',
-  REINITIALIZE_SETTINGS: 'reinitialize-settings',
-  REMOVE_SETTINGS_MESSAGE: 'remove-settings-message',
-
-  // ストア関連
-  GET_STORE_VALUE: 'get-store-value',
-  SET_STORE_VALUE: 'set-store-value',
-
-  // ソース関連
-  SOURCE_GET_ALL: 'source-get-all',
-  SOURCE_RELOAD: 'source-reload',
-  SOURCE_UPDATE_ENABLED: 'source-update-enabled',
-
-  // チャット関連
-  CHAT_SEND_MESSAGE: 'chat-send-message',
-  CHAT_GET_ROOMS: 'chat-get-rooms',
-  CHAT_GET_MESSAGES: 'chat-get-messages',
-  CHAT_DELETE_ROOM: 'chat-delete-room',
-  CHAT_CREATE_THREAD: 'chat-create-thread',
-  CHAT_STREAM: 'chat-stream',
-  CHAT_COMPLETE: 'chat-complete',
-  CHAT_STEP: 'chat-step',
-  CHAT_ERROR: 'chat-error',
-  CHAT_ABORT_REQUEST: 'chat-abort-request',
-  CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID:
-    'chat-delete-messages-before-specific-id',
-
-  // ファイルシステム関連
-  FS_CHECK_PATH_EXISTS: 'fs-check-path-exists',
-  FS_SHOW_OPEN_DIALOG: 'fs-show-open-dialog',
-  FS_READ_FILE: 'fs-read-file',
-
-  // ドキュメントレビュー関連
-  REVIEW_GET_HISTORIES: 'review-get-histories', // ドキュメント履歴切り替え時やチェックリスト抽出・ドキュメントレビュー時のポーリング処理にて呼び出される
-  REVIEW_GET_HISTORY_DETAIL: 'review-get-history-detail',
-  REVIEW_DELETE_HISTORY: 'review-delete-history',
-  REVIEW_EXTRACT_CHECKLIST_CALL: 'review-extract-checklist-call', // チェックリスト抽出処理を開始する
-  REVIEW_EXTRACT_CHECKLIST_FINISHED: 'review-extract-checklist-finished', // チェックリスト抽出が完了した際の通知
-  REVIEW_UPDATE_CHECKLIST: 'review-update-checklist',
-  REVIEW_EXECUTE_CALL: 'review-execute', // ドキュメントレビューを開始する
-  REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
-} as const;
-
-export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
-
-/**
- * IPC通信のペイロード型マッピング
- * 各チャネルごとにリクエストとレスポンスの型を厳密に定義
- */
-export type IpcRequestPayloadMap = {
-  // Mastra関連
-  [IpcChannels.REINITIALIZE_SETTINGS]: undefined;
-  [IpcChannels.REMOVE_SETTINGS_MESSAGE]: string; // message id
-
-  // ファイルシステム関連
-  [IpcChannels.FS_CHECK_PATH_EXISTS]: string;
-  [IpcChannels.FS_SHOW_OPEN_DIALOG]: {
-    title: string;
-    filters?: { name: string; extensions: string[] }[];
-    properties?: string[];
-  };
-  [IpcChannels.FS_READ_FILE]: string; // file path
-
-  // ストア関連
-  [IpcChannels.GET_STORE_VALUE]: string;
-  [IpcChannels.SET_STORE_VALUE]: { key: string; value: unknown };
-
-  // ソース関連
-  [IpcChannels.SOURCE_GET_ALL]: undefined;
-  [IpcChannels.SOURCE_RELOAD]: undefined;
-  [IpcChannels.SOURCE_UPDATE_ENABLED]: { sourceId: number; isEnabled: boolean };
-
-  // チャット関連
-  [IpcChannels.CHAT_SEND_MESSAGE]: { roomId: string; messages: ChatMessage[] };
-  [IpcChannels.CHAT_GET_ROOMS]: undefined;
-  [IpcChannels.CHAT_GET_MESSAGES]: string; // threadId
-  [IpcChannels.CHAT_DELETE_ROOM]: string; // threadId
-  [IpcChannels.CHAT_CREATE_THREAD]: {
-    roomId: string;
-    title: string;
-  };
-  [IpcChannels.CHAT_ABORT_REQUEST]: { threadId: string };
-  [IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]: {
-    threadId: string;
-    messageId: string;
-  };
-
-  // ドキュメントレビュー関連
-  [IpcChannels.REVIEW_GET_HISTORIES]: undefined;
-  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: string; // review history id
-  [IpcChannels.REVIEW_DELETE_HISTORY]: string; // review history id
-  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
-    reviewHistoryId: string;
-    files: UploadFile[];
-    documentType?: DocumentType;
-    checklistRequirements?: string;
-  };
-  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: {
-    reviewHistoryId: string;
-    checklistEdits: ReviewChecklistEdit[];
-  };
-  [IpcChannels.REVIEW_EXECUTE_CALL]: {
-    reviewHistoryId: string;
-    files: UploadFile[];
-    additionalInstructions?: string;
-    commentFormat?: string;
-  };
-};
-
-export type IpcResponsePayloadMap = {
-  // Mastra関連
-  [IpcChannels.GET_SETTINGS_STATUS]: SettingsSavingStatus;
-  [IpcChannels.REINITIALIZE_SETTINGS]: { success: boolean; error?: string };
-  [IpcChannels.REMOVE_SETTINGS_MESSAGE]: { success: boolean; error?: string };
-
-  // ファイルシステム関連
-  [IpcChannels.FS_CHECK_PATH_EXISTS]: boolean;
-  [IpcChannels.FS_SHOW_OPEN_DIALOG]: {
-    filePaths: string[];
-    canceled: boolean;
-  };
-  [IpcChannels.FS_READ_FILE]: Uint8Array; // ファイルのバイナリデータ
-
-  // ストア関連
-  [IpcChannels.GET_STORE_VALUE]: unknown;
-  [IpcChannels.SET_STORE_VALUE]: boolean;
-
-  // ソース関連
-  [IpcChannels.SOURCE_GET_ALL]: {
-    success: boolean;
-    sources?: Source[];
-    error?: string;
-  };
-  [IpcChannels.SOURCE_RELOAD]: { success: boolean; message?: string };
-  [IpcChannels.SOURCE_UPDATE_ENABLED]: { success: boolean; error?: string };
-
-  // チャット関連
-  [IpcChannels.CHAT_SEND_MESSAGE]: { success: boolean; error?: string };
-  [IpcChannels.CHAT_GET_ROOMS]: ChatRoom[];
-  [IpcChannels.CHAT_GET_MESSAGES]: ChatMessage[];
-  [IpcChannels.CHAT_DELETE_ROOM]: { success: boolean; error?: string };
-  [IpcChannels.CHAT_CREATE_THREAD]: { success: boolean; error?: string };
-  [IpcChannels.CHAT_ABORT_REQUEST]: { success: boolean; error?: string };
-  [IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]: {
-    success: boolean;
-    error?: string;
-  };
-
-  // ドキュメントレビュー関連
-  [IpcChannels.REVIEW_GET_HISTORIES]: {
-    success: boolean;
-    histories?: ReviewHistory[];
-    error?: string;
-  };
-  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: {
-    success: boolean;
-    checklistResults?: ReviewChecklistResultDisplay[];
-    additionalInstructions?: string;
-    commentFormat?: string;
-    error?: string;
-  };
-  [IpcChannels.REVIEW_DELETE_HISTORY]: { success: boolean; error?: string };
-  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
-    success: boolean;
-    error?: string;
-  };
-  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: {
-    success: boolean;
-    error?: string;
-  };
-  [IpcChannels.REVIEW_EXECUTE_CALL]: {
-    success: boolean;
-    error?: string;
-  };
-};
-
-export type IpcEventPayloadMap = {
-  [IpcChannels.CHAT_STREAM]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
-  [IpcChannels.CHAT_COMPLETE]: unknown;
-  [IpcChannels.CHAT_ERROR]: { message: string };
-  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED]: {
-    success: boolean;
-    error?: string;
-  };
-  [IpcChannels.REVIEW_EXECUTE_FINISHED]: {
-    success: boolean;
-    error?: string;
-  };
-};
-
-/**
- * 型安全性を確保するためのヘルパー型
- */
-export type IpcRequestPayload<T extends keyof IpcRequestPayloadMap> =
-  IpcRequestPayloadMap[T];
-
-export type IpcResponsePayload<T extends keyof IpcResponsePayloadMap> =
-  IpcResponsePayloadMap[T];
-
-export type IpcEventPayload<T extends keyof IpcEventPayloadMap> =
-  IpcEventPayloadMap[T];
diff --git a/src/main/types/schema.ts b/src/main/types/schema.ts
deleted file mode 100644
index 4616f8c96..000000000
--- a/src/main/types/schema.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { z } from 'zod';
-
-// StdioServerParameters(Mastraで設定されているMCPサーバ設定)のZodスキーマ定義
-// eslint-disable-next-line
-export const McpSchema = z.record(
-  z.union([
-    z.object({
-      command: z.string(),
-      args: z.array(z.string()).optional(),
-      env: z.record(z.string()).optional(),
-      cwd: z.string().optional(),
-    }),
-    z.object({
-      url: z
-        .string()
-        .url()
-        .transform((s) => new URL(s)),
-    }),
-  ]),
-);
-
-export type McpSchemaType = z.infer<typeof McpSchema>;
diff --git a/src/mastra/agents/model/openAICompatible.ts b/src/mastra/agents/model/openAICompatible.ts
index d6fffe07a..c741004b1 100644
--- a/src/mastra/agents/model/openAICompatible.ts
+++ b/src/mastra/agents/model/openAICompatible.ts
@@ -1,6 +1,8 @@
 import { createOpenAICompatible } from '@ai-sdk/openai-compatible';
+// @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
 import type { BaseRuntimeContext } from '../types';
+import { internalError } from '@/main/lib/error';
 
 export const getOpenAICompatibleModel = ({
   runtimeContext,
@@ -9,9 +11,11 @@ export const getOpenAICompatibleModel = ({
 }) => {
   const apiConfig = runtimeContext.get('model');
   if (!apiConfig || !apiConfig.key || !apiConfig.url || !apiConfig.modelName) {
-    throw new Error(
-      'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。',
-    );
+    throw internalError({
+      expose: true,
+      messageCode: 'VALIDATION_ERROR',
+      messageParams: { detail: 'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。' },
+    });
   }
 
   const model = createOpenAICompatible({
diff --git a/src/mastra/agents/orchestrator.ts b/src/mastra/agents/orchestrator.ts
index 1e346e7d7..66730c8c7 100644
--- a/src/mastra/agents/orchestrator.ts
+++ b/src/mastra/agents/orchestrator.ts
@@ -1,14 +1,18 @@
+// @ts-ignore
 import { Agent } from '@mastra/core/agent';
+// @ts-ignore
 import { Memory } from '@mastra/memory';
+// @ts-ignore
 import { TokenLimiter } from '@mastra/memory/processors';
+// @ts-ignore
 import { LibSQLStore } from '@mastra/libsql';
-import { getStore } from '../../main/store';
+import { getStore } from '@/main/store';
 import { getOrchestratorSystemPrompt } from './prompts';
 import { getOpenAICompatibleModel } from './model/openAICompatible';
-import { isPathExists, toAbsoluteFileURL } from '../../main/utils/util';
+import { isPathExists, toAbsoluteFileURL } from '@/main/lib/util';
 import { CustomToolCallFilter } from '../memory/filter/customToolCallFilter';
 import { BaseRuntimeContext } from './types';
-import type { AgentToolStatus } from '../../main/types';
+import type { AgentToolStatus } from '@/types';
 import type { RedmineBaseInfo } from '../tools/redmine/types';
 
 // orchestrator用のRuntimeContext
diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
index c7b5354a6..eba05ff08 100644
--- a/src/mastra/agents/prompts.ts
+++ b/src/mastra/agents/prompts.ts
@@ -1,3 +1,4 @@
+// @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
 import { OrchestratorRuntimeContext } from './orchestrator';
 import { DocumentExpertAgentRuntimeContext } from './toolAgents';
diff --git a/src/mastra/agents/toolAgents.ts b/src/mastra/agents/toolAgents.ts
index 36628f267..089032238 100644
--- a/src/mastra/agents/toolAgents.ts
+++ b/src/mastra/agents/toolAgents.ts
@@ -1,4 +1,5 @@
 // toolで利用するエージェントをまとめたクラス
+// @ts-ignore
 import { Agent } from '@mastra/core/agent';
 import { getOpenAICompatibleModel } from './model/openAICompatible';
 // eslint-disable-next-line import/no-cycle
diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
index c3a44b7e3..f40642ebd 100644
--- a/src/mastra/agents/workflowAgents.ts
+++ b/src/mastra/agents/workflowAgents.ts
@@ -1,4 +1,5 @@
 // workflowで利用するエージェントをまとめたクラス
+// @ts-ignore
 import { Agent } from '@mastra/core/agent';
 // eslint-disable-next-line import/no-cycle
 import {
diff --git a/src/mastra/index.ts b/src/mastra/index.ts
index c69c2da72..f6c9ababd 100644
--- a/src/mastra/index.ts
+++ b/src/mastra/index.ts
@@ -3,7 +3,9 @@
 // @ts-ignore
 import { Mastra } from '@mastra/core';
 // @ts-ignore
-import { ConsoleLogger } from '@mastra/core/logger';
+import { PinoLogger } from '@mastra/loggers';
+// @ts-ignore
+import { FileTransport } from '@mastra/loggers/file';
 import { orchestrator } from './agents/orchestrator';
 import { documentExpertAgent } from './agents/toolAgents';
 import {
@@ -19,14 +21,33 @@ import {
 import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
 import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
 import { reviewExecutionWorkflow } from './workflows/sourceReview/reviewExecution';
+import { getConfigDir } from '@/main/store';
+import fs from 'fs';
+import path from 'path';
+import { getLogLevel } from '@/main/lib/logger';
+
+const logDir = getConfigDir();
+// ログファイルの保存先ディレクトリを設定
+const logFilePath = path.join(logDir, 'ai.log');
+console.log(`AIログファイルの保存先: ${logFilePath}`);
 
-// 開発環境か本番環境かによってログレベルを切り替え
-const logLevel = process.env.NODE_ENV === 'production' ? 'info' : 'debug';
+// --- ここでログファイルの初期化処理 ---
+try {
+  if (fs.existsSync(logFilePath)) {
+    // 存在する場合は削除
+    fs.unlinkSync(logFilePath);
+  }
+  // 空ファイルを作成（存在しない場合でも touch 的に作れる）
+  fs.writeFileSync(logFilePath, '');
+} catch (err) {
+  console.error('ログファイル初期化に失敗:', err);
+}
 
 // ロガーの作成
-const logger = new ConsoleLogger({
+export const logger = new PinoLogger({
   name: 'AIKATA',
-  level: logLevel,
+  level: getLogLevel(),
+  transports: { file: new FileTransport({ path: logFilePath }) },
 });
 
 export const mastra: Mastra = new Mastra({
diff --git a/src/mastra/agents/lib.ts b/src/mastra/lib/agentUtils.ts
similarity index 72%
rename from src/mastra/agents/lib.ts
rename to src/mastra/lib/agentUtils.ts
index 7001fd32d..2fac51222 100644
--- a/src/mastra/agents/lib.ts
+++ b/src/mastra/lib/agentUtils.ts
@@ -1,17 +1,19 @@
+// @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
 import { FinishReason } from 'ai';
-import { BaseRuntimeContext } from './types';
-import { getStore } from '../../main/store';
+import { getSettingsRepository } from '@/main/repository/settingsRepository';
+import { BaseRuntimeContext } from '../agents/types';
 
 // BaseRuntimeConotextに値を入れた上で、指定したRuntimeContextを返す関数
-export function createRuntimeContext<T extends BaseRuntimeContext>() {
-  const store = getStore();
+export async function createRuntimeContext<T extends BaseRuntimeContext>() {
   const runtimeContext = new RuntimeContext<T>();
+  const settingsRepository = getSettingsRepository();
+  const store = await settingsRepository.getSettings();
   // @ts-ignore
   runtimeContext.set('model', {
-    key: store.get('api').key,
-    url: store.get('api').url,
-    modelName: store.get('api').model,
+    key: store.api.key,
+    url: store.api.url,
+    modelName: store.api.model,
   });
   return runtimeContext;
 }
diff --git a/src/mastra/workflows/libs.ts b/src/mastra/lib/workflowUtils.ts
similarity index 92%
rename from src/mastra/workflows/libs.ts
rename to src/mastra/lib/workflowUtils.ts
index 549159b94..befd76d84 100644
--- a/src/mastra/workflows/libs.ts
+++ b/src/mastra/lib/workflowUtils.ts
@@ -1,10 +1,11 @@
+// @ts-ignore
 import { WorkflowResult } from '@mastra/core';
-import { baseStepOutputSchema } from './schema';
+import { baseStepOutputSchema } from '../workflows/schema';
 import { z } from 'zod';
 
 // workflowの結果を確認するための関数
-export function checkStatus(result: WorkflowResult<any, any>): {
-  status: 'success' | 'failed' | 'suspended';
+export function checkWorkflowResult(result: WorkflowResult<any, any>): {
+  status: 'success' | 'failed' | 'suspended' | 'canceled';
   errorMessage?: string;
 } {
   // ワークフロー全体がfailedの場合(本アプリについてはエラーの場合、stepとしては成功させ、outputのstatusをfailedと指定するため、発生しないはず)
@@ -15,6 +16,13 @@ export function checkStatus(result: WorkflowResult<any, any>): {
     };
   }
 
+  // @ts-ignore
+  if (result.status === 'canceled') {
+    return {
+      status: 'canceled',
+    };
+  }
+
   if (result.status == 'suspended') {
     return {
       status: 'suspended',
diff --git a/src/mastra/memory/filter/customToolCallFilter.ts b/src/mastra/memory/filter/customToolCallFilter.ts
index e2b09b865..1471c3ab1 100644
--- a/src/mastra/memory/filter/customToolCallFilter.ts
+++ b/src/mastra/memory/filter/customToolCallFilter.ts
@@ -2,7 +2,9 @@
 // toolの呼び出し履歴は除外せず、toolの呼び出し結果については特定の文言に置き換える
 // https://github.com/mastra-ai/mastra/blob/%40mastra/core%400.8.3/packages/memory/src/processors/tool-call-filter.ts
 
+// @ts-ignore
 import type { CoreMessage } from '@mastra/core';
+// @ts-ignore
 import { MemoryProcessor } from '@mastra/core';
 
 /**
diff --git a/src/mastra/tools/gitlab/gitlabClient.ts b/src/mastra/tools/gitlab/gitlabClient.ts
index 51859c80d..66fe0aaea 100644
--- a/src/mastra/tools/gitlab/gitlabClient.ts
+++ b/src/mastra/tools/gitlab/gitlabClient.ts
@@ -12,6 +12,7 @@ import {
   MergeRequestDiscussions,
   MergeRequestNotes,
 } from '@gitbeaker/rest';
+import { internalError } from '@/main/lib/error';
 
 /**
  * GitLabクライアント設定のインターフェース
@@ -120,8 +121,11 @@ export class GitLabClient {
       await gitlab.Users.showCurrentUser();
       return true;
     } catch (error) {
-      console.error('GitLab API疎通確認に失敗:', error);
-      throw new Error('GitLab APIへの接続に失敗しました');
+      throw internalError({
+        expose: true,
+        messageCode: 'GITLAB_API_CONNECTION_ERROR',
+        cause: error,
+      });
     }
   }
 }
diff --git a/src/mastra/tools/gitlab/index.ts b/src/mastra/tools/gitlab/index.ts
index 6d365e526..854542d11 100644
--- a/src/mastra/tools/gitlab/index.ts
+++ b/src/mastra/tools/gitlab/index.ts
@@ -3,7 +3,7 @@
  * GitLabクライアントとGitLab操作用のツール群を提供
  */
 import { GitLabClient, createGitLabClient } from './gitlabClient';
-import { GitLabSchema } from '../../../main/types/settingsSchema';
+import { GitLabSchema } from '@/types';
 import { createRepositoryTools } from './repositoryTools';
 import { createMergeRequestTools } from './mergeRequestTools';
 
@@ -37,25 +37,16 @@ export const createGitLabTools = (config: { host: string; token: string }) => {
 export const setupGitLabTools = (config: { host: string; token: string }) => {
   return (async () => {
     // settingsSchemaによる設定値の検証
-    const validationResult = GitLabSchema.safeParse({
+    GitLabSchema.parse({
       endpoint: config.host,
       apiKey: config.token,
     });
-    if (!validationResult.success) {
-      throw new Error(
-        `GitLab設定が不正です: ${validationResult.error.message}`,
-      );
-    }
 
     // GitLabクライアントを作成
     const client = createGitLabClient(config);
 
-    // API疎通確認
-    try {
-      await client.testConnection();
-    } catch (error: any) {
-      throw new Error(`GitLab APIへの接続確認に失敗しました: ${error.message}`);
-    }
+    // API接続確認
+    await client.testConnection();
 
     // GitLab操作ツール一式を作成
     return createGitLabTools(config);
diff --git a/src/mastra/tools/gitlab/mergeRequestTools.ts b/src/mastra/tools/gitlab/mergeRequestTools.ts
index 16e725aa5..0977409bd 100644
--- a/src/mastra/tools/gitlab/mergeRequestTools.ts
+++ b/src/mastra/tools/gitlab/mergeRequestTools.ts
@@ -3,6 +3,7 @@
  * マージリクエスト一覧取得、詳細取得、コメント投稿・削除などの操作を提供
  */
 
+// @ts-ignore
 import { createTool } from '@mastra/core/tools';
 import { z } from 'zod';
 import { GitLabClient } from './gitlabClient';
diff --git a/src/mastra/tools/gitlab/repositoryTools.ts b/src/mastra/tools/gitlab/repositoryTools.ts
index dc4b39534..d6e66e934 100644
--- a/src/mastra/tools/gitlab/repositoryTools.ts
+++ b/src/mastra/tools/gitlab/repositoryTools.ts
@@ -3,6 +3,7 @@
  * ブランチ一覧取得・作成、タグ一覧取得、ファイルの取得、リポジトリツリー参照、コミット履歴取得などの操作を提供
  */
 
+// @ts-ignore
 import { createTool } from '@mastra/core/tools';
 import { z } from 'zod';
 import { GitLabClient } from './gitlabClient';
@@ -24,9 +25,7 @@ export const createGetFileContentTool = (client: GitLabClient) => {
         .describe('Project ID or non-encoded project path (required)'),
       file_path: z
         .string()
-        .describe(
-          'Non-encoded relative path from repository root (required)',
-        ),
+        .describe('Non-encoded relative path from repository root (required)'),
       ref: z.string().describe('Branch name or tag (required)'),
     }),
     outputSchema: createBaseToolResponseSchema(
@@ -80,9 +79,7 @@ export const createGetRawFileTool = (client: GitLabClient) => {
         .describe('Project ID or non-encoded project path (required)'),
       file_path: z
         .string()
-        .describe(
-          'Non-encoded relative path from repository root (required)',
-        ),
+        .describe('Non-encoded relative path from repository root (required)'),
       ref: z.string().describe('Branch name or tag (required)'),
     }),
     outputSchema: createBaseToolResponseSchema(
@@ -136,9 +133,7 @@ export const createGeBlameFileTool = (client: GitLabClient) => {
         .describe('Project ID or non-encoded project path (required)'),
       file_path: z
         .string()
-        .describe(
-          'Non-encoded relative path from repository root (required)',
-        ),
+        .describe('Non-encoded relative path from repository root (required)'),
       ref: z.string().describe('Branch name or tag (required)'),
       range: z
         .object({
@@ -201,9 +196,7 @@ export const createGetRepositoryTreeTool = (client: GitLabClient) => {
       path: z
         .string()
         .optional()
-        .describe(
-          'Directory path relative to repository root (optional)',
-        ),
+        .describe('Directory path relative to repository root (optional)'),
       ref: z.string().describe('Branch name or tag (required)'),
       recursive: z
         .boolean()
diff --git a/src/mastra/tools/index.ts b/src/mastra/tools/index.ts
index e60842d81..d42e2d9d4 100644
--- a/src/mastra/tools/index.ts
+++ b/src/mastra/tools/index.ts
@@ -1,10 +1,13 @@
+// @ts-ignore
 import { ToolsInput } from '@mastra/core/agent';
 import { z } from 'zod';
-import { McpSchema } from '../../main/types/schema';
+import { McpSchema } from '@/types';
 import { documentQueryTool } from './sourcesTools';
 import type { RedmineBaseInfo } from './redmine/types';
 import { createRedmineClient, setupRedmineTools } from './redmine';
 import { setupGitLabTools } from './gitlab';
+import { getMainLogger } from '@/main/lib/logger';
+import { normalizeUnknownError } from '@/main/lib/error';
 
 export type InitializeToolsConfig = {
   documentTool?: boolean;
@@ -39,6 +42,8 @@ type InitializeToolsResult = {
   toolsInput: ToolsInput;
 };
 
+const logger = getMainLogger();
+
 // ツールを初期化/更新する関数
 export const initializeTools = async (
   config: InitializeToolsConfig,
@@ -49,10 +54,12 @@ export const initializeTools = async (
     try {
       tools.documentQueryTool = documentQueryTool;
       result.documentTool = { success: true };
-    } catch (error) {
+    } catch (err) {
+      logger.error(err, 'ドキュメントツールの初期化に失敗しました');
+      const error = normalizeUnknownError(err);
       result.documentTool = {
         success: false,
-        error: error instanceof Error ? error.message : JSON.stringify(error),
+        error: error.message,
       };
     }
   }
@@ -68,16 +75,20 @@ export const initializeTools = async (
         apiUrl: config.redmineTool.endpoint,
       });
 
-      // 基本情報の取得
-      const redmineInfo = await client.getBaseInfo();
       // 作成したクライアントを使ってツールを初期化
       const redmineTools = await setupRedmineTools(client);
+
+      // 基本情報の取得
+      const redmineInfo = await client.getBaseInfo();
       tools = { ...tools, ...redmineTools };
       result.redmineTool = { success: true, redmineInfo };
-    } catch (error) {
+    } catch (err) {
+      console.error(err);
+      logger.error(err, 'Redmineツールの初期化に失敗しました');
+      const error = normalizeUnknownError(err);
       result.redmineTool = {
         success: false,
-        error: error instanceof Error ? error.message : JSON.stringify(error),
+        error: error.message,
       };
     }
   }
@@ -94,10 +105,12 @@ export const initializeTools = async (
       });
       tools = { ...tools, ...gitlabTools };
       result.gitlabTool = { success: true };
-    } catch (error) {
+    } catch (err) {
+      logger.error(err, 'GitLabツールの初期化に失敗しました');
+      const error = normalizeUnknownError(err);
       result.gitlabTool = {
         success: false,
-        error: error instanceof Error ? error.message : JSON.stringify(error),
+        error: error.message,
       };
     }
   }
diff --git a/src/mastra/tools/mcp/index.ts b/src/mastra/tools/mcp/index.ts
index 96ae7b6c9..88a8f9491 100644
--- a/src/mastra/tools/mcp/index.ts
+++ b/src/mastra/tools/mcp/index.ts
@@ -1,10 +1,14 @@
+// @ts-ignore
 import { MCPClient, LogMessage } from '@mastra/mcp';
 import { writeFileSync } from 'fs';
 import { z } from 'zod';
-import { McpSchema } from '../../../main/types/schema';
+import { McpSchema } from '@/types';
+import { getMainLogger } from '@/main/lib/logger';
 
 const LOG_FILE_PATH = './mcp.log';
 
+const systemLogger = getMainLogger();
+
 /**
  * ログメッセージをフォーマットする
  */
@@ -81,7 +85,7 @@ export const initializeMCPClient = async ({
       logPath: LOG_FILE_PATH,
     };
   } catch (error) {
-    console.error('MCPClientの初期化に失敗しました:', error);
+    systemLogger.error(error, 'MCPクライアントの初期化に失敗しました');
     return {
       success: false,
       logPath: LOG_FILE_PATH,
diff --git a/src/mastra/tools/redmine/index.ts b/src/mastra/tools/redmine/index.ts
index 2ce11d20b..08a13b000 100644
--- a/src/mastra/tools/redmine/index.ts
+++ b/src/mastra/tools/redmine/index.ts
@@ -3,6 +3,7 @@
  * RedmineクライアントとRedmine操作用のツール群を提供
  */
 
+// @ts-ignore
 import { createTool } from '@mastra/core/tools';
 import { z } from 'zod';
 import {
@@ -91,12 +92,7 @@ export const setupRedmineTools = async (
   }
 
   // API疎通確認
-  try {
-    await client.testConnection();
-    // eslint-disable-next-line
-  } catch (error: any) {
-    throw new Error(`Redmine APIへの接続確認に失敗しました`);
-  }
+  await client.testConnection();
 
   // Redmine操作ツール一式を作成
   return createRedmineTools(client);
diff --git a/src/mastra/tools/redmine/issueTools.ts b/src/mastra/tools/redmine/issueTools.ts
index d8382f7e7..43ea6e354 100644
--- a/src/mastra/tools/redmine/issueTools.ts
+++ b/src/mastra/tools/redmine/issueTools.ts
@@ -4,8 +4,10 @@
  */
 
 import { z } from 'zod';
+// @ts-ignore
 import { createTool } from '@mastra/core/tools';
 import { RedmineClient } from './redmineClient';
+import { internalError } from '@/main/lib/error';
 import { createBaseToolResponseSchema, RunToolStatus } from '../types';
 import {
   IssueFilter,
@@ -625,7 +627,11 @@ export const createUpdateIssueTool = (client: RedmineClient) => {
 
       // 更新内容があるか確認
       if (Object.keys(updateData).length === 0) {
-        throw new Error('No update fields specified');
+        throw internalError({
+          expose: true,
+          messageCode: 'VALIDATION_ERROR',
+          messageParams: { detail: 'No update fields specified' },
+        });
       }
 
       try {
diff --git a/src/mastra/tools/redmine/redmineClient.ts b/src/mastra/tools/redmine/redmineClient.ts
index f8317d3d5..d383049b7 100644
--- a/src/mastra/tools/redmine/redmineClient.ts
+++ b/src/mastra/tools/redmine/redmineClient.ts
@@ -5,7 +5,8 @@
 
 import { z } from 'zod';
 import { RedmineProject, RedmineBaseInfo } from './types';
-import { RedmineSchema } from '../../../main/types/settingsSchema';
+import { RedmineSchema } from '@/types';
+import { internalError } from '@/main/lib/error';
 
 /**
  * Redmineクライアント設定のインターフェース
@@ -88,9 +89,11 @@ export class RedmineClient {
         body: data ? JSON.stringify(data) : undefined,
       });
       if (!response.ok) {
-        throw new Error(
-          `Redmine API Error: ${response.status} ${response.statusText}`,
-        );
+        throw internalError({
+          expose: true,
+          messageCode: 'REDMINE_API_ERROR',
+          messageParams: { detail: `${response.status} ${response.statusText}` },
+        });
       }
       if (response.status === 204) {
         return {} as T;
@@ -120,7 +123,11 @@ export class RedmineClient {
         headers: commonHeaders,
       });
       if (!res.ok) {
-        throw new Error(`Redmine API Error: ${res.status} ${res.statusText}`);
+        throw internalError({
+          expose: true,
+          messageCode: 'REDMINE_API_ERROR',
+          messageParams: { detail: `${res.status} ${res.statusText}` },
+        });
       }
       const json = (await res.json()) as Record<string, any>;
 
@@ -205,7 +212,11 @@ export class RedmineClient {
       return found.id;
     }
 
-    throw new Error(`Unable to resolve ID for: ${value}`);
+    throw internalError({
+      expose: true,
+      messageCode: 'VALIDATION_ERROR',
+      messageParams: { detail: `Unable to resolve ID for: ${value}` },
+    });
   }
 
   /**
@@ -393,8 +404,11 @@ export class RedmineClient {
       await this.request('issues.json?limit=1', 'GET');
       return true;
     } catch (error) {
-      console.error('Redmine API疎通確認に失敗:', error);
-      throw error;
+      throw internalError({
+        expose: true,
+        messageCode: 'REDMINE_API_CONNECTION_ERROR',
+        cause: error,
+      });
     }
   }
 }
@@ -408,13 +422,11 @@ export const createRedmineClient = (
   config: RedmineClientConfig,
 ): RedmineClient => {
   // settingsSchemaによる設定値の検証
-  const validationResult = RedmineSchema.safeParse({
+  RedmineSchema.parse({
     endpoint: config.apiUrl,
     apiKey: config.apiKey,
   });
-  if (!validationResult.success) {
-    throw new Error(`Redmine設定が不正です: ${validationResult.error.message}`);
-  }
+
   return new RedmineClient(config);
 };
 
diff --git a/src/mastra/tools/sourcesTools.ts b/src/mastra/tools/sourcesTools.ts
index 5244a0b26..e9723243b 100644
--- a/src/mastra/tools/sourcesTools.ts
+++ b/src/mastra/tools/sourcesTools.ts
@@ -1,14 +1,14 @@
-import { APICallError } from 'ai';
 import { z } from 'zod';
+// @ts-ignore
 import { createTool } from '@mastra/core/tools';
-import { MastraError } from '@mastra/core/error';
 import { eq, and } from 'drizzle-orm';
-import { sources } from '../../db/schema';
-import getDb from '../../db/index';
-import FileExtractor from '../../main/utils/fileExtractor';
+import { sources } from '@/db/schema';
+import getDb from '@/db/index';
+import FileExtractor from '@/main/lib/fileExtractor';
 import { createBaseToolResponseSchema, RunToolStatus } from './types';
 import { DocumentExpertAgentRuntimeContext } from '../agents/toolAgents';
-import { createRuntimeContext, judgeFinishReason } from '../agents/lib';
+import { createRuntimeContext, judgeFinishReason } from '../lib/agentUtils';
+import { normalizeUnknownError, internalError } from '@/main/lib/error';
 
 /**
  * ソース一覧表示ツール
@@ -161,7 +161,7 @@ export const documentQueryTool = createTool({
             const documentExpertAgent = mastra.getAgent('documentExpertAgent');
 
             const runtimeContext =
-              createRuntimeContext<DocumentExpertAgentRuntimeContext>();
+              await createRuntimeContext<DocumentExpertAgentRuntimeContext>();
 
             runtimeContext.set('documentContent', content);
 
@@ -172,7 +172,11 @@ export const documentQueryTool = createTool({
             answer = res.text;
             const { success, reason } = judgeFinishReason(res.finishReason);
             if (!success) {
-              throw new Error(reason);
+              throw internalError({
+                expose: true,
+                messageCode: 'AI_API_ERROR',
+                messageParams: { detail: reason },
+              });
             }
           } catch (error) {
             answer = `error occured while processing the query: ${error instanceof Error ? `: ${error.message}` : JSON.stringify(error)}`;
@@ -194,20 +198,8 @@ export const documentQueryTool = createTool({
       };
     } catch (error) {
       let errorDetail: string;
-      if (
-        error instanceof MastraError &&
-        APICallError.isInstance(error.cause)
-      ) {
-        // APIコールエラーの場合はresponseBodyの内容を取得
-        errorDetail = error.cause.message;
-        if (error.cause.responseBody) {
-          errorDetail += `:\n${error.cause.responseBody}`;
-        }
-      } else if (error instanceof Error) {
-        errorDetail = error.message;
-      } else {
-        errorDetail = JSON.stringify(error);
-      }
+      const normalizedError = normalizeUnknownError(error);
+      errorDetail = normalizedError.message;
       const errorMessage = `ドキュメント検索ツール実行時にエラーが発生しました:\n${errorDetail}`;
 
       status = 'failed';
diff --git a/src/mastra/workflows/sourceRegistration/sourceRegistration.ts b/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
index 38ec8aa42..c0f30ca1e 100644
--- a/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
+++ b/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
@@ -1,14 +1,15 @@
 /* eslint-disable import/prefer-default-export */
-import { APICallError } from 'ai';
 // @ts-ignore
 import { createWorkflow, createStep } from '@mastra/core/workflows';
-// @ts-ignore
-import { MastraError } from '@mastra/core/error';
 import { z } from 'zod';
 import { stepStatus } from '../types';
 import { baseStepOutputSchema } from '../schema';
-import { getSourceRepository } from '../../../db/repository/sourceRepository';
-import { createRuntimeContext, judgeFinishReason } from '../../agents/lib';
+import { getSourceRepository } from '../../../main/repository/sourceRepository';
+import { createRuntimeContext, judgeFinishReason } from '../../lib/agentUtils';
+import { normalizeUnknownError, internalError } from '@/main/lib/error';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
 
 const triggerSchema = z.object({
   filePath: z.string().describe('登録するソースのファイルパス'),
@@ -60,7 +61,7 @@ const analyzeSourceStep = createStep({
       });
 
       const analysisResult = await summarizeSourceAgent.generate(content, {
-        runtimeContext: createRuntimeContext(),
+        runtimeContext: await createRuntimeContext(),
         output: outputSchema,
       });
 
@@ -68,7 +69,11 @@ const analyzeSourceStep = createStep({
         analysisResult.finishReason,
       );
       if (!success) {
-        throw new Error(reason);
+        throw internalError({
+          expose: true,
+          messageCode: 'AI_API_ERROR',
+          messageParams: { detail: reason },
+        });
       }
 
       title = analysisResult.object.title;
@@ -84,23 +89,11 @@ const analyzeSourceStep = createStep({
 
       status = 'success';
     } catch (error) {
+      logger.error(error, 'ソース分析に失敗しました');
       let errorDetail: string;
-      if (
-        error instanceof MastraError &&
-        APICallError.isInstance(error.cause)
-      ) {
-        // APIコールエラーの場合はresponseBodyの内容を取得
-        errorDetail = error.cause.responseBody
-          ? error.cause.responseBody
-          : error.cause.message;
-      } else if (error instanceof Error) {
-        errorDetail = error.message;
-      } else {
-        errorDetail = JSON.stringify(error);
-      }
-      errorMessage = `ソース分析でエラーが発生しました:\n${errorDetail}`;
-      console.error(error);
-
+      const normalizedError = normalizeUnknownError(error);
+      errorDetail = normalizedError.message;
+      errorMessage = `ソース分析に失敗しました\n${errorDetail}`;
       // DBにエラー情報を更新
       await sourceRepository.updateProcessingStatus({
         id: sourceId,
@@ -155,14 +148,18 @@ const extractTopicAndSummaryStep = createStep({
       });
 
       const analysisResult = await summarizeTopicAgent.generate(content, {
-        runtimeContext: createRuntimeContext(),
+        runtimeContext: await createRuntimeContext(),
         output: outputSchema,
       });
       const { success, reason } = judgeFinishReason(
         analysisResult.finishReason,
       );
       if (!success) {
-        throw new Error(reason);
+        throw internalError({
+          expose: true,
+          messageCode: 'AI_API_ERROR',
+          messageParams: { detail: reason },
+        });
       }
 
       // トピックと要約をデータベースに登録
@@ -184,20 +181,8 @@ const extractTopicAndSummaryStep = createStep({
       status = 'success';
     } catch (error) {
       let errorDetail: string;
-      if (
-        error instanceof MastraError &&
-        APICallError.isInstance(error.cause)
-      ) {
-        // APIコールエラーの場合はresponseBodyの内容を取得
-        errorDetail = error.cause.message;
-        if (error.cause.responseBody) {
-          errorDetail += `:\n${error.cause.responseBody}`;
-        }
-      } else if (error instanceof Error) {
-        errorDetail = error.message;
-      } else {
-        errorDetail = JSON.stringify(error);
-      }
+      const normalizedError = normalizeUnknownError(error);
+      errorDetail = normalizedError.message;
       errorMessage = `ソース分析でエラーが発生しました:\n${errorDetail}`;
       console.error(error);
 
diff --git a/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts b/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
index ec5215f71..248f7ec78 100644
--- a/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
+++ b/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
@@ -1,20 +1,27 @@
 import fs from 'fs/promises';
 import path from 'path';
-import { getStore } from '../../../main/store';
-import FileExtractor from '../../../main/utils/fileExtractor';
+import FileExtractor from '../../../main/lib/fileExtractor';
 import { mastra } from '../..';
-import { getSourceRepository } from '../../../db/repository/sourceRepository';
-import { checkStatus } from '../libs';
+import { getSourceRepository } from '../../../main/repository/sourceRepository';
+import { checkWorkflowResult } from '../../lib/workflowUtils';
+import { getMainLogger } from '@/main/lib/logger';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { getSettingsRepository } from '@/main/repository/settingsRepository';
+import { publishEvent } from '@/main/lib/eventPayloadHelper';
+import { IpcChannels } from '@/types';
+
+const logger = getMainLogger();
 
 /**
  * フォルダ内の全てのファイルを登録するワークフロー
  */
 export default class SourceRegistrationManager {
-  // eslint-disable-next-line
   private static instance: SourceRegistrationManager | null = null;
 
   private sourceRepository = getSourceRepository();
 
+  private settingsRepository = getSettingsRepository();
+
   /**
    * シングルトンインスタンスを取得するメソッド
    */
@@ -29,18 +36,12 @@ export default class SourceRegistrationManager {
    * ソースとそのキャッシュを削除
    * @param sourcePath ソースのパス
    */
-  // eslint-disable-next-line
   private async deleteSourceAndCache(sourcePath: string): Promise<void> {
-    try {
-      const result = await this.sourceRepository.deleteSourceByPath(sourcePath);
-      if (result) {
-        if (FileExtractor.isCacheTarget(sourcePath)) {
-          await FileExtractor.deleteCache(sourcePath);
-        }
+    const result = await this.sourceRepository.deleteSourceByPath(sourcePath);
+    if (result) {
+      if (FileExtractor.isCacheTarget(sourcePath)) {
+        await FileExtractor.deleteCache(sourcePath);
       }
-    } catch (error) {
-      console.error(`ソースの削除に失敗しました: ${sourcePath}`, error);
-      throw error;
     }
   }
 
@@ -48,20 +49,16 @@ export default class SourceRegistrationManager {
    * アプリ起動時に、処理中のソースを全て削除する
    */
   public async clearProcessingSources(): Promise<void> {
-    try {
-      // 削除対象のソースを取得
-      const targetSources = await this.sourceRepository.getSouorceInStatus([
-        'processing',
-        'idle',
-      ]);
-
-      // 各ソースを削除
-      for (const source of targetSources) {
-        await this.deleteSourceAndCache(source.path);
-      }
-    } catch (error) {
-      console.error('処理中のソースの削除に失敗しました', error);
-      throw error;
+    // 削除対象のソースを取得
+    const targetSources = await this.sourceRepository.getSouorceInStatus([
+      'processing',
+      'idle',
+      'failed',
+    ]);
+
+    // 各ソースを削除
+    for (const source of targetSources) {
+      await this.deleteSourceAndCache(source.path);
     }
   }
 
@@ -70,8 +67,8 @@ export default class SourceRegistrationManager {
    */
   public async registerAllFiles(excludeRegisteredFile = true): Promise<void> {
     try {
-      const store = getStore();
-      const { registerDir } = store.get('source');
+      const store = await this.settingsRepository.getSettings();
+      const { registerDir } = store.source;
       let files: string[] = [];
       if (registerDir.trim() !== '') {
         // フォルダ内のファイル一覧を取得
@@ -98,6 +95,8 @@ export default class SourceRegistrationManager {
       // フォルダ内のファイルが存在しない場合は早期リターン
       if (files.length === 0) {
         console.log('登録するファイルが見つかりませんでした');
+        // ドキュメント更新完了イベントを発行（成功）
+        publishEvent(IpcChannels.SOURCE_RELOAD_FINISHED, { success: true });
         return;
       }
 
@@ -126,6 +125,8 @@ export default class SourceRegistrationManager {
       // 登録対象のファイルが存在しない場合は早期リターン
       if (files.length === 0) {
         console.log('登録するファイルが見つかりませんでした');
+        // ドキュメント更新完了イベントを発行（成功）
+        publishEvent(IpcChannels.SOURCE_RELOAD_FINISHED, { success: true });
         return;
       }
 
@@ -152,7 +153,6 @@ export default class SourceRegistrationManager {
         (previousPromise, filePath) => {
           return previousPromise.then(async (resultList) => {
             try {
-              let success = false;
               // ファイルからテキストを抽出
               const { content } = await FileExtractor.extractText(filePath);
 
@@ -164,14 +164,17 @@ export default class SourceRegistrationManager {
               });
 
               // 結果を確認
-              const checkResult = checkStatus(result);
+              const checkResult = checkWorkflowResult(result);
 
               resultList.push({
                 success: checkResult.status == 'success',
                 filePath,
               });
             } catch (error) {
-              console.error(error);
+              logger.error(
+                error,
+                'ドキュメント登録用ワークフロー実行中にエラー',
+              );
               resultList.push({
                 success: false,
                 filePath,
@@ -187,9 +190,20 @@ export default class SourceRegistrationManager {
 
       // 成功件数をカウント
       const successCount = registrationResults.filter((r) => r.success).length;
-      console.log(`${successCount}件のファイルの登録が完了しました`);
+      logger.debug(`${successCount}件のファイルの登録が完了しました`);
+
+      // ドキュメント更新完了イベントを発行（成功）
+      publishEvent(IpcChannels.SOURCE_RELOAD_FINISHED, { success: true });
     } catch (error) {
-      console.error('ファイル登録処理に失敗しました', error);
+      // ドキュメント更新完了イベントを発行（失敗）
+      const normalizedError = normalizeUnknownError(error);
+      let errorMessage = normalizedError.message;
+      publishEvent(IpcChannels.SOURCE_RELOAD_FINISHED, {
+        success: false,
+        error: errorMessage,
+      });
+
+      // エラーを再throw
       throw error;
     }
   }
@@ -200,20 +214,32 @@ export default class SourceRegistrationManager {
    * @returns ファイルパスの配列
    */
   private async readDirectoryRecursively(dirPath: string): Promise<string[]> {
-    const items = await fs.readdir(dirPath, { withFileTypes: true });
-
-    // map して Promise<string[]> の配列を作成
-    const nested = await Promise.all(
-      items.map(async (item) => {
-        const fullPath = path.resolve(path.join(dirPath, item.name));
-        if (item.isDirectory()) {
-          return this.readDirectoryRecursively(fullPath);
-        }
-        return [fullPath];
-      }),
-    );
+    try {
+      const items = await fs.readdir(dirPath, { withFileTypes: true });
+
+      // map して Promise<string[]> の配列を作成
+      const nested = await Promise.all(
+        items.map(async (item) => {
+          const fullPath = path.resolve(path.join(dirPath, item.name));
+          if (item.isDirectory()) {
+            return this.readDirectoryRecursively(fullPath);
+          }
+          return [fullPath];
+        }),
+      );
 
-    // 配列の配列を平坦化して返却
-    return nested.flat();
+      // 配列の配列を平坦化して返却
+      return nested.flat();
+    } catch (error) {
+      logger.error(
+        error,
+        'ドキュメント登録用ディレクトリの読み込みに失敗しました',
+      );
+      throw internalError({
+        expose: true,
+        messageCode: 'SOURCE_REGISTRATION_DIR_READING_ERROR',
+        cause: error,
+      });
+    }
   }
 }
diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
index 3698e613d..781b0c7b8 100644
--- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
@@ -1,11 +1,11 @@
 /* eslint-disable prefer-template */
-import { APICallError, NoObjectGeneratedError } from 'ai';
+import { NoObjectGeneratedError } from 'ai';
+// @ts-ignore
 import { createStep, createWorkflow } from '@mastra/core/workflows';
-import { MastraError } from '@mastra/core/error';
 import { z } from 'zod';
-import { getReviewRepository } from '../../../db/repository/reviewRepository';
-import { getSourceRepository } from '../../../db/repository/sourceRepository';
-import FileExtractor from '../../../main/utils/fileExtractor';
+import { getReviewRepository } from '@/main/repository/reviewRepository';
+import { getSourceRepository } from '@/main/repository/sourceRepository';
+import FileExtractor from '@/main/lib/fileExtractor';
 import { baseStepOutputSchema } from '../schema';
 import { stepStatus } from '../types';
 import {
@@ -13,8 +13,12 @@ import {
   TopicExtractionAgentRuntimeContext,
   TopicChecklistAgentRuntimeContext,
 } from '../../agents/workflowAgents';
-import { createRuntimeContext } from '../../agents/lib';
-import { UploadFile } from '../../../renderer/components/review/types';
+import { createRuntimeContext } from '../../lib/agentUtils';
+import { UploadFile } from '@/types';
+import { normalizeUnknownError, internalError } from '@/main/lib/error';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
 
 // ワークフローの入力スキーマ
 const triggerSchema = z.object({
@@ -77,15 +81,13 @@ const checklistDocumentExtractionStep = createStep({
   description: 'チェックリストドキュメントから既存項目を抽出するステップ',
   inputSchema: triggerSchema,
   outputSchema: checklistDocumentStepOutputSchema,
-  execute: async ({ inputData, mastra }) => {
+  execute: async ({ inputData, mastra, abortSignal }) => {
     // レビュー用のリポジトリを取得
     const reviewRepository = getReviewRepository();
     const sourceRepository = getSourceRepository();
     // トリガーから入力を取得
     const { reviewHistoryId, files } = inputData;
-    const errorMessages: string[] = [
-      'チェックリスト抽出処理中に以下エラーが発生しました',
-    ];
+    const errorMessages: string[] = [];
 
     try {
       // 既存のシステム作成チェックリストを削除
@@ -172,7 +174,7 @@ const checklistDocumentExtractionStep = createStep({
           while (attempts < MAX_ATTEMPTS) {
             let isCompleted = true;
             const runtimeContext =
-              createRuntimeContext<ChecklistExtractionAgentRuntimeContext>();
+              await createRuntimeContext<ChecklistExtractionAgentRuntimeContext>();
             // これまでに抽出したチェックリスト項目
             runtimeContext.set('extractedItems', accumulated);
             const extractionResult = await checklistExtractionAgent.generate(
@@ -180,6 +182,7 @@ const checklistDocumentExtractionStep = createStep({
               {
                 output: outputSchema,
                 runtimeContext,
+                abortSignal,
                 // AIの限界生成トークン数を超えた場合のエラーを回避するための設定
                 experimental_repairText: async (options) => {
                   isCompleted = false;
@@ -213,9 +216,10 @@ const checklistDocumentExtractionStep = createStep({
                     console.error(
                       `チェックリスト抽出の修正に失敗しました: ${error}`,
                     );
-                    throw new Error(
-                      'チェックリストの抽出結果がAIモデルの最大出力トークン数を超え、不正な出力となった為修正を試みましたが失敗しました。抽出結果が最大出力トークン内に収まるようにチェックリストのファイル分割を検討してください。',
-                    );
+                    throw internalError({
+                      expose: true,
+                      messageCode: 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS',
+                    });
                   }
                   return repairedText;
                 },
@@ -224,9 +228,10 @@ const checklistDocumentExtractionStep = createStep({
 
             // チェックリストドキュメントでない場合はエラー
             if (!extractionResult.object.isChecklistDocument) {
-              throw new Error(
-                `チェックリスト抽出に適さないドキュメントとして判定されたため処理を終了しました`,
-              );
+              throw internalError({
+                expose: true,
+                messageCode: 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT',
+              });
             }
 
             if (
@@ -234,7 +239,11 @@ const checklistDocumentExtractionStep = createStep({
               (!extractionResult.object.newChecklists ||
                 extractionResult.object.newChecklists.length === 0)
             ) {
-              throw new Error(`チェックリストが抽出されませんでした`);
+              throw internalError({
+                expose: true,
+                messageCode: 'AI_API_ERROR',
+                messageParams: { detail: 'チェックリストが抽出されませんでした' },
+              });
             }
 
             // 抽出されたチェックリストから新規のものを蓄積
@@ -258,35 +267,27 @@ const checklistDocumentExtractionStep = createStep({
             }
             attempts++;
             if (attempts >= MAX_ATTEMPTS) {
-              throw new Error(
-                `チェックリスト抽出処理の実行回数が一定数を超えました。チェックリストのファイル分割を検討してください。`,
-              );
+              throw internalError({
+                expose: true,
+                messageCode: 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS',
+              });
             }
           }
         } catch (error) {
+          logger.error(error, 'チェックリスト抽出処理に失敗しました');
           let errorMessage = '';
           let errorDetail: string;
           if (
-            error instanceof MastraError &&
-            APICallError.isInstance(error.cause)
-          ) {
-            // APIコールエラーの場合はresponseBodyの内容を取得
-            errorDetail = error.cause.message;
-            if (error.cause.responseBody) {
-              errorDetail += `:\n${error.cause.responseBody}`;
-            }
-          } else if (
             NoObjectGeneratedError.isInstance(error) &&
             error.finishReason === 'length'
           ) {
             errorDetail =
-              'AIモデルが生成できる文字数を超えています。チェックリストをファイル分割して再実行してください。';
-          } else if (error instanceof Error) {
-            errorDetail = error.message;
+              'AIの大量出力の補正に失敗しました、チェックリストをファイルの分割を検討してください';
           } else {
-            errorDetail = JSON.stringify(error);
+            const normalizedError = normalizeUnknownError(error);
+            errorDetail = normalizedError.message;
           }
-          errorMessage += `- ${file.name}のチェックリスト抽出でエラー: ${errorDetail}`;
+          errorMessage = `${file.name}のチェックリスト抽出中にエラー: ${errorDetail}`;
           errorMessages.push(errorMessage);
         }
       });
@@ -295,7 +296,7 @@ const checklistDocumentExtractionStep = createStep({
       await Promise.all(extractionPromises);
 
       // エラーがあれば失敗として返す
-      if (errorMessages.length > 1) {
+      if (errorMessages.length > 0) {
         return {
           status: 'failed' as stepStatus,
           errorMessage: errorMessages.join('\n'),
@@ -306,12 +307,9 @@ const checklistDocumentExtractionStep = createStep({
         status: 'success' as stepStatus,
       };
     } catch (error) {
-      if (error instanceof Error && error.message) {
-        if (errorMessages.length > 1) {
-          errorMessages.push(''); // エラーメッセージの区切り
-        }
-        errorMessages.push(`${error.message}`);
-      }
+      logger.error(error, 'チェックリスト抽出処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      errorMessages.push(normalizedError.message);
       return {
         status: 'failed' as stepStatus,
         errorMessage: errorMessages.join('\n'),
@@ -328,12 +326,10 @@ const topicExtractionStep = createStep({
   description: '一般ドキュメントから独立したトピックを抽出するステップ',
   inputSchema: triggerSchema,
   outputSchema: topicExtractionStepOutputSchema,
-  execute: async ({ inputData, mastra, bail }) => {
+  execute: async ({ inputData, mastra, bail, abortSignal }) => {
     const reviewRepository = getReviewRepository();
     const { files, reviewHistoryId, checklistRequirements } = inputData;
-    const errorMessages: string[] = [
-      'チェックリスト作成処理中にエラーが発生しました',
-    ];
+    const errorMessages: string[] = [];
 
     try {
       const allTopics: Array<{
@@ -416,7 +412,7 @@ const topicExtractionStep = createStep({
               .describe('Extracted topics from the document'),
           });
           const runtimeContext =
-            createRuntimeContext<TopicExtractionAgentRuntimeContext>();
+            await createRuntimeContext<TopicExtractionAgentRuntimeContext>();
           if (checklistRequirements) {
             runtimeContext.set('checklistRequirements', checklistRequirements);
           }
@@ -426,15 +422,14 @@ const topicExtractionStep = createStep({
             {
               output: outputSchema,
               runtimeContext,
+              abortSignal,
             },
           );
 
-          mastra
-            .getLogger()
-            .debug(
-              `document(${file.name}) extracted topics for creating checklist:`,
-              JSON.stringify(extractionResult.object.topics, null, 2),
-            );
+          logger.debug(
+            `document(${file.name}) extracted topics for creating checklist:`,
+            JSON.stringify(extractionResult.object.topics, null, 2),
+          );
 
           allTopics.push(
             ...extractionResult.object.topics.map((t) => ({
@@ -444,14 +439,13 @@ const topicExtractionStep = createStep({
             })),
           );
         } catch (error) {
-          let errorDetail: string;
-          if (error instanceof Error) {
-            errorDetail = error.message;
-          } else {
-            errorDetail = JSON.stringify(error);
-          }
+          logger.error(
+            error,
+            'チェックリスト作成のトピック抽出処理に失敗しました',
+          );
+          const normalizedError = normalizeUnknownError(error);
           errorMessages.push(
-            `- ${file.name}のトピック抽出でエラー: ${errorDetail}`,
+            `${file.name}のチェックリスト作成中にエラー: ${normalizedError.message}`,
           );
         }
       });
@@ -466,13 +460,6 @@ const topicExtractionStep = createStep({
         });
       }
 
-      if (allTopics.length === 0) {
-        return bail({
-          status: 'failed' as stepStatus,
-          errorMessage: 'トピックが抽出されませんでした',
-        });
-      }
-
       // 既存のシステム作成チェックリストを削除
       await reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
 
@@ -481,12 +468,9 @@ const topicExtractionStep = createStep({
         topics: allTopics,
       };
     } catch (error) {
-      if (error instanceof Error && error.message) {
-        if (errorMessages.length > 1) {
-          errorMessages.push(''); // エラーメッセージの区切り
-        }
-        errorMessages.push(`${error.message}`);
-      }
+      logger.error(error, 'チェックリスト作成のトピック抽出処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      errorMessages.push(`${normalizedError.message}`);
       return bail({
         status: 'failed' as stepStatus,
         errorMessage: errorMessages.join('\n'),
@@ -507,13 +491,10 @@ const topicChecklistCreationStep = createStep({
     checklistRequirements: z.string().optional(),
   }),
   outputSchema: topicChecklistStepOutputSchema,
-  execute: async ({ inputData, mastra, bail }) => {
+  execute: async ({ inputData, mastra, bail, abortSignal }) => {
     const { title, file, content, reviewHistoryId, checklistRequirements } =
       inputData;
     const reviewRepository = getReviewRepository();
-    const errorMessages: string[] = [
-      'チェックリスト作成処理中にエラーが発生しました',
-    ];
 
     try {
       let message;
@@ -585,7 +566,7 @@ const topicChecklistCreationStep = createStep({
       });
 
       const runtimeContext =
-        createRuntimeContext<TopicChecklistAgentRuntimeContext>();
+        await createRuntimeContext<TopicChecklistAgentRuntimeContext>();
       runtimeContext.set('topic', { title });
       if (checklistRequirements) {
         runtimeContext.set('checklistRequirements', checklistRequirements);
@@ -594,22 +575,25 @@ const topicChecklistCreationStep = createStep({
       const result = await topicChecklistAgent.generate(message, {
         output: outputSchema,
         runtimeContext,
+        abortSignal,
       });
-      mastra
-        .getLogger()
-        .debug(
-          `document(${file.name}) topic(${title}) generated checklist items:`,
-          JSON.stringify(result.object.checklistItems, null, 2),
-        );
+      logger.debug(
+        `document(${file.name}) topic(${title}) generated checklist items:`,
+        JSON.stringify(result.object.checklistItems, null, 2),
+      );
 
       if (
         !result.object.checklistItems ||
         result.object.checklistItems.length === 0
       ) {
-        return bail({
-          status: 'failed' as stepStatus,
-          errorMessage: `トピック「${title}」に対するチェックリスト項目が生成されませんでした`,
-        });
+        logger.error(
+          `トピック「${title}」に対するチェックリスト項目が生成されませんでした`,
+        );
+        // 別トピックでも生成される可能性があるため、失敗とはせず成功で返す
+        return {
+          status: 'success' as stepStatus,
+          checklistItems: [],
+        };
       }
 
       // 抽出されたチェックリストをDBに保存
@@ -628,15 +612,11 @@ const topicChecklistCreationStep = createStep({
         ),
       };
     } catch (error) {
-      if (error instanceof Error && error.message) {
-        if (errorMessages.length > 1) {
-          errorMessages.push(''); // エラーメッセージの区切り
-        }
-        errorMessages.push(`トピック「${title}」: ${error.message}`);
-      }
+      logger.error(error, `チェックリスト作成処理に失敗しました: ${title}`);
+      const normalizedError = normalizeUnknownError(error);
       return bail({
         status: 'failed' as stepStatus,
-        errorMessage: errorMessages.join('\n'),
+        errorMessage: `${file.name}のチェックリスト作成中にエラー: ${normalizedError.message}`,
       });
     }
   },
diff --git a/src/mastra/workflows/sourceReview/reviewExecution.ts b/src/mastra/workflows/sourceReview/reviewExecution.ts
index 5e2b6921c..038049e67 100644
--- a/src/mastra/workflows/sourceReview/reviewExecution.ts
+++ b/src/mastra/workflows/sourceReview/reviewExecution.ts
@@ -1,10 +1,12 @@
-import { APICallError, NoObjectGeneratedError } from 'ai';
+import { NoObjectGeneratedError } from 'ai';
+// @ts-ignore
 import { createWorkflow, createStep } from '@mastra/core/workflows';
+// @ts-ignore
 import { MastraError } from '@mastra/core/error';
 import { z } from 'zod';
-import { getReviewRepository } from '../../../db/repository/reviewRepository';
-import FileExtractor from '../../../main/utils/fileExtractor';
-import type { ReviewEvaluation } from '../../../main/types';
+import { getReviewRepository } from '@/main/repository/reviewRepository';
+import FileExtractor from '@/main/lib/fileExtractor';
+import type { ReviewEvaluation } from '@/types';
 import { baseStepOutputSchema } from '../schema';
 import { stepStatus } from '../types';
 import { splitChecklistEquallyByMaxSize } from './lib';
@@ -12,7 +14,11 @@ import {
   ClassifyCategoryAgentRuntimeContext,
   ReviewExecuteAgentRuntimeContext,
 } from '../../agents/workflowAgents';
-import { createRuntimeContext, judgeFinishReason } from '../../agents/lib';
+import { createRuntimeContext, judgeFinishReason } from '../../lib/agentUtils';
+import { getMainLogger } from '@/main/lib/logger';
+import { normalizeUnknownError, extractAIAPISafeError, internalError } from '@/main/lib/error';
+
+const logger = getMainLogger();
 
 // 一つのカテゴリに含めるチェックリストの最大数
 const MAX_CHECKLISTS_PER_CATEGORY = 3;
@@ -68,7 +74,7 @@ const classifyChecklistsByCategoryStep = createStep({
   description: 'チェックリストをカテゴリごとに分類するステップ',
   inputSchema: triggerSchema,
   outputSchema: classifyChecklistsByCategoryOutputSchema,
-  execute: async ({ inputData, mastra }) => {
+  execute: async ({ inputData, mastra, abortSignal }) => {
     // トリガーから入力を取得
     const { reviewHistoryId } = inputData;
 
@@ -79,7 +85,10 @@ const classifyChecklistsByCategoryStep = createStep({
       // チェックリストを取得
       const checklistsResult = await repository.getChecklists(reviewHistoryId);
       if (!checklistsResult || checklistsResult.length === 0) {
-        throw new Error('レビュー対象のチェックリストが見つかりません');
+        throw internalError({
+          expose: true,
+          messageCode: 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST',
+        });
       }
 
       // チェックリストデータを整形
@@ -103,7 +112,7 @@ const classifyChecklistsByCategoryStep = createStep({
           .describe('Classified categories'),
       });
       const runtimeContext =
-        createRuntimeContext<ClassifyCategoryAgentRuntimeContext>();
+        await createRuntimeContext<ClassifyCategoryAgentRuntimeContext>();
       runtimeContext.set(
         'maxChecklistsPerCategory',
         MAX_CHECKLISTS_PER_CATEGORY,
@@ -116,6 +125,7 @@ const classifyChecklistsByCategoryStep = createStep({
         {
           output: outputSchema,
           runtimeContext,
+          abortSignal,
         },
       );
       // 分類結果の妥当性をチェック
@@ -187,10 +197,10 @@ const classifyChecklistsByCategoryStep = createStep({
         categories: finalCategories,
       };
     } catch (error) {
+      logger.error(error, 'チェックリストのカテゴリ分類処理に失敗しました');
       if (
-        APICallError.isInstance(error) ||
-        (NoObjectGeneratedError.isInstance(error) &&
-          error.finishReason === 'length') ||
+        extractAIAPISafeError(error) ||
+        NoObjectGeneratedError.isInstance(error) ||
         error instanceof MastraError
       ) {
         // APIコールエラーまたはAIモデルが生成できる文字数を超えた場合、手動でカテゴリー分割
@@ -199,13 +209,16 @@ const classifyChecklistsByCategoryStep = createStep({
           await repository.getChecklists(reviewHistoryId);
         return {
           status: 'success' as stepStatus,
-          categories: splitChecklistEquallyByMaxSize(checklistsResult, 7),
+          categories: splitChecklistEquallyByMaxSize(
+            checklistsResult,
+            MAX_CHECKLISTS_PER_CATEGORY,
+          ),
         };
       }
-      const errorDetail =
-        error instanceof Error ? error.message : JSON.stringify(error);
+      const normalizedError = normalizeUnknownError(error);
+      const errorDetail = normalizedError.message;
       // エラーが発生した場合はエラ
-      const errorMessage = `ドキュメントレビュー中にエラーが発生しました:\n${errorDetail}`;
+      const errorMessage = `${errorDetail}`;
       return {
         status: 'failed' as stepStatus,
         errorMessage,
@@ -220,7 +233,7 @@ const reviewExecutionStep = createStep({
   description: 'チェックリストごとにレビューを実行するステップ',
   inputSchema: classifyChecklistsByCategoryOutputSchema,
   outputSchema: baseStepOutputSchema,
-  execute: async ({ inputData, getInitData, mastra }) => {
+  execute: async ({ inputData, getInitData, mastra, abortSignal }) => {
     // レビュー対象のファイル
     const { files, additionalInstructions, commentFormat } =
       getInitData() as z.infer<typeof triggerSchema>;
@@ -240,7 +253,7 @@ const reviewExecutionStep = createStep({
 
     // チェックリストを全量チェックできなかったドキュメントを格納
     // key: ファイル名, value: エラー内容
-    const errorDocuments = new Map<string, string[]>();
+    const errorDocuments = new Map<string, string>();
 
     try {
       const reviewAgent = mastra.getAgent('reviewExecuteAgent');
@@ -317,7 +330,7 @@ const reviewExecutionStep = createStep({
                 }),
               );
               const runtimeContext =
-                createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
+                await createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
               runtimeContext.set('checklistItems', reviewTargetChecklists);
               runtimeContext.set(
                 'additionalInstructions',
@@ -328,12 +341,17 @@ const reviewExecutionStep = createStep({
               const reviewResult = await reviewAgent.generate(message, {
                 output: outputSchema,
                 runtimeContext,
+                abortSignal,
               });
               const { success, reason } = judgeFinishReason(
                 reviewResult.finishReason,
               );
               if (!success) {
-                throw new Error(reason);
+                throw internalError({
+                  expose: true,
+                  messageCode: 'AI_API_ERROR',
+                  messageParams: { detail: reason },
+                });
               }
               // レビュー結果をDBに保存
               if (reviewResult.object && Array.isArray(reviewResult.object)) {
@@ -361,56 +379,43 @@ const reviewExecutionStep = createStep({
                 break;
               }
             } catch (error) {
+              logger.error(
+                error,
+                `${file.name}チェックリストのレビュー実行処理に失敗しました`,
+              );
               let errorDetail: string;
               if (
-                error instanceof MastraError &&
-                APICallError.isInstance(error.cause)
-              ) {
-                // APIコールエラーの場合はresponseBodyの内容を取得
-                errorDetail = error.cause.message;
-                if (error.cause.responseBody) {
-                  errorDetail += `:\n${error.cause.responseBody}`;
-                }
-              } else if (
                 NoObjectGeneratedError.isInstance(error) &&
                 error.finishReason === 'length'
               ) {
                 // AIモデルが生成できる文字数を超えているため、手動でレビューを分割
                 errorDetail = `AIモデルが生成できる文字数を超えています。チェックリスト量の削減を検討してください。`;
-              } else if (error instanceof Error) {
-                errorDetail = error.message;
               } else {
-                errorDetail = JSON.stringify(error);
+                const normalizedError = normalizeUnknownError(error);
+                errorDetail = normalizedError.message;
               }
               // レビューに失敗したチェックリストを記録
-              if (!errorDocuments.has(file.name)) {
-                errorDocuments.set(file.name, []);
-              }
-              errorDocuments.get(file.name)!.push(errorDetail);
+              // 最新のエラー内容に更新
+              errorDocuments.set(file.name, errorDetail);
             } finally {
               attempt += 1;
             }
           }
           if (attempt >= maxAttempts) {
             // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
-            if (!errorDocuments.has(file.name)) {
-              errorDocuments.set(file.name, []);
-            }
-            errorDocuments
-              .get(file.name)!
-              .push(
-                `全てのチェックリストに対してレビューを完了することができませんでした`,
-              );
+            errorDocuments.set(
+              file.name,
+              `全てのチェックリストに対してレビューを完了することができませんでした`,
+            );
           }
         }
       }
       // errorDocumentsが空でない場合、レビューに失敗したドキュメントを返す
       if (errorDocuments.size > 0) {
-        const errorMessage = `以下ドキュメントのレビュー中にエラーが発生しました:
-        ${Array.from(errorDocuments.entries())
+        const errorMessage = `${Array.from(errorDocuments.entries())
           .map(
-            ([fileName, errors]) =>
-              `${fileName}:\n  - ${errors.join('\n  - ')}`,
+            ([fileName, error]) =>
+              `${fileName}のレビュー実行中にエラー: ${error}`,
           )
           .join('\n')}`;
         return {
@@ -426,11 +431,12 @@ const reviewExecutionStep = createStep({
         },
       };
     } catch (error) {
-      const errorMessage =
-        error instanceof Error ? error.message : '不明なエラー';
+      logger.error(error, 'チェックリストのレビュー実行処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      // エラーが発生した場合はエラ
       return {
         status: 'failed' as stepStatus,
-        errorMessage: `ドキュメントレビュー中にエラーが発生しました: ${errorMessage}`,
+        errorMessage: `${normalizedError.message}`,
       };
     }
   },
diff --git a/src/mastra/workflows/sourceReview/sourceReviewManager.ts b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
index 1a7f18896..7819b54ba 100644
--- a/src/mastra/workflows/sourceReview/sourceReviewManager.ts
+++ b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
@@ -1,29 +1,33 @@
-import { IpcMainInvokeEvent } from 'electron';
-import { getReviewRepository } from '../../../db/repository/reviewRepository';
-import { getSourceRepository } from '../../../db/repository/sourceRepository';
-import {
-  IpcChannels,
-  IpcEventPayloadMap,
-  IpcResponsePayloadMap,
-} from '../../../main/types/ipc';
+import { getReviewRepository } from '@/main/repository/reviewRepository';
+import { IpcChannels } from '@/types/ipc';
 import { generateReviewTitle } from './lib';
-import { ReviewHistory } from '../../../db/schema';
+import { ReviewHistory } from '@/db/schema';
 import { mastra } from '../..';
 import {
+  ChecklistExtractionResultStatus,
   DocumentType,
+  ReviewExecutionResultStatus,
   UploadFile,
-} from '../../../renderer/components/review/types';
-import { checkStatus } from '../libs';
+} from '@/types';
+import { checkWorkflowResult } from '../../lib/workflowUtils';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { getMainLogger } from '@/main/lib/logger';
+import { formatMessage } from '@/main/lib/messages';
+import { publishEvent } from '@/main/lib/eventPayloadHelper';
+
+const logger = getMainLogger();
 
 /**
  * ソースレビュー処理を管理するクラス
  */
 export default class SourceReviewManager {
-  // eslint-disable-next-line
   private static instance: SourceReviewManager | null = null;
 
   private reviewRepository = getReviewRepository();
 
+  // 実行中のワークフロー管理
+  private runningWorkflows = new Map<string, { cancel: () => void }>();
+
   /**
    * シングルトンインスタンスを取得
    */
@@ -45,7 +49,7 @@ export default class SourceReviewManager {
     files: UploadFile[],
     documentType: DocumentType = 'checklist',
     checklistRequirements?: string,
-  ): Promise<{ success: boolean; error?: string }> {
+  ): Promise<{ status: ChecklistExtractionResultStatus; error?: string }> {
     try {
       let reviewHistory: ReviewHistory | null;
       reviewHistory =
@@ -56,6 +60,8 @@ export default class SourceReviewManager {
           generateReviewTitle(),
           reviewHistoryId,
         );
+        // 新規作成時はレビュー履歴更新イベントを送信
+        publishEvent(IpcChannels.REVIEW_HISTORY_UPDATED, undefined);
       } else {
         // 既存のレビュー履歴がある場合は、システム作成チェックリストを削除
         await this.reviewRepository.deleteSystemCreatedChecklists(
@@ -67,13 +73,19 @@ export default class SourceReviewManager {
       const workflow = mastra.getWorkflow('checklistExtractionWorkflow');
 
       if (!workflow) {
-        return {
-          success: false,
-          error: 'チェックリスト抽出ワークフローが見つかりません',
-        };
+        logger.error('レビュー実行ワークフローが見つかりません');
+        throw internalError({
+          expose: false,
+        });
       }
 
-      const run = workflow.createRun();
+      const run = await workflow.createRunAsync();
+
+      // 実行中のワークフローを管理
+      this.runningWorkflows.set(reviewHistoryId, {
+        cancel: () => run.cancel(),
+      });
+
       const runResult = await run.start({
         inputData: {
           reviewHistoryId,
@@ -84,17 +96,28 @@ export default class SourceReviewManager {
       });
 
       // 結果を確認
-      const checkResult = checkStatus(runResult);
+      const checkResult = checkWorkflowResult(runResult);
+
+      // クリーンアップ
+      this.runningWorkflows.delete(reviewHistoryId);
+
       return {
-        success: checkResult.status === 'success',
+        status: checkResult.status,
         error: checkResult.errorMessage,
       };
     } catch (error) {
-      const errorMessage =
-        error instanceof Error ? error.message : '不明なエラー';
+      logger.error(error, 'チェックリスト抽出処理に失敗しました');
+
+      // エラー時もクリーンアップ
+      this.runningWorkflows.delete(reviewHistoryId);
+
+      const err = normalizeUnknownError(error);
+      const errorMessage = err.message;
       return {
-        success: false,
-        error: `チェックリスト抽出処理でエラーが発生しました: ${errorMessage}`,
+        status: 'failed',
+        error: formatMessage('REVIEW_CHECKLIST_EXTRACTION_ERROR', {
+          detail: errorMessage,
+        }),
       };
     }
   }
@@ -110,14 +133,14 @@ export default class SourceReviewManager {
     files: UploadFile[],
     additionalInstructions?: string,
     commentFormat?: string,
-  ): Promise<{ success: boolean; error?: string }> {
+  ): Promise<{ status: ReviewExecutionResultStatus; error?: string }> {
     try {
       // レビュー履歴の存在確認
       const reviewHistory =
         await this.reviewRepository.getReviewHistory(reviewHistoryId);
       if (!reviewHistory) {
         return {
-          success: false,
+          status: 'failed',
           error: `チェックリストが一度も作成されていません`,
         };
       }
@@ -126,10 +149,10 @@ export default class SourceReviewManager {
       const workflow = mastra.getWorkflow('reviewExecutionWorkflow');
 
       if (!workflow) {
-        return {
-          success: false,
-          error: 'レビュー実行ワークフローが見つかりません',
-        };
+        logger.error('レビュー実行ワークフローが見つかりません');
+        throw internalError({
+          expose: false,
+        });
       }
 
       // タイトルの変更
@@ -140,13 +163,16 @@ export default class SourceReviewManager {
         reviewHistory.id,
         reviewTitle,
       );
-      await this.reviewRepository.updateReviewHistoryAdditionalData(
-        reviewHistory.id,
-        additionalInstructions,
-        commentFormat,
-      );
+      // タイトル更新時はレビュー履歴更新イベントを送信
+      publishEvent(IpcChannels.REVIEW_HISTORY_UPDATED, undefined);
+
+      const run = await workflow.createRunAsync();
+
+      // 実行中のワークフローを管理
+      this.runningWorkflows.set(reviewHistoryId, {
+        cancel: () => run.cancel(),
+      });
 
-      const run = workflow.createRun();
       const result = await run.start({
         inputData: {
           reviewHistoryId,
@@ -155,18 +181,33 @@ export default class SourceReviewManager {
           commentFormat,
         },
       });
+      console.log(
+        'Review Execution Workflow Result:',
+        JSON.stringify(result, null, 2),
+      );
       // 結果を確認
-      const checkResult = checkStatus(result);
+      const checkResult = checkWorkflowResult(result);
+
+      // クリーンアップ
+      this.runningWorkflows.delete(reviewHistoryId);
+
       return {
-        success: checkResult.status === 'success',
+        status: checkResult.status,
         error: checkResult.errorMessage,
       };
     } catch (error) {
-      const errorMessage =
-        error instanceof Error ? error.message : '不明なエラー';
+      logger.error(error, 'レビュー実行処理に失敗しました');
+
+      // エラー時もクリーンアップ
+      this.runningWorkflows.delete(reviewHistoryId);
+
+      const err = normalizeUnknownError(error);
+      const errorMessage = err.message;
       return {
-        success: false,
-        error: `レビュー実行処理でエラーが発生しました: ${errorMessage}`,
+        status: 'failed',
+        error: formatMessage('REVIEW_EXECUTION_ERROR', {
+          detail: errorMessage,
+        }),
       };
     }
   }
@@ -180,10 +221,9 @@ export default class SourceReviewManager {
   public extractChecklistWithNotification(
     reviewHistoryId: string,
     files: UploadFile[],
-    event: IpcMainInvokeEvent,
     documentType: DocumentType = 'checklist',
     checklistRequirements?: string,
-  ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL] {
+  ): { success: boolean; error?: string } {
     try {
       this.extractChecklist(
         reviewHistoryId,
@@ -193,21 +233,21 @@ export default class SourceReviewManager {
       )
         .then((res) => {
           // 完了イベントを送信
-          event.sender.send(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
-            success: res.success,
+          publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
+            status: res.status,
             error: res.error,
-          } as IpcEventPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED]);
+          });
           return true;
         })
         .catch((error) => {
           const errorMessage =
             error instanceof Error ? error.message : '不明なエラー';
           const errorResult = {
-            success: false,
+            status: 'failed' as ChecklistExtractionResultStatus,
             error: errorMessage,
           };
           // エラーイベントを送信
-          event.sender.send(
+          publishEvent(
             IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
             errorResult,
           );
@@ -216,16 +256,21 @@ export default class SourceReviewManager {
         success: true,
       };
     } catch (error) {
-      const errorMessage =
-        error instanceof Error ? error.message : '不明なエラー';
+      logger.error(error, 'チェックリスト抽出処理に失敗しました');
+      const err = normalizeUnknownError(error);
+      const errorMessage = err.message;
       const errorResult = {
         success: false,
         error: errorMessage,
       };
+      const payloadResult = {
+        status: 'failed' as ChecklistExtractionResultStatus,
+        error: errorMessage,
+      };
       // エラーイベントを送信
-      event.sender.send(
+      publishEvent(
         IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
-        errorResult,
+        payloadResult,
       );
       return errorResult;
     }
@@ -240,10 +285,9 @@ export default class SourceReviewManager {
   public executeReviewWithNotification(
     reviewHistoryId: string,
     files: UploadFile[],
-    event: IpcMainInvokeEvent,
     additionalInstructions?: string,
     commentFormat?: string,
-  ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL] {
+  ): { success: boolean; error?: string } {
     try {
       this.executeReview(
         reviewHistoryId,
@@ -253,37 +297,106 @@ export default class SourceReviewManager {
       )
         .then((res) => {
           // 完了イベントを送信
-          event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, {
-            success: res.success,
+          publishEvent(IpcChannels.REVIEW_EXECUTE_FINISHED, {
+            status: res.status,
             error: res.error,
-          } as IpcEventPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_FINISHED]);
+          });
           return true;
         })
         .catch((error) => {
           const errorMessage =
             error instanceof Error ? error.message : '不明なエラー';
           const errorResult = {
-            success: false,
+            status: 'failed' as ReviewExecutionResultStatus,
             error: errorMessage,
-          } as IpcEventPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_FINISHED];
+          };
           // エラーイベントを送信
-          event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, errorResult);
+          publishEvent(IpcChannels.REVIEW_EXECUTE_FINISHED, errorResult);
         });
       return {
         success: true,
       };
     } catch (error) {
-      const errorMessage =
-        error instanceof Error ? error.message : '不明なエラー';
+      logger.error(error, 'レビュー実行処理に失敗しました');
+      const err = normalizeUnknownError(error);
+      const errorMessage = err.message;
       const errorResult = {
         success: false,
         error: errorMessage,
       };
+      const payloadResult = {
+        status: 'failed' as ReviewExecutionResultStatus,
+        error: errorMessage,
+      };
 
       // エラーイベントを送信
-      event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, errorResult);
+      publishEvent(IpcChannels.REVIEW_EXECUTE_FINISHED, payloadResult);
 
       return errorResult;
     }
   }
+
+  /**
+   * チェックリスト抽出処理をキャンセル
+   * @param reviewHistoryId レビュー履歴ID
+   */
+  public abortExtractChecklist(reviewHistoryId: string): {
+    success: boolean;
+    error?: string;
+  } {
+    try {
+      const runningWorkflow = this.runningWorkflows.get(reviewHistoryId);
+      if (runningWorkflow) {
+        runningWorkflow.cancel();
+        this.runningWorkflows.delete(reviewHistoryId);
+        logger.info(
+          `チェックリスト抽出処理をキャンセルしました: ${reviewHistoryId}`,
+        );
+        return { success: true };
+      } else {
+        logger.warn(
+          `キャンセル対象のチェックリスト抽出処理が見つかりません: ${reviewHistoryId}`,
+        );
+        return {
+          success: false,
+          error: 'キャンセル対象の処理が見つかりません',
+        };
+      }
+    } catch (error) {
+      logger.error(error, 'チェックリスト抽出のキャンセルに失敗しました');
+      const err = normalizeUnknownError(error);
+      return { success: false, error: err.message };
+    }
+  }
+
+  /**
+   * レビュー実行処理をキャンセル
+   * @param reviewHistoryId レビュー履歴ID
+   */
+  public abortExecuteReview(reviewHistoryId: string): {
+    success: boolean;
+    error?: string;
+  } {
+    try {
+      const runningWorkflow = this.runningWorkflows.get(reviewHistoryId);
+      if (runningWorkflow) {
+        runningWorkflow.cancel();
+        this.runningWorkflows.delete(reviewHistoryId);
+        logger.info(`レビュー実行処理をキャンセルしました: ${reviewHistoryId}`);
+        return { success: true };
+      } else {
+        logger.warn(
+          `キャンセル対象のレビュー実行処理が見つかりません: ${reviewHistoryId}`,
+        );
+        return {
+          success: false,
+          error: 'キャンセル対象の処理が見つかりません',
+        };
+      }
+    } catch (error) {
+      logger.error(error, 'レビュー実行のキャンセルに失敗しました');
+      const err = normalizeUnknownError(error);
+      return { success: false, error: err.message };
+    }
+  }
 }
diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
new file mode 100644
index 000000000..0b7d5ae55
--- /dev/null
+++ b/src/messages/ja/template.ts
@@ -0,0 +1,32 @@
+export const template = {
+  PLAIN_MESSAGE: `{message}`,
+  UNKNOWN_ERROR: `予期せぬエラーが発生しました`,
+  VALIDATION_ERROR: `入力内容に誤りがあります\n{detail}`,
+  DATA_ACCESS_ERROR: `データ操作中にエラーが発生しました\n{detail}`,
+  IPC_ERROR: `{hasIpcName, select,
+    true {
+      {hasDetail, select,
+        true {{ipcName}処理でエラーが発生しました\n{detail}}
+        other {{ipcName}処理で予期せぬエラーが発生しました}
+      }
+    }
+    other {予期せぬエラーが発生しました}
+  }`,
+  SERVER_INITIALIZE_ERROR: `アプリケーションの起動中にエラーが発生しました\n{detail}`,
+  MASTRA_MEMORY_ERROR: `チャットデータの取得に失敗しました`,
+  CHAT_GENERATE_ERROR: `テキスト生成に失敗しました\n{detail}`,
+  CHAT_EDIT_ERROR: `メッセージの編集に失敗しました\n{detail}`,
+  GITLAB_API_CONNECTION_ERROR: `GitLab APIへの接続に失敗しました`,
+  REDMINE_API_CONNECTION_ERROR: `Redmine APIへの接続に失敗しました`,
+  REDMINE_API_ERROR: `Redmine APIとの通信中にエラーが発生しました\n{detail}`,
+  FS_OPEN_DIALOG_ERROR: `ファイルダイアログの表示に失敗しました`,
+  FILE_TEXT_EXTRACTION_ERROR: `ファイルのテキスト抽出に失敗しました\n{path}`,
+  SOURCE_REGISTRATION_DIR_READING_ERROR: `ドキュメント登録用ディレクトリの読み込みに失敗しました`,
+  REVIEW_CHECKLIST_EXTRACTION_ERROR: `チェックリスト抽出処理に失敗しました\n{detail}`,
+  REVIEW_EXECUTION_ERROR: `レビュー実行処理に失敗しました\n{detail}`,
+  REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS: `チェックリストの抽出結果がAIモデルの最大出力トークン数を超え、不正な出力となった為修正を試みましたが失敗しました。抽出結果が最大出力トークン内に収まるようにチェックリストのファイル分割を検討してください。`,
+  REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT: `チェックリスト抽出に適さないドキュメントとして判定されたため処理を終了しました`,
+  REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM: `チェックリストが抽出されませんでした`,
+  REVIEW_EXECUTION_NO_TARGET_CHECKLIST: `対象のチェックリストが存在しないためレビューを実行できませんでした`,
+  AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
+} as const;
diff --git a/src/renderer/App.tsx b/src/renderer/App.tsx
index eac3c6384..31ab8d37c 100644
--- a/src/renderer/App.tsx
+++ b/src/renderer/App.tsx
@@ -1,21 +1,24 @@
-import React, { useState } from 'react';
+import { useState, useCallback, useRef } from 'react';
 import { MemoryRouter as Router, Routes, Route } from 'react-router-dom';
 import {
   ThemeProvider,
   createTheme,
   CssBaseline,
   Box,
-  AlertColor,
+  Alert,
+  Stack,
 } from '@mui/material';
 import './App.css';
 import Sidebar from './components/sidebar/Sidebar';
 import ChatArea from './components/chat/ChatArea';
 import ReviewArea from './components/review/ReviewArea';
-import SnackbarNotification from './components/common/SnackbarNotification';
-import { sourceService } from './services/sourceService';
-import { ROUTES } from '../main/types';
-import ChatRoomList from './components/chat/ChatRoomList';
+import { SourceApi } from './service/sourceApi';
+import { useAlertStore } from './stores/alertStore';
+import { ROUTES } from '../types';
+import ChatRoomList, { ChatRoomListRef } from './components/chat/ChatRoomList';
 import ReviewHistoryList from './components/review/ReviewHistoryList';
+import { useAgentStatusStore } from './stores/agentStatusStore';
+import AppErrorBoundary from './components/common/AppErrorBoundary';
 
 // テーマの設定
 const theme = createTheme({
@@ -62,114 +65,164 @@ function App() {
   const [selectedReviewHistoryId, setSelectedReviewHistoryId] = useState<
     string | null
   >(null);
-  const [snackbar, setSnackbar] = useState<{
-    open: boolean;
-    message: string;
-    severity: AlertColor;
-  }>({
-    open: false,
-    message: '',
-    severity: 'info',
-  });
-
-  // スナックバー表示ヘルパー
-  const showSnackbar = (message: string, severity: AlertColor) => {
-    setSnackbar({
-      open: true,
-      message,
-      severity,
-    });
-  };
+  const chatRoomListRef = useRef<ChatRoomListRef>(null);
+  const alerts = useAlertStore((state) => state.alerts);
+  const removeAlert = useAlertStore((state) => state.removeAlert);
+  const addAlert = useAlertStore((state) => state.addAlert);
+  const { status: agentStatus, closeMessage } = useAgentStatusStore();
 
   // ソース再読み込みハンドラ
-  const handleReloadSources = async () => {
-    try {
-      const result = await sourceService.reloadSources();
-      if (result.success) {
-        showSnackbar(
-          result.message || 'ソースの再読み込みが完了しました',
-          'success',
-        );
-      } else {
-        showSnackbar(
-          result.message || 'ソースの再読み込みに失敗しました',
-          'error',
-        );
-      }
-    } catch (error) {
-      showSnackbar(
-        `ソースの再読み込みに失敗しました: ${(error as Error).message}`,
-        'error',
-      );
-    }
-  };
+  const handleReloadSources = () => {
+    const sourceApi = SourceApi.getInstance();
 
-  // スナックバーを閉じる
-  const handleCloseSnackbar = () => {
-    setSnackbar((prev) => ({ ...prev, open: false }));
+    // 処理開始のキック
+    sourceApi.reloadSources({
+      showAlert: false,
+      throwError: false, // エラーはイベントpushで処理するため
+    });
+
+    // 完了イベントの購読を開始（ワンショット）
+    const unsubscribe = sourceApi.subscribeSourceReloadFinished(
+      (payload: { success: boolean; error?: string }) => {
+        if (payload.success) {
+          addAlert({
+            severity: 'success',
+            message: 'ドキュメントの再読み込みが完了しました',
+          });
+        } else {
+          addAlert({
+            severity: 'error',
+            message: payload.error || 'ドキュメントの再読み込みに失敗しました',
+          });
+        }
+        // 処理完了と同時に購読解除
+        unsubscribe();
+      },
+    );
   };
 
   return (
-    <ThemeProvider theme={theme}>
-      <CssBaseline />
-      <Router>
-        <Box
-          sx={{
-            display: 'flex',
-            height: '100vh',
-          }}
-        >
-          {/* サイドバー */}
-          <Sidebar
-            onReloadSources={handleReloadSources}
-            showSnackbar={showSnackbar}
+    <AppErrorBoundary>
+      <ThemeProvider theme={theme}>
+        <CssBaseline />
+        <Router>
+          <Box
+            sx={{
+              display: 'flex',
+              height: '100vh',
+            }}
           >
-            <Routes>
-              <Route
-                path={ROUTES.CHAT}
-                element={
-                  <ChatRoomList
-                    onRoomSelect={setSelectedRoomId}
-                    selectedRoomId={selectedRoomId}
-                  />
-                }
-              />
-              <Route
-                path={ROUTES.REVIEW}
-                element={
-                  <ReviewHistoryList
-                    onReviewHistorySelect={setSelectedReviewHistoryId}
-                    selectedReviewHistoryId={selectedReviewHistoryId}
-                  />
-                }
-              />
-            </Routes>
-          </Sidebar>
+            {/* サイドバー */}
+            <Sidebar onReloadSources={handleReloadSources}>
+              <Routes>
+                <Route
+                  path={ROUTES.CHAT}
+                  element={
+                    <ChatRoomList
+                      ref={chatRoomListRef}
+                      onRoomSelect={setSelectedRoomId}
+                      selectedRoomId={selectedRoomId}
+                    />
+                  }
+                />
+                <Route
+                  path={ROUTES.REVIEW}
+                  element={
+                    <ReviewHistoryList
+                      onReviewHistorySelect={setSelectedReviewHistoryId}
+                      selectedReviewHistoryId={selectedReviewHistoryId}
+                    />
+                  }
+                />
+              </Routes>
+            </Sidebar>
 
-          {/* メインコンテンツ */}
-          <Routes>
-            <Route
-              path={ROUTES.CHAT}
-              element={<ChatArea selectedRoomId={selectedRoomId} />}
-            />
-            <Route
-              path={ROUTES.REVIEW}
-              element={
-                <ReviewArea selectedReviewHistoryId={selectedReviewHistoryId} />
-              }
-            />
-          </Routes>
+            {/* メインコンテンツ領域：ここを relative にして、内部で absolute 配置する */}
+            <Box
+              component="main"
+              sx={{
+                position: 'relative', // ★ アラートを「この領域の中」で絶対配置できるようにする
+                flex: 1, // サイドバー以外の空間をすべて使う
+                minWidth: 0, // コンテンツのオーバーフロー対策
+                overflow: 'hidden', // スクロールバー制御（必要なら調整）
+                display: 'flex', // 中身のレイアウト（任意）
+              }}
+            >
+              {/* ルーティング（通常表示の中身） */}
+              <Routes>
+                <Route
+                  path={ROUTES.CHAT}
+                  element={
+                    <ChatArea
+                      selectedRoomId={selectedRoomId}
+                      onChatRoomUpdate={() => {
+                        // チャットルーム一覧を更新
+                        if (chatRoomListRef.current) {
+                          chatRoomListRef.current.refreshChatRooms();
+                        }
+                      }}
+                    />
+                  }
+                />
+                <Route
+                  path={ROUTES.REVIEW}
+                  element={
+                    <ReviewArea
+                      selectedReviewHistoryId={selectedReviewHistoryId}
+                    />
+                  }
+                />
+              </Routes>
 
-          {/* 通知 */}
-          <SnackbarNotification
-            open={snackbar.open}
-            message={snackbar.message}
-            severity={snackbar.severity}
-            onClose={handleCloseSnackbar}
-          />
-        </Box>
-      </Router>
-    </ThemeProvider>
+              {/* 中央オーバーレイのエラーメッセージ表示 */}
+              {(alerts.length > 0 || agentStatus.messages.length > 0) && (
+                <Box
+                  // ★ main(Box)の「中」で中央に重ねる
+                  sx={{
+                    position: 'absolute',
+                    top: 20,
+                    left: '50%',
+                    transform: 'translateX(-50%)',
+                    width: 'fit-content',
+                    maxWidth: '80%',
+                    zIndex: 1300,
+                    display: 'flex',
+                    flexDirection: 'column',
+                    gap: 1,
+                  }}
+                >
+                  <Stack spacing={1} sx={{ pointerEvents: 'auto' }}>
+                    {agentStatus.messages?.map((message) => (
+                      <Alert
+                        key={message.id}
+                        severity={message.type}
+                        sx={{ whiteSpace: 'pre-line', boxShadow: 3 }}
+                        onClose={() => closeMessage(message.id)}
+                      >
+                        {message.content}
+                      </Alert>
+                    ))}
+                    {alerts.map((error) => (
+                      <Alert
+                        key={error.id}
+                        severity={error.severity}
+                        onClose={() => removeAlert(error.id)}
+                        sx={{
+                          whiteSpace: 'pre-line',
+                          boxShadow: 3,
+                        }}
+                      >
+                        {error.message}
+                      </Alert>
+                    ))}
+                  </Stack>
+                </Box>
+              )}
+            </Box>
+          </Box>
+        </Router>
+      </ThemeProvider>
+    </AppErrorBoundary>
   );
 }
 
diff --git a/src/renderer/components/chat/ChatArea.tsx b/src/renderer/components/chat/ChatArea.tsx
index 23c5902c2..779699f7c 100644
--- a/src/renderer/components/chat/ChatArea.tsx
+++ b/src/renderer/components/chat/ChatArea.tsx
@@ -2,13 +2,14 @@ import React, { useState, useEffect } from 'react';
 import { useChat } from '@ai-sdk/react';
 import { Box, Divider, Typography } from '@mui/material';
 import { v4 as uuid } from 'uuid';
-import useSettingsStatus from '../../hooks/useSettingsStatus';
+import { ChatMessage } from '@/types';
+import { IpcRequestPayload, IpcChannels } from '@/types/ipc';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+import { getSafeErrorMessage, internalError } from '@/renderer/lib/error';
+import { useAgentStatusStore } from '../../stores/agentStatusStore';
 import MessageList from './MessageList';
 import MessageInput, { Attachment } from './MessageInput';
-import { chatService } from '../../services/chatService';
-import { ChatMessage } from '../../../main/types';
-import AlertManager, { AlertMessage } from '../common/AlertMessage';
-import { IpcRequestPayload, IpcChannels } from '../../../main/types/ipc';
+import { ChatApi } from '../../service/chatApi';
 
 // ai-sdk提供のcreateDataStreamResponseを使ってストリーミングレスポンスを取得する場合の関数
 // なぜか適切なヘッダが付与されないので、利用しない
@@ -60,10 +61,11 @@ const customFetch: typeof fetch = async (input, init) => {
   if (typeof input === 'string' && input === '/api/chat') {
     let unsubscribe: () => void;
     const encoder = new TextEncoder();
+    const chatApi = ChatApi.getInstance();
 
     const stream = new ReadableStream({
       start(controller) {
-        unsubscribe = chatService.streamResponse({
+        unsubscribe = chatApi.streamResponse({
           onMessage(raw) {
             controller.enqueue(encoder.encode(raw));
           },
@@ -79,12 +81,18 @@ const customFetch: typeof fetch = async (input, init) => {
           init!.body as string,
         ) as IpcRequestPayload<typeof IpcChannels.CHAT_SEND_MESSAGE>;
         init?.signal?.addEventListener('abort', () => {
-          console.log('Abort signal received, from threadId: ', roomId);
-          window.electron.chat.requestAbort(roomId);
+          chatApi.abortChatRequest(roomId, {
+            showAlert: false,
+            throwError: true,
+          });
           unsubscribe();
           controller.close();
         });
-        window.electron.chat.sendMessage({ roomId, messages });
+        chatApi.sendMessage(roomId!, messages, {
+          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
+          showAlert: false,
+          throwError: false,
+        });
       },
       cancel() {
         unsubscribe();
@@ -105,6 +113,7 @@ const customFetch: typeof fetch = async (input, init) => {
 
 interface ChatAreaProps {
   selectedRoomId: string | null;
+  onChatRoomUpdate?: () => void;
 }
 
 // プレースホルダーテキストを取得する関数
@@ -126,30 +135,34 @@ const fileToDataURL = (file: File): Promise<string> =>
     reader.readAsDataURL(file);
   });
 
-const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
+const ChatArea: React.FC<ChatAreaProps> = ({
+  selectedRoomId,
+  onChatRoomUpdate,
+}) => {
   const [loading, setLoading] = useState(false);
   const [initialMessages, setInitialMessages] = useState<ChatMessage[]>([]);
-  // useChatからのエラーを表示するための状態
-  const [additionalAlerts, setAdditionalAlerts] = useState<AlertMessage[]>([]);
   const [editMessageId, setEditMessageId] = useState<string>('');
   const [editMessageContent, setEditMessageContent] = useState<string>('');
-  const { status: settingsStatus } = useSettingsStatus();
+  const { status: agentStatus } = useAgentStatusStore();
   const [isEditHistory, setIsEditHistory] = useState(false);
   /* ---------- 添付画像 ---------- */
   const [attachments, setAttachments] = useState<Attachment[]>([]);
   // メッセージ入力状態
   const [input, setInput] = useState<string>('');
+  const addAlert = useAlertStore((state) => state.addAlert);
 
-  const isAgentInitializing = settingsStatus.state === 'saving';
+  const isAgentInitializing = agentStatus.state === 'saving';
 
   // メッセージ履歴を取得
   const fetchMessages = async (roomId: string) => {
+    const chatApi = ChatApi.getInstance();
     setLoading(true);
     try {
-      const chatMessages = await chatService.getChatMessages(roomId);
-      setInitialMessages(chatMessages);
-    } catch (error) {
-      console.error('チャットメッセージの取得に失敗しました:', error);
+      const chatMessages = await chatApi.getChatMessages(roomId, {
+        showAlert: true,
+        throwError: true,
+      });
+      setInitialMessages(chatMessages || []);
     } finally {
       setLoading(false);
     }
@@ -170,20 +183,44 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
     fetch: customFetch,
     initialMessages,
     experimental_throttle: 75,
+    onFinish: () => {
+      // AIレスポンス完了時にチャットルーム一覧を更新
+      if (onChatRoomUpdate) {
+        (async () => {
+          try {
+            onChatRoomUpdate();
+          } catch (err) {
+            addAlert({
+              message: getSafeErrorMessage(
+                err,
+                'チャットルーム一覧の更新に失敗しました',
+              ),
+              severity: 'error',
+            });
+          }
+        })();
+      }
+    },
     experimental_prepareRequestBody: (request) => {
+      const chatApi = ChatApi.getInstance();
       // Ensure messages array is not empty and get the last message
       const lastMessage =
         request.messages.length > 0
           ? request.messages[request.messages.length - 1]
           : null;
       if (!lastMessage) {
-        throw new Error('送信メッセージの取得に失敗しました');
+        throw internalError('送信メッセージの取得に失敗しました', {
+          expose: true,
+        });
       }
 
       // 初回メッセージ送信時にスレッドを作成
       // titleについてはここで、指定してもmemoryのオプションでgenerateTitleをtrueにしていた場合、「New Thread 2025-04-27T08:20:05.694Z」のようなタイトルが自動生成されてしまう
       if (selectedRoomId && request.messages.length === 1) {
-        chatService.createThread(selectedRoomId, '');
+        chatApi.createThread(selectedRoomId, '', {
+          showAlert: false,
+          throwError: true,
+        });
       }
 
       // Return the structured body for your API route
@@ -200,21 +237,12 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
   // useChatのエラーをアラートとして表示
   useEffect(() => {
     if (error) {
-      setAdditionalAlerts((prev) => [
-        ...prev,
-        {
-          id: uuid(),
-          type: 'error',
-          content: error.message,
-        },
-      ]);
+      addAlert({
+        message: getSafeErrorMessage(error),
+        severity: 'error',
+      });
     }
-  }, [error]);
-
-  // メッセージアラートが閉じられる際の挙動
-  const closeAdditionalAlerts = (id: string) => {
-    setAdditionalAlerts((prev) => prev.filter((alert) => alert.id !== id));
-  };
+  }, [error, addAlert]);
 
   const handleEditStart = (messageId: string) => {
     setEditMessageId(messageId);
@@ -291,6 +319,7 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
   };
 
   const handleEditSubmit = async () => {
+    const chatApi = ChatApi.getInstance();
     const messageIndex = messages.findIndex((m) => m.id === editMessageId);
     if (messageIndex === -1) return;
 
@@ -307,14 +336,30 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
     };
     setMessages(updatedMessages);
     setIsEditHistory(true);
-    await window.electron.chat.deleteMessagesBeforeSpecificId({
-      threadId: selectedRoomId!,
-      messageId: editMessageId,
-    });
-    setEditMessageId('');
-    setEditMessageContent('');
-    setIsEditHistory(false);
-    reload();
+    try {
+      await chatApi.deleteMessagesBeforeSpecificId(
+        selectedRoomId!,
+        editMessageId,
+        {
+          showAlert: false,
+          throwError: true,
+        },
+      );
+      setEditMessageId('');
+      setEditMessageContent('');
+      setIsEditHistory(false);
+      reload();
+    } catch (err) {
+      addAlert({
+        message: getSafeErrorMessage(err, 'メッセージ編集に失敗しました'),
+        severity: 'error',
+      });
+    } finally {
+      setEditMessageId('');
+      setEditMessageContent('');
+      setIsEditHistory(false);
+      reload();
+    }
   };
 
   const handleEditCancel = () => {
@@ -324,7 +369,7 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
   return (
     <Box
       sx={{
-        width: 'calc(100% - 280px)',
+        width: '100%',
         height: '100vh',
         display: 'flex',
         flexDirection: 'column',
@@ -335,10 +380,6 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
         overflow: 'hidden',
       }}
     >
-      <AlertManager
-        additionalAlerts={additionalAlerts}
-        closeAdditionalAlerts={closeAdditionalAlerts}
-      />
       {selectedRoomId ? (
         <>
           {/* メッセージリスト */}
diff --git a/src/renderer/components/chat/ChatRoomList.tsx b/src/renderer/components/chat/ChatRoomList.tsx
index 8bfc66195..d0c4c8d93 100644
--- a/src/renderer/components/chat/ChatRoomList.tsx
+++ b/src/renderer/components/chat/ChatRoomList.tsx
@@ -1,4 +1,10 @@
-import React, { useState, useEffect, useCallback } from 'react';
+import React, {
+  useState,
+  useEffect,
+  useCallback,
+  forwardRef,
+  useImperativeHandle,
+} from 'react';
 import {
   List,
   ListItem,
@@ -17,67 +23,102 @@ import {
 import { MoreVert as MoreIcon } from '@mui/icons-material';
 import AddCircleOutlineOutlinedIcon from '@mui/icons-material/AddCircleOutlineOutlined';
 import { v4 as uuidv4 } from 'uuid';
-import type { ChatRoom } from '../../../main/types';
-import { chatService } from '../../services/chatService';
+import type { ChatRoom } from '@/types';
+import { ChatApi } from '../../service/chatApi';
 
 interface ChatRoomListProps {
   selectedRoomId?: string | null;
   onRoomSelect: (roomId: string) => void;
 }
 
-function ChatRoomList({
-  selectedRoomId = null,
-  onRoomSelect,
-}: ChatRoomListProps) {
-  const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
-  const [loading, setLoading] = useState(true);
-  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
-  // メニュー選択中のチャットルームID
-  const [activeRoomId, setActiveRoomId] = useState<string | null>(null);
-
-  // チャットルーム一覧を取得
-  const fetchChatRooms = useCallback(async () => {
-    try {
-      const rooms = await chatService.getChatRooms();
+export interface ChatRoomListRef {
+  refreshChatRooms: () => void;
+}
+
+const ChatRoomList = forwardRef<ChatRoomListRef, ChatRoomListProps>(
+  function ChatRoomList({ selectedRoomId = null, onRoomSelect }, ref) {
+    const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
+    const [loading, setLoading] = useState(true);
+    const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
+    // メニュー選択中のチャットルームID
+    const [activeRoomId, setActiveRoomId] = useState<string | null>(null);
+
+    // チャットルーム一覧を取得
+    const fetchChatRooms = useCallback(async () => {
+      const chatApi = ChatApi.getInstance();
+      const rooms = await chatApi.getChatRooms({
+        throwError: true,
+        showAlert: false,
+      });
       // updatedAtで降順ソート
-      const sortedRooms = [...rooms].sort(
-        (a, b) =>
-          new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime(),
-      );
+      const sortedRooms = rooms
+        ? [...rooms!].sort(
+            (a, b) =>
+              new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime(),
+          )
+        : [];
       setChatRooms(sortedRooms);
-      setLoading(false);
-    } catch (error) {
-      console.error(error);
+    }, []);
+
+    // 初期データ読み込み
+    useEffect(() => {
       setLoading(true);
-    }
-  }, []);
-
-  // 初期データ読み込み
-  useEffect(() => {
-    fetchChatRooms();
-  }, [fetchChatRooms]);
-
-  // メニュー操作
-  const handleMenuOpen = (
-    event: React.MouseEvent<HTMLElement>,
-    roomId: string,
-  ) => {
-    event.stopPropagation();
-    setMenuAnchorEl(event.currentTarget);
-    setActiveRoomId(roomId);
-  };
-
-  const handleMenuClose = () => {
-    setMenuAnchorEl(null);
-    setActiveRoomId(null);
-  };
-
-  // チャットルーム削除
-  const handleDeleteRoom = async () => {
-    if (!activeRoomId) return;
-
-    try {
-      await chatService.deleteChatRoom(activeRoomId);
+      let intervalId: ReturnType<typeof setInterval> | null = null;
+
+      const loadChatRooms = async () => {
+        try {
+          await fetchChatRooms();
+          setLoading(false);
+
+          // 読み込み成功したらポーリングを停止
+          if (intervalId) {
+            clearInterval(intervalId);
+            intervalId = null;
+          }
+        } catch (error) {
+          console.error('チャットルーム読み込みに失敗しました:', error);
+          // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
+          if (!intervalId) {
+            intervalId = setInterval(loadChatRooms, 5000);
+          }
+        }
+      };
+
+      // 初回読み込み
+      loadChatRooms();
+
+      // クリーンアップでポーリング停止
+      return () => {
+        if (intervalId) {
+          clearInterval(intervalId);
+        }
+      };
+    }, [fetchChatRooms]);
+
+    // メニュー操作
+    const handleMenuOpen = (
+      event: React.MouseEvent<HTMLElement>,
+      roomId: string,
+    ) => {
+      event.stopPropagation();
+      setMenuAnchorEl(event.currentTarget);
+      setActiveRoomId(roomId);
+    };
+
+    const handleMenuClose = () => {
+      setMenuAnchorEl(null);
+      setActiveRoomId(null);
+    };
+
+    // チャットルーム削除
+    const handleDeleteRoom = async () => {
+      if (!activeRoomId) return;
+
+      const chatApi = ChatApi.getInstance();
+      await chatApi.deleteChatRoom(activeRoomId, {
+        showAlert: true,
+        throwError: false,
+      });
       // 削除したルームが選択中だった場合は選択を解除
       if (selectedRoomId === activeRoomId) {
         onRoomSelect('');
@@ -85,140 +126,133 @@ function ChatRoomList({
 
       // 一覧を再取得して最新状態を反映
       fetchChatRooms();
-    } catch (error) {
-      console.error(error);
-    } finally {
       handleMenuClose();
-    }
-  };
-
-  // チャットルーム一覧の更新をトリガーする関数
-  const refreshChatRooms = useCallback(() => {
-    fetchChatRooms();
-  }, [fetchChatRooms]);
-
-  // チャットルーム一覧の定期更新
-  useEffect(() => {
-    const interval = setInterval(refreshChatRooms, 5000);
-    return () => clearInterval(interval);
-  }, [refreshChatRooms]);
-
-  // 新しいチャットを開始
-  const handleCreateRoom = () => {
-    // 新しいUUIDを生成してルームIDとして使用
-    const newRoomId = uuidv4();
-    // 選択状態を更新
-    onRoomSelect(newRoomId);
-    // モーダルは表示せず、すぐにチャット画面に遷移
-  };
-
-  const renderContent = () => {
-    // ローディング中は「チャット履歴取得中」とスピナーを表示
-    if (loading) {
-      return (
-        <Box sx={{ p: 3, textAlign: 'center' }}>
-          <CircularProgress size={24} sx={{ mb: 1 }} />
-          <Typography variant="body2" color="text.secondary">
-            チャット履歴取得中
-          </Typography>
-        </Box>
-      );
-    }
+    };
+
+    // ref経由で外部から更新関数を呼び出せるように公開
+    useImperativeHandle(ref, () => ({
+      refreshChatRooms: fetchChatRooms,
+    }));
+
+    // 新しいチャットを開始
+    const handleCreateRoom = () => {
+      // 新しいUUIDを生成してルームIDとして使用
+      const newRoomId = uuidv4();
+      // 選択状態を更新
+      onRoomSelect(newRoomId);
+      // モーダルは表示せず、すぐにチャット画面に遷移
+    };
+
+    const renderContent = () => {
+      // ローディング中は「チャット履歴取得中」とスピナーを表示
+      if (loading) {
+        return (
+          <Box sx={{ p: 3, textAlign: 'center' }}>
+            <CircularProgress size={24} sx={{ mb: 1 }} />
+            <Typography variant="body2" color="text.secondary">
+              チャット履歴取得中
+            </Typography>
+          </Box>
+        );
+      }
+
+      // チャットルームがない場合は「チャットルームがありません」と表示
+      if (chatRooms.length === 0) {
+        return (
+          <Box sx={{ p: 3, textAlign: 'center' }}>
+            <Typography variant="body2" color="text.secondary">
+              チャット履歴がありません
+            </Typography>
+          </Box>
+        );
+      }
 
-    // チャットルームがない場合は「チャットルームがありません」と表示
-    if (chatRooms.length === 0) {
       return (
-        <Box sx={{ p: 3, textAlign: 'center' }}>
-          <Typography variant="body2" color="text.secondary">
-            チャット履歴がありません
-          </Typography>
-        </Box>
+        <>
+          <List disablePadding>
+            {chatRooms.map((room) => (
+              <ListItem
+                key={room.id}
+                disablePadding
+                secondaryAction={
+                  <IconButton
+                    edge="end"
+                    aria-label="more"
+                    onClick={(e) => handleMenuOpen(e, room.id)}
+                  >
+                    <MoreIcon />
+                  </IconButton>
+                }
+              >
+                <ListItemButton
+                  selected={selectedRoomId === room.id}
+                  onClick={() => onRoomSelect(room.id)}
+                  sx={{ pr: 6 }}
+                >
+                  <Tooltip title={room.title} placement="right">
+                    <ListItemText
+                      primary={room.title}
+                      slotProps={{
+                        primary: {
+                          noWrap: true,
+                          sx: {
+                            overflow: 'hidden',
+                            textOverflow: 'ellipsis',
+                          },
+                        },
+                      }}
+                    />
+                  </Tooltip>
+                </ListItemButton>
+              </ListItem>
+            ))}
+          </List>
+          {/* チャットルームメニュー */}
+          <Menu
+            anchorEl={menuAnchorEl}
+            open={Boolean(menuAnchorEl)}
+            onClose={handleMenuClose}
+          >
+            <MenuItem onClick={handleDeleteRoom}>削除</MenuItem>
+          </Menu>
+        </>
       );
-    }
+    };
 
     return (
-      <>
-        <List disablePadding>
-          {chatRooms.map((room) => (
-            <ListItem
-              key={room.id}
-              disablePadding
-              secondaryAction={
-                <IconButton
-                  edge="end"
-                  aria-label="more"
-                  onClick={(e) => handleMenuOpen(e, room.id)}
-                >
-                  <MoreIcon />
-                </IconButton>
-              }
-            >
-              <ListItemButton
-                selected={selectedRoomId === room.id}
-                onClick={() => onRoomSelect(room.id)}
-                sx={{ pr: 6 }}
-              >
-                <Tooltip title={room.title} placement="right">
-                  <ListItemText
-                    primary={room.title}
-                    primaryTypographyProps={{
-                      noWrap: true,
-                      sx: {
-                        overflow: 'hidden',
-                        textOverflow: 'ellipsis',
-                      },
-                    }}
-                  />
-                </Tooltip>
-              </ListItemButton>
-            </ListItem>
-          ))}
-        </List>
-        {/* チャットルームメニュー */}
-        <Menu
-          anchorEl={menuAnchorEl}
-          open={Boolean(menuAnchorEl)}
-          onClose={handleMenuClose}
-        >
-          <MenuItem onClick={handleDeleteRoom}>削除</MenuItem>
-        </Menu>
-      </>
-    );
-  };
-
-  return (
-    <Box
-      sx={{
-        display: 'flex',
-        flexDirection: 'column',
-        height: '100%',
-      }}
-    >
-      <Box
-        sx={{ py: 1, px: 2, pt: 0, display: 'flex', justifyContent: 'start' }}
-      >
-        <Button
-          startIcon={<AddCircleOutlineOutlinedIcon />}
-          onClick={handleCreateRoom}
-          sx={{ pl: 0.3, fontSize: '1rem' }}
-          disabled={loading}
-          // fullWidth
-        >
-          新規チャット
-        </Button>
-      </Box>
-      <Divider />
       <Box
         sx={{
-          flexGrow: 1,
-          overflowY: 'auto',
+          display: 'flex',
+          flexDirection: 'column',
+          height: '100%',
         }}
-        className="hidden-scrollbar"
       >
-        {renderContent()}
+        <Box
+          sx={{ py: 1, px: 2, pt: 0, display: 'flex', justifyContent: 'start' }}
+        >
+          <Button
+            startIcon={<AddCircleOutlineOutlinedIcon />}
+            onClick={handleCreateRoom}
+            sx={{ pl: 0.3, fontSize: '1rem' }}
+            disabled={loading}
+            // fullWidth
+          >
+            新規チャット
+          </Button>
+        </Box>
+        <Divider />
+        <Box
+          sx={{
+            flexGrow: 1,
+            overflowY: 'auto',
+          }}
+          className="hidden-scrollbar"
+        >
+          {renderContent()}
+        </Box>
       </Box>
-    </Box>
-  );
-}
+    );
+  },
+);
 
 export default React.memo(ChatRoomList);
diff --git a/src/renderer/components/chat/MessageItem.tsx b/src/renderer/components/chat/MessageItem.tsx
index 17175d355..4a8877c44 100644
--- a/src/renderer/components/chat/MessageItem.tsx
+++ b/src/renderer/components/chat/MessageItem.tsx
@@ -32,7 +32,7 @@ import {
 import { ContentCopy as CopyIcon } from '@mui/icons-material';
 // @ts-ignore
 import type { Components } from 'react-markdown';
-import type { ChatMessage } from '../../../main/types';
+import type { ChatMessage } from '@/types';
 import { TOOL_NAME_DISPLAY_MAP } from '../../../mastra/tools/toolDisplayConfig';
 
 // ─────────────── Mermaid 図レンダラー ───────────────
diff --git a/src/renderer/components/chat/MessageList.tsx b/src/renderer/components/chat/MessageList.tsx
index 351009614..e8325677a 100644
--- a/src/renderer/components/chat/MessageList.tsx
+++ b/src/renderer/components/chat/MessageList.tsx
@@ -1,7 +1,7 @@
 import React, { useEffect, useRef } from 'react';
 import { Box, CircularProgress } from '@mui/material';
+import { ChatMessage } from '@/types';
 import MessageItem from './MessageItem';
-import { ChatMessage } from '../../../main/types';
 
 interface MessageListProps {
   messages: ChatMessage[];
diff --git a/src/renderer/components/common/AlertMessage.tsx b/src/renderer/components/common/AlertMessage.tsx
deleted file mode 100644
index acd457a1c..000000000
--- a/src/renderer/components/common/AlertMessage.tsx
+++ /dev/null
@@ -1,65 +0,0 @@
-import React, { memo } from 'react';
-import { Box, Alert } from '@mui/material';
-import { useSettingsZustandStore } from '../../stores/settingsZustandStore';
-
-export interface AlertMessage {
-  id: string;
-  type: 'success' | 'info' | 'warning' | 'error' | undefined;
-  content: string;
-}
-
-interface AlertManagerProps {
-  additionalAlerts?: AlertMessage[];
-  closeAdditionalAlerts?: (id: string) => void;
-  position?: 'top' | 'bottom';
-}
-
-const AlertManager: React.FC<AlertManagerProps> = memo(
-  ({
-    additionalAlerts,
-    closeAdditionalAlerts,
-    position = 'top',
-  }: AlertManagerProps) => {
-    const { status, closeMessage } = useSettingsZustandStore();
-
-    return (
-      <Box
-        sx={{
-          position: 'absolute',
-          [position]: 20,
-          left: '50%',
-          transform: 'translateX(-50%)',
-          width: 'fit-content',
-          maxWidth: '80%',
-          zIndex: 1000,
-          display: 'flex',
-          flexDirection: 'column',
-          gap: 1,
-        }}
-      >
-        {status.messages?.map((message) => (
-          <Alert
-            key={message.id}
-            severity={message.type}
-            sx={{ whiteSpace: 'pre-line' }}
-            onClose={() => closeMessage(message.id)}
-          >
-            {message.content}
-          </Alert>
-        ))}
-        {additionalAlerts?.map((alert) => (
-          <Alert
-            key={alert.id}
-            severity={alert.type}
-            sx={{ whiteSpace: 'pre-line' }}
-            onClose={() => closeAdditionalAlerts?.(alert.id)}
-          >
-            {alert.content}
-          </Alert>
-        ))}
-      </Box>
-    );
-  },
-);
-
-export default AlertManager;
diff --git a/src/renderer/components/common/AppErrorBoundary.tsx b/src/renderer/components/common/AppErrorBoundary.tsx
new file mode 100644
index 000000000..1ec35d955
--- /dev/null
+++ b/src/renderer/components/common/AppErrorBoundary.tsx
@@ -0,0 +1,50 @@
+import React from 'react';
+import { ErrorBoundary } from 'react-error-boundary';
+import { getSafeErrorMessage } from '@/renderer/lib/error';
+import { alertStore } from '../../stores/alertStore';
+
+interface ErrorFallbackProps {
+  error: Error;
+  resetErrorBoundary: () => void;
+}
+
+function ErrorFallback({ error, resetErrorBoundary }: ErrorFallbackProps) {
+  React.useEffect(() => {
+    // エラー発生時にアラートを表示
+    alertStore.getState().addAlert({
+      severity: 'error',
+      message: getSafeErrorMessage(error),
+    });
+
+    // エラー詳細をコンソールに出力（開発時のデバッグ用）
+    console.error('Application Error:', error);
+
+    // エラー状態をリセットしてアプリを初期化
+    const timer = setTimeout(() => {
+      resetErrorBoundary();
+    }, 100);
+
+    return () => clearTimeout(timer);
+  }, [error, resetErrorBoundary]);
+
+  // エラー発生時は一瞬だけ表示してすぐにリセット
+  return null;
+}
+
+interface AppErrorBoundaryProps {
+  children: React.ReactNode;
+}
+
+export default function AppErrorBoundary({ children }: AppErrorBoundaryProps) {
+  return (
+    <ErrorBoundary
+      FallbackComponent={ErrorFallback}
+      onError={(error, errorInfo) => {
+        // エラー情報をログ出力
+        console.error('ErrorBoundary caught an error:', error, errorInfo);
+      }}
+    >
+      {children}
+    </ErrorBoundary>
+  );
+}
diff --git a/src/renderer/components/common/SettingsModal.tsx b/src/renderer/components/common/SettingsModal.tsx
index b9d306a79..c5b8d8a92 100644
--- a/src/renderer/components/common/SettingsModal.tsx
+++ b/src/renderer/components/common/SettingsModal.tsx
@@ -9,7 +9,7 @@ import {
   Alert,
 } from '@mui/material';
 import Modal from './Modal';
-import useSettingsStore from '../../hooks/useSettingsStore';
+import useSettingsStore from '../../hooks/useSettings';
 import { StoreSchema as Settings } from '../../../main/store';
 
 interface SettingsModalProps {
@@ -29,7 +29,7 @@ const SettingsModal: React.FC<SettingsModalProps> = ({
     settings,
     validationErrors,
     loading,
-    error,
+    saveError,
     updateField,
     saveSettings,
     isValid,
@@ -79,9 +79,9 @@ const SettingsModal: React.FC<SettingsModalProps> = ({
 
   return (
     <Modal open={open} onClose={onClose} title="設定" actions={actions}>
-      {error && (
+      {saveError && (
         <Typography color="error" sx={{ p: 2 }}>
-          {error}
+          {saveError}
         </Typography>
       )}
       <Box sx={{ flexGrow: 1 }}>
@@ -220,15 +220,15 @@ const SettingsModal: React.FC<SettingsModalProps> = ({
               label="MCPサーバー設定（JSON）"
               multiline
               rows={4}
-              value={settings.mcp.serverConfigText}
+              value={settings.mcp.serverConfig}
               disabled={loading || saving}
               onChange={(e) => {
-                handleChange('mcp', 'serverConfigText', e.target.value);
+                handleChange('mcp', 'serverConfig', e.target.value);
               }}
               margin="normal"
               variant="outlined"
-              error={!!validationErrors.mcp?.serverConfigText}
-              helperText={validationErrors.mcp?.serverConfigText?.message}
+              error={!!validationErrors.mcp?.serverConfig}
+              helperText={validationErrors.mcp?.serverConfig?.message}
             />
             <Typography variant="caption" color="textSecondary" sx={{ mt: 1 }}>
               設定例:
diff --git a/src/renderer/components/common/SourceListModal.tsx b/src/renderer/components/common/SourceListModal.tsx
index 8230facbd..ff4676736 100644
--- a/src/renderer/components/common/SourceListModal.tsx
+++ b/src/renderer/components/common/SourceListModal.tsx
@@ -1,6 +1,5 @@
-import React, { useEffect, useState } from 'react';
+import React, { useEffect, useState, useCallback } from 'react';
 import {
-  AlertColor,
   Alert,
   Modal,
   Box,
@@ -24,8 +23,11 @@ import {
   HourglassEmpty as ProcessingIcon,
   Help as UnknownIcon,
 } from '@mui/icons-material';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+import { getSafeErrorMessage } from '../../lib/error';
 
 import { Source } from '../../../db/schema';
+import { SourceApi } from '../../service/sourceApi';
 
 interface SourceListModalProps {
   open: boolean;
@@ -36,7 +38,6 @@ interface SourceListModalProps {
     processing: boolean;
     enabledCount: number;
   }) => void;
-  showSnackbar: (message: string, severity: AlertColor) => void;
 }
 
 function SourceListModal({
@@ -45,7 +46,6 @@ function SourceListModal({
   onClose,
   onReloadSources,
   onStatusUpdate,
-  showSnackbar,
 }: SourceListModalProps): React.ReactElement {
   const [sources, setSources] = useState<Source[]>([]);
   const [checkedSources, setCheckedSources] = useState<{
@@ -54,6 +54,9 @@ function SourceListModal({
   const [updatingSources, setUpdatingSources] = useState<Set<number>>(
     new Set(),
   );
+  const [reloadPolling, setReloadPolling] = useState(false);
+
+  const addAlert = useAlertStore((state) => state.addAlert);
 
   // チェック状態の更新
   useEffect(() => {
@@ -85,24 +88,17 @@ function SourceListModal({
     setUpdatingSources((prev) => new Set(prev).add(sourceId));
 
     try {
-      const { success, error } =
-        await window.electron.source.updateSourceEnabled(
-          sourceId,
-          newCheckedState[sourceId],
-        );
-      if (!success) {
-        showSnackbar(
-          `${sources.find((s) => s.id === sourceId)?.path}の有効化/無効化に失敗しました: ${error}`,
-          'error',
-        );
-        // チェック状態を元に戻す
-        setCheckedSources((prev) => ({
-          ...prev,
-          [sourceId]: !newCheckedState[sourceId],
-        }));
-      }
+      const sourceApi = SourceApi.getInstance();
+      await sourceApi.updateSourceEnabled(sourceId, newCheckedState[sourceId], {
+        showAlert: true,
+        throwError: true,
+      });
     } catch (err) {
-      console.error('ドキュメントの有効化/無効化に失敗しました:', err);
+      // チェック状態を元に戻す
+      setCheckedSources((prev) => ({
+        ...prev,
+        [sourceId]: !newCheckedState[sourceId],
+      }));
     } finally {
       // 更新中状態から削除
       setUpdatingSources((prev) => {
@@ -152,29 +148,19 @@ function SourceListModal({
     // 各ソースの状態を更新
     targetSources.forEach(async (source) => {
       try {
-        const { success, error } =
-          await window.electron.source.updateSourceEnabled(source.id, newValue);
-        if (!success) {
-          showSnackbar(
-            `${source.path}の有効化/無効化に失敗しました: ${error}`,
-            'error',
-          );
-          // チェック状態を元に戻す
-          setCheckedSources((prev) => ({
-            ...prev,
-            [source.id]: !newValue,
-          }));
-        }
-
-        // 完了したソースを更新中状態から削除
-        setUpdatingSources((prev) => {
-          const next = new Set(prev);
-          next.delete(source.id);
-          return next;
+        const sourceApi = SourceApi.getInstance();
+        await sourceApi.updateSourceEnabled(source.id, newValue, {
+          showAlert: true,
+          throwError: true,
         });
-      } catch (err) {
-        console.error('ドキュメントの有効化/無効化に失敗しました:', err);
-        // エラー時もソースを更新中状態から削除
+      } catch (error) {
+        // チェック状態を元に戻す
+        setCheckedSources((prev) => ({
+          ...prev,
+          [source.id]: !newValue,
+        }));
+      } finally {
+        // 完了したソースを更新中状態から削除
         setUpdatingSources((prev) => {
           const next = new Set(prev);
           next.delete(source.id);
@@ -184,39 +170,122 @@ function SourceListModal({
     });
   };
 
-  // ソースデータの定期更新（processingステータスがある場合のみ）
+  // ソースデータの取得関数
+  const fetchSources = useCallback(async () => {
+    const sourceApi = SourceApi.getInstance();
+    const responseSources = await sourceApi.getSources({
+      showAlert: false,
+      throwError: true,
+    });
+    const sourceList = responseSources || [];
+    setSources(sourceList);
+    const newProcessing = sourceList.some(
+      (s: Source) => s.status === 'idle' || s.status === 'processing',
+    );
+    // 状態更新
+    const enabledCount = sourceList.filter(
+      (s: Source) => s.isEnabled === 1 && s.status === 'completed',
+    ).length;
+    onStatusUpdate({ processing: newProcessing, enabledCount });
+  }, [onStatusUpdate]);
+
+  // 初期データ読み込み（エラーが発生しなくなるまでポーリング）
   useEffect(() => {
-    const fetchSources = async () => {
+    if (!open) return; // モーダルが開いていない場合は処理しない
+
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    const loadSources = async () => {
       try {
-        const response = await window.electron.source.getSources();
-        const responseSources: Source[] = response.sources || [];
-        setSources(responseSources);
-        const newProcessing = responseSources.some(
-          (s: Source) => s.status === 'idle' || s.status === 'processing',
-        );
-        // 状態更新
-        const enabledCount = responseSources.filter(
-          (s: Source) => s.isEnabled === 1 && s.status === 'completed',
-        ).length;
-        onStatusUpdate({ processing: newProcessing, enabledCount });
+        await fetchSources();
+
+        // 読み込み成功したらポーリングを停止
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+      } catch (error) {
+        console.error('ソース一覧の読み込みに失敗しました:', error);
+        // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
+        if (!intervalId) {
+          intervalId = setInterval(loadSources, 5000);
+        }
+      }
+    };
+
+    // 初回読み込み
+    loadSources();
+
+    // クリーンアップでポーリング停止
+    // eslint-disable-next-line consistent-return
+    return () => {
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
+    };
+  }, [open, fetchSources]);
+
+  // ドキュメント更新時のポーリング処理
+  useEffect(() => {
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    if (!reloadPolling) {
+      if (intervalId) {
+        clearInterval(intervalId);
+        intervalId = null;
+      }
+      return;
+    }
+
+    const pollSources = async () => {
+      try {
+        await fetchSources();
       } catch (error) {
-        console.error('ドキュメントデータの取得に失敗しました:', error);
+        console.error('ソース一覧のポーリング中にエラーが発生しました:', error);
       }
     };
-    // 初回データ取得
-    fetchSources();
 
-    const intervalId = setInterval(fetchSources, 5000);
+    // ポーリング開始
+    intervalId = setInterval(pollSources, 5000);
 
+    // クリーンアップでポーリング停止
+    // eslint-disable-next-line consistent-return
     return () => {
       if (intervalId) {
         clearInterval(intervalId);
       }
     };
-  }, [open, checkedSources, onStatusUpdate]);
+  }, [reloadPolling, sources, fetchSources]);
 
   const handleReloadClick = () => {
+    setReloadPolling(true);
     onReloadSources();
+
+    // 完了イベントの購読を開始（ワンショット）
+    const sourceApi = SourceApi.getInstance();
+    const unsubscribe = sourceApi.subscribeSourceReloadFinished(
+      (payload: { success: boolean; error?: string }) => {
+        // ドキュメント更新完了時にポーリングを停止
+        setReloadPolling(false);
+
+        if (payload.success) {
+          // 成功時：最新データを取得（アラート表示はApp.tsxで行う）
+          fetchSources().catch((error) => {
+            console.error('ソース一覧の更新に失敗しました:', error);
+            addAlert({
+              message: getSafeErrorMessage(
+                error,
+                'ドキュメント一覧の更新に失敗しました',
+              ),
+              severity: 'error',
+            });
+          });
+        }
+        // 失敗時のエラーアラート表示はApp.tsxで行う
+        // 処理完了と同時に購読解除
+        unsubscribe();
+      },
+    );
   };
 
   const getStatusIcon = (status: Source['status'], error?: Source['error']) => {
diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
index d9a2082b4..b9f0d5eb8 100644
--- a/src/renderer/components/review/ReviewArea.tsx
+++ b/src/renderer/components/review/ReviewArea.tsx
@@ -9,16 +9,23 @@ import {
 } from '@mui/material';
 import CheckBoxIcon from '@mui/icons-material/CheckBox';
 import RateReviewIcon from '@mui/icons-material/RateReview';
-import { v4 as uuid } from 'uuid';
-import { ReviewAreaProps, ModalMode, DocumentType, UploadFile } from './types';
-import ReviewChecklistSection from './ReviewChecklistSection';
-import ReviewSourceModal from './ReviewSourceModal';
+import StopIcon from '@mui/icons-material/Stop';
 import {
   ReviewChecklistEdit,
   ReviewChecklistResultDisplay,
-} from '../../../main/types';
-import AlertManager, { AlertMessage } from '../common/AlertMessage';
-import { reviewService } from '../../services/reviewService';
+  ModalMode,
+  DocumentType,
+  UploadFile,
+} from '@/types';
+import { ReviewAreaProps } from './types';
+import ReviewChecklistSection from './ReviewChecklistSection';
+import ReviewSourceModal from './ReviewSourceModal';
+import { ReviewApi } from '../../service/reviewApi';
+import { useAlertStore } from '../../stores/alertStore';
+import { getSafeErrorMessage } from '../../lib/error';
+
+const defaultCommentFormat =
+  '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）';
 
 const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   // 状態管理
@@ -30,51 +37,96 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   const [isExtracting, setIsExtracting] = useState(false);
   const [isReviewing, setIsReviewing] = useState(false);
   const [isModalOpen, setIsModalOpen] = useState(false);
-  const [additionalAlerts, setAdditionalAlerts] = useState<AlertMessage[]>([]);
   const [modalMode, setModalMode] = useState<ModalMode | null>(null);
+  const [additionalInstructions, setAdditionalInstructions] = useState('');
+  const [commentFormat, setCommentFormat] = useState(defaultCommentFormat);
 
-  // メッセージアラートが閉じられる際の挙動
-  const closeAdditionalAlerts = (id: string) => {
-    setAdditionalAlerts((prev) => prev.filter((alert) => alert.id !== id));
-  };
+  const addAlert = useAlertStore((state) => state.addAlert);
 
-  // チェックリスト取得
+  // チェック履歴取得
   const fetchChecklistResults = useCallback(async () => {
     if (!selectedReviewHistoryId) return;
+    const reviewApi = ReviewApi.getInstance();
 
-    try {
-      const result = await reviewService.getReviewHistoryDetail(
-        selectedReviewHistoryId,
-      );
-      setChecklistResults(result.checklists || []);
-    } catch (error) {
-      setAdditionalAlerts((prev) => [
-        ...prev,
-        {
-          id: uuid(),
-          type: 'error',
-          content: `チェックリストの取得中にエラーが発生しました: ${(error as Error).message}`,
-        },
-      ]);
-    }
+    const result = await reviewApi.getReviewHistoryDetail(
+      selectedReviewHistoryId,
+      { throwError: true, showAlert: true },
+    );
+    setChecklistResults(result?.checklistResults || []);
   }, [selectedReviewHistoryId]);
 
-  // 選択中の履歴が変更されたら、チェックリスト取得のポーリングを開始
+  // 選択中の履歴が変更されたら、初期データ取得を実行
   useEffect(() => {
     if (!selectedReviewHistoryId) return;
 
-    // チェックリストの初期取得
-    fetchChecklistResults();
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    // 初期データ取得（エラーが発生しなくなるまでポーリング）
+    const loadInitialData = async () => {
+      try {
+        // チェックリストの初期取得
+        await fetchChecklistResults();
+
+        // 追加指示とコメントフォーマットの取得
+        const reviewApi = ReviewApi.getInstance();
+        const result = await reviewApi.getReviewInstruction(
+          selectedReviewHistoryId,
+          {
+            throwError: true,
+            showAlert: true,
+          },
+        );
+        setAdditionalInstructions(result?.additionalInstructions || '');
+        setCommentFormat(result?.commentFormat || defaultCommentFormat);
+
+        // 初期データ取得成功したらポーリングを停止
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+      } catch (error) {
+        console.error('初期データの取得に失敗しました:', error);
+        // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
+        if (!intervalId) {
+          intervalId = setInterval(loadInitialData, 5000);
+        }
+      }
+    };
 
-    // ポーリングの開始
-    const timer = setInterval(fetchChecklistResults, 5000);
+    // 初回実行
+    loadInitialData();
 
-    // eslint-disable-next-line
+    // クリーンアップでポーリング停止
     return () => {
-      clearInterval(timer);
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
     };
   }, [selectedReviewHistoryId, fetchChecklistResults]);
 
+  // 処理中のポーリング制御
+  useEffect(() => {
+    if (!selectedReviewHistoryId || (!isExtracting && !isReviewing)) return;
+
+    // チェックリスト抽出処理中またはレビュー実行処理中のみポーリング開始
+    const processingTimer = setInterval(async () => {
+      try {
+        await fetchChecklistResults();
+      } catch (error) {
+        console.error('チェックリスト結果の取得に失敗しました:', error);
+      }
+    }, 5000);
+
+    return () => {
+      clearInterval(processingTimer);
+    };
+  }, [
+    selectedReviewHistoryId,
+    isExtracting,
+    isReviewing,
+    fetchChecklistResults,
+  ]);
+
   // チェックリストの抽出処理
   const handleExtractChecklist = useCallback(
     async (
@@ -84,136 +136,169 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
     ) => {
       if (!selectedReviewHistoryId) return;
 
+      const reviewApi = ReviewApi.getInstance();
+
       try {
         setIsExtracting(true);
         setIsModalOpen(false);
 
         // チェックリスト抽出処理を開始
-        const result = await window.electron.review.extractChecklist({
-          reviewHistoryId: selectedReviewHistoryId,
+        await reviewApi.extractChecklist(
+          selectedReviewHistoryId,
           files,
           documentType,
           checklistRequirements,
-        });
-
-        if (!result.success) {
-          throw new Error(result.error);
-        }
+          { throwError: true, showAlert: false },
+        );
 
         // 抽出完了イベントの購読を開始
-        const unsubscribe = reviewService.subscribeChecklistExtractionFinished(
+        const unsubscribe = reviewApi.subscribeChecklistExtractionFinished(
           (payload) => {
-            if (payload.success) {
-              setAdditionalAlerts((prev) => [
-                ...prev,
-                {
-                  id: uuid(),
-                  type: 'success',
-                  content: 'チェックリストの抽出が完了しました',
-                },
-              ]);
-            } else {
-              setAdditionalAlerts((prev) => [
-                ...prev,
-                {
-                  id: uuid(),
-                  type: 'error',
-                  content: `チェックリストの抽出に失敗しました: ${payload.error}`,
-                },
-              ]);
+            if (payload.status === 'success') {
+              addAlert({
+                message: 'チェックリストの抽出が完了しました',
+                severity: 'success',
+              });
+              // 抽出結果の再取得
+              fetchChecklistResults().catch((error) => {
+                addAlert({
+                  message: getSafeErrorMessage(
+                    error,
+                    'チェックリスト結果の取得に失敗しました',
+                  ),
+                  severity: 'error',
+                });
+              });
+            } else if (payload.status === 'failed') {
+              addAlert({
+                message: `チェックリストの抽出に失敗しました\n${payload.error}`,
+                severity: 'error',
+              });
             }
             setIsExtracting(false);
             unsubscribe();
           },
         );
       } catch (error) {
-        setAdditionalAlerts((prev) => [
-          ...prev,
-          {
-            id: uuid(),
-            type: 'error',
-            content: `チェックリストの抽出処理実行時にエラーが発生しました: ${(error as Error).message}`,
-          },
-        ]);
+        console.error(error);
+        addAlert({
+          message: getSafeErrorMessage(
+            error,
+            'チェックリスト抽出の実行に失敗しました',
+          ),
+          severity: 'error',
+        });
         setIsExtracting(false);
       }
     },
-    [selectedReviewHistoryId],
+    [selectedReviewHistoryId, addAlert],
   );
 
   // レビュー実行処理
   const handleExecuteReview = useCallback(
-    async (
-      files: UploadFile[],
-      reviewAdditionalInstructions?: string,
-      reviewCommentFormat?: string,
-    ) => {
+    async (files: UploadFile[]) => {
       if (!selectedReviewHistoryId) return;
 
+      const reviewApi = ReviewApi.getInstance();
+
       try {
         setIsReviewing(true);
         setIsModalOpen(false);
 
         // レビュー実行処理を開始
-        const result = await window.electron.review.execute({
-          reviewHistoryId: selectedReviewHistoryId,
+        const result = await reviewApi.executeReview(
+          selectedReviewHistoryId,
           files,
-          additionalInstructions: reviewAdditionalInstructions,
-          commentFormat: reviewCommentFormat,
-        });
-
-        if (!result.success) {
-          throw new Error(result.error);
-        }
+          additionalInstructions || additionalInstructions,
+          commentFormat || commentFormat,
+          { throwError: true, showAlert: false },
+        );
 
         // レビュー完了イベントの購読を開始
-        const unsubscribe = reviewService.subscribeReviewExecutionFinished(
+        const unsubscribe = reviewApi.subscribeReviewExtractionFinished(
           (payload) => {
-            if (payload.success) {
-              setAdditionalAlerts((prev) => [
-                ...prev,
-                {
-                  id: uuid(),
-                  type: 'success',
-                  content: 'レビューが完了しました',
-                },
-              ]);
-            } else {
-              setAdditionalAlerts((prev) => [
-                ...prev,
-                {
-                  id: uuid(),
-                  type: 'error',
-                  content: `レビューに失敗しました: ${payload.error}`,
-                },
-              ]);
+            if (payload.status === 'success') {
+              addAlert({
+                message: 'レビューが完了しました',
+                severity: 'success',
+              });
+            } else if (payload.status === 'failed') {
+              addAlert({
+                message: `レビューに失敗しました\n${payload.error}`,
+                severity: 'error',
+              });
             }
             setIsReviewing(false);
             unsubscribe();
           },
         );
       } catch (error) {
-        setAdditionalAlerts((prev) => [
-          ...prev,
-          {
-            id: uuid(),
-            type: 'error',
-            content: `レビュー処理実行時にエラーが発生しました: ${(error as Error).message}`,
-          },
-        ]);
+        console.error(error);
+        addAlert({
+          message: getSafeErrorMessage(error, 'レビューの実行に失敗しました'),
+          severity: 'error',
+        });
         setIsReviewing(false);
       }
     },
-    [selectedReviewHistoryId],
+    [selectedReviewHistoryId, addAlert, additionalInstructions, commentFormat],
   );
 
+  // チェックリスト抽出のキャンセル処理
+  const handleCancelExtractChecklist = useCallback(async () => {
+    if (!selectedReviewHistoryId) return;
+
+    const reviewApi = ReviewApi.getInstance();
+
+    try {
+      await reviewApi.abortExtractChecklist(selectedReviewHistoryId, {
+        showAlert: false,
+        throwError: true,
+      });
+      setIsExtracting(false);
+      addAlert({
+        message: 'チェックリスト抽出をキャンセルしました',
+        severity: 'info',
+      });
+    } catch (error) {
+      console.error('チェックリスト抽出のキャンセルエラー:', error);
+      addAlert({
+        message: 'チェックリスト抽出のキャンセルに失敗しました',
+        severity: 'warning',
+      });
+    }
+  }, [selectedReviewHistoryId, addAlert]);
+
+  // レビュー実行のキャンセル処理
+  const handleCancelExecuteReview = useCallback(async () => {
+    if (!selectedReviewHistoryId) return;
+
+    const reviewApi = ReviewApi.getInstance();
+
+    try {
+      await reviewApi.abortExecuteReview(selectedReviewHistoryId, {
+        showAlert: true,
+        throwError: true,
+      });
+      setIsReviewing(false);
+      addAlert({
+        message: 'レビュー実行をキャンセルしました',
+        severity: 'info',
+      });
+    } catch (error) {
+      console.error('レビュー実行のキャンセルエラー:', error);
+      addAlert({
+        message: 'レビュー実行のキャンセルに失敗しました',
+        severity: 'warning',
+      });
+    }
+  }, [selectedReviewHistoryId, addAlert]);
+
   const handleModalSubmit = useCallback(
     async (
       files: UploadFile[],
       documentType?: DocumentType,
       checklistRequirements?: string,
-      modalAdditionalInstructions?: string,
-      modalCommentFormat?: string,
     ) => {
       if (modalMode === 'extract') {
         await handleExtractChecklist(
@@ -222,11 +307,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
           checklistRequirements,
         );
       } else if (modalMode === 'review') {
-        await handleExecuteReview(
-          files,
-          modalAdditionalInstructions,
-          modalCommentFormat,
-        );
+        await handleExecuteReview(files);
       }
     },
     [modalMode, handleExtractChecklist, handleExecuteReview],
@@ -236,44 +317,36 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   const handleSaveChecklist = async (checklists: ReviewChecklistEdit[]) => {
     if (!selectedReviewHistoryId) return;
 
+    setIsSaving(true);
+    const reviewApi = ReviewApi.getInstance();
     try {
-      setIsSaving(true);
-      const result = await window.electron.review.updateChecklist({
-        reviewHistoryId: selectedReviewHistoryId,
-        checklistEdits: checklists,
+      await reviewApi.updateChecklist(selectedReviewHistoryId, checklists, {
+        throwError: false,
+        showAlert: true,
+      });
+      // 更新後は最新状態を再取得
+      await fetchChecklistResults();
+      addAlert({
+        message: 'チェックリストを保存しました',
+        severity: 'info',
       });
-
-      if (result.success) {
-        setAdditionalAlerts((prev) => [
-          ...prev,
-          {
-            id: uuid(),
-            type: 'success',
-            content: 'チェックリストが更新されました',
-          },
-        ]);
-        await fetchChecklistResults();
-      } else {
-        throw new Error(result.error);
-      }
     } catch (error) {
-      setAdditionalAlerts((prev) => [
-        ...prev,
-        {
-          id: uuid(),
-          type: 'error',
-          content: `チェックリストの更新中にエラーが発生しました: ${(error as Error).message}`,
-        },
-      ]);
-    } finally {
-      setIsSaving(false);
+      console.error('チェックリストの保存に失敗しました:', error);
+      addAlert({
+        message: getSafeErrorMessage(
+          error,
+          'チェックリストの保存に失敗しました',
+        ),
+        severity: 'error',
+      });
     }
+    setIsSaving(false);
   };
 
   return (
     <Box
       sx={{
-        width: 'calc(100% - 280px)',
+        width: '100%',
         display: 'flex',
         flexDirection: 'column',
         flexGrow: 1,
@@ -286,11 +359,6 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
         overflow: 'hidden',
       }}
     >
-      {/* アラートメッセージ */}
-      <AlertManager
-        additionalAlerts={additionalAlerts}
-        closeAdditionalAlerts={closeAdditionalAlerts}
-      />
       {selectedReviewHistoryId && (
         <>
           {/* ヘッダー部分 */}
@@ -303,45 +371,39 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
             <Stack direction="row" spacing={2}>
               <Button
                 variant="contained"
-                startIcon={
-                  !isExtracting ? (
-                    <CheckBoxIcon />
-                  ) : (
-                    <CircularProgress size={24} color="inherit" />
-                  )
-                }
-                onClick={() => {
-                  setModalMode('extract');
-                  setIsModalOpen(true);
-                }}
-                disabled={
-                  !selectedReviewHistoryId || isExtracting || isReviewing
+                color={isExtracting ? 'error' : 'primary'}
+                startIcon={isExtracting ? <StopIcon /> : <CheckBoxIcon />}
+                onClick={
+                  isExtracting
+                    ? handleCancelExtractChecklist
+                    : () => {
+                        setModalMode('extract');
+                        setIsModalOpen(true);
+                      }
                 }
+                disabled={!selectedReviewHistoryId || isReviewing}
               >
-                チェックリスト抽出
+                {isExtracting ? 'キャンセル' : 'チェックリスト抽出'}
               </Button>
               <Button
                 variant="contained"
-                color="primary"
-                startIcon={
-                  !isReviewing ? (
-                    <RateReviewIcon />
-                  ) : (
-                    <CircularProgress size={24} color="inherit" />
-                  )
+                color={isReviewing ? 'error' : 'primary'}
+                startIcon={isReviewing ? <StopIcon /> : <RateReviewIcon />}
+                onClick={
+                  isReviewing
+                    ? handleCancelExecuteReview
+                    : () => {
+                        setModalMode('review');
+                        setIsModalOpen(true);
+                      }
                 }
-                onClick={() => {
-                  setModalMode('review');
-                  setIsModalOpen(true);
-                }}
                 disabled={
                   !selectedReviewHistoryId ||
                   isExtracting ||
-                  isReviewing ||
-                  checklistResults.length === 0
+                  (checklistResults.length === 0 && !isReviewing)
                 }
               >
-                レビュー実行
+                {isReviewing ? 'キャンセル' : 'レビュー実行'}
               </Button>
             </Stack>
           </Stack>
@@ -374,6 +436,10 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
             selectedReviewHistoryId={selectedReviewHistoryId || null}
             disabled={isSaving || isExtracting || isReviewing}
             modalMode={modalMode!}
+            additionalInstructions={additionalInstructions}
+            setAdditionalInstructions={setAdditionalInstructions}
+            commentFormat={commentFormat}
+            setCommentFormat={setCommentFormat}
           />
         </>
       )}
diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
index 913fdb56c..9e950df0e 100644
--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++ b/src/renderer/components/review/ReviewChecklistSection.tsx
@@ -22,13 +22,13 @@ import EditIcon from '@mui/icons-material/Edit';
 import SaveIcon from '@mui/icons-material/Save';
 import CancelIcon from '@mui/icons-material/Cancel';
 import FileDownloadIcon from '@mui/icons-material/FileDownload';
+import { ReviewEvaluation } from '@/types';
 import { ReviewChecklistSectionProps } from './types';
-import { ReviewEvaluation } from '../../../main/types';
 import {
   convertReviewResultsToCSV,
   downloadCSV,
   generateCSVFilename,
-} from '../../utils/csvUtils';
+} from '../../lib/csvUtils';
 
 // 評価ごとの色マッピング
 const evaluationColors: Record<ReviewEvaluation, string> = {
diff --git a/src/renderer/components/review/ReviewHistoryList.tsx b/src/renderer/components/review/ReviewHistoryList.tsx
index 80c8c8740..fb5dfe52f 100644
--- a/src/renderer/components/review/ReviewHistoryList.tsx
+++ b/src/renderer/components/review/ReviewHistoryList.tsx
@@ -17,8 +17,12 @@ import {
 import { MoreVert as MoreIcon } from '@mui/icons-material';
 import AddCircleOutlineOutlinedIcon from '@mui/icons-material/AddCircleOutlineOutlined';
 import { v4 as uuidv4 } from 'uuid';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+import { getSafeErrorMessage } from '../../lib/error';
 import type { ReviewHistory } from '../../../db/schema';
-import { reviewService } from '../../services/reviewService';
+import { ReviewApi } from '../../service/reviewApi';
+import { usePushChannel } from '../../hooks/usePushChannel';
+import { IpcChannels } from '../../../types/ipc';
 
 interface ReviewHistoryListProps {
   selectedReviewHistoryId?: string | null;
@@ -34,28 +38,76 @@ function ReviewHistoryList({
   const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
   // メニュー選択中のレビュー履歴ID
   const [activeReviewId, setActiveHistoryId] = useState<string | null>(null);
+  const addAlert = useAlertStore((state) => state.addAlert);
 
   // レビュー履歴一覧を取得
   const fetchReviewHistories = useCallback(async () => {
-    try {
-      const histories = await reviewService.getHistories();
+    const reviewApi = ReviewApi.getInstance();
+    const histories = await reviewApi.getHistories({
+      showAlert: false,
+      throwError: true,
+    });
+    if (histories && histories.length > 0) {
       // updatedAtで降順ソート
       const sortedHistories = [...histories].sort(
         (a, b) =>
           new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime(),
       );
       setReviewHistories(sortedHistories);
-      setLoading(false);
-    } catch (error) {
-      console.error(error);
-      setLoading(true);
+    } else {
+      setReviewHistories([]);
     }
   }, []);
 
-  // 初期データ読み込み
+  // レビュー履歴一覧を取得（サーバプッシュ更新用）
+  const refreshReviewHistories = useCallback(async () => {
+    try {
+      await fetchReviewHistories();
+      // サーバプッシュ更新時は既にロード完了しているのでローディング状態は変更しない
+    } catch (error) {
+      console.error('レビュー履歴の更新に失敗しました:', error);
+      addAlert({
+        message: getSafeErrorMessage(error, 'レビュー履歴の更新に失敗しました'),
+        severity: 'error',
+      });
+    }
+  }, [fetchReviewHistories, addAlert]);
+
+  // 初期データ読み込み（エラーが発生しなくなるまでポーリング）
   useEffect(() => {
-    fetchReviewHistories();
-  }, [fetchReviewHistories]);
+    setLoading(true);
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    const loadReviewHistories = async () => {
+      try {
+        await fetchReviewHistories();
+
+        setLoading(false);
+
+        // 読み込み成功したらポーリングを停止
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+      } catch (error) {
+        console.error('レビュー履歴の読み込みに失敗しました:', error);
+        // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
+        if (!intervalId) {
+          intervalId = setInterval(loadReviewHistories, 5000);
+        }
+      }
+    };
+
+    // 初回読み込み
+    loadReviewHistories();
+
+    // クリーンアップでポーリング停止
+    return () => {
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
+    };
+  }, [setLoading, fetchReviewHistories]);
 
   // メニュー操作
   const handleMenuOpen = (
@@ -77,7 +129,11 @@ function ReviewHistoryList({
     if (!activeReviewId) return;
 
     try {
-      await reviewService.deleteHistory(activeReviewId);
+      const reviewApi = ReviewApi.getInstance();
+      await reviewApi.deleteHistory(activeReviewId, {
+        showAlert: true,
+        throwError: true,
+      });
       // 削除した履歴が選択中だった場合は選択を解除
       if (selectedReviewHistoryId === activeReviewId) {
         onReviewHistorySelect(null);
@@ -92,16 +148,11 @@ function ReviewHistoryList({
     }
   };
 
-  // レビュー履歴の更新をトリガーする関数
-  const refreshReviewHistories = useCallback(() => {
-    fetchReviewHistories();
-  }, [fetchReviewHistories]);
-
-  // レビュー履歴の定期更新
-  useEffect(() => {
-    const interval = setInterval(refreshReviewHistories, 5000);
-    return () => clearInterval(interval);
-  }, [refreshReviewHistories]);
+  // レビュー履歴の更新イベントを購読
+  usePushChannel(IpcChannels.REVIEW_HISTORY_UPDATED, () => {
+    // イベント受信時にレビュー履歴を再取得
+    refreshReviewHistories();
+  });
 
   // 新しいレビューを開始
   const handleCreateReview = () => {
@@ -161,11 +212,13 @@ function ReviewHistoryList({
                 <Tooltip title={reviewHistory.title} placement="right">
                   <ListItemText
                     primary={reviewHistory.title}
-                    primaryTypographyProps={{
-                      noWrap: true,
-                      sx: {
-                        overflow: 'hidden',
-                        textOverflow: 'ellipsis',
+                    slotProps={{
+                      primary: {
+                        noWrap: true,
+                        sx: {
+                          overflow: 'hidden',
+                          textOverflow: 'ellipsis',
+                        },
                       },
                     }}
                   />
diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
index 87bdea446..283335d35 100644
--- a/src/renderer/components/review/ReviewSourceModal.tsx
+++ b/src/renderer/components/review/ReviewSourceModal.tsx
@@ -28,21 +28,81 @@ import {
   ViewAgenda as MergedIcon,
   ViewStream as PagesIcon,
 } from '@mui/icons-material';
-import { createHash } from 'crypto';
-
 import {
-  ReviewSourceModalProps,
   DocumentType,
   UploadFile,
   PdfProcessMode,
   PdfImageMode,
-} from './types';
-
-import { combineImages, convertPdfBytesToImages } from '../../utils/pdfUtils';
-import { reviewService } from '../../services/reviewService';
-
-const defaultCommentFormat =
-  '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）';
+} from '@/types';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+import { getSafeErrorMessage } from '../../lib/error';
+import { ReviewSourceModalProps } from './types';
+import { FsApi } from '../../service/fsApi';
+
+import { combineImages, convertPdfBytesToImages } from '../../lib/pdfUtils';
+
+const getMimeTypeFromExtension = (extension: string): string => {
+  const mimeTypes: { [key: string]: string } = {
+    pdf: 'application/pdf',
+    doc: 'application/msword',
+    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
+    xls: 'application/vnd.ms-excel',
+    xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
+    ppt: 'application/vnd.ms-powerpoint',
+    pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
+    txt: 'text/plain',
+  };
+  return mimeTypes[extension] || 'application/octet-stream';
+};
+
+const getButtonText = (modalMode: ReviewSourceModalProps['modalMode']) => {
+  if (modalMode === 'review') return 'ドキュメントレビュー実行';
+  if (modalMode === 'extract') return 'チェックリスト抽出';
+  return null;
+};
+
+const getTitle = (modalMode: ReviewSourceModalProps['modalMode']) => {
+  if (modalMode === 'review') return 'レビュー対象ファイルのアップロード';
+  if (modalMode === 'extract')
+    return 'チェックリスト抽出対象ファイルのアップロード';
+  return 'ファイルアップロード';
+};
+
+const getAlertMessage = ({
+  modalMode,
+  documentType,
+}: {
+  modalMode: ReviewSourceModalProps['modalMode'];
+  documentType: DocumentType;
+}) => {
+  if (modalMode === 'extract') {
+    return (
+      <>
+        ファイルを選択してチェックリスト抽出を実行できます
+        <br />
+        {documentType === 'checklist'
+          ? '選択されたチェックリストドキュメントから、AIが既存のチェック項目を抽出できます'
+          : '選択された一般ドキュメントから、AIがレビュー用のチェックリストを新規作成できます'}
+        <br />
+        ※
+        <br />
+        チェックリストは手動で編集・追加・削除が可能です
+        <br />
+        手動で追加・編集されたチェックリスト以外は、再度チェックリスト抽出を実行すると削除されます
+      </>
+    );
+  }
+  if (modalMode === 'review') {
+    return (
+      <>
+        レビュー対象ファイルを選択してください
+        <br />
+        選択されたドキュメントに対して、AIがチェックリストに基づいてレビューを行います
+      </>
+    );
+  }
+  return null;
+};
 
 function ReviewSourceModal({
   open,
@@ -51,14 +111,17 @@ function ReviewSourceModal({
   selectedReviewHistoryId,
   disabled,
   modalMode,
+  additionalInstructions,
+  setAdditionalInstructions,
+  commentFormat,
+  setCommentFormat,
 }: ReviewSourceModalProps): React.ReactElement {
   const [uploadedFiles, setUploadedFiles] = useState<UploadFile[]>([]);
   const [processing, setProcessing] = useState(false); // ★ 送信処理やPDF変換の進行中フラグ
   const [documentType, setDocumentType] = useState<DocumentType>('checklist');
   const [checklistRequirements, setChecklistRequirements] = useState('');
-  const [additionalInstructions, setAdditionalInstructions] = useState('');
-  const [commentFormat, setCommentFormat] = useState(defaultCommentFormat);
-  const [error, setError] = useState<string | null>(null); // ★ エラー表示用
+
+  const addAlert = useAlertStore((state) => state.addAlert);
 
   // modalMode, selectedReviewHistoryIdが変わったときに初期化し、保存された値を取得
   useEffect(() => {
@@ -66,71 +129,41 @@ function ReviewSourceModal({
       setUploadedFiles([]);
       setDocumentType('checklist');
       setChecklistRequirements('');
-      setError(null);
-
-      // レビューモードの場合、保存された追加指示とコメントフォーマットを取得
-      if (modalMode === 'review' && selectedReviewHistoryId) {
-        try {
-          const result = await reviewService.getReviewHistoryDetail(
-            selectedReviewHistoryId,
-          );
-
-          // 保存された値がある場合はそれを使用、なければデフォルト値を使用
-          setAdditionalInstructions(result.additionalInstructions || '');
-          setCommentFormat(result.commentFormat || defaultCommentFormat);
-        } catch (error) {
-          console.error('保存されたレビュー設定の取得に失敗:', error);
-          // エラーが発生した場合はデフォルト値を使用
-          setAdditionalInstructions('');
-          setCommentFormat(defaultCommentFormat);
-        }
-      } else {
-        // 抽出モードの場合はデフォルト値をセット
-        setAdditionalInstructions('');
-        setCommentFormat(defaultCommentFormat);
-      }
     };
 
     loadSavedData();
   }, [modalMode, selectedReviewHistoryId]);
 
-  const getMimeTypeFromExtension = (extension: string): string => {
-    const mimeTypes: { [key: string]: string } = {
-      pdf: 'application/pdf',
-      doc: 'application/msword',
-      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
-      xls: 'application/vnd.ms-excel',
-      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
-      ppt: 'application/vnd.ms-powerpoint',
-      pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
-      txt: 'text/plain',
-    };
-    return mimeTypes[extension] || 'application/octet-stream';
-  };
-
   const handleFileUpload = async () => {
     try {
-      const result = await window.electron.fs.showOpenDialog({
-        title: 'ドキュメントファイルを選択',
-        filters: [
-          {
-            name: 'ドキュメントファイル',
-            extensions: [
-              'pdf',
-              'doc',
-              'docx',
-              'xls',
-              'xlsx',
-              'ppt',
-              'pptx',
-              'txt',
-            ],
-          },
-        ],
-        properties: ['openFile', 'multiSelections'],
-      });
+      const fsApi = FsApi.getInstance();
+      const result = await fsApi.showOpenDialog(
+        {
+          title: 'ドキュメントファイルを選択',
+          filters: [
+            {
+              name: 'ドキュメントファイル',
+              extensions: [
+                'pdf',
+                'doc',
+                'docx',
+                'xls',
+                'xlsx',
+                'ppt',
+                'pptx',
+                'txt',
+              ],
+            },
+          ],
+          properties: ['openFile', 'multiSelections'],
+        },
+        {
+          showAlert: true,
+          throwError: true,
+        },
+      );
 
-      if (!result.canceled && result.filePaths.length > 0) {
+      if (result && !result.canceled && result.filePaths.length > 0) {
         const newFiles: UploadFile[] = result.filePaths.map(
           (filePath: string) => {
             const fileName = filePath.split(/[/\\]/).pop() || filePath;
@@ -155,7 +188,10 @@ function ReviewSourceModal({
       }
     } catch (e) {
       console.error('ファイル選択エラー:', e);
-      setError('ファイル選択に失敗しました。もう一度お試しください。');
+      addAlert({
+        message: getSafeErrorMessage(e, 'ファイル選択に失敗しました'),
+        severity: 'error',
+      });
     }
   };
 
@@ -198,7 +234,6 @@ function ReviewSourceModal({
   const handleSubmit = async () => {
     if (disabled || processing || uploadedFiles.length === 0) return;
 
-    setError(null);
     setProcessing(true);
 
     try {
@@ -206,10 +241,14 @@ function ReviewSourceModal({
       for (const f of uploadedFiles) {
         if (f.type === 'application/pdf' && f.pdfProcessMode === 'image') {
           // Mainから安全にPDFバイト列を取得（file:// fetch を使わない）
-          const data = await window.electron.fs.readFile(f.path);
+          const fsApi = FsApi.getInstance();
+          const data = await fsApi.readFile(f.path, {
+            showAlert: false,
+            throwError: true,
+          });
 
           // ブラウザ側で pdf.js にレンダリングさせて PNG を得る
-          const imagePages = await convertPdfBytesToImages(data, {
+          const imagePages = await convertPdfBytesToImages(data!, {
             scale: 2.0,
           });
 
@@ -262,57 +301,15 @@ function ReviewSourceModal({
       );
     } catch (e) {
       console.error('送信処理中に失敗:', e);
-      setError(
-        '送信時の処理に失敗しました。PDFが壊れていないか、またはPDFが非常に大きすぎないかをご確認ください。',
-      );
+      addAlert({
+        message: getSafeErrorMessage(e, 'ファイルの送信処理に失敗しました'),
+        severity: 'error',
+      });
     } finally {
       setProcessing(false);
     }
   };
 
-  const getButtonText = () => {
-    if (modalMode === 'review') return 'ドキュメントレビュー実行';
-    if (modalMode === 'extract') return 'チェックリスト抽出';
-    return null;
-  };
-
-  const getTitle = () => {
-    if (modalMode === 'review') return 'レビュー対象ファイルのアップロード';
-    if (modalMode === 'extract')
-      return 'チェックリスト抽出対象ファイルのアップロード';
-    return 'ファイルアップロード';
-  };
-
-  const getAlertMessage = () => {
-    if (modalMode === 'extract') {
-      return (
-        <>
-          ファイルを選択してチェックリスト抽出を実行できます
-          <br />
-          {documentType === 'checklist'
-            ? '選択されたチェックリストドキュメントから、AIが既存のチェック項目を抽出できます'
-            : '選択された一般ドキュメントから、AIがレビュー用のチェックリストを新規作成できます'}
-          <br />
-          ※
-          <br />
-          チェックリストは手動で編集・追加・削除が可能です
-          <br />
-          手動で追加・編集されたチェックリスト以外は、再度チェックリスト抽出を実行すると削除されます
-        </>
-      );
-    }
-    if (modalMode === 'review') {
-      return (
-        <>
-          レビュー対象ファイルを選択してください
-          <br />
-          選択されたドキュメントに対して、AIがチェックリストに基づいてレビューを行います
-        </>
-      );
-    }
-    return null;
-  };
-
   return (
     <Modal open={open} onClose={onClose}>
       <Box
@@ -332,19 +329,13 @@ function ReviewSourceModal({
         }}
       >
         <Typography variant="h6" component="h2" gutterBottom>
-          {getTitle()}
+          {getTitle(modalMode)}
         </Typography>
 
         <Alert severity="info" sx={{ whiteSpace: 'pre-line', mb: 2 }}>
-          {getAlertMessage()}
+          {getAlertMessage({ modalMode, documentType })}
         </Alert>
 
-        {error && (
-          <Alert severity="error" sx={{ mb: 2 }}>
-            {error}
-          </Alert>
-        )}
-
         {modalMode === 'extract' && (
           <>
             <FormControl component="fieldset" sx={{ mb: 2 }}>
@@ -565,7 +556,7 @@ function ReviewSourceModal({
             disabled={processing || disabled || uploadedFiles.length === 0}
             startIcon={processing ? <CircularProgress size={20} /> : null}
           >
-            {processing ? '処理中...' : getButtonText()}
+            {processing ? '処理中...' : getButtonText(modalMode)}
           </Button>
         </Box>
       </Box>
diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
index fada4b0fa..6f14dff08 100644
--- a/src/renderer/components/review/types.ts
+++ b/src/renderer/components/review/types.ts
@@ -1,8 +1,11 @@
 import {
   ReviewChecklistEdit,
   ReviewChecklistResultDisplay,
-} from '../../../main/types';
-import { Source } from '../../../db/schema';
+  ModalMode,
+  UploadFile,
+  DocumentType,
+} from '@/types';
+import { Source } from '@/db/schema';
 
 // ReviewAreaのProps型
 export interface ReviewAreaProps {
@@ -16,28 +19,6 @@ export interface ReviewChecklistSectionProps {
   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
 }
 
-export type ModalMode = 'extract' | 'review';
-
-// ドキュメント種別の定義
-export type DocumentType = 'checklist' | 'general';
-
-// PDF処理方式の定義
-export type PdfProcessMode = 'text' | 'image';
-
-// PDF画像化方式の定義
-export type PdfImageMode = 'merged' | 'pages';
-
-// アップロードファイル情報の型定義
-export interface UploadFile {
-  id: string;
-  name: string;
-  path: string;
-  type: string;
-  pdfProcessMode?: PdfProcessMode; // PDFファイルの場合のみ
-  pdfImageMode?: PdfImageMode; // PDF画像化の場合のみ (merged: 統合画像, pages: ページ別画像)
-  imageData?: string[]; // PDF画像変換時のBase64データ配列 (merged: 長さ1, pages: 各ページ)
-}
-
 // ReviewSourceModalのProps型
 export interface ReviewSourceModalProps {
   open: boolean;
@@ -52,6 +33,10 @@ export interface ReviewSourceModalProps {
   selectedReviewHistoryId: string | null;
   disabled?: boolean;
   modalMode: ModalMode;
+  additionalInstructions: string;
+  setAdditionalInstructions: (instructions: string) => void;
+  commentFormat: string;
+  setCommentFormat: (format: string) => void;
 }
 
 // ソースファイルセレクタのProps型
diff --git a/src/renderer/components/sidebar/Sidebar.tsx b/src/renderer/components/sidebar/Sidebar.tsx
index d940f635f..4e78c206b 100644
--- a/src/renderer/components/sidebar/Sidebar.tsx
+++ b/src/renderer/components/sidebar/Sidebar.tsx
@@ -1,5 +1,6 @@
 import React, { useState, useCallback } from 'react';
-import { Box, AlertColor } from '@mui/material';
+import { Box } from '@mui/material';
+import { useAlertStore } from '@/renderer/stores/alertStore';
 import SourceListModal from '../common/SourceListModal';
 import SettingsModal from '../common/SettingsModal';
 import SidebarHeader from './SidebarHeader';
@@ -7,15 +8,10 @@ import SidebarFooter from './SidebarFooter';
 
 interface SidebarProps {
   onReloadSources: () => void;
-  showSnackbar: (message: string, severity: AlertColor) => void;
   children?: React.ReactNode;
 }
 
-function Sidebar({
-  onReloadSources,
-  showSnackbar,
-  children = null,
-}: SidebarProps) {
+function Sidebar({ onReloadSources, children = null }: SidebarProps) {
   const [isSourceListOpen, setIsSourceListOpen] = useState(false);
   const [settingsHasError, setSettingsHasError] = useState(false);
   const [sourceStatus, setSourceStatus] = useState<{
@@ -25,10 +21,12 @@ function Sidebar({
 
   const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
 
+  const addAlert = useAlertStore((state) => state.addAlert);
+
   const onSettingsUpdated = useCallback(() => {
     // 設定更新完了時の処理
-    showSnackbar('設定を更新しました', 'success');
-  }, [showSnackbar]);
+    addAlert({ message: '設定を更新しました', severity: 'info' });
+  }, [addAlert]);
 
   // 設定モーダルを開く
   const handleSettingsClick = () => {
@@ -81,7 +79,6 @@ function Sidebar({
         onClose={() => setIsSourceListOpen(false)}
         onReloadSources={onReloadSources}
         onStatusUpdate={setSourceStatus}
-        showSnackbar={showSnackbar}
       />
 
       {/* 設定モーダル */}
diff --git a/src/renderer/components/sidebar/SidebarFooter.tsx b/src/renderer/components/sidebar/SidebarFooter.tsx
index 861d5ebca..5a14e54d7 100644
--- a/src/renderer/components/sidebar/SidebarFooter.tsx
+++ b/src/renderer/components/sidebar/SidebarFooter.tsx
@@ -11,7 +11,7 @@ import {
   AttachFile as AttachFileIcon,
 } from '@mui/icons-material';
 import { useLocation } from 'react-router-dom';
-import { ROUTES } from '../../../main/types';
+import { ROUTES } from '@/types';
 
 interface SidebarFooterProps {
   onSettingsClick: () => void;
diff --git a/src/renderer/components/sidebar/SidebarHeader.tsx b/src/renderer/components/sidebar/SidebarHeader.tsx
index 672416a7e..15aac0a0d 100644
--- a/src/renderer/components/sidebar/SidebarHeader.tsx
+++ b/src/renderer/components/sidebar/SidebarHeader.tsx
@@ -12,8 +12,8 @@ import {
 import ChatOutlinedIcon from '@mui/icons-material/ChatOutlined';
 import ChecklistOutlinedIcon from '@mui/icons-material/ChecklistOutlined';
 import { useNavigate, useLocation } from 'react-router-dom';
-import { ROUTES } from '../../../main/types';
-import useSettingsStatus from '../../hooks/useSettingsStatus';
+import { ROUTES } from '@/types';
+import { useAgentStatusStore } from '../../stores/agentStatusStore';
 
 interface SidebarHeaderProps {}
 
@@ -27,7 +27,7 @@ const FEATURES = [
 ] as const;
 
 const SidebarHeader: React.FC<SidebarHeaderProps> = () => {
-  const { status } = useSettingsStatus();
+  const { status } = useAgentStatusStore();
   const navigate = useNavigate();
   const location = useLocation();
 
diff --git a/src/renderer/hooks/useElectronStore.ts b/src/renderer/hooks/useElectronStore.ts
deleted file mode 100644
index 69c358a2b..000000000
--- a/src/renderer/hooks/useElectronStore.ts
+++ /dev/null
@@ -1,84 +0,0 @@
-import { useState, useEffect } from 'react';
-
-/**
- * Electronのストア操作の結果型
- */
-export type StoreHookResult<T> = {
-  value: T;
-  loading: boolean;
-  error: string | null;
-  setValue: (value: T) => Promise<void>;
-};
-
-/**
- * Electronのストア操作用フック
- * @param key ストアのキー
- * @returns StoreHookResult
- */
-export function useElectronStore<T extends Record<string, unknown>>(
-  key: string,
-): StoreHookResult<T> {
-  const [value, setValue] = useState<T>({} as T);
-  const [loading, setLoading] = useState(true);
-  const [error, setError] = useState<string | null>(null);
-
-  // 値の取得
-  useEffect(() => {
-    let intervalId: ReturnType<typeof setInterval> | null = null;
-
-    const fetchValue = async () => {
-      try {
-        const storedValue = await window.electron.store.get(key);
-        if (storedValue !== undefined) {
-          setValue(storedValue as T);
-        }
-        setError(null);
-        // 成功時はポーリングを停止
-        if (intervalId) {
-          clearInterval(intervalId);
-          intervalId = null;
-        }
-      } catch (err) {
-        const message =
-          err instanceof Error ? err.message : '不明なエラーが発生しました';
-        setError(`値の取得に失敗しました: ${message}`);
-        console.error(`Failed to get value for key "${key}":`, err);
-        // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
-        if (!intervalId) {
-          intervalId = setInterval(fetchValue, 5000);
-        }
-      } finally {
-        setLoading(false);
-      }
-    };
-
-    // 初回実行
-    fetchValue();
-
-    // クリーンアップ関数
-    return () => {
-      if (intervalId) {
-        clearInterval(intervalId);
-      }
-    };
-  }, [key]);
-
-  // 値の設定
-  const setStoreValue = async (newValue: T) => {
-    try {
-      await window.electron.store.set(key, newValue);
-      setValue(newValue);
-      setError(null);
-    } catch (err) {
-      const message =
-        err instanceof Error ? err.message : '不明なエラーが発生しました';
-      setError(`値の保存に失敗しました: ${message}`);
-      console.error(`Failed to set value for key "${key}":`, err);
-      throw err;
-    }
-  };
-
-  return { value, loading, error, setValue: setStoreValue };
-}
-
-export default useElectronStore;
diff --git a/src/renderer/hooks/usePushChannel.ts b/src/renderer/hooks/usePushChannel.ts
new file mode 100644
index 000000000..34fa7dc77
--- /dev/null
+++ b/src/renderer/hooks/usePushChannel.ts
@@ -0,0 +1,40 @@
+import { useEffect, useMemo, useRef, useState } from 'react';
+import { Channel, PushClient, PushEvent } from '@/types';
+import { ElectronPushClient } from '../lib/ElectronPushClient';
+
+function createPushClient(): PushClient {
+  // Electron 環境なら preload で露出された API が存在
+  return new ElectronPushClient();
+  // Web/Next.js環境ならSSEクライアントを返す
+}
+
+export function usePushChannel<C extends Channel>(
+  channel: C,
+  onEvent?: (ev: PushEvent<C>) => void,
+) {
+  const client = useMemo(createPushClient, []);
+  const [last, setLast] = useState<PushEvent<C> | null>(null);
+  const abortRef = useRef<AbortController>(new AbortController());
+  const cbRef = useRef(onEvent);
+
+  useEffect(() => {
+    abortRef.current?.abort();
+    const ac = new AbortController();
+    abortRef.current = ac;
+
+    const unsub = client.subscribe<C>(
+      channel,
+      (ev) => {
+        setLast(ev);
+        cbRef.current?.(ev);
+      },
+      { signal: ac.signal },
+    );
+    return () => {
+      ac.abort();
+      unsub();
+    };
+  }, [channel, client]);
+
+  return last;
+}
diff --git a/src/renderer/hooks/useSettings.ts b/src/renderer/hooks/useSettings.ts
new file mode 100644
index 000000000..5da798fa8
--- /dev/null
+++ b/src/renderer/hooks/useSettings.ts
@@ -0,0 +1,370 @@
+import { useState, useCallback, useEffect } from 'react';
+import { z } from 'zod';
+import {
+  SettingsSchema,
+  type Settings,
+  type ValidationState,
+  type ValidationError,
+} from '@/types';
+import { SettingsApi } from '../service/settingsApi';
+import { useAgentStatusStore } from '../stores/agentStatusStore';
+import { useAlertStore } from '../stores/alertStore';
+import { getSafeErrorMessage, internalError } from '../lib/error';
+
+/**
+ * 設定値の型安全な管理と検証を行うフック
+ */
+const useSettingsStore = () => {
+  // 設定値の状態管理
+  const [settings, setSettings] = useState<Settings>({
+    database: { dir: '' },
+    source: { registerDir: './source' },
+    api: { key: '', url: '', model: '' },
+    redmine: { endpoint: '', apiKey: '' },
+    gitlab: { endpoint: '', apiKey: '' },
+    mcp: { serverConfig: undefined },
+    systemPrompt: { content: '' },
+  });
+
+  // バリデーションエラーの状態管理
+  const [validationErrors, setValidationErrors] = useState<ValidationState>({
+    database: {},
+    source: {},
+    api: {},
+    redmine: {},
+    gitlab: {},
+    mcp: {},
+    systemPrompt: {},
+  });
+
+  const [loading, setLoading] = useState(true);
+  const [saving, setSaving] = useState(false);
+  const [saveError, setSaveError] = useState<string | null>(null);
+  const {
+    setUpdatedFlg,
+    setStatus: setAgentStatus,
+  } = useAgentStatusStore();
+
+  // エージェント状態のポーリング制御
+  const [agentStatusPolling, setAgentStatusPolling] = useState(false);
+  const addAlert = useAlertStore((state) => state.addAlert);
+
+  // SettingsApiインスタンス
+  const settingsApi = SettingsApi.getInstance();
+
+  /**
+   * エージェント状態を取得する関数
+   */
+  const fetchAgentStatus = useCallback(async () => {
+    const data = await settingsApi.getAgentStatus({
+      showAlert: false,
+      throwError: true,
+    });
+    if (data) {
+      setAgentStatus(data);
+    }
+  }, [settingsApi, setAgentStatus]);
+
+  /**
+   * バリデーションエラーの種類を判定
+   */
+  const determineErrorType = (
+    code: z.ZodIssueCode,
+  ): ValidationError['type'] => {
+    if (code === 'custom') return 'existence';
+    if (code === 'invalid_type') return 'required';
+    return 'format';
+  };
+
+  /**
+   * セクション単位でのバリデーション実行
+   */
+  const validateSection = useCallback(
+    async (section: keyof Settings, value: Settings[keyof Settings]) => {
+      try {
+        // セクションごとのスキーマを取得
+        const schema = SettingsSchema.shape[section];
+        await schema.parseAsync(value);
+
+        // バリデーション成功時はエラーをクリア
+        setValidationErrors((prev) => ({
+          ...prev,
+          [section]: {},
+        }));
+      } catch (err) {
+        if (err instanceof z.ZodError) {
+          // Zodのバリデーションエラーを整形
+          const errors = err.errors.reduce(
+            (acc, validationError) => {
+              const field =
+                validationError.path[validationError.path.length - 1];
+
+              if (typeof field === 'string') {
+                const validationErrorEntry = {
+                  message: validationError.message,
+                  type: determineErrorType(validationError.code),
+                };
+
+                (acc as Record<string, ValidationError>)[field] =
+                  validationErrorEntry;
+              }
+
+              return acc;
+            },
+            {} as ValidationState[typeof section],
+          );
+
+          // エラー状態を更新
+          setValidationErrors((prev) => ({
+            ...prev,
+            [section]: errors,
+          }));
+        }
+      }
+    },
+    [],
+  );
+
+  // 設定値の読み込み
+  useEffect(() => {
+    setLoading(true);
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    const loadSettings = async () => {
+      try {
+        const loadedSettings = await settingsApi.getSettings({
+          showAlert: false,
+          throwError: true,
+        });
+
+        if (loadedSettings) {
+          setSettings(loadedSettings);
+
+          // 各セクションのバリデーションを実行
+          Object.entries(loadedSettings).forEach(([section, value]) => {
+            validateSection(section as keyof Settings, value);
+          });
+        }
+
+        setLoading(false);
+
+        // 読み込み成功したらポーリングを停止
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+      } catch (err) {
+        console.error('設定の読み込みに処理失敗しました:', err);
+        // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
+        if (!intervalId) {
+          intervalId = setInterval(loadSettings, 5000);
+        }
+      }
+    };
+
+    // 初回読み込み
+    loadSettings();
+
+    // クリーンアップでポーリング停止
+    return () => {
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
+    };
+  }, [validateSection]);
+
+  // エージェント状態の初回ポーリング処理（エラーが発生しなくなるまでポーリング継続）
+  useEffect(() => {
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    const loadAgentStatus = async () => {
+      try {
+        await fetchAgentStatus();
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+      } catch (error) {
+        console.error('エージェント状態の取得に失敗しました:', error);
+        // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
+        if (!intervalId) {
+          intervalId = setInterval(loadAgentStatus, 5000);
+        }
+      }
+    };
+
+    // 初回取得
+    loadAgentStatus();
+
+    // クリーンアップでポーリング停止
+    return () => {
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
+    };
+  }, [fetchAgentStatus]);
+
+  // 設定更新時のエージェント状態ポーリング処理
+  useEffect(() => {
+    let intervalId: ReturnType<typeof setInterval> | null = null;
+
+    if (!agentStatusPolling) {
+      if (intervalId) {
+        clearInterval(intervalId);
+        intervalId = null;
+      }
+      return;
+    }
+
+    const pollAgentStatus = async () => {
+      try {
+        await fetchAgentStatus();
+      } catch (error) {
+        console.error(
+          'エージェント状態のポーリング中にエラーが発生しました:',
+          error,
+        );
+      }
+    };
+
+    // ポーリング開始
+    intervalId = setInterval(pollAgentStatus, 5000);
+
+    // クリーンアップでポーリング停止
+    return () => {
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
+    };
+  }, [agentStatusPolling, fetchAgentStatus]);
+
+
+  /**
+   * フィールドの更新処理
+   */
+  const updateField = useCallback(
+    async (section: keyof Settings, field: string, value: unknown) => {
+      // 設定値を更新
+      setSettings((prev) => {
+        const newSettings = {
+          ...prev,
+          [section]: {
+            ...prev[section],
+            [field]: value,
+          },
+        };
+
+        // バリデーション実行
+        validateSection(section, newSettings[section]);
+
+        return newSettings;
+      });
+    },
+    [validateSection],
+  );
+
+  /**
+   * 全体のバリデーションチェック
+   */
+  const validateAll = async () => {
+    try {
+      await SettingsSchema.parseAsync(settings);
+      return true;
+    } catch {
+      return false;
+    }
+  };
+
+  /**
+   * 設定の保存処理
+   */
+  const saveSettings = async (): Promise<boolean> => {
+    setSaving(true);
+    setSaveError(null);
+
+    try {
+      // 全体のバリデーションを実行
+      const isValid = await validateAll();
+      if (!isValid) {
+        throw internalError('不正な設定値があります', {
+          expose: true,
+        });
+      }
+
+      // 設定を一括保存
+      await settingsApi.setSettings(settings, {
+        showAlert: false,
+        throwError: true,
+      });
+
+      // 再初期化処理開始のキック
+      settingsApi.reinitialize({
+        showAlert: false,
+        throwError: false, // エラーはイベントpushで処理するため
+      });
+
+      // 完了イベントの購読を開始（ワンショット）
+      const unsubscribe = settingsApi.subscribeSettingsUpdateFinished((payload: { success: boolean; error?: string }) => {
+        // 設定更新完了時にポーリングを停止
+        setAgentStatusPolling(false);
+
+        if (payload.success) {
+          // 成功時：最新データを取得
+          try {
+            fetchAgentStatus();
+          } catch (error) {
+            console.error('エージェント状態取得に失敗しました:', error);
+            addAlert({
+              message: getSafeErrorMessage(error, 'AIツール情報の取得に失敗しました'),
+              severity: 'error',
+            });
+          }
+        } else {
+          // 失敗時：エラー状態設定
+          addAlert({
+            message: `エージェント初期化に失敗しました\n${payload.error || '不明なエラーが発生しました'}`,
+            severity: 'error',
+          });
+        }
+        // 処理完了と同時に購読解除
+        unsubscribe();
+      });
+
+      setUpdatedFlg(true);
+
+      // 設定更新後にポーリング開始
+      setAgentStatusPolling(true);
+
+      return true;
+    } catch (err) {
+      setSaveError(
+        err instanceof Error
+          ? err.message
+          : '設定保存処理で予期せぬエラーが発生しました',
+      );
+      return false;
+    } finally {
+      setSaving(false);
+    }
+  };
+
+  /**
+   * すべてのバリデーションが通過しているかチェック
+   */
+  const isValid = Object.values(validationErrors).every(
+    (sectionErrors) => Object.keys(sectionErrors).length === 0,
+  );
+
+  return {
+    settings,
+    validationErrors,
+    loading,
+    saveError,
+    updateField,
+    saveSettings,
+    isValid,
+    saving,
+  };
+};
+
+export default useSettingsStore;
diff --git a/src/renderer/hooks/useSettingsStatus.ts b/src/renderer/hooks/useSettingsStatus.ts
deleted file mode 100644
index 054196a9d..000000000
--- a/src/renderer/hooks/useSettingsStatus.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-import { useCallback, useEffect } from 'react';
-import { useSettingsZustandStore } from '../stores/settingsZustandStore';
-
-const useSettingsStatus = () => {
-  const { status, setStatus, closeMessage, updatedFlg, setUpdatedFlg } =
-    useSettingsZustandStore();
-
-  // ポーリング処理
-  const startPolling = useCallback(() => {
-    let intervalId: ReturnType<typeof setInterval>;
-
-    const pollStatus = async () => {
-      const agentStatus = await window.electron.settings.getStatus();
-      setStatus(agentStatus);
-
-      if (agentStatus.state !== 'saving') {
-        clearInterval(intervalId);
-        setUpdatedFlg(false);
-      }
-    };
-
-    // 初回実行
-    pollStatus();
-    intervalId = setInterval(pollStatus, 5000);
-    return () => clearInterval(intervalId);
-  }, [setStatus, setUpdatedFlg]);
-
-  // 初期マウント時のポーリング
-  useEffect(() => {
-    return startPolling();
-  }, [startPolling]);
-
-  // 設定保存時のポーリング再開
-  useEffect(() => {
-    if (updatedFlg) {
-      setStatus({ state: 'saving', messages: [] });
-      startPolling();
-    }
-  }, [updatedFlg, setStatus, startPolling]);
-
-  return {
-    status,
-    closeMessage,
-  };
-};
-
-export default useSettingsStatus;
diff --git a/src/renderer/hooks/useSettingsStore.ts b/src/renderer/hooks/useSettingsStore.ts
deleted file mode 100644
index 0eda2262e..000000000
--- a/src/renderer/hooks/useSettingsStore.ts
+++ /dev/null
@@ -1,335 +0,0 @@
-import { useState, useCallback, useEffect } from 'react';
-import { z } from 'zod';
-import type { StoreSchema as Settings } from '../../main/store';
-import {
-  SettingsSchema,
-  type ValidationState,
-  type ValidationError,
-} from '../../main/types/settingsSchema';
-import { useElectronStore } from './useElectronStore';
-import { useSettingsZustandStore } from '../stores/settingsZustandStore';
-
-/**
- * 設定値の型安全な管理と検証を行うフック
- */
-const useSettingsStore = () => {
-  // 各セクションの設定値を取得
-  const {
-    value: databaseStore,
-    loading: loadingDatabase,
-    setValue: setDatabaseStore,
-  } = useElectronStore<Settings['database']>('database');
-
-  const {
-    value: sourceStore,
-    loading: loadingSource,
-    setValue: setSourceStore,
-  } = useElectronStore<Settings['source']>('source');
-
-  const {
-    value: apiStore,
-    loading: loadingApi,
-    setValue: setApiStore,
-  } = useElectronStore<Settings['api']>('api');
-
-  const {
-    value: redmineStore,
-    loading: loadingRedmine,
-    setValue: setRedmineStore,
-  } = useElectronStore<Settings['redmine']>('redmine');
-
-  const {
-    value: gitlabStore,
-    loading: loadingGitlab,
-    setValue: setGitlabStore,
-  } = useElectronStore<Settings['gitlab']>('gitlab');
-
-  const {
-    value: mcpStore,
-    loading: loadingMcp,
-    setValue: setMcpStore,
-  } = useElectronStore<Settings['mcp']>('mcp');
-
-  const {
-    value: systemPromptStore,
-    loading: loadingSystemPrompt,
-    setValue: setSystemPromptStore,
-  } = useElectronStore<Settings['systemPrompt']>('systemPrompt');
-
-  // ローディング状態の管理
-  const loading =
-    loadingDatabase ||
-    loadingSource ||
-    loadingApi ||
-    loadingRedmine ||
-    loadingGitlab ||
-    loadingMcp ||
-    loadingSystemPrompt;
-
-  // 設定値の状態管理
-  const [settings, setSettings] = useState<Settings>({
-    database: { dir: '' },
-    source: { registerDir: './source' },
-    api: { key: '', url: '', model: '' },
-    redmine: { endpoint: '', apiKey: '' },
-    gitlab: { endpoint: '', apiKey: '' },
-    mcp: { serverConfigText: '{}' },
-    systemPrompt: { content: '' },
-  });
-
-  // 変更前の設定値を保持するstate
-  // const [originalSettings, setOriginalSettings] = useState<Settings>({
-  //   database: { dir: '' },
-  //   source: { registerDir: './source' },
-  //   api: { key: '', url: '', model: '' },
-  //   redmine: { endpoint: '', apiKey: '' },
-  //   gitlab: { endpoint: '', apiKey: '' },
-  //   mcp: { serverConfigText: '{}' },
-  //   systemPrompt: { content: '' },
-  // });
-
-  // バリデーションエラーの状態管理
-  const [validationErrors, setValidationErrors] = useState<ValidationState>({
-    database: {},
-    source: {},
-    api: {},
-    redmine: {},
-    gitlab: {},
-    mcp: {},
-    systemPrompt: {},
-  });
-
-  const [saving, setSaving] = useState(false);
-  const [error, setError] = useState<string | null>(null);
-  const { setUpdatedFlg } = useSettingsZustandStore();
-
-  /**
-   * バリデーションエラーの種類を判定
-   */
-  const determineErrorType = (
-    code: z.ZodIssueCode,
-  ): ValidationError['type'] => {
-    if (code === 'custom') return 'existence';
-    if (code === 'invalid_type') return 'required';
-    return 'format';
-  };
-
-  /**
-   * セクション単位でのバリデーション実行
-   */
-  const validateSection = useCallback(
-    async (section: keyof Settings, value: Settings[keyof Settings]) => {
-      try {
-        // セクションごとのスキーマを取得
-        const schema = SettingsSchema.shape[section];
-        await schema.parseAsync(value);
-
-        // バリデーション成功時はエラーをクリア
-        setValidationErrors((prev) => ({
-          ...prev,
-          [section]: {},
-        }));
-      } catch (err) {
-        if (err instanceof z.ZodError) {
-          // Zodのバリデーションエラーを整形
-          const errors = err.errors.reduce(
-            (acc, validationError) => {
-              const field =
-                validationError.path[validationError.path.length - 1];
-
-              if (typeof field === 'string') {
-                const validationErrorEntry = {
-                  message: validationError.message,
-                  type: determineErrorType(validationError.code),
-                };
-
-                (acc as Record<string, ValidationError>)[field] =
-                  validationErrorEntry;
-              }
-
-              return acc;
-            },
-            {} as ValidationState[typeof section],
-          );
-
-          // エラー状態を更新
-          setValidationErrors((prev) => ({
-            ...prev,
-            [section]: errors,
-          }));
-        }
-      }
-    },
-    [],
-  );
-
-  // ストアからの値の更新を監視
-  useEffect(() => {
-    if (!loading) {
-      const newSettings = {
-        database: databaseStore ?? { dir: '' },
-        source: sourceStore ?? { registerDir: '' },
-        api: apiStore ?? { key: '', url: '', model: '' },
-        redmine: redmineStore ?? { endpoint: '', apiKey: '' },
-        gitlab: gitlabStore ?? { endpoint: '', apiKey: '' },
-        mcp: {
-          serverConfigText: mcpStore.serverConfigText ?? {
-            serverConfigText: '{}',
-          },
-        },
-        systemPrompt: systemPromptStore ?? { content: '' },
-      };
-
-      setSettings(newSettings);
-      // setOriginalSettings(newSettings);
-
-      // 各セクションのバリデーションを実行
-      Object.entries(newSettings).forEach(([section, value]) => {
-        validateSection(section as keyof Settings, value);
-      });
-    }
-  }, [
-    databaseStore,
-    sourceStore,
-    apiStore,
-    redmineStore,
-    gitlabStore,
-    mcpStore,
-    systemPromptStore,
-    loading,
-    validateSection,
-  ]);
-
-  /**
-   * フィールドの更新処理
-   */
-  const updateField = useCallback(
-    async (section: keyof Settings, field: string, value: unknown) => {
-      // 設定値を更新
-      setSettings((prev) => {
-        const newSettings = {
-          ...prev,
-          [section]: {
-            ...prev[section],
-            [field]: value,
-          },
-        };
-
-        // バリデーション実行
-        validateSection(section, newSettings[section]);
-
-        return newSettings;
-      });
-    },
-    [validateSection],
-  );
-
-  /**
-   * 全体のバリデーションチェック
-   */
-  const validateAll = async () => {
-    try {
-      await SettingsSchema.parseAsync(settings);
-      return true;
-    } catch {
-      return false;
-    }
-  };
-
-  /**
-   * 設定が変更されたかどうかを判定する
-   */
-  // const hasSettingsChanged = useMemo(() => {
-  //   return JSON.stringify(settings) !== JSON.stringify(originalSettings);
-  // }, [settings, originalSettings]);
-
-  /**
-   * Mastra初期化に関わる設定が変更されたかをチェック
-   */
-  // const requiresReinitialization = useMemo(() => {
-  //   // 設定が変更されていない場合は初期化不要
-  //   if (!hasSettingsChanged) {
-  //     return false;
-  //   }
-
-  //   // システムプロンプトとドキュメントディレクトリ以外の変更があるかチェック
-  //   const hasChanges = Object.entries(settings).some(([key, value]) => {
-  //     if (key === 'systemPrompt' || key === 'source') {
-  //       return false;
-  //     }
-  //     return (
-  //       JSON.stringify(value) !==
-  //       JSON.stringify(originalSettings[key as keyof Settings])
-  //     );
-  //   });
-
-  //   // システムプロンプトまたはドキュメントディレクトリのみの変更の場合はfalse
-  //   return hasChanges;
-  // }, [settings, originalSettings, hasSettingsChanged]);
-
-  /**
-   * 設定の保存処理
-   */
-  const saveSettings = async (): Promise<boolean> => {
-    setSaving(true);
-    setError(null);
-
-    try {
-      // 全体のバリデーションを実行
-      const isValid = await validateAll();
-      if (!isValid) {
-        throw new Error('入力内容に誤りがあります');
-      }
-
-      // 各セクションの設定を保存
-      await Promise.all([
-        setDatabaseStore(settings.database),
-        setSourceStore(settings.source),
-        setApiStore(settings.api),
-        setRedmineStore(settings.redmine),
-        setGitlabStore(settings.gitlab),
-        setMcpStore(settings.mcp),
-        setSystemPromptStore(settings.systemPrompt),
-      ]);
-
-      // 必要な場合のみMastraを再初期化
-      // if (requiresReinitialization) {
-      //   await window.electron.settings.reinitialize();
-      // }
-      await window.electron.settings.reinitialize();
-      setUpdatedFlg(true);
-
-      // 新しい設定を元の設定として保存
-      // setOriginalSettings(settings);
-
-      return true;
-    } catch (err) {
-      setError(
-        err instanceof Error ? err.message : '不明なエラーが発生しました',
-      );
-      return false;
-    } finally {
-      setSaving(false);
-    }
-  };
-
-  /**
-   * すべてのバリデーションが通過しているかチェック
-   */
-  const isValid = Object.values(validationErrors).every(
-    (sectionErrors) => Object.keys(sectionErrors).length === 0,
-  );
-
-  return {
-    settings,
-    validationErrors,
-    loading,
-    error,
-    updateField,
-    saveSettings,
-    isValid,
-    saving,
-  };
-};
-
-export default useSettingsStore;
diff --git a/src/renderer/lib/ElectronPushClient.ts b/src/renderer/lib/ElectronPushClient.ts
new file mode 100644
index 000000000..6f16f7c9f
--- /dev/null
+++ b/src/renderer/lib/ElectronPushClient.ts
@@ -0,0 +1,28 @@
+import type { Channel, PushClient, PushEvent } from '@/types';
+import { internalError } from './error';
+
+// Rendererプロセス側で使うPushクライアント実装
+export class ElectronPushClient implements PushClient {
+  subscribe<C extends Channel>(
+    channel: C,
+    onEvent: (ev: PushEvent<C>) => void,
+    opts?: { signal?: AbortSignal },
+  ): () => void {
+    if (!window.electron.pushApi) {
+      throw internalError('pushApi not available', {
+        expose: false,
+      });
+    }
+    // preload経由で購読登録
+    let unsub = () => {};
+    // 非同期を吸収するため、即時IIFEで握る
+    (async () => {
+      unsub = await window.electron.pushApi.subscribe(channel, onEvent);
+    })();
+    // AbortSignalで解除できるようにする
+    opts?.signal?.addEventListener('abort', () => {
+      unsub();
+    });
+    return () => unsub();
+  }
+}
diff --git a/src/renderer/lib/apiUtils.ts b/src/renderer/lib/apiUtils.ts
new file mode 100644
index 000000000..3ac8eac63
--- /dev/null
+++ b/src/renderer/lib/apiUtils.ts
@@ -0,0 +1,56 @@
+import { IpcResult } from '@/types';
+import { alertStore } from '../stores/alertStore';
+import { ApiServiceDefaultOptions } from '../types';
+import { appApiCallError, appApiError } from './error';
+
+/**
+ * API通信の結果を取り出す関数
+ */
+export function getData<T>(
+  result: IpcResult<T>,
+  options?: ApiServiceDefaultOptions,
+): T | null {
+  const showAlert = options?.showAlert ?? false;
+  const throwError = options?.throwError ?? true;
+
+  if (result.success) {
+    return result.data as T;
+  } else {
+    console.error(result.error);
+    if (showAlert) {
+      alertStore.getState().addAlert({
+        message: result.error?.message || '不明なエラー',
+        severity: 'error',
+      });
+    }
+    if (throwError) {
+      throw appApiError(result.error!);
+    }
+    return null;
+  }
+}
+
+/**
+ * API通信を行う関数をラップ
+ */
+export async function invokeApi<T>(
+  fn: () => Promise<IpcResult<T>>,
+  options?: ApiServiceDefaultOptions,
+): Promise<T | null> {
+  const showAlert = options?.showAlert ?? false;
+  const throwError = options?.throwError ?? true;
+  let result: IpcResult<T>;
+  try {
+    result = await fn();
+  } catch (error) {
+    console.error('API通信に失敗しました:', error);
+    if (throwError) {
+      throw appApiCallError(error);
+    }
+    result = {
+      success: false,
+      error: { message: 'API通信に失敗しました', code: 'INTERNAL' },
+    };
+  }
+  return getData(result, options);
+}
diff --git a/src/renderer/utils/csvUtils.ts b/src/renderer/lib/csvUtils.ts
similarity index 98%
rename from src/renderer/utils/csvUtils.ts
rename to src/renderer/lib/csvUtils.ts
index 889bf858f..0820ead17 100644
--- a/src/renderer/utils/csvUtils.ts
+++ b/src/renderer/lib/csvUtils.ts
@@ -1,4 +1,4 @@
-import { ReviewChecklistResultDisplay } from '../../main/types';
+import { ReviewChecklistResultDisplay } from '@/types';
 
 /**
  * CSV用文字列のエスケープ処理
diff --git a/src/renderer/lib/error.ts b/src/renderer/lib/error.ts
new file mode 100644
index 000000000..2e7cdbc9b
--- /dev/null
+++ b/src/renderer/lib/error.ts
@@ -0,0 +1,73 @@
+import { FrontErrorCode, AppErrorPayload } from '@/types';
+
+/**
+ * 例外として扱うアプリケーションエラー。
+ * - expose: true のときのみ message をクライアントに出す
+ */
+export class FrontAppError extends Error {
+  public readonly expose: boolean;
+  public readonly errorCode: FrontErrorCode;
+  // ログに出すための追加情報
+  public readonly couse?: unknown;
+
+  constructor(
+    errorCode: FrontErrorCode,
+    message: string,
+    options?: {
+      expose?: boolean;
+      cause?: unknown;
+    },
+  ) {
+    super(message);
+    this.name = 'FrontAppError';
+    this.errorCode = errorCode;
+    this.expose = options?.expose ?? false;
+    this.couse = options?.cause;
+  }
+
+  override get message(): string {
+    return this.expose ? super.message : '予期せぬエラーが発生しました';
+  }
+}
+
+// よく使うビルダー
+export const appApiError = (error: AppErrorPayload) =>
+  new FrontAppError('APP_API', error.message, { expose: true });
+
+export const appApiCallError = (error: unknown) =>
+  new FrontAppError('APP_API_CALL', 'API通信に失敗しました', {
+    expose: true,
+    cause: error,
+  });
+
+export const internalError = (
+  message: string,
+  options?: {
+    expose?: boolean;
+    cause?: unknown;
+  },
+) => new FrontAppError('INTERNAL', message, options);
+
+/**
+ * 予期しない例外を AppError に正規化。
+ * - 既に AppError → そのまま
+ * - ZodError → VALIDATION に変換
+ * - それ以外 → INTERNAL に丸める
+ */
+export function normalizeUnknownError(err: unknown): FrontAppError {
+  if (err instanceof FrontAppError) return err;
+  if (err instanceof Error) {
+    return internalError(err.message, { expose: false, cause: err });
+  }
+  return internalError('予期せぬエラーが発生しました');
+}
+
+export function getSafeErrorMessage(err: unknown, title?: string): string {
+  const normalizedError = normalizeUnknownError(err);
+  if (normalizedError.errorCode === 'APP_API') {
+    return normalizedError.message;
+  }
+  return title
+    ? `${title}\n${normalizedError.message}`
+    : normalizedError.message;
+}
diff --git a/src/renderer/lib/logger.ts b/src/renderer/lib/logger.ts
new file mode 100644
index 000000000..8a6c5c37a
--- /dev/null
+++ b/src/renderer/lib/logger.ts
@@ -0,0 +1,12 @@
+import Logger from 'electron-log';
+import log from 'electron-log/renderer';
+
+// シングルトン変数
+let _rendererLogger: Logger.RendererLogger | null = null;
+
+export function getRendererLogger() {
+  if (!_rendererLogger) {
+    _rendererLogger = log;
+  }
+  return _rendererLogger;
+}
diff --git a/src/renderer/utils/pdfUtils.ts b/src/renderer/lib/pdfUtils.ts
similarity index 85%
rename from src/renderer/utils/pdfUtils.ts
rename to src/renderer/lib/pdfUtils.ts
index 1f7c41657..a9fd5fd84 100644
--- a/src/renderer/utils/pdfUtils.ts
+++ b/src/renderer/lib/pdfUtils.ts
@@ -1,4 +1,5 @@
 import * as pdfjsLib from 'pdfjs-dist';
+import { internalError } from './error';
 
 // PDF.jsのワーカーを設定
 const workerUrl = new URL('pdf.worker.mjs', window.location.href).toString();
@@ -29,7 +30,11 @@ export const convertPdfBytesToImages = async (
 
     const canvas = document.createElement('canvas');
     const ctx = canvas.getContext('2d');
-    if (!ctx) throw new Error('Canvas context could not be created');
+    if (!ctx) {
+      throw internalError('Canvas context could not be created', {
+        expose: true,
+      });
+    }
 
     canvas.width = viewport.width;
     canvas.height = viewport.height;
@@ -46,7 +51,11 @@ export const convertPdfBytesToImages = async (
 export const combineImages = async (
   imageDataArray: string[],
 ): Promise<string> => {
-  if (imageDataArray.length === 0) throw new Error('画像データが空です');
+  if (imageDataArray.length === 0) {
+    throw internalError('画像データが空です', {
+      expose: true,
+    });
+  }
   if (imageDataArray.length === 1) return imageDataArray[0];
 
   const images = await Promise.all(
@@ -66,7 +75,11 @@ export const combineImages = async (
 
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
-  if (!context) throw new Error('Canvas context could not be created');
+  if (!context) {
+    throw internalError('Canvas context could not be created', {
+      expose: true,
+    });
+  }
 
   canvas.width = maxWidth;
   canvas.height = totalHeight;
diff --git a/src/renderer/service/chatApi.ts b/src/renderer/service/chatApi.ts
new file mode 100644
index 000000000..28b44f9ab
--- /dev/null
+++ b/src/renderer/service/chatApi.ts
@@ -0,0 +1,170 @@
+import { ChatMessage, ChatRoom, IpcChannels, IpcEventPayload } from '@/types';
+import { invokeApi } from '../lib/apiUtils';
+import { ApiServiceDefaultOptions } from '../types';
+import { ElectronPushClient } from '../lib/ElectronPushClient';
+
+export interface IChatApi {
+  getChatRooms(options?: ApiServiceDefaultOptions): Promise<ChatRoom[] | null>;
+  deleteChatRoom(
+    roomId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  streamResponse(callbacks: {
+    onMessage: (chunk: IpcEventPayload<typeof IpcChannels.CHAT_STREAM>) => void;
+    onDone: () => void;
+    onError: (error: Error) => void;
+  }): () => void;
+  abortChatRequest(roomId: string, options?: ApiServiceDefaultOptions): void;
+  getChatMessages(
+    roomId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<ChatMessage[] | null>;
+  createThread(
+    roomId: string,
+    title: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  sendMessage(
+    roomId: string,
+    messages: ChatMessage[],
+    options?: ApiServiceDefaultOptions,
+  ): void;
+  deleteMessagesBeforeSpecificId(
+    roomId: string,
+    messageId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+}
+
+// IPC通信を使用してメインプロセスのAIエージェントへメッセージを送信するためのチャットサービス
+export class ChatApi implements IChatApi {
+  // シングルトン変数
+  private static instance: ChatApi;
+
+  // コンストラクタをprivateにして外部からのインスタンス化を防止
+  private constructor() {}
+
+  // シングルトンインスタンスを取得するための静的メソッド
+  public static getInstance(): ChatApi {
+    if (!ChatApi.instance) {
+      ChatApi.instance = new ChatApi();
+    }
+    return ChatApi.instance;
+  }
+
+  /**
+   * チャットルーム一覧を取得
+   * @returns チャットルーム配列
+   */
+  public async getChatRooms(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<ChatRoom[] | null> {
+    // IPCを使用してメインプロセスから取得
+    return invokeApi(() => window.electron.chat.getRooms(), options);
+  }
+
+  /**
+   * チャットルームを削除
+   * @param roomId チャットルームID
+   */
+  public async deleteChatRoom(
+    roomId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    // IPCを使用してメインプロセスから削除
+    await invokeApi(() => window.electron.chat.deleteRoom(roomId), options);
+  }
+
+  public streamResponse(callbacks: {
+    onMessage: (chunk: IpcEventPayload<typeof IpcChannels.CHAT_STREAM>) => void;
+    onDone: () => void;
+    onError: (error: Error) => void;
+  }): () => void {
+    const pushClient = new ElectronPushClient();
+    const abortController = new AbortController();
+
+    // ストリーミングイベントの購読
+    pushClient.subscribe(
+      IpcChannels.CHAT_STREAM,
+      (event) => {
+        callbacks.onMessage(event.payload);
+      },
+      { signal: abortController.signal },
+    );
+
+    // 完了イベントの購読
+    pushClient.subscribe(
+      IpcChannels.CHAT_COMPLETE,
+      () => {
+        // 購読を解除
+        abortController.abort();
+        // 完了コールバックを呼び出し
+        callbacks.onDone();
+      },
+      { signal: abortController.signal },
+    );
+
+    // エラーイベントの購読
+    pushClient.subscribe(
+      IpcChannels.CHAT_ERROR,
+      (event) => {
+        // 購読を解除
+        abortController.abort();
+        // エラーコールバックを呼び出し
+        callbacks.onError(
+          new Error(event.payload.message || '予期せぬエラーが発生しました'),
+        );
+      },
+      { signal: abortController.signal },
+    );
+
+    // 購読解除のためのクリーンアップ
+    return () => {
+      abortController.abort();
+    };
+  }
+
+  public async abortChatRequest(
+    roomId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.chat.requestAbort({
+      threadId: roomId,
+    }), options);
+  }
+
+  public async getChatMessages(
+    roomId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<ChatMessage[] | null> {
+    return invokeApi(() => window.electron.chat.getMessages(roomId), options);
+  }
+
+  public async createThread(
+    roomId: string,
+    title: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.chat.createThread({ roomId, title }), options);
+  }
+
+  public async sendMessage(
+    roomId: string,
+    messages: ChatMessage[],
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.chat.sendMessage({ roomId, messages }), options);
+    console.log('Message sent via IPC:', { roomId, messages });
+  }
+
+  public async deleteMessagesBeforeSpecificId(
+    roomId: string,
+    messageId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.chat.deleteMessagesBeforeSpecificId({
+      threadId: roomId,
+      messageId,
+    }), options);
+  }
+}
diff --git a/src/renderer/service/fsApi.ts b/src/renderer/service/fsApi.ts
new file mode 100644
index 000000000..3de64d078
--- /dev/null
+++ b/src/renderer/service/fsApi.ts
@@ -0,0 +1,55 @@
+import { OpenDialogOptions } from 'electron';
+import { invokeApi } from '../lib/apiUtils';
+import { ApiServiceDefaultOptions } from '../types';
+
+export interface IFsApi {
+  showOpenDialog(
+    options: OpenDialogOptions,
+    apiOptions?: ApiServiceDefaultOptions,
+  ): Promise<{ filePaths: string[]; canceled: boolean } | null>;
+  readFile(
+    filePath: string,
+    apiOptions?: ApiServiceDefaultOptions,
+  ): Promise<Uint8Array | null>;
+  access(
+    path: string,
+    apiOptions?: ApiServiceDefaultOptions,
+  ): Promise<boolean | null>;
+}
+
+export class FsApi implements IFsApi {
+  // シングルトン変数
+  private static instance: FsApi;
+
+  // コンストラクタをprivateにして外部からのインスタンス化を防止
+  private constructor() {}
+
+  // シングルトンインスタンスを取得するための静的メソッド
+  public static getInstance(): FsApi {
+    if (!FsApi.instance) {
+      FsApi.instance = new FsApi();
+    }
+    return FsApi.instance;
+  }
+
+  public async showOpenDialog(
+    options: OpenDialogOptions,
+    apiOptions?: ApiServiceDefaultOptions,
+  ): Promise<{ filePaths: string[]; canceled: boolean } | null> {
+    return invokeApi(() => window.electron.fs.showOpenDialog(options), apiOptions);
+  }
+
+  public async readFile(
+    filePath: string,
+    apiOptions?: ApiServiceDefaultOptions,
+  ): Promise<Uint8Array | null> {
+    return invokeApi(() => window.electron.fs.readFile(filePath), apiOptions);
+  }
+
+  public async access(
+    path: string,
+    apiOptions?: ApiServiceDefaultOptions,
+  ): Promise<boolean | null> {
+    return invokeApi(() => window.electron.fs.access(path), apiOptions);
+  }
+}
diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
new file mode 100644
index 000000000..50f98c17f
--- /dev/null
+++ b/src/renderer/service/reviewApi.ts
@@ -0,0 +1,210 @@
+import {
+  ReviewChecklistResultDisplay,
+  UploadFile,
+  DocumentType,
+  ReviewChecklistEdit,
+  ChecklistExtractionResultStatus,
+  ReviewExecutionResultStatus,
+} from '@/types';
+import { ApiServiceDefaultOptions } from '../types';
+import { invokeApi } from '../lib/apiUtils';
+import { ReviewHistory } from '@/db/schema';
+import { ElectronPushClient } from '../lib/ElectronPushClient';
+import { IpcChannels } from '@/types';
+
+export interface IReviewApi {
+  getHistories(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<ReviewHistory[] | null>;
+  deleteHistory(
+    historyId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  getReviewHistoryDetail(
+    historyId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<{
+    checklistResults?: ReviewChecklistResultDisplay[];
+  } | null>;
+  getReviewInstruction(
+    historyId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<{
+    additionalInstructions?: string;
+    commentFormat?: string;
+  } | null>;
+  extractChecklist(
+    historyId: string,
+    files: UploadFile[],
+    documentType?: DocumentType,
+    checklistRequirements?: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  executeReview(
+    historyId: string,
+    files: UploadFile[],
+    additionalInstructions?: string,
+    commentFormat?: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  subscribeChecklistExtractionFinished(
+    callback: (payload: {
+      status: ChecklistExtractionResultStatus;
+      error?: string;
+    }) => void,
+  ): () => void;
+  subscribeReviewExtractionFinished(
+    callback: (payload: {
+      status: ReviewExecutionResultStatus;
+      error?: string;
+    }) => void,
+  ): () => void;
+  updateChecklist(
+    historyId: string,
+    checklistEdits: ReviewChecklistEdit[],
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+}
+
+export class ReviewApi implements IReviewApi {
+  // シングルトン変数
+  private static instance: ReviewApi;
+
+  // コンストラクタをprivateにして外部からのインスタンス化を防止
+  private constructor() {}
+
+  // シングルトンインスタンスを取得するための静的メソッド
+  public static getInstance(): ReviewApi {
+    if (!ReviewApi.instance) {
+      ReviewApi.instance = new ReviewApi();
+    }
+    return ReviewApi.instance;
+  }
+
+  public async getHistories(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<ReviewHistory[] | null> {
+    return invokeApi(() => window.electron.review.getHistories(), options);
+  }
+
+  public async deleteHistory(
+    historyId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.review.deleteHistory(historyId), options);
+  }
+
+  public async getReviewHistoryDetail(
+    historyId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<{
+    checklistResults?: ReviewChecklistResultDisplay[];
+  } | null> {
+    return invokeApi(() => window.electron.review.getHistoryDetail(historyId), options);
+  }
+
+  public async getReviewInstruction(
+    historyId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<{
+    additionalInstructions?: string;
+    commentFormat?: string;
+  } | null> {
+    return invokeApi(() => window.electron.review.getHistoryInstruction(historyId), options);
+  }
+
+  public async extractChecklist(
+    historyId: string,
+    files: UploadFile[],
+    documentType?: DocumentType,
+    checklistRequirements?: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.review.extractChecklist({
+      reviewHistoryId: historyId,
+      files,
+      documentType,
+      checklistRequirements,
+    }), options);
+  }
+
+  public async executeReview(
+    historyId: string,
+    files: UploadFile[],
+    additionalInstructions?: string,
+    commentFormat?: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.review.execute({
+      reviewHistoryId: historyId,
+      files,
+      additionalInstructions,
+      commentFormat,
+    }), options);
+  }
+
+  /**
+   * チェックリスト抽出処理をキャンセル
+   * @param reviewHistoryId レビュー履歴ID
+   * @param options API オプション
+   */
+  public async abortExtractChecklist(
+    reviewHistoryId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.review.abortExtractChecklist(reviewHistoryId), options);
+  }
+
+  /**
+   * レビュー実行処理をキャンセル
+   * @param reviewHistoryId レビュー履歴ID
+   * @param options API オプション
+   */
+  public async abortExecuteReview(
+    reviewHistoryId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.review.abortExecute(reviewHistoryId), options);
+  }
+
+  public subscribeChecklistExtractionFinished(
+    callback: (payload: {
+      status: ChecklistExtractionResultStatus;
+      error?: string;
+    }) => void,
+  ): () => void {
+    const pushClient = new ElectronPushClient();
+    return pushClient.subscribe(
+      IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+      (event) => {
+        callback(event.payload);
+      },
+    );
+  }
+
+  public subscribeReviewExtractionFinished(
+    callback: (payload: {
+      status: ReviewExecutionResultStatus;
+      error?: string;
+    }) => void,
+  ): () => void {
+    const pushClient = new ElectronPushClient();
+    return pushClient.subscribe(
+      IpcChannels.REVIEW_EXECUTE_FINISHED,
+      (event) => {
+        callback(event.payload);
+      },
+    );
+  }
+
+  public async updateChecklist(
+    historyId: string,
+    checklistEdits: ReviewChecklistEdit[],
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.review.updateChecklist({
+      reviewHistoryId: historyId,
+      checklistEdits,
+    }), options);
+  }
+}
diff --git a/src/renderer/service/settingsApi.ts b/src/renderer/service/settingsApi.ts
new file mode 100644
index 000000000..c793945c9
--- /dev/null
+++ b/src/renderer/service/settingsApi.ts
@@ -0,0 +1,81 @@
+import { SettingsSavingStatus, Settings, IpcChannels } from '@/types';
+import { invokeApi } from '../lib/apiUtils';
+import { ApiServiceDefaultOptions } from '../types';
+import { ElectronPushClient } from '../lib/ElectronPushClient';
+
+export interface ISettingsApi {
+  getAgentStatus(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<SettingsSavingStatus | null>;
+  removeMessage(
+    messageId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  reinitialize(options?: ApiServiceDefaultOptions): Promise<void>;
+  getSettings(options?: ApiServiceDefaultOptions): Promise<Settings | null>;
+  setSettings(
+    settings: Settings,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<boolean | null>;
+  subscribeSettingsUpdateFinished(
+    callback: (payload: { success: boolean; error?: string }) => void,
+  ): () => void;
+}
+
+export class SettingsApi implements ISettingsApi {
+  // シングルトン変数
+  private static instance: SettingsApi;
+
+  // コンストラクタをprivateにして外部からのインスタンス化を防止
+  private constructor() {}
+
+  // シングルトンインスタンスを取得するための静的メソッド
+  public static getInstance(): SettingsApi {
+    if (!SettingsApi.instance) {
+      SettingsApi.instance = new SettingsApi();
+    }
+    return SettingsApi.instance;
+  }
+
+  public async getAgentStatus(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<SettingsSavingStatus | null> {
+    return invokeApi(() => window.electron.settings.getStatus(), options);
+  }
+
+  public async removeMessage(
+    messageId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.settings.removeMessage(messageId), options);
+  }
+
+  public async reinitialize(options?: ApiServiceDefaultOptions): Promise<void> {
+    await invokeApi(() => window.electron.settings.reinitialize(), options);
+  }
+
+  public async getSettings(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<Settings | null> {
+    return invokeApi(() => window.electron.settings.getSettings(), options);
+  }
+
+  public async setSettings(
+    settings: Settings,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<boolean | null> {
+    return invokeApi(() => window.electron.settings.setSettings(settings), options);
+  }
+
+  public subscribeSettingsUpdateFinished(
+    callback: (payload: { success: boolean; error?: string }) => void,
+  ): () => void {
+    const pushClient = new ElectronPushClient();
+    return pushClient.subscribe(
+      IpcChannels.SETTINGS_UPDATE_FINISHED,
+      (event) => {
+        callback(event.payload);
+      },
+    );
+  }
+}
diff --git a/src/renderer/service/sourceApi.ts b/src/renderer/service/sourceApi.ts
new file mode 100644
index 000000000..89845f15f
--- /dev/null
+++ b/src/renderer/service/sourceApi.ts
@@ -0,0 +1,69 @@
+import { invokeApi } from '../lib/apiUtils';
+import { ApiServiceDefaultOptions } from '../types';
+import { Source } from '@/db/schema';
+import { ElectronPushClient } from '../lib/ElectronPushClient';
+import { IpcChannels } from '@/types';
+
+export interface ISourceApi {
+  reloadSources(options?: ApiServiceDefaultOptions): Promise<void>;
+  getSources(options?: ApiServiceDefaultOptions): Promise<Source[] | null>;
+  updateSourceEnabled(
+    id: number,
+    enabled: boolean,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  subscribeSourceReloadFinished(
+    callback: (payload: { success: boolean; error?: string }) => void,
+  ): () => void;
+}
+
+export class SourceApi implements ISourceApi {
+  // シングルトン変数
+  private static instance: SourceApi;
+
+  // コンストラクタをprivateにして外部からのインスタンス化を防止
+  private constructor() {}
+
+  // シングルトンインスタンスを取得するための静的メソッド
+  public static getInstance(): SourceApi {
+    if (!SourceApi.instance) {
+      SourceApi.instance = new SourceApi();
+    }
+    return SourceApi.instance;
+  }
+
+  public async reloadSources(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.source.reloadSources(), options);
+  }
+
+  public async getSources(
+    options?: ApiServiceDefaultOptions,
+  ): Promise<Source[] | null> {
+    return invokeApi(() => window.electron.source.getSources(), options);
+  }
+
+  public async updateSourceEnabled(
+    id: number,
+    enabled: boolean,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(() => window.electron.source.updateSourceEnabled({
+      sourceId: id,
+      isEnabled: enabled,
+    }), options);
+  }
+
+  public subscribeSourceReloadFinished(
+    callback: (payload: { success: boolean; error?: string }) => void,
+  ): () => void {
+    const pushClient = new ElectronPushClient();
+    return pushClient.subscribe(
+      IpcChannels.SOURCE_RELOAD_FINISHED,
+      (event) => {
+        callback(event.payload);
+      },
+    );
+  }
+}
diff --git a/src/renderer/services/chatService.ts b/src/renderer/services/chatService.ts
deleted file mode 100644
index 54c19b753..000000000
--- a/src/renderer/services/chatService.ts
+++ /dev/null
@@ -1,130 +0,0 @@
-import { ChatMessage, ChatRoom } from '../../main/types';
-import { IpcChannels, IpcEventPayload } from '../../main/types/ipc';
-
-// IPC通信を使用してメインプロセスのAIエージェントへメッセージを送信するためのチャットサービス
-export const chatService = {
-  /**
-   * チャットルーム一覧を取得
-   * @returns チャットルーム配列
-   */
-  getChatRooms: async (): Promise<ChatRoom[]> => {
-    try {
-      // IPCを使用してメインプロセスから取得
-      const rooms = await window.electron.chat.getRooms();
-      return rooms || [];
-    } catch (error) {
-      console.error('チャットルーム一覧の取得に失敗しました:', error);
-      throw error;
-    }
-  },
-
-  /**
-   * チャットルームを削除
-   * @param roomId チャットルームID
-   */
-  deleteChatRoom: async (roomId: string): Promise<void> => {
-    try {
-      // IPCを使用してメインプロセスから削除
-      await window.electron.chat.deleteRoom(roomId);
-    } catch (error) {
-      console.error('チャットルームの削除に失敗しました:', error);
-      throw error;
-    }
-  },
-
-  /**
-   * 特定のチャットルームのメッセージ履歴を取得
-   * @param roomId チャットルームID
-   * @returns メッセージ配列
-   */
-  getChatMessages: async (roomId: string): Promise<ChatMessage[]> => {
-    try {
-      // IPCを使用してメインプロセスから取得
-      const messages = await window.electron.chat.getMessages(roomId);
-      return messages || [];
-    } catch (error) {
-      console.error('チャットメッセージの取得に失敗しました:', error);
-      return [];
-    }
-  },
-
-  /**
-   * チャットメッセージを送信
-   * @param roomId チャットルームID
-   * @param content メッセージ内容
-   * @returns 送信結果
-   */
-  sendMessage: (roomId: string, messages: ChatMessage[]): void => {
-    window.electron.chat.sendMessage({ roomId, messages });
-  },
-
-  /**
-   * 新規スレッドを作成
-   * @param roomId チャットルームID
-   */
-  createThread: async (roomId: string, title: string): Promise<void> => {
-    try {
-      const result = await window.electron.chat.createThread({
-        roomId,
-        title,
-      });
-      if (!result.success) {
-        throw new Error(result.error);
-      }
-    } catch (error) {
-      console.error('スレッドの作成に失敗しました:', error);
-      throw error;
-    }
-  },
-
-  /**
-   * ストリーミングでAIからの応答を取得
-   * @param callbacks コールバック関数群
-   */
-  streamResponse: (callbacks: {
-    onMessage: (chunk: IpcEventPayload<typeof IpcChannels.CHAT_STREAM>) => void;
-    onDone: () => void;
-    onError: (error: Error) => void;
-  }): (() => void) => {
-    // ストリーミングイベントの購読
-    const unsubscribeStream = window.electron.chat.onStream((chunk) => {
-      callbacks.onMessage(chunk);
-    });
-
-    // 完了イベントの購読
-    const unsubscribeComplete = window.electron.chat.onComplete(
-      // eslint-disable-next-line
-      () => {
-        // 購読を解除
-        unsubscribeStream();
-        unsubscribeComplete();
-        // eslint-disable-next-line
-        unsubscribeError();
-
-        // 完了コールバックを呼び出し
-        callbacks.onDone();
-      },
-    );
-
-    // エラーイベントの購読
-    const unsubscribeError = window.electron.chat.onError((error) => {
-      // 購読を解除
-      unsubscribeStream();
-      unsubscribeComplete();
-      unsubscribeError();
-
-      // エラーコールバックを呼び出し
-      callbacks.onError(
-        new Error(error.message || '不明なエラーが発生しました'),
-      );
-    });
-    // 購読解除のためのクリーンアップ
-    return () => {
-      unsubscribeStream();
-      unsubscribeComplete();
-      unsubscribeError();
-    };
-  },
-};
-
-export default chatService;
diff --git a/src/renderer/services/reviewService.ts b/src/renderer/services/reviewService.ts
deleted file mode 100644
index 38b774c89..000000000
--- a/src/renderer/services/reviewService.ts
+++ /dev/null
@@ -1,113 +0,0 @@
-import { ReviewHistory } from '../../db/schema';
-import { IpcChannels, IpcEventPayload } from '../../main/types/ipc';
-import { UploadFile } from '../components/review/types';
-
-// IPC通信を使用してメインプロセスとやり取りするレビュー機能用のサービス
-export const reviewService = {
-  /**
-   * ドキュメントレビュー履歴を取得
-   * @returns ドキュメントレビュー履歴配列
-   */
-  getHistories: async (): Promise<ReviewHistory[]> => {
-    try {
-      // IPCを使用してメインプロセスから取得
-      const result = await window.electron.review.getHistories();
-      if (!result || !result.success) {
-        throw new Error(result?.error || '不明なエラー');
-      }
-      return result.histories || [];
-    } catch (error) {
-      console.error('ドキュメントレビュー履歴の取得に失敗しました:', error);
-      throw error;
-    }
-  },
-
-  /**
-   * ドキュメントレビュー履歴を削除
-   * @param reviewHistoryId ドキュメントレビュー履歴ID
-   */
-  deleteHistory: async (reviewHistoryId: string): Promise<void> => {
-    try {
-      // IPCを使用してメインプロセスから削除
-      const result =
-        await window.electron.review.deleteHistory(reviewHistoryId);
-      if (!result.success) {
-        throw new Error(result?.error || '不明なエラー');
-      }
-    } catch (error) {
-      console.error('ドキュメントレビュー履歴の削除に失敗しました:', error);
-      throw error;
-    }
-  },
-
-  /**
-   * ドキュメントレビュー履歴の詳細情報抽出
-   * @param reviewHistoryId ドキュメントレビュー履歴ID
-   * @returns 抽出されたチェックリスト
-   */
-  getReviewHistoryDetail: async (historyId: string) => {
-    try {
-      const result = await window.electron.review.getHistoryDetail(historyId);
-      if (!result.success) {
-        throw new Error(result.error || '不明なエラー');
-      }
-      return {
-        checklists: result.checklistResults || [],
-        additionalInstructions: result.additionalInstructions,
-        commentFormat: result.commentFormat,
-      };
-    } catch (error) {
-      console.error('チェックリストの取得に失敗しました:', error);
-      throw error;
-    }
-  },
-
-  /**
-   * チェックリスト抽出を呼び出す
-   * @param reviewHistoryId レビュー履歴ID
-   * @param sourceIds 抽出対象のソースID配列
-   * @returns チェックリスト抽出結果
-   */
-  callChecklistExtraction: async (
-    reviewHistoryId: string,
-    files: UploadFile[],
-  ) => {
-    try {
-      const result = await window.electron.review.extractChecklist({
-        reviewHistoryId,
-        files,
-      });
-      if (!result.success) {
-        throw new Error(result.error || '不明なエラー');
-      }
-      return result;
-    } catch (error) {
-      console.error('チェックリスト抽出の呼び出しに失敗しました:', error);
-      throw error;
-    }
-  },
-
-  subscribeChecklistExtractionFinished: (
-    callback: (
-      payload: IpcEventPayload<
-        typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
-      >,
-    ) => void,
-  ) => {
-    return window.electron.review.onExtractChecklistFinished((payload) => {
-      callback(payload);
-    });
-  },
-
-  subscribeReviewExecutionFinished: (
-    callback: (
-      payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
-    ) => void,
-  ) => {
-    return window.electron.review.onExecuteReviewFinished((payload) => {
-      callback(payload);
-    });
-  },
-};
-
-export default reviewService;
diff --git a/src/renderer/services/sourceService.ts b/src/renderer/services/sourceService.ts
deleted file mode 100644
index 71dc83864..000000000
--- a/src/renderer/services/sourceService.ts
+++ /dev/null
@@ -1,49 +0,0 @@
-// ソース情報の管理サービス
-export const sourceService = {
-  /**
-   * ソースの再読み込みを実行する
-   * @returns 実行結果
-   */
-  reloadSources: async (): Promise<{ success: boolean; message?: string }> => {
-    try {
-      // IPC通信を使用してメインプロセスに再読み込みを要求する
-      const result = await window.electron.source.reloadSources();
-      return result;
-      // eslint-disable-next-line
-    } catch (error) {
-      return {
-        success: false,
-        message: `ソースの再読み込みに失敗しました: ${(error as Error).message}`,
-      };
-    }
-  },
-  /**
-   * ソースの登録ディレクトリを取得する
-   * @returns 登録ディレクトリのパス
-   */
-  getRegisterDir: async (): Promise<{
-    success: boolean;
-    dir?: string;
-    error?: string;
-  }> => {
-    try {
-      // IPC通信を使用してメインプロセスから登録ディレクトリを取得する
-      const source = (await window.electron.store.get('source')) as any;
-      if (!source || !source.registerDir) {
-        return {
-          success: false,
-          error: 'ドキュメント登録ディレクトリが設定されていません',
-        };
-      }
-      return { success: true, dir: source.registerDir || '' };
-      // eslint-disable-next-line
-    } catch (error) {
-      return {
-        success: false,
-        error: `ドキュメント登録ディレクトリの取得に失敗しました`,
-      };
-    }
-  },
-};
-
-export default sourceService;
diff --git a/src/renderer/stores/settingsZustandStore.ts b/src/renderer/stores/agentStatusStore.ts
similarity index 57%
rename from src/renderer/stores/settingsZustandStore.ts
rename to src/renderer/stores/agentStatusStore.ts
index 3b49fa075..93d62f85a 100644
--- a/src/renderer/stores/settingsZustandStore.ts
+++ b/src/renderer/stores/agentStatusStore.ts
@@ -1,7 +1,8 @@
 import { create } from 'zustand';
-import type { SettingsSavingStatus, MakeOptional } from '../../main/types';
+import type { SettingsSavingStatus, MakeOptional } from '@/types';
+import { SettingsApi } from '../service/settingsApi';
 
-type SettingsStore = {
+type AgentStatusStore = {
   // エージェントが更新されたかどうかを保持するフラグ
   updatedFlg: boolean;
   setUpdatedFlg: (updatedFlg: boolean) => void;
@@ -10,7 +11,7 @@ type SettingsStore = {
   closeMessage: (messageId: string) => Promise<void>;
 };
 
-export const useSettingsZustandStore = create<SettingsStore>((set) => ({
+export const useAgentStatusStore = create<AgentStatusStore>((set) => ({
   updatedFlg: false,
   setUpdatedFlg: (updatedFlg: boolean) => {
     set({ updatedFlg });
@@ -20,9 +21,18 @@ export const useSettingsZustandStore = create<SettingsStore>((set) => ({
     set({ status });
   },
   closeMessage: async (messageId: string) => {
-    await window.electron.settings.removeMessage(messageId);
+    const settingsApi = SettingsApi.getInstance();
+    await settingsApi.removeMessage(messageId, {
+      showAlert: false,
+      throwError: false,
+    });
     // メッセージ削除後に最新のステータスを取得して更新
-    const newStatus = await window.electron.settings.getStatus();
-    set({ status: newStatus });
+    const newStatus = await settingsApi.getAgentStatus({
+      showAlert: false,
+      throwError: false,
+    });
+    if (newStatus) {
+      set({ status: newStatus });
+    }
   },
 }));
diff --git a/src/renderer/stores/alertStore.ts b/src/renderer/stores/alertStore.ts
new file mode 100644
index 000000000..35115f191
--- /dev/null
+++ b/src/renderer/stores/alertStore.ts
@@ -0,0 +1,93 @@
+// stores/errorStore.ts
+import { createStore } from 'zustand/vanilla';
+import { useStore, type StoreApi } from 'zustand';
+import type { AlertColor } from '@mui/material';
+import { v4 as uuidv4 } from 'uuid';
+
+export interface AlertMessage {
+  id: string;
+  message: string;
+  severity: AlertColor;
+  timestamp: number;
+  timerId?: NodeJS.Timeout; // 自動削除用タイマーID
+}
+
+interface AlertState {
+  alerts: AlertMessage[];
+}
+
+interface AlertActions {
+  addAlert: (alert: Omit<AlertMessage, 'id' | 'timestamp'>) => void;
+  removeAlert: (id: string) => void;
+  clearAlerts: () => void;
+}
+
+export type AlertStore = AlertState & AlertActions;
+
+const MAX_ALERT_MESSAGES = 4;
+
+export const alertStore: StoreApi<AlertStore> = createStore<AlertStore>()(
+  (set, get) => ({
+    alerts: [],
+
+    addAlert: (alert) => {
+      const id = uuidv4();
+      const newAlert: AlertMessage = {
+        ...alert,
+        id,
+        timestamp: Date.now(),
+      };
+
+      // errorメッセージ以外は5秒後に自動削除
+      if (alert.severity !== 'error' && alert.severity !== 'success') {
+        const timerId = setTimeout(() => {
+          get().removeAlert(id);
+        }, 2000);
+        newAlert.timerId = timerId;
+      }
+
+      set((state) => {
+        const newAlerts = [newAlert, ...state.alerts].slice(
+          0,
+          MAX_ALERT_MESSAGES,
+        );
+
+        // 最大数を超えて削除されたアラートのタイマーもクリア
+        const removedAlerts = [newAlert, ...state.alerts].slice(
+          MAX_ALERT_MESSAGES,
+        );
+        removedAlerts.forEach((alert) => {
+          if (alert.timerId) {
+            clearTimeout(alert.timerId);
+          }
+        });
+
+        return { alerts: newAlerts };
+      });
+    },
+
+    removeAlert: (id) =>
+      set((state) => {
+        // 削除対象のアラートを見つけてタイマーをクリア
+        const alertToRemove = state.alerts.find((alert) => alert.id === id);
+        if (alertToRemove?.timerId) {
+          clearTimeout(alertToRemove.timerId);
+        }
+        return { alerts: state.alerts.filter((e) => e.id !== id) };
+      }),
+
+    clearAlerts: () =>
+      set((state) => {
+        // 全てのタイマーをクリア
+        state.alerts.forEach((alert) => {
+          if (alert.timerId) {
+            clearTimeout(alert.timerId);
+          }
+        });
+        return { alerts: [] };
+      }),
+  }),
+);
+
+export const useAlertStore = <T>(selector: (s: AlertStore) => T) =>
+  useStore(alertStore, selector);
diff --git a/src/renderer/types/index.ts b/src/renderer/types/index.ts
new file mode 100644
index 000000000..a6e0a506a
--- /dev/null
+++ b/src/renderer/types/index.ts
@@ -0,0 +1,4 @@
+export type ApiServiceDefaultOptions = {
+  showAlert?: boolean;
+  throwError?: boolean;
+};
diff --git a/src/types/chat.ts b/src/types/chat.ts
new file mode 100644
index 000000000..ceac16fc3
--- /dev/null
+++ b/src/types/chat.ts
@@ -0,0 +1,27 @@
+// @ts-ignore
+import type { AiMessageType, StorageThreadType } from '@mastra/core';
+
+/**
+ * チャットのロール型
+ */
+export type ChatRole = 'user' | 'assistant' | 'system';
+
+/**
+ * チャットルーム情報の型（Mastraの型を利用）
+ */
+export type ChatRoom = StorageThreadType;
+
+/**
+ * チャットメッセージの型（Mastraの型を利用）
+ */
+export type ChatMessage = AiMessageType;
+
+/**
+ * エージェントのツール状態を表す型
+ */
+export type AgentToolStatus = {
+  document: boolean;
+  redmine: boolean;
+  gitlab: boolean;
+  mcp: boolean;
+};
diff --git a/src/types/error.ts b/src/types/error.ts
new file mode 100644
index 000000000..a4fd32185
--- /dev/null
+++ b/src/types/error.ts
@@ -0,0 +1,30 @@
+/**
+ * アプリ全体で使うエラーコード。
+ * UI 側の文言切り替えや翻訳キーにも使えます。
+ */
+export type ErrorCode =
+  | 'BAD_REQUEST'
+  | 'FORBIDDEN'
+  | 'NOT_FOUND'
+  | 'VALIDATION'
+  | 'EXTERNAL_SERVICE'
+  | 'INTERNAL'
+  | 'AI_API';
+
+/**
+ * フロントエンドで利用するエラーコード
+ */
+export type FrontErrorCode =
+  | 'APP_API'
+  | 'APP_API_CALL'
+  | 'INTERNAL';
+
+/**
+ * クライアントへ返す標準エラー形
+ * - code: アプリ内の安定したエラーコード
+ * - message: ユーザー向けの安全なメッセージ
+ */
+export type AppErrorPayload = {
+  code: ErrorCode;
+  message: string;
+};
diff --git a/src/types/eventPush.ts b/src/types/eventPush.ts
new file mode 100644
index 000000000..af166d2ef
--- /dev/null
+++ b/src/types/eventPush.ts
@@ -0,0 +1,36 @@
+import { EventChannel, IpcEventPayloadMap } from './ipc';
+
+export type Channel = EventChannel;
+
+export type PushEvent<C extends Channel = Channel> = {
+  channel: C;
+  payload: IpcEventPayloadMap[C]; // ドメイン固有データ
+  ts: number; // サーバでの生成時刻(ms)
+};
+
+// サーバ側で「クライアント接続（ストリーム）」を表すシンク
+export type StreamSink<C extends Channel = Channel> = {
+  id?: string; // 省略可。未指定ならBroker側で採番
+  write: (ev: PushEvent<C>) => void; // クライアントへ送出
+  close?: () => void; // 切断時の後始末（任意）
+};
+
+// サーバ側で使う共通ブローカー
+export interface PushBroker {
+  // ドメイン／サービスは基本これだけ呼べばOK（push送信）
+  publish<C extends Channel = Channel>(channel: C, ev: PushEvent<C>): void;
+
+  // 下位トランスポート（アプリ形態に合わせてSSE/ElectronIPC等を選択）が「接続（購読）を登録」
+  registerStream<C extends Channel = Channel>(
+    channel: C,
+    sink: StreamSink<C>,
+  ): () => void; // 解除用のunsubscribeを返す
+}
+
+export interface PushClient {
+  subscribe<C extends Channel>(
+    channel: C,
+    onEvent: (ev: PushEvent<C>) => void,
+    opts?: { signal?: AbortSignal },
+  ): () => void;
+}
diff --git a/src/types/index.ts b/src/types/index.ts
new file mode 100644
index 000000000..8c5e546f5
--- /dev/null
+++ b/src/types/index.ts
@@ -0,0 +1,19 @@
+export * from './chat';
+export * from './review';
+export * from './setting';
+export * from './sourceRegister';
+export * from './ipc';
+export * from './message';
+export * from './error';
+export * from './eventPush';
+
+// パス定義
+export const ROUTES = {
+  CHAT: '/',
+  REVIEW: '/review',
+} as const;
+
+export type Feature = keyof typeof ROUTES;
+
+export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
+  Partial<Pick<T, K>>;
diff --git a/src/types/ipc.ts b/src/types/ipc.ts
new file mode 100644
index 000000000..9828e36d5
--- /dev/null
+++ b/src/types/ipc.ts
@@ -0,0 +1,271 @@
+import { OpenDialogOptions } from 'electron';
+import type { ChatMessage, ChatRoom } from './chat';
+import { AppErrorPayload } from './error';
+import type {
+  DocumentType,
+  UploadFile,
+  ReviewChecklistResultDisplay,
+  ReviewChecklistEdit,
+  ChecklistExtractionResultStatus,
+  ReviewExecutionResultStatus,
+} from './review';
+import type { SettingsSavingStatus, Settings } from './setting';
+import type { Source, ReviewHistory } from '@/db/schema';
+
+type IpcSuccess<T> = {
+  success: true;
+  data?: T;
+};
+
+type IpcError = {
+  success: false;
+  error: AppErrorPayload;
+};
+
+export type IpcResult<T = never> = IpcSuccess<T> | IpcError;
+
+/**
+ * IPC通信で使用するチャネル名の定義
+ */
+export const IpcChannels = {
+  // Agent関連
+  GET_SETTINGS_STATUS: 'get-settings-status',
+  SETTINGS_STATUS_CHANGED: 'settings-status-changed',
+  SETTINGS_UPDATE_FINISHED: 'settings-update-finished', // 設定更新処理が完了した際の通知
+  REINITIALIZE_SETTINGS: 'reinitialize-settings',
+  REMOVE_SETTINGS_MESSAGE: 'remove-settings-message',
+
+  // 設定関連
+  GET_SETTINGS: 'get-settings',
+  SET_SETTINGS: 'set-settings',
+
+  // ソース関連
+  SOURCE_GET_ALL: 'source-get-all',
+  SOURCE_RELOAD: 'source-reload',
+  SOURCE_RELOAD_FINISHED: 'source-reload-finished', // ドキュメント更新処理が完了した際の通知
+  SOURCE_UPDATE_ENABLED: 'source-update-enabled',
+
+  // チャット関連
+  CHAT_SEND_MESSAGE: 'chat-send-message',
+  CHAT_GET_ROOMS: 'chat-get-rooms',
+  CHAT_GET_MESSAGES: 'chat-get-messages',
+  CHAT_DELETE_ROOM: 'chat-delete-room',
+  CHAT_CREATE_THREAD: 'chat-create-thread',
+  CHAT_STREAM: 'chat-stream',
+  CHAT_COMPLETE: 'chat-complete',
+  CHAT_STEP: 'chat-step',
+  CHAT_ERROR: 'chat-error',
+  CHAT_ABORT_REQUEST: 'chat-abort-request',
+  CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID:
+    'chat-delete-messages-before-specific-id',
+
+  // ファイルシステム関連
+  FS_CHECK_PATH_EXISTS: 'fs-check-path-exists',
+  FS_SHOW_OPEN_DIALOG: 'fs-show-open-dialog',
+  FS_READ_FILE: 'fs-read-file',
+
+  // ドキュメントレビュー関連
+  REVIEW_GET_HISTORIES: 'review-get-histories', // ドキュメント履歴切り替え時やチェックリスト抽出・ドキュメントレビュー時のポーリング処理にて呼び出される
+  REVIEW_GET_HISTORY_DETAIL: 'review-get-history-detail',
+  REVIEW_GET_HISTORY_INSTRUCTION: 'review-get-history-instruction',
+  REVIEW_DELETE_HISTORY: 'review-delete-history',
+  REVIEW_EXTRACT_CHECKLIST_CALL: 'review-extract-checklist-call', // チェックリスト抽出処理を開始する
+  REVIEW_EXTRACT_CHECKLIST_FINISHED: 'review-extract-checklist-finished', // チェックリスト抽出が完了した際の通知
+  REVIEW_EXTRACT_CHECKLIST_ABORT: 'review-extract-checklist-abort', // チェックリスト抽出処理をキャンセルする
+  REVIEW_UPDATE_CHECKLIST: 'review-update-checklist',
+  REVIEW_EXECUTE_CALL: 'review-execute', // ドキュメントレビューを開始する
+  REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
+  REVIEW_EXECUTE_ABORT: 'review-execute-abort', // レビュー実行処理をキャンセルする
+  REVIEW_HISTORY_UPDATED: 'review-history-updated', // レビュー履歴が更新された際の通知
+} as const;
+
+export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
+
+/**
+ * IPC通信のペイロード型マッピング
+ * 各チャネルごとにリクエストとレスポンスの型を厳密に定義
+ */
+export type IpcRequestPayloadMap = {
+  // Mastra関連
+  [IpcChannels.GET_SETTINGS_STATUS]: undefined;
+  [IpcChannels.REINITIALIZE_SETTINGS]: undefined;
+  [IpcChannels.REMOVE_SETTINGS_MESSAGE]: string; // message id
+
+  // 設定関連
+  [IpcChannels.GET_SETTINGS]: undefined;
+  [IpcChannels.SET_SETTINGS]: Settings;
+
+  // ファイルシステム関連
+  [IpcChannels.FS_CHECK_PATH_EXISTS]: string;
+  [IpcChannels.FS_SHOW_OPEN_DIALOG]: OpenDialogOptions;
+  [IpcChannels.FS_READ_FILE]: string; // file path
+
+  // ソース関連
+  [IpcChannels.SOURCE_GET_ALL]: undefined;
+  [IpcChannels.SOURCE_RELOAD]: undefined;
+  [IpcChannels.SOURCE_UPDATE_ENABLED]: { sourceId: number; isEnabled: boolean };
+
+  // チャット関連
+  [IpcChannels.CHAT_SEND_MESSAGE]: { roomId: string; messages: ChatMessage[] };
+  [IpcChannels.CHAT_GET_ROOMS]: undefined;
+  [IpcChannels.CHAT_GET_MESSAGES]: string; // threadId
+  [IpcChannels.CHAT_DELETE_ROOM]: string; // threadId
+  [IpcChannels.CHAT_CREATE_THREAD]: {
+    roomId: string;
+    title: string;
+  };
+  [IpcChannels.CHAT_ABORT_REQUEST]: { threadId: string };
+  [IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]: {
+    threadId: string;
+    messageId: string;
+  };
+
+  // ドキュメントレビュー関連
+  [IpcChannels.REVIEW_GET_HISTORIES]: undefined;
+  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: string; // review history id
+  [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: string; // review history id
+  [IpcChannels.REVIEW_DELETE_HISTORY]: string; // review history id
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
+    reviewHistoryId: string;
+    files: UploadFile[];
+    documentType?: DocumentType;
+    checklistRequirements?: string;
+  };
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_ABORT]: string; // review history id
+  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: {
+    reviewHistoryId: string;
+    checklistEdits: ReviewChecklistEdit[];
+  };
+  [IpcChannels.REVIEW_EXECUTE_CALL]: {
+    reviewHistoryId: string;
+    files: UploadFile[];
+    additionalInstructions?: string;
+    commentFormat?: string;
+  };
+  [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
+};
+
+export type IpcResponsePayloadMap = {
+  // Mastra関連
+  [IpcChannels.GET_SETTINGS_STATUS]: IpcResult<SettingsSavingStatus>;
+  [IpcChannels.REINITIALIZE_SETTINGS]: IpcResult;
+  [IpcChannels.REMOVE_SETTINGS_MESSAGE]: IpcResult;
+
+  // 設定関連
+  [IpcChannels.GET_SETTINGS]: IpcResult<Settings>;
+  [IpcChannels.SET_SETTINGS]: IpcResult<boolean>;
+
+  // ファイルシステム関連
+  [IpcChannels.FS_CHECK_PATH_EXISTS]: IpcResult<boolean>;
+  [IpcChannels.FS_SHOW_OPEN_DIALOG]: IpcResult<{
+    filePaths: string[];
+    canceled: boolean;
+  }>;
+  [IpcChannels.FS_READ_FILE]: IpcResult<Uint8Array>; // ファイルのバイナリデータ
+
+  // ソース関連
+  [IpcChannels.SOURCE_GET_ALL]: IpcResult<Source[]>;
+  [IpcChannels.SOURCE_RELOAD]: IpcResult<{ message?: string }>;
+  [IpcChannels.SOURCE_UPDATE_ENABLED]: IpcResult;
+
+  // チャット関連
+  [IpcChannels.CHAT_SEND_MESSAGE]: IpcResult;
+  [IpcChannels.CHAT_GET_ROOMS]: IpcResult<ChatRoom[]>;
+  [IpcChannels.CHAT_GET_MESSAGES]: IpcResult<ChatMessage[]>;
+  [IpcChannels.CHAT_DELETE_ROOM]: IpcResult;
+  [IpcChannels.CHAT_CREATE_THREAD]: IpcResult;
+  [IpcChannels.CHAT_ABORT_REQUEST]: IpcResult;
+  [IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]: IpcResult;
+
+  // ドキュメントレビュー関連
+  [IpcChannels.REVIEW_GET_HISTORIES]: IpcResult<ReviewHistory[]>;
+  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: IpcResult<{
+    checklistResults?: ReviewChecklistResultDisplay[];
+  }>;
+  [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: IpcResult<{
+    additionalInstructions?: string;
+    commentFormat?: string;
+  }>;
+  [IpcChannels.REVIEW_DELETE_HISTORY]: IpcResult;
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: IpcResult;
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_ABORT]: IpcResult;
+  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: IpcResult;
+  [IpcChannels.REVIEW_EXECUTE_CALL]: IpcResult;
+  [IpcChannels.REVIEW_EXECUTE_ABORT]: IpcResult;
+};
+
+export type IpcEventPayloadMap = {
+  [IpcChannels.CHAT_STREAM]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
+  [IpcChannels.CHAT_COMPLETE]: unknown;
+  [IpcChannels.CHAT_ERROR]: { message: string };
+  [IpcChannels.SETTINGS_UPDATE_FINISHED]: { success: boolean; error?: string }; // 設定更新処理完了通知
+  [IpcChannels.SOURCE_RELOAD_FINISHED]: { success: boolean; error?: string }; // ドキュメント更新処理完了通知
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED]: {
+    status: ChecklistExtractionResultStatus;
+    error?: string;
+  };
+  [IpcChannels.REVIEW_EXECUTE_FINISHED]: {
+    status: ReviewExecutionResultStatus;
+    error?: string;
+  };
+  [IpcChannels.REVIEW_HISTORY_UPDATED]: undefined;
+};
+
+/**
+ * 型安全性を確保するためのヘルパー型
+ */
+export type IpcRequestPayload<T extends keyof IpcRequestPayloadMap> =
+  IpcRequestPayloadMap[T];
+
+export type IpcResponsePayload<T extends keyof IpcResponsePayloadMap> =
+  IpcResponsePayloadMap[T];
+
+export type IpcEventPayload<T extends keyof IpcEventPayloadMap> =
+  IpcEventPayloadMap[T];
+
+export type RequestChannel = keyof IpcRequestPayloadMap;
+export type ResponseChannel = keyof IpcResponsePayloadMap;
+export type EventChannel = keyof IpcEventPayloadMap;
+
+// チャネル名と処理内容のマッピング（ログ出力やエラー処理などで使用）
+export const IpcNameMap = {
+  // Mastra関連
+  [IpcChannels.GET_SETTINGS_STATUS]: 'AIツール情報の取得',
+  [IpcChannels.REINITIALIZE_SETTINGS]: 'AIツール情報の更新',
+  [IpcChannels.REMOVE_SETTINGS_MESSAGE]: 'AIツール情報メッセージの削除',
+
+  // 設定関連
+  [IpcChannels.GET_SETTINGS]: '設定情報の取得',
+  [IpcChannels.SET_SETTINGS]: '設定情報の更新',
+
+  // ファイルシステム関連
+  [IpcChannels.FS_CHECK_PATH_EXISTS]: 'ファイルパスの存在確認',
+  [IpcChannels.FS_SHOW_OPEN_DIALOG]: 'ファイルダイアログ表示',
+  [IpcChannels.FS_READ_FILE]: 'ファイル読み込み',
+
+  // ソース関連
+  [IpcChannels.SOURCE_GET_ALL]: 'ドキュメント情報の取得',
+  [IpcChannels.SOURCE_RELOAD]: 'ドキュメント情報の再読み込み',
+  [IpcChannels.SOURCE_UPDATE_ENABLED]: 'ドキュメントの有効/無効更新',
+
+  // チャット関連
+  [IpcChannels.CHAT_SEND_MESSAGE]: 'チャットメッセージ送信',
+  [IpcChannels.CHAT_GET_ROOMS]: 'チャット履歴一覧取得',
+  [IpcChannels.CHAT_GET_MESSAGES]: 'チャット履歴取得',
+  [IpcChannels.CHAT_DELETE_ROOM]: 'チャットルーム削除',
+  [IpcChannels.CHAT_CREATE_THREAD]: 'チャットルーム作成',
+  [IpcChannels.CHAT_ABORT_REQUEST]: 'チャット中断',
+  [IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]:
+    'チャットメッセージ削除',
+
+  // ドキュメントレビュー関連
+  [IpcChannels.REVIEW_GET_HISTORIES]: 'レビュー結果一覧の取得',
+  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: 'レビュー結果詳細の取得',
+  [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: 'レビュー指示内容の取得',
+  [IpcChannels.REVIEW_DELETE_HISTORY]: 'レビュー結果の削除',
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: 'チェックリストの抽出',
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_ABORT]: 'チェックリスト抽出の中断',
+  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: 'チェックリストの更新',
+  [IpcChannels.REVIEW_EXECUTE_CALL]: 'ドキュメントレビューの実行',
+  [IpcChannels.REVIEW_EXECUTE_ABORT]: 'ドキュメントレビューの中断',
+};
diff --git a/src/types/message.ts b/src/types/message.ts
new file mode 100644
index 000000000..d114ead74
--- /dev/null
+++ b/src/types/message.ts
@@ -0,0 +1,21 @@
+export type MessageCode =
+  | 'PLAIN_MESSAGE'
+  | 'UNKNOWN_ERROR'
+  | 'VALIDATION_ERROR'
+  | 'DATA_ACCESS_ERROR'
+  | 'IPC_ERROR'
+  | 'SERVER_INITIALIZE_ERROR'
+  | 'MASTRA_MEMORY_ERROR'
+  | 'CHAT_GENERATE_ERROR'
+  | 'CHAT_EDIT_ERROR'
+  | 'GITLAB_API_CONNECTION_ERROR'
+  | 'REDMINE_API_CONNECTION_ERROR'
+  | 'REDMINE_API_ERROR'
+  | 'FILE_TEXT_EXTRACTION_ERROR'
+  | 'SOURCE_REGISTRATION_DIR_READING_ERROR'
+  | 'REVIEW_CHECKLIST_EXTRACTION_ERROR'
+  | 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS'
+  | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
+  | 'REVIEW_EXECUTION_ERROR'
+  | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
+  | 'AI_API_ERROR';
diff --git a/src/types/review.ts b/src/types/review.ts
new file mode 100644
index 000000000..0e957677d
--- /dev/null
+++ b/src/types/review.ts
@@ -0,0 +1,58 @@
+// レビュー評価の型定義
+export type ReviewEvaluation = 'A' | 'B' | 'C' | '-';
+
+// チェックリストの作成元
+export type ReviewChecklistCreatedBy = 'user' | 'system';
+
+// 最終的に画面に表示するチェックリストの型
+export type ReviewChecklistResultDisplay = {
+  id: number; // チェックリストのID
+  content: string;
+  sourceEvaluations?: {
+    fileId: string;
+    fileName: string;
+    evaluation?: ReviewEvaluation;
+    comment?: string;
+  }[];
+};
+
+// チェックリストの編集内容を表す型
+export type ReviewChecklistEdit = {
+  id: number | null; // 新規作成時はnull
+  content?: string; // 削除の場合は指定不要
+  delete?: boolean; // trueの場合は削除対象
+};
+
+export type ModalMode = 'extract' | 'review';
+
+// ドキュメント種別の定義
+export type DocumentType = 'checklist' | 'general';
+
+// PDF処理方式の定義
+export type PdfProcessMode = 'text' | 'image';
+
+// PDF画像化方式の定義
+export type PdfImageMode = 'merged' | 'pages';
+
+// アップロードファイル情報の型定義
+export interface UploadFile {
+  id: string;
+  name: string;
+  path: string;
+  type: string;
+  pdfProcessMode?: PdfProcessMode; // PDFファイルの場合のみ
+  pdfImageMode?: PdfImageMode; // PDF画像化の場合のみ (merged: 統合画像, pages: ページ別画像)
+  imageData?: string[]; // PDF画像変換時のBase64データ配列 (merged: 長さ1, pages: 各ページ)
+}
+
+export type ChecklistExtractionResultStatus =
+  | 'success'
+  | 'failed'
+  | 'suspended'
+  | 'canceled';
+
+export type ReviewExecutionResultStatus =
+  | 'success'
+  | 'failed'
+  | 'suspended'
+  | 'canceled';
diff --git a/src/main/types/settingsSchema.ts b/src/types/setting.ts
similarity index 63%
rename from src/main/types/settingsSchema.ts
rename to src/types/setting.ts
index 8bd3e9dce..18b0b4556 100644
--- a/src/main/types/settingsSchema.ts
+++ b/src/types/setting.ts
@@ -1,5 +1,23 @@
 import { z } from 'zod';
-import { McpSchema } from './schema';
+import { AgentToolStatus } from './chat';
+
+// 設定状態管理用の型定義
+export type SettingsSavingState = 'saving' | 'done' | 'error';
+
+export type SettingsSavingMessage = {
+  id: string;
+  type: 'info' | 'warning' | 'error';
+  content: string;
+};
+
+/**
+ * エージェントのブート状態を表す型
+ */
+export type SettingsSavingStatus = {
+  state: SettingsSavingState;
+  messages: SettingsSavingMessage[];
+  tools: AgentToolStatus;
+};
 
 /**
  * パスの存在確認を行う関数
@@ -7,13 +25,40 @@ import { McpSchema } from './schema';
  * @returns パスが存在する場合はtrue、存在しない場合はfalse
  */
 export const checkPathExists = async (path: string): Promise<boolean> => {
+  // 画面上でのみ厳密にチェックする
+  // 設定値を直接変更してエラーになる場合は、画面上にエラー文言を表示するため問題ない
   try {
-    return await window.electron.fs.access(path);
-  } catch {
+    if (process && process.type !== 'renderer') return true;
+  } catch (error) {}
+  try {
+    const result = await window.electron.fs.access(path);
+    return result.success === true && result.data === true;
+  } catch (error) {
     return false;
   }
 };
 
+// StdioServerParameters(Mastraで設定されているMCPサーバ設定)のZodスキーマ定義
+// eslint-disable-next-line
+export const McpSchema = z.record(
+  z.union([
+    z.object({
+      command: z.string(),
+      args: z.array(z.string()).optional(),
+      env: z.record(z.string()).optional(),
+      cwd: z.string().optional(),
+    }),
+    z.object({
+      url: z
+        .string()
+        .url()
+        .transform((s) => new URL(s)),
+    }),
+  ]),
+);
+
+export type McpSchemaType = z.infer<typeof McpSchema>;
+
 /**
  * データベース設定のスキーマ
  */
@@ -30,14 +75,15 @@ export const DatabaseSchema = z.object({
  * ソース設定のスキーマ
  */
 export const SourceSchema = z.object({
-  registerDir: z
-    .string()
-    .refine(async (path) => {
+  registerDir: z.string().refine(
+    async (path) => {
       if (path === '') return true; // 空文字は許容
-      return await checkPathExists(path)
-    }, {
+      return await checkPathExists(path);
+    },
+    {
       message: '指定されたパスが存在しません',
-    }),
+    },
+  ),
 });
 
 /**
@@ -84,18 +130,21 @@ export const SystemPromptSchema = z.object({
  * MCP設定のスキーマ
  */
 export const McpStoreSchema = z.object({
-  serverConfigText: z
+  serverConfig: z
     .string()
-    .min(1, { message: 'MCPサーバー設定は必須です' })
+    .optional()
     .transform((str, ctx) => {
       try {
+        if (!str || str.trim() === '') {
+          return undefined;
+        }
         const json = JSON.parse(str);
         const result = McpSchema.safeParse(json);
         if (!result.success) {
           ctx.addIssue({
             code: z.ZodIssueCode.custom,
             message:
-              'MCP設定形式が不正です: ' +
+              'MCP設定形式が不正です\n' +
               result.error.errors.map((err) => err.message).join(', '),
           });
           return z.NEVER;
@@ -108,7 +157,8 @@ export const McpStoreSchema = z.object({
         });
         return z.NEVER;
       }
-    }),
+    })
+    .optional(),
 });
 
 /**
@@ -124,6 +174,8 @@ export const SettingsSchema = z.object({
   systemPrompt: SystemPromptSchema,
 });
 
+export type Settings = z.infer<typeof SettingsSchema>;
+
 export type ValidationError = {
   message: string;
   type: 'required' | 'format' | 'existence' | 'schema';
diff --git a/src/types/sourceRegister.ts b/src/types/sourceRegister.ts
new file mode 100644
index 000000000..d982b1c63
--- /dev/null
+++ b/src/types/sourceRegister.ts
@@ -0,0 +1,4 @@
+/**
+ * プロセス状態を表す型
+ */
+export type ProcessStatus = 'idle' | 'processing' | 'completed' | 'failed';
