diff --git a/.gitignore b/.gitignore
index 458394a06..614fb2018 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,7 +43,6 @@ source
 /db
 local_docker
 mcp.log
-electron-store
 .erb/chrome.exe
 /release/app/drizzle
 dev_appdata
diff --git a/CLAUDE.md b/CLAUDE.md
index 81694e235..1fe110be8 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -61,7 +61,7 @@ npm test
             - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
               - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
             - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
-      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つのドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
+      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
       - 対応可能なファイルは以下
         - word,excel,powerpoint,pdf,テキスト文書
           - テキスト抽出するか画像としてAIに送信するか選択することができる
@@ -203,11 +203,110 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
   - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
 - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
 - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
-- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型（ドメイン型）(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
 - テストについては指示されない限り、実行も修正もしなくてよい
+- DBマイグレーションの実行は指示されない限り不要
 - 適宜調査や実装の際に必要あればcodex mcpを活用すること
+- 新規追加した部分については型エラーが出ないようにすること
 
 
 ## 依頼タスク
-- 要件
-  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
+- ビジネス要件
+  - レビュー機能利用時に、レビュー結果に対してAIとチャットできる機能を追加する
+- 機能要件
+  1. 1レビュー履歴に対して1つの（結合）ドキュメントのみ登録可能にする: 完了済み
+    - 目的
+      - AIとチャットする際に複数のドキュメントがレビュー結果として登録されているとどのドキュメントに対して回答して良いかわからなくなるため
+    - 実装方針
+      - DBテーブルの更新
+        - `review_checklist_results`を廃止して`review_checklists`に統合
+        - `review_checklist_results`のfileId,fileNameを削除して、`review_histories`にtargetDocumentName(レビュー対象の(統合)ドキュメント名のこと)として同じ役割を引き継がせる
+      - ドメイン型の更新
+        - ReviewChecklistResultのsourceEvaluations属性は配列ではなく、単一要素とする
+        - ReviewChecklistResultのfileIdとfileNameを削除、targetDocumentNameを新規追加
+        - これらに伴い既存処理の変更も必要になるので注意すること
+      - サーバサイド処理更新
+        - レビュー実行の開始時(`src/mastra/workflows/sourceReview/executeReview/index.ts`のステップ1テキスト抽出とカテゴリ分割の実行後のmap処理内)に、既存のレビュー結果は全て削除してから実行するように変更する
+  2. レビュー実行時にアップロードしたファイル内容(抽出済みテキスト、画像データ)と、（大量ドキュメントレビューの場合は）個別レビューの結果を、後にチャットする時のために保存して取り出すことができるようにする: 完了済み
+    - 実装方針
+      - DBテーブルの更新
+        - `review_document_chaches`テーブルの作成
+          - `review_histories`と一対多の関係
+          - ファイルのメタデータ(id, originalFileName(大量ドキュメントレビュー用), fileName, processMode('text' or 'image'), originalPath, cachePath,...等)を保存
+        - `review_histories`テーブルに大量ドキュメントレビューか少量ドキュメントレビューかを示すフラグを追加
+        - `review_largedocument_result_chaches`テーブルの作成
+          - `review_document_chaches`と`review_checklists`の中間テーブル
+          - 少量ドキュメントレビューの場合に、個別チェックリストに対して、個別ドキュメントをレビューするが、その際のチャンクパラメータ(チャンク総数と個別ドキュメントのチャンクインデックス)と結果を保存
+      - ドメイン型の更新
+        - 上記に合わせてドメイン型(`src/types/review.ts`)の新規作成が必要
+        - 今後も見据えて最善のドメイン型を作成してください
+      - サーバサイド処理更新
+        - レビュー実行方法が大量ドキュメントレビューであったか、それとも少量ドキュメントレビューであったのか、レビュー実行時に保存できるようにする
+        - ファイルのメタデータについてはDBに保存し、実態はキャッシュ用のディレクトリに保存
+          - キャッシュについては以下パスに保存
+            - 抽出済みテキスト`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}.txt`
+            - 画像データ`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}/page_${インデックス値}.b64`
+          - キャッシュのパスはDBに保存して、後ほどチャット機能で簡単にパスを取得できるようにする
+            - processModeがtextの場合はキャッシュのパスはファイルパス(`.../${id}.txt`)になり、imageの場合はディレクトリパス(`.../${id}`)になる
+          - 実際にレビューが実行された直後にレビュー結果とともにドキュメントのキャッシュを保存する
+      - 実装時の注意点
+        - （少量、大量）レビュー実行時の処理（コンポーネント~workflow）に影響があるので、幅広く影響を見極めること
+        - DBとドメインについてはどちらも上手くrepositoryインターフェースに依存性逆転させているのでこれを利用して効率的に実装すること
+  3. レビュー結果に対してAIとチャットできるようにする: 実行中
+    - 実装方針
+      - UI
+        - チャット結果画面内(`src/renderer/components/review/ReviewChecklistSection.tsx`)にチャットを開始できるボタンを配置
+          - このボタンが押下されると画面右サイドからチャット画面が出現する
+            - チャット画面については`src/renderer/components/chat/ChatArea.tsx`を参考にすること(特にuseChatフックを利用する部分)
+        - チャットに関するコンポーネントは最大限既存のものを活用する（`src/renderer/components/chat`） 
+        - チャット内容は永続化する必要はなく、レビューIDを切り替えたらチャット内容は初期化される
+        - チャット入力欄で「@」と入力するとどのチェックリストに対して質問をするかスクロール形式で選ぶことができる
+          - 一般的にAIコーディングエディタ内で任意のファイルを参照させることができるようにするための用途で実装されているものと同じ形式と理解して実装してください
+          - 対象のチェックリストについてはuseStateで状態管理しておく
+            - 「@チェックリストA」のような完全な状態から「@チェックリスト」のように一文字でも欠けた状態になった場合は、状態管理から外す
+            - 管理下にあるチェックリストについてはチャット入力欄内の「@チェックリストA」を青字で表示する(これも一般的なAIコーディングエディタでよくある実装方法です)
+            - 複数のチェックリストを登録可能
+      - サーバサイド処理更新
+        - AIチャット機能実装
+          - mastra workflowとして実装
+            - workflowは以下のようなステップで構築する(大量ドキュメントレビュー、少量ドキュメントレビューで区別しない)
+              1. AIにユーザからの質問と対象のチェックリストを与えて、調査対象ドキュメントとその調査内容のペアの配列を出力させる
+                - AI処理詳細
+                  - システムプロンプト
+                    - 提示する内容
+                      - @で指定されたチェックリストの内容とレビュー結果（大量レビューの場合は個別のレビュー結果も） 
+                      - ドキュメントキャッシュ内容(id, FileName)
+                        - 出力時に質問対象ドキュメントを指定できるようにするため
+                      - AIの役割：ユーザから与えられたチェックリスト結果と質問に対して、最終的に良い回答ができるように、調査すべきドキュメントとその調査内容を出力すること
+                  - ユーザコンテキスト
+                      - ユーザからの質問
+                  - 出力内容
+                  ```
+                  {
+                    documentId: string # review_document_cachesテーブルのId
+                    researchContent: string
+                  }[]
+                  ```
+              2. 1で指定されたドキュメント毎に以下ステップを並列実行(foreach)
+                - `review_largedocument_result_chaches`テーブル内のドキュメントキャッシュIDが一致するレコードからtotalChunksの最大値を取得
+                - 以下をループ(dountil)※`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts`の`individualDocumentReviewWorkflow`を参考にすること
+                  - ドキュメントをtotalChunks分のチャンクに分解して(`src/mastra/workflows/sourceReview/lib.ts`を利用)、それぞれに対して以下を並列実行(foreach)
+                    - AIに調査対象ドキュメント(reviewRepository#getReviewDocumentCacheByDocumentIdを利用して取得)と調査内容を与えて、調査結果を出力する
+                  - 並列処理の結果一つでもコンテキスト長エラーになっていた場合は、チャンク数を一つ増やして処理をループする（全てsuccessの場合はループ終了）
+              3. 2の調査結果を全てAIに与えて、最終的にユーザ返す質問内容を出力する
+            - workflowの最終的な処理結果はチャット機能と同様にAI SDK形式のチャンクをイベントpushで送信する(chatService#generateを参照)
+    - 実装時の注意点
+      - workflowの実装方法は大量ドキュメントレビュー実行時のworkflowを参考にすること
+      - AIに与えるシステムプロンプトも大量ドキュメントレビュー実行時ものもを参考にすること(なぜその処理を実行させたいのか、背景もうまく伝えられるようにして欲しい)
+  - 改善依頼
+    - レビュー質問workflow内で利用するAIの挙動（プロンプトや入力情報）の改善
+      - 特に改善が必要かどうか確認して欲しいポイント
+        - システムプロンプトの精度にクリティカルに影響するであろうチェックリスト情報等のテキスト組み立てをworkflow内で実施しているが、プロンプト関数内で組み立てた方が責任範囲が明確ではないか
+        - `getReviewChatResearchPromp`についてもreviewModeをruntimeContextから受け取って、プロンプトを組み立てるべきではないか
+
+### タスク実装時の注意点
+- 依頼タスクの全ての手順を理解した上で、最適な実装をすること
+- **ドキュメントレビュー機能、レビュー質問機能の全て**を正しく理解した上で実装すること
+- プロンプト作成の際はベストプラクティスに沿って効果的なプロンプトにすること
+- ユーザが直感的に操作できて、尚且つ一般的なUIにすること
+  - 美しく、ユーザへの配慮がしっかりとできているUIにすること
diff --git a/changes.patch b/changes.patch
index b53722bce..0db8c3e8e 100644
--- a/changes.patch
+++ b/changes.patch
@@ -1,81 +1,26149 @@
+diff --git a/.gitignore b/.gitignore
+index 458394a06..614fb2018 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -43,7 +43,6 @@ source
+ /db
+ local_docker
+ mcp.log
+-electron-store
+ .erb/chrome.exe
+ /release/app/drizzle
+ dev_appdata
 diff --git a/CLAUDE.md b/CLAUDE.md
-index 33069f026..81694e235 100644
+index 81694e235..f9600cdaf 100644
 --- a/CLAUDE.md
 +++ b/CLAUDE.md
-@@ -210,8 +210,4 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
+@@ -61,7 +61,7 @@ npm test
+             - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
+               - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
+             - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
+-      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つのドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
++      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
+       - 対応可能なファイルは以下
+         - word,excel,powerpoint,pdf,テキスト文書
+           - テキスト抽出するか画像としてAIに送信するか選択することができる
+@@ -203,11 +203,109 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
+   - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
+ - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
+ - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
+-- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
++- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型（ドメイン型）(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+ - テストについては指示されない限り、実行も修正もしなくてよい
++- DBマイグレーションの実行は指示されない限り不要
+ - 適宜調査や実装の際に必要あればcodex mcpを活用すること
++- 新規追加した部分については型エラーが出ないようにすること
+ 
  
  ## 依頼タスク
- - 要件
--  - レビュー機能にて、excel文書をpdfに変換する際に、`ReviewSourceModal`の変換進捗表示用`Backdrop`にシートの印刷設定中は「〇〇シートPDF印刷設定中」と表示しPDFファイルにエクスポートする際は「PDFファイルへエクスポート中」 と表示する
--  - 目的
--    - excelのpdf変換が特に時間がかかるので、ユーザに進捗を通知したいため（ユーザ体験の向上）
--  - 実装方針
--    - 最も効率的な方法を採用して欲しいが、イベント送信が無難か？
-+  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
+-- 要件
+-  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
++- ビジネス要件
++  - レビュー機能利用時に、レビュー結果に対してAIとチャットできる機能を追加する
++- 機能要件
++  1. 1レビュー履歴に対して1つの（結合）ドキュメントのみ登録可能にする: 完了済み
++    - 目的
++      - AIとチャットする際に複数のドキュメントがレビュー結果として登録されているとどのドキュメントに対して回答して良いかわからなくなるため
++    - 実装方針
++      - DBテーブルの更新
++        - `review_checklist_results`を廃止して`review_checklists`に統合
++        - `review_checklist_results`のfileId,fileNameを削除して、`review_histories`にtargetDocumentName(レビュー対象の(統合)ドキュメント名のこと)として同じ役割を引き継がせる
++      - ドメイン型の更新
++        - ReviewChecklistResultのsourceEvaluations属性は配列ではなく、単一要素とする
++        - ReviewChecklistResultのfileIdとfileNameを削除、targetDocumentNameを新規追加
++        - これらに伴い既存処理の変更も必要になるので注意すること
++      - サーバサイド処理更新
++        - レビュー実行の開始時(`src/mastra/workflows/sourceReview/executeReview/index.ts`のステップ1テキスト抽出とカテゴリ分割の実行後のmap処理内)に、既存のレビュー結果は全て削除してから実行するように変更する
++  2. レビュー実行時にアップロードしたファイル内容(抽出済みテキスト、画像データ)と、（大量ドキュメントレビューの場合は）個別レビューの結果を、後にチャットする時のために保存して取り出すことができるようにする: 完了済み
++    - 実装方針
++      - DBテーブルの更新
++        - `review_document_chaches`テーブルの作成
++          - `review_histories`と一対多の関係
++          - ファイルのメタデータ(id, originalFileName(大量ドキュメントレビュー用), fileName, processMode('text' or 'image'), originalPath, cachePath,...等)を保存
++        - `review_histories`テーブルに大量ドキュメントレビューか少量ドキュメントレビューかを示すフラグを追加
++        - `review_largedocument_result_chaches`テーブルの作成
++          - `review_document_chaches`と`review_checklists`の中間テーブル
++          - 少量ドキュメントレビューの場合に、個別チェックリストに対して、個別ドキュメントをレビューするが、その際のチャンクパラメータ(チャンク総数と個別ドキュメントのチャンクインデックス)と結果を保存
++      - ドメイン型の更新
++        - 上記に合わせてドメイン型(`src/types/review.ts`)の新規作成が必要
++        - 今後も見据えて最善のドメイン型を作成してください
++      - サーバサイド処理更新
++        - レビュー実行方法が大量ドキュメントレビューであったか、それとも少量ドキュメントレビューであったのか、レビュー実行時に保存できるようにする
++        - ファイルのメタデータについてはDBに保存し、実態はキャッシュ用のディレクトリに保存
++          - キャッシュについては以下パスに保存
++            - 抽出済みテキスト`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}.txt`
++            - 画像データ`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}/page_${インデックス値}.b64`
++          - キャッシュのパスはDBに保存して、後ほどチャット機能で簡単にパスを取得できるようにする
++            - processModeがtextの場合はキャッシュのパスはファイルパス(`.../${id}.txt`)になり、imageの場合はディレクトリパス(`.../${id}`)になる
++          - 実際にレビューが実行された直後にレビュー結果とともにドキュメントのキャッシュを保存する
++      - 実装時の注意点
++        - （少量、大量）レビュー実行時の処理（コンポーネント~workflow）に影響があるので、幅広く影響を見極めること
++        - DBとドメインについてはどちらも上手くrepositoryインターフェースに依存性逆転させているのでこれを利用して効率的に実装すること
++  3. レビュー結果に対してAIとチャットできるようにする: 実行中
++    - 実装方針
++      - UI
++        - チャット結果画面内(`src/renderer/components/review/ReviewChecklistSection.tsx`)にチャットを開始できるボタンを配置
++          - このボタンが押下されると画面右サイドからチャット画面が出現する
++            - チャット画面については`src/renderer/components/chat/ChatArea.tsx`を参考にすること(特にuseChatフックを利用する部分)
++        - チャットに関するコンポーネントは最大限既存のものを活用する（`src/renderer/components/chat`） 
++        - チャット内容は永続化する必要はなく、レビューIDを切り替えたらチャット内容は初期化される
++        - チャット入力欄で「@」と入力するとどのチェックリストに対して質問をするかスクロール形式で選ぶことができる
++          - 一般的にAIコーディングエディタ内で任意のファイルを参照させることができるようにするための用途で実装されているものと同じ形式と理解して実装してください
++          - 対象のチェックリストについてはuseStateで状態管理しておく
++            - 「@チェックリストA」のような完全な状態から「@チェックリスト」のように一文字でも欠けた状態になった場合は、状態管理から外す
++            - 管理下にあるチェックリストについてはチャット入力欄内の「@チェックリストA」を青字で表示する(これも一般的なAIコーディングエディタでよくある実装方法です)
++            - 複数のチェックリストを登録可能
++      - サーバサイド処理更新
++        - AIチャット機能実装
++          - mastra workflowとして実装
++            - workflowは以下のようなステップで構築する(大量ドキュメントレビュー、少量ドキュメントレビューで区別しない)
++              1. AIにユーザからの質問と対象のチェックリストを与えて、調査対象ドキュメントとその調査内容のペアの配列を出力させる
++                - AI処理詳細
++                  - システムプロンプト
++                    - 提示する内容
++                      - @で指定されたチェックリストの内容とレビュー結果（大量レビューの場合は個別のレビュー結果も） 
++                      - ドキュメントキャッシュ内容(id, FileName)
++                        - 出力時に質問対象ドキュメントを指定できるようにするため
++                      - AIの役割：ユーザから与えられたチェックリスト結果と質問に対して、最終的に良い回答ができるように、調査すべきドキュメントとその調査内容を出力すること
++                  - ユーザコンテキスト
++                      - ユーザからの質問
++                  - 出力内容
++                  ```
++                  {
++                    documentId: string # review_document_cachesテーブルのId
++                    researchContent: string
++                  }[]
++                  ```
++              2. 1で指定されたドキュメント毎に以下ステップを並列実行(foreach)
++                - `review_largedocument_result_chaches`テーブル内のドキュメントキャッシュIDが一致するレコードからtotalChunksの最大値を取得
++                - 以下をループ(dountil)※`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts`の`individualDocumentReviewWorkflow`を参考にすること
++                  - ドキュメントをtotalChunks分のチャンクに分解して(`src/mastra/workflows/sourceReview/lib.ts`を利用)、それぞれに対して以下を並列実行(foreach)
++                    - AIに調査対象ドキュメント(reviewRepository#getReviewDocumentCacheByDocumentIdを利用して取得)と調査内容を与えて、調査結果を出力する
++                  - 並列処理の結果一つでもコンテキスト長エラーになっていた場合は、チャンク数を一つ増やして処理をループする（全てsuccessの場合はループ終了）
++              3. 2の調査結果を全てAIに与えて、最終的にユーザ返す質問内容を出力する
++            - workflowの最終的な処理結果はチャット機能と同様にAI SDK形式のチャンクをイベントpushで送信する(chatService#generateを参照)
++    - 実装時の注意点
++      - workflowの実装方法は大量ドキュメントレビュー実行時のworkflowを参考にすること
++      - AIに与えるシステムプロンプトも大量ドキュメントレビュー実行時ものもを参考にすること(なぜその処理を実行させたいのか、背景もうまく伝えられるようにして欲しい)
++  - 改善事項
++    - reviewChatResearchAgentの改善
++      - ASIS
++        - ドキュメントチャンクの情報のみ与えられる
++      - TOBE
++        - 質問対象チェックリストの情報、ユーザの質問の情報もシステムプロンプトのコンテキストに含めることで、質問の背景知識をAIに理解させより回答精度を上げる
++### タスク実装時の注意点
++- 全ての手順を理解した上で、最適な実装をすること
++- プロンプト作成の際はベストプラクティスに沿って効果的なプロンプトにすること
++- ユーザが直感的に操作できて、尚且つ一般的なUIにすること
++  - 美しく、ユーザへの配慮がしっかりとできているUIにすること
+diff --git a/changes.patch b/changes.patch
+index b53722bce..becb554dd 100644
+--- a/changes.patch
++++ b/changes.patch
+@@ -1,81 +1,19427 @@
+ diff --git a/CLAUDE.md b/CLAUDE.md
+-index 33069f026..81694e235 100644
++index 81694e235..f9600cdaf 100644
+ --- a/CLAUDE.md
+ +++ b/CLAUDE.md
+-@@ -210,8 +210,4 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
++@@ -61,7 +61,7 @@ npm test
++             - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
++               - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
++             - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
++-      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つのドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
+++      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
++       - 対応可能なファイルは以下
++         - word,excel,powerpoint,pdf,テキスト文書
++           - テキスト抽出するか画像としてAIに送信するか選択することができる
++@@ -203,11 +203,109 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
++   - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
++ - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
++ - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
++-- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+++- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型（ドメイン型）(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
++ - テストについては指示されない限り、実行も修正もしなくてよい
+++- DBマイグレーションの実行は指示されない限り不要
++ - 適宜調査や実装の際に必要あればcodex mcpを活用すること
+++- 新規追加した部分については型エラーが出ないようにすること
++ 
+  
+  ## 依頼タスク
+- - 要件
+--  - レビュー機能にて、excel文書をpdfに変換する際に、`ReviewSourceModal`の変換進捗表示用`Backdrop`にシートの印刷設定中は「〇〇シートPDF印刷設定中」と表示しPDFファイルにエクスポートする際は「PDFファイルへエクスポート中」 と表示する
+--  - 目的
+--    - excelのpdf変換が特に時間がかかるので、ユーザに進捗を通知したいため（ユーザ体験の向上）
+--  - 実装方針
+--    - 最も効率的な方法を採用して欲しいが、イベント送信が無難か？
+-+  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
++-- 要件
++-  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
+++- ビジネス要件
+++  - レビュー機能利用時に、レビュー結果に対してAIとチャットできる機能を追加する
+++- 機能要件
+++  1. 1レビュー履歴に対して1つの（結合）ドキュメントのみ登録可能にする: 完了済み
+++    - 目的
+++      - AIとチャットする際に複数のドキュメントがレビュー結果として登録されているとどのドキュメントに対して回答して良いかわからなくなるため
+++    - 実装方針
+++      - DBテーブルの更新
+++        - `review_checklist_results`を廃止して`review_checklists`に統合
+++        - `review_checklist_results`のfileId,fileNameを削除して、`review_histories`にtargetDocumentName(レビュー対象の(統合)ドキュメント名のこと)として同じ役割を引き継がせる
+++      - ドメイン型の更新
+++        - ReviewChecklistResultのsourceEvaluations属性は配列ではなく、単一要素とする
+++        - ReviewChecklistResultのfileIdとfileNameを削除、targetDocumentNameを新規追加
+++        - これらに伴い既存処理の変更も必要になるので注意すること
+++      - サーバサイド処理更新
+++        - レビュー実行の開始時(`src/mastra/workflows/sourceReview/executeReview/index.ts`のステップ1テキスト抽出とカテゴリ分割の実行後のmap処理内)に、既存のレビュー結果は全て削除してから実行するように変更する
+++  2. レビュー実行時にアップロードしたファイル内容(抽出済みテキスト、画像データ)と、（大量ドキュメントレビューの場合は）個別レビューの結果を、後にチャットする時のために保存して取り出すことができるようにする: 完了済み
+++    - 実装方針
+++      - DBテーブルの更新
+++        - `review_document_chaches`テーブルの作成
+++          - `review_histories`と一対多の関係
+++          - ファイルのメタデータ(id, originalFileName(大量ドキュメントレビュー用), fileName, processMode('text' or 'image'), originalPath, cachePath,...等)を保存
+++        - `review_histories`テーブルに大量ドキュメントレビューか少量ドキュメントレビューかを示すフラグを追加
+++        - `review_largedocument_result_chaches`テーブルの作成
+++          - `review_document_chaches`と`review_checklists`の中間テーブル
+++          - 少量ドキュメントレビューの場合に、個別チェックリストに対して、個別ドキュメントをレビューするが、その際のチャンクパラメータ(チャンク総数と個別ドキュメントのチャンクインデックス)と結果を保存
+++      - ドメイン型の更新
+++        - 上記に合わせてドメイン型(`src/types/review.ts`)の新規作成が必要
+++        - 今後も見据えて最善のドメイン型を作成してください
+++      - サーバサイド処理更新
+++        - レビュー実行方法が大量ドキュメントレビューであったか、それとも少量ドキュメントレビューであったのか、レビュー実行時に保存できるようにする
+++        - ファイルのメタデータについてはDBに保存し、実態はキャッシュ用のディレクトリに保存
+++          - キャッシュについては以下パスに保存
+++            - 抽出済みテキスト`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}.txt`
+++            - 画像データ`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}/page_${インデックス値}.b64`
+++          - キャッシュのパスはDBに保存して、後ほどチャット機能で簡単にパスを取得できるようにする
+++            - processModeがtextの場合はキャッシュのパスはファイルパス(`.../${id}.txt`)になり、imageの場合はディレクトリパス(`.../${id}`)になる
+++          - 実際にレビューが実行された直後にレビュー結果とともにドキュメントのキャッシュを保存する
+++      - 実装時の注意点
+++        - （少量、大量）レビュー実行時の処理（コンポーネント~workflow）に影響があるので、幅広く影響を見極めること
+++        - DBとドメインについてはどちらも上手くrepositoryインターフェースに依存性逆転させているのでこれを利用して効率的に実装すること
+++  3. レビュー結果に対してAIとチャットできるようにする: 実行中
+++    - 実装方針
+++      - UI
+++        - チャット結果画面内(`src/renderer/components/review/ReviewChecklistSection.tsx`)にチャットを開始できるボタンを配置
+++          - このボタンが押下されると画面右サイドからチャット画面が出現する
+++            - チャット画面については`src/renderer/components/chat/ChatArea.tsx`を参考にすること(特にuseChatフックを利用する部分)
+++        - チャットに関するコンポーネントは最大限既存のものを活用する（`src/renderer/components/chat`） 
+++        - チャット内容は永続化する必要はなく、レビューIDを切り替えたらチャット内容は初期化される
+++        - チャット入力欄で「@」と入力するとどのチェックリストに対して質問をするかスクロール形式で選ぶことができる
+++          - 一般的にAIコーディングエディタ内で任意のファイルを参照させることができるようにするための用途で実装されているものと同じ形式と理解して実装してください
+++          - 対象のチェックリストについてはuseStateで状態管理しておく
+++            - 「@チェックリストA」のような完全な状態から「@チェックリスト」のように一文字でも欠けた状態になった場合は、状態管理から外す
+++            - 管理下にあるチェックリストについてはチャット入力欄内の「@チェックリストA」を青字で表示する(これも一般的なAIコーディングエディタでよくある実装方法です)
+++            - 複数のチェックリストを登録可能
+++      - サーバサイド処理更新
+++        - AIチャット機能実装
+++          - mastra workflowとして実装
+++            - workflowは以下のようなステップで構築する(大量ドキュメントレビュー、少量ドキュメントレビューで区別しない)
+++              1. AIにユーザからの質問と対象のチェックリストを与えて、調査対象ドキュメントとその調査内容のペアの配列を出力させる
+++                - AI処理詳細
+++                  - システムプロンプト
+++                    - 提示する内容
+++                      - @で指定されたチェックリストの内容とレビュー結果（大量レビューの場合は個別のレビュー結果も） 
+++                      - ドキュメントキャッシュ内容(id, FileName)
+++                        - 出力時に質問対象ドキュメントを指定できるようにするため
+++                      - AIの役割：ユーザから与えられたチェックリスト結果と質問に対して、最終的に良い回答ができるように、調査すべきドキュメントとその調査内容を出力すること
+++                  - ユーザコンテキスト
+++                      - ユーザからの質問
+++                  - 出力内容
+++                  ```
+++                  {
+++                    documentId: string # review_document_cachesテーブルのId
+++                    researchContent: string
+++                  }[]
+++                  ```
+++              2. 1で指定されたドキュメント毎に以下ステップを並列実行(foreach)
+++                - `review_largedocument_result_chaches`テーブル内のドキュメントキャッシュIDが一致するレコードからtotalChunksの最大値を取得
+++                - 以下をループ(dountil)※`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts`の`individualDocumentReviewWorkflow`を参考にすること
+++                  - ドキュメントをtotalChunks分のチャンクに分解して(`src/mastra/workflows/sourceReview/lib.ts`を利用)、それぞれに対して以下を並列実行(foreach)
+++                    - AIに調査対象ドキュメント(reviewRepository#getReviewDocumentCacheByDocumentIdを利用して取得)と調査内容を与えて、調査結果を出力する
+++                  - 並列処理の結果一つでもコンテキスト長エラーになっていた場合は、チャンク数を一つ増やして処理をループする（全てsuccessの場合はループ終了）
+++              3. 2の調査結果を全てAIに与えて、最終的にユーザ返す質問内容を出力する
+++            - workflowの最終的な処理結果はチャット機能と同様にAI SDK形式のチャンクをイベントpushで送信する(chatService#generateを参照)
+++    - 実装時の注意点
+++      - workflowの実装方法は大量ドキュメントレビュー実行時のworkflowを参考にすること
+++      - AIに与えるシステムプロンプトも大量ドキュメントレビュー実行時ものもを参考にすること(なぜその処理を実行させたいのか、背景もうまく伝えられるようにして欲しい)
+++  - 改善事項
+++    - reviewChatResearchAgentの改善
+++      - ASIS
+++        - ドキュメントチャンクの情報のみ与えられる
+++      - TOBE
+++        - 質問対象チェックリストの情報、ユーザの質問の情報もシステムプロンプトのコンテキストに含めることで、質問の背景知識をAIに理解させより回答精度を上げる
+++### タスク実装時の注意点
+++- 全ての手順を理解した上で、最適な実装をすること
+++- プロンプト作成の際はベストプラクティスに沿って効果的なプロンプトにすること
+++- ユーザが直感的に操作できて、尚且つ一般的なUIにすること
+++  - 美しく、ユーザへの配慮がしっかりとできているUIにすること
++diff --git a/changes.patch b/changes.patch
++index b53722bce..560b72b48 100644
++--- a/changes.patch
+++++ b/changes.patch
++@@ -1,81 +1,12527 @@
++ diff --git a/CLAUDE.md b/CLAUDE.md
++-index 33069f026..81694e235 100644
+++index 81694e235..f9600cdaf 100644
++ --- a/CLAUDE.md
++ +++ b/CLAUDE.md
++-@@ -210,8 +210,4 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
+++@@ -61,7 +61,7 @@ npm test
+++             - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
+++               - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
+++             - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
+++-      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つのドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
++++      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
+++       - 対応可能なファイルは以下
+++         - word,excel,powerpoint,pdf,テキスト文書
+++           - テキスト抽出するか画像としてAIに送信するか選択することができる
+++@@ -203,11 +203,109 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
+++   - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
+++ - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
+++ - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
+++-- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
++++- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型（ドメイン型）(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+++ - テストについては指示されない限り、実行も修正もしなくてよい
++++- DBマイグレーションの実行は指示されない限り不要
+++ - 適宜調査や実装の際に必要あればcodex mcpを活用すること
++++- 新規追加した部分については型エラーが出ないようにすること
+++ 
++  
++  ## 依頼タスク
++- - 要件
++--  - レビュー機能にて、excel文書をpdfに変換する際に、`ReviewSourceModal`の変換進捗表示用`Backdrop`にシートの印刷設定中は「〇〇シートPDF印刷設定中」と表示しPDFファイルにエクスポートする際は「PDFファイルへエクスポート中」 と表示する
++--  - 目的
++--    - excelのpdf変換が特に時間がかかるので、ユーザに進捗を通知したいため（ユーザ体験の向上）
++--  - 実装方針
++--    - 最も効率的な方法を採用して欲しいが、イベント送信が無難か？
++-+  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
+++-- 要件
+++-  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
++++- ビジネス要件
++++  - レビュー機能利用時に、レビュー結果に対してAIとチャットできる機能を追加する
++++- 機能要件
++++  1. 1レビュー履歴に対して1つの（結合）ドキュメントのみ登録可能にする: 完了済み
++++    - 目的
++++      - AIとチャットする際に複数のドキュメントがレビュー結果として登録されているとどのドキュメントに対して回答して良いかわからなくなるため
++++    - 実装方針
++++      - DBテーブルの更新
++++        - `review_checklist_results`を廃止して`review_checklists`に統合
++++        - `review_checklist_results`のfileId,fileNameを削除して、`review_histories`にtargetDocumentName(レビュー対象の(統合)ドキュメント名のこと)として同じ役割を引き継がせる
++++      - ドメイン型の更新
++++        - ReviewChecklistResultのsourceEvaluations属性は配列ではなく、単一要素とする
++++        - ReviewChecklistResultのfileIdとfileNameを削除、targetDocumentNameを新規追加
++++        - これらに伴い既存処理の変更も必要になるので注意すること
++++      - サーバサイド処理更新
++++        - レビュー実行の開始時(`src/mastra/workflows/sourceReview/executeReview/index.ts`のステップ1テキスト抽出とカテゴリ分割の実行後のmap処理内)に、既存のレビュー結果は全て削除してから実行するように変更する
++++  2. レビュー実行時にアップロードしたファイル内容(抽出済みテキスト、画像データ)と、（大量ドキュメントレビューの場合は）個別レビューの結果を、後にチャットする時のために保存して取り出すことができるようにする: 完了済み
++++    - 実装方針
++++      - DBテーブルの更新
++++        - `review_document_chaches`テーブルの作成
++++          - `review_histories`と一対多の関係
++++          - ファイルのメタデータ(id, originalFileName(大量ドキュメントレビュー用), fileName, processMode('text' or 'image'), originalPath, cachePath,...等)を保存
++++        - `review_histories`テーブルに大量ドキュメントレビューか少量ドキュメントレビューかを示すフラグを追加
++++        - `review_largedocument_result_chaches`テーブルの作成
++++          - `review_document_chaches`と`review_checklists`の中間テーブル
++++          - 少量ドキュメントレビューの場合に、個別チェックリストに対して、個別ドキュメントをレビューするが、その際のチャンクパラメータ(チャンク総数と個別ドキュメントのチャンクインデックス)と結果を保存
++++      - ドメイン型の更新
++++        - 上記に合わせてドメイン型(`src/types/review.ts`)の新規作成が必要
++++        - 今後も見据えて最善のドメイン型を作成してください
++++      - サーバサイド処理更新
++++        - レビュー実行方法が大量ドキュメントレビューであったか、それとも少量ドキュメントレビューであったのか、レビュー実行時に保存できるようにする
++++        - ファイルのメタデータについてはDBに保存し、実態はキャッシュ用のディレクトリに保存
++++          - キャッシュについては以下パスに保存
++++            - 抽出済みテキスト`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}.txt`
++++            - 画像データ`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}/page_${インデックス値}.b64`
++++          - キャッシュのパスはDBに保存して、後ほどチャット機能で簡単にパスを取得できるようにする
++++            - processModeがtextの場合はキャッシュのパスはファイルパス(`.../${id}.txt`)になり、imageの場合はディレクトリパス(`.../${id}`)になる
++++          - 実際にレビューが実行された直後にレビュー結果とともにドキュメントのキャッシュを保存する
++++      - 実装時の注意点
++++        - （少量、大量）レビュー実行時の処理（コンポーネント~workflow）に影響があるので、幅広く影響を見極めること
++++        - DBとドメインについてはどちらも上手くrepositoryインターフェースに依存性逆転させているのでこれを利用して効率的に実装すること
++++  3. レビュー結果に対してAIとチャットできるようにする: 実行中
++++    - 実装方針
++++      - UI
++++        - チャット結果画面内(`src/renderer/components/review/ReviewChecklistSection.tsx`)にチャットを開始できるボタンを配置
++++          - このボタンが押下されると画面右サイドからチャット画面が出現する
++++            - チャット画面については`src/renderer/components/chat/ChatArea.tsx`を参考にすること(特にuseChatフックを利用する部分)
++++        - チャットに関するコンポーネントは最大限既存のものを活用する（`src/renderer/components/chat`） 
++++        - チャット内容は永続化する必要はなく、レビューIDを切り替えたらチャット内容は初期化される
++++        - チャット入力欄で「@」と入力するとどのチェックリストに対して質問をするかスクロール形式で選ぶことができる
++++          - 一般的にAIコーディングエディタ内で任意のファイルを参照させることができるようにするための用途で実装されているものと同じ形式と理解して実装してください
++++          - 対象のチェックリストについてはuseStateで状態管理しておく
++++            - 「@チェックリストA」のような完全な状態から「@チェックリスト」のように一文字でも欠けた状態になった場合は、状態管理から外す
++++            - 管理下にあるチェックリストについてはチャット入力欄内の「@チェックリストA」を青字で表示する(これも一般的なAIコーディングエディタでよくある実装方法です)
++++            - 複数のチェックリストを登録可能
++++      - サーバサイド処理更新
++++        - AIチャット機能実装
++++          - mastra workflowとして実装
++++            - workflowは以下のようなステップで構築する(大量ドキュメントレビュー、少量ドキュメントレビューで区別しない)
++++              1. AIにユーザからの質問と対象のチェックリストを与えて、調査対象ドキュメントとその調査内容のペアの配列を出力させる
++++                - AI処理詳細
++++                  - システムプロンプト
++++                    - 提示する内容
++++                      - @で指定されたチェックリストの内容とレビュー結果（大量レビューの場合は個別のレビュー結果も） 
++++                      - ドキュメントキャッシュ内容(id, FileName)
++++                        - 出力時に質問対象ドキュメントを指定できるようにするため
++++                      - AIの役割：ユーザから与えられたチェックリスト結果と質問に対して、最終的に良い回答ができるように、調査すべきドキュメントとその調査内容を出力すること
++++                  - ユーザコンテキスト
++++                      - ユーザからの質問
++++                  - 出力内容
++++                  ```
++++                  {
++++                    documentId: string # review_document_cachesテーブルのId
++++                    researchContent: string
++++                  }[]
++++                  ```
++++              2. 1で指定されたドキュメント毎に以下ステップを並列実行(foreach)
++++                - `review_largedocument_result_chaches`テーブル内のドキュメントキャッシュIDが一致するレコードからtotalChunksの最大値を取得
++++                - 以下をループ(dountil)※`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts`の`individualDocumentReviewWorkflow`を参考にすること
++++                  - ドキュメントをtotalChunks分のチャンクに分解して(`src/mastra/workflows/sourceReview/lib.ts`を利用)、それぞれに対して以下を並列実行(foreach)
++++                    - AIに調査対象ドキュメント(reviewRepository#getReviewDocumentCacheByDocumentIdを利用して取得)と調査内容を与えて、調査結果を出力する
++++                  - 並列処理の結果一つでもコンテキスト長エラーになっていた場合は、チャンク数を一つ増やして処理をループする（全てsuccessの場合はループ終了）
++++              3. 2の調査結果を全てAIに与えて、最終的にユーザ返す質問内容を出力する
++++            - workflowの最終的な処理結果はチャット機能と同様にAI SDK形式のチャンクをイベントpushで送信する(chatService#generateを参照)
++++    - 実装時の注意点
++++      - workflowの実装方法は大量ドキュメントレビュー実行時のworkflowを参考にすること
++++      - AIに与えるシステムプロンプトも大量ドキュメントレビュー実行時ものもを参考にすること(なぜその処理を実行させたいのか、背景もうまく伝えられるようにして欲しい)
++++  - 改善事項
++++    - reviewChatResearchAgentの改善
++++      - ASIS
++++        - ドキュメントチャンクの情報のみ与えられる
++++      - TOBE
++++        - 質問対象チェックリストの情報、ユーザの質問の情報もシステムプロンプトのコンテキストに含めることで、質問の背景知識をAIに理解させより回答精度を上げる
++++### タスク実装時の注意点
++++- 全ての手順を理解した上で、最適な実装をすること
++++- プロンプト作成の際はベストプラクティスに沿って効果的なプロンプトにすること
++++- ユーザが直感的に操作できて、尚且つ一般的なUIにすること
++++  - 美しく、ユーザへの配慮がしっかりとできているUIにすること
+++diff --git a/changes.patch b/changes.patch
+++index b53722bce..094dfc800 100644
+++--- a/changes.patch
++++++ b/changes.patch
+++@@ -1,81 +1,5917 @@
+++ diff --git a/CLAUDE.md b/CLAUDE.md
+++-index 33069f026..81694e235 100644
++++index 81694e235..f9600cdaf 100644
+++ --- a/CLAUDE.md
+++ +++ b/CLAUDE.md
+++-@@ -210,8 +210,4 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
++++@@ -61,7 +61,7 @@ npm test
++++             - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
++++               - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
++++             - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
++++-      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つのドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
+++++      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
++++       - 対応可能なファイルは以下
++++         - word,excel,powerpoint,pdf,テキスト文書
++++           - テキスト抽出するか画像としてAIに送信するか選択することができる
++++@@ -203,11 +203,109 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
++++   - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
++++ - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
++++ - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
++++-- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+++++- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型（ドメイン型）(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
++++ - テストについては指示されない限り、実行も修正もしなくてよい
+++++- DBマイグレーションの実行は指示されない限り不要
++++ - 適宜調査や実装の際に必要あればcodex mcpを活用すること
+++++- 新規追加した部分については型エラーが出ないようにすること
++++ 
+++  
+++  ## 依頼タスク
+++- - 要件
+++--  - レビュー機能にて、excel文書をpdfに変換する際に、`ReviewSourceModal`の変換進捗表示用`Backdrop`にシートの印刷設定中は「〇〇シートPDF印刷設定中」と表示しPDFファイルにエクスポートする際は「PDFファイルへエクスポート中」 と表示する
+++--  - 目的
+++--    - excelのpdf変換が特に時間がかかるので、ユーザに進捗を通知したいため（ユーザ体験の向上）
+++--  - 実装方針
+++--    - 最も効率的な方法を採用して欲しいが、イベント送信が無難か？
+++-+  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
++++-- 要件
++++-  - 大量ドキュメントレビューの結果を表示する際に、ドキュメント分割した際に一時的に付与したファイル名が全て結合されてしまっており、結果が見にくい。少量ドキュメントレビューと同じようにファイルアップロードした元のファイル名のみ結合するように変更する。
+++++- ビジネス要件
+++++  - レビュー機能利用時に、レビュー結果に対してAIとチャットできる機能を追加する
+++++- 機能要件
+++++  1. 1レビュー履歴に対して1つの（結合）ドキュメントのみ登録可能にする: 完了済み
+++++    - 目的
+++++      - AIとチャットする際に複数のドキュメントがレビュー結果として登録されているとどのドキュメントに対して回答して良いかわからなくなるため
+++++    - 実装方針
+++++      - DBテーブルの更新
+++++        - `review_checklist_results`を廃止して`review_checklists`に統合
+++++        - `review_checklist_results`のfileId,fileNameを削除して、`review_histories`にtargetDocumentName(レビュー対象の(統合)ドキュメント名のこと)として同じ役割を引き継がせる
+++++      - ドメイン型の更新
+++++        - ReviewChecklistResultのsourceEvaluations属性は配列ではなく、単一要素とする
+++++        - ReviewChecklistResultのfileIdとfileNameを削除、targetDocumentNameを新規追加
+++++        - これらに伴い既存処理の変更も必要になるので注意すること
+++++      - サーバサイド処理更新
+++++        - レビュー実行の開始時(`src/mastra/workflows/sourceReview/executeReview/index.ts`のステップ1テキスト抽出とカテゴリ分割の実行後のmap処理内)に、既存のレビュー結果は全て削除してから実行するように変更する
+++++  2. レビュー実行時にアップロードしたファイル内容(抽出済みテキスト、画像データ)と、（大量ドキュメントレビューの場合は）個別レビューの結果を、後にチャットする時のために保存して取り出すことができるようにする: 完了済み
+++++    - 実装方針
+++++      - DBテーブルの更新
+++++        - `review_document_chaches`テーブルの作成
+++++          - `review_histories`と一対多の関係
+++++          - ファイルのメタデータ(id, originalFileName(大量ドキュメントレビュー用), fileName, processMode('text' or 'image'), originalPath, cachePath,...等)を保存
+++++        - `review_histories`テーブルに大量ドキュメントレビューか少量ドキュメントレビューかを示すフラグを追加
+++++        - `review_largedocument_result_chaches`テーブルの作成
+++++          - `review_document_chaches`と`review_checklists`の中間テーブル
+++++          - 少量ドキュメントレビューの場合に、個別チェックリストに対して、個別ドキュメントをレビューするが、その際のチャンクパラメータ(チャンク総数と個別ドキュメントのチャンクインデックス)と結果を保存
+++++      - ドメイン型の更新
+++++        - 上記に合わせてドメイン型(`src/types/review.ts`)の新規作成が必要
+++++        - 今後も見据えて最善のドメイン型を作成してください
+++++      - サーバサイド処理更新
+++++        - レビュー実行方法が大量ドキュメントレビューであったか、それとも少量ドキュメントレビューであったのか、レビュー実行時に保存できるようにする
+++++        - ファイルのメタデータについてはDBに保存し、実態はキャッシュ用のディレクトリに保存
+++++          - キャッシュについては以下パスに保存
+++++            - 抽出済みテキスト`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}.txt`
+++++            - 画像データ`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}/page_${インデックス値}.b64`
+++++          - キャッシュのパスはDBに保存して、後ほどチャット機能で簡単にパスを取得できるようにする
+++++            - processModeがtextの場合はキャッシュのパスはファイルパス(`.../${id}.txt`)になり、imageの場合はディレクトリパス(`.../${id}`)になる
+++++          - 実際にレビューが実行された直後にレビュー結果とともにドキュメントのキャッシュを保存する
+++++      - 実装時の注意点
+++++        - （少量、大量）レビュー実行時の処理（コンポーネント~workflow）に影響があるので、幅広く影響を見極めること
+++++        - DBとドメインについてはどちらも上手くrepositoryインターフェースに依存性逆転させているのでこれを利用して効率的に実装すること
+++++  3. レビュー結果に対してAIとチャットできるようにする: 実行中
+++++    - 実装方針
+++++      - UI
+++++        - チャット結果画面内(`src/renderer/components/review/ReviewChecklistSection.tsx`)にチャットを開始できるボタンを配置
+++++          - このボタンが押下されると画面右サイドからチャット画面が出現する
+++++            - チャット画面については`src/renderer/components/chat/ChatArea.tsx`を参考にすること(特にuseChatフックを利用する部分)
+++++        - チャットに関するコンポーネントは最大限既存のものを活用する（`src/renderer/components/chat`） 
+++++        - チャット内容は永続化する必要はなく、レビューIDを切り替えたらチャット内容は初期化される
+++++        - チャット入力欄で「@」と入力するとどのチェックリストに対して質問をするかスクロール形式で選ぶことができる
+++++          - 一般的にAIコーディングエディタ内で任意のファイルを参照させることができるようにするための用途で実装されているものと同じ形式と理解して実装してください
+++++          - 対象のチェックリストについてはuseStateで状態管理しておく
+++++            - 「@チェックリストA」のような完全な状態から「@チェックリスト」のように一文字でも欠けた状態になった場合は、状態管理から外す
+++++            - 管理下にあるチェックリストについてはチャット入力欄内の「@チェックリストA」を青字で表示する(これも一般的なAIコーディングエディタでよくある実装方法です)
+++++            - 複数のチェックリストを登録可能
+++++      - サーバサイド処理更新
+++++        - AIチャット機能実装
+++++          - mastra workflowとして実装
+++++            - workflowは以下のようなステップで構築する(大量ドキュメントレビュー、少量ドキュメントレビューで区別しない)
+++++              1. AIにユーザからの質問と対象のチェックリストを与えて、調査対象ドキュメントとその調査内容のペアの配列を出力させる
+++++                - AI処理詳細
+++++                  - システムプロンプト
+++++                    - 提示する内容
+++++                      - @で指定されたチェックリストの内容とレビュー結果（大量レビューの場合は個別のレビュー結果も） 
+++++                      - ドキュメントキャッシュ内容(id, FileName)
+++++                        - 出力時に質問対象ドキュメントを指定できるようにするため
+++++                      - AIの役割：ユーザから与えられたチェックリスト結果と質問に対して、最終的に良い回答ができるように、調査すべきドキュメントとその調査内容を出力すること
+++++                  - ユーザコンテキスト
+++++                      - ユーザからの質問
+++++                  - 出力内容
+++++                  ```
+++++                  {
+++++                    documentId: string # review_document_cachesテーブルのId
+++++                    researchContent: string
+++++                  }[]
+++++                  ```
+++++              2. 1で指定されたドキュメント毎に以下ステップを並列実行(foreach)
+++++                - `review_largedocument_result_chaches`テーブル内のドキュメントキャッシュIDが一致するレコードからtotalChunksの最大値を取得
+++++                - 以下をループ(dountil)※`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts`の`individualDocumentReviewWorkflow`を参考にすること
+++++                  - ドキュメントをtotalChunks分のチャンクに分解して(`src/mastra/workflows/sourceReview/lib.ts`を利用)、それぞれに対して以下を並列実行(foreach)
+++++                    - AIに調査対象ドキュメント(reviewRepository#getReviewDocumentCacheByDocumentIdを利用して取得)と調査内容を与えて、調査結果を出力する
+++++                  - 並列処理の結果一つでもコンテキスト長エラーになっていた場合は、チャンク数を一つ増やして処理をループする（全てsuccessの場合はループ終了）
+++++              3. 2の調査結果を全てAIに与えて、最終的にユーザ返す質問内容を出力する
+++++            - workflowの最終的な処理結果はチャット機能と同様にAI SDK形式のチャンクをイベントpushで送信する(chatService#generateを参照)
+++++    - 実装時の注意点
+++++      - workflowの実装方法は大量ドキュメントレビュー実行時のworkflowを参考にすること
+++++      - AIに与えるシステムプロンプトも大量ドキュメントレビュー実行時ものもを参考にすること(なぜその処理を実行させたいのか、背景もうまく伝えられるようにして欲しい)
+++++  - 改善事項
+++++    - reviewChatResearchAgentの改善
+++++      - ASIS
+++++        - ドキュメントチャンクの情報のみ与えられる
+++++      - TOBE
+++++        - 質問対象チェックリストの情報、ユーザの質問の情報もシステムプロンプトのコンテキストに含めることで、質問の背景知識をAIに理解させより回答精度を上げる
+++++### タスク実装時の注意点
+++++- 全ての手順を理解した上で、最適な実装をすること
+++++- プロンプト作成の際はベストプラクティスに沿って効果的なプロンプトにすること
+++++- ユーザが直感的に操作できて、尚且つ一般的なUIにすること
+++++  - 美しく、ユーザへの配慮がしっかりとできているUIにすること
++++diff --git a/drizzle.config.ts b/drizzle.config.ts
++++index 36ebf09d3..f73e59241 100644
++++--- a/drizzle.config.ts
+++++++ b/drizzle.config.ts
++++@@ -12,7 +12,7 @@ console.log(
++++ );
++++ 
++++ export default {
++++-  schema: './src/db/schema.ts',
+++++  schema: './src/adapter/db/drizzle/schema.ts',
++++   out: './drizzle/migrations',
++++   dialect: 'sqlite',
++++   dbCredentials: {
++++diff --git a/drizzle/migrations/0008_pink_ezekiel.sql b/drizzle/migrations/0008_pink_ezekiel.sql
++++new file mode 100644
++++index 000000000..8169d2866
++++--- /dev/null
+++++++ b/drizzle/migrations/0008_pink_ezekiel.sql
++++@@ -0,0 +1,4 @@
+++++DROP TABLE `review_checklist_results`;--> statement-breakpoint
+++++ALTER TABLE `review_checklists` ADD `evaluation` text;--> statement-breakpoint
+++++ALTER TABLE `review_checklists` ADD `comment` text;--> statement-breakpoint
+++++ALTER TABLE `review_histories` ADD `target_document_name` text;
++++\ No newline at end of file
++++diff --git a/drizzle/migrations/0009_keen_radioactive_man.sql b/drizzle/migrations/0009_keen_radioactive_man.sql
++++new file mode 100644
++++index 000000000..999bdbbd9
++++--- /dev/null
+++++++ b/drizzle/migrations/0009_keen_radioactive_man.sql
++++@@ -0,0 +1,23 @@
+++++CREATE TABLE `review_checklist_result_caches` (
+++++	`review_document_cache_id` integer NOT NULL,
+++++	`review_checklist_id` integer NOT NULL,
+++++	`comment` text NOT NULL,
+++++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`),
+++++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
+++++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+++++);
+++++--> statement-breakpoint
+++++CREATE TABLE `review_document_caches` (
+++++	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
+++++	`review_history_id` text NOT NULL,
+++++	`document_id` text NOT NULL,
+++++	`original_file_name` text NOT NULL,
+++++	`file_name` text NOT NULL,
+++++	`process_mode` text NOT NULL,
+++++	`cache_path` text NOT NULL,
+++++	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+++++	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
+++++	FOREIGN KEY (`review_history_id`) REFERENCES `review_histories`(`id`) ON UPDATE no action ON DELETE cascade
+++++);
+++++--> statement-breakpoint
+++++ALTER TABLE `review_histories` ADD `document_mode` text;
++++\ No newline at end of file
++++diff --git a/drizzle/migrations/0010_wet_shooting_star.sql b/drizzle/migrations/0010_wet_shooting_star.sql
++++new file mode 100644
++++index 000000000..49668f9f0
++++--- /dev/null
+++++++ b/drizzle/migrations/0010_wet_shooting_star.sql
++++@@ -0,0 +1,14 @@
+++++CREATE TABLE `review_largedocument_result_caches` (
+++++	`review_document_cache_id` integer NOT NULL,
+++++	`review_checklist_id` integer NOT NULL,
+++++	`comment` text NOT NULL,
+++++	`total_chunks` integer NOT NULL,
+++++	`chunk_index` integer NOT NULL,
+++++	`individual_file_name` text NOT NULL,
+++++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`, `chunk_index`),
+++++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
+++++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+++++);
+++++--> statement-breakpoint
+++++DROP TABLE `review_checklist_result_caches`;--> statement-breakpoint
+++++ALTER TABLE `review_document_caches` DROP COLUMN `original_file_name`;
++++\ No newline at end of file
++++diff --git a/drizzle/migrations/meta/0008_snapshot.json b/drizzle/migrations/meta/0008_snapshot.json
++++new file mode 100644
++++index 000000000..5148d151e
++++--- /dev/null
+++++++ b/drizzle/migrations/meta/0008_snapshot.json
++++@@ -0,0 +1,329 @@
+++++{
+++++  "version": "6",
+++++  "dialect": "sqlite",
+++++  "id": "e0ad999a-87f1-4f45-b070-a32c673d6352",
+++++  "prevId": "f10b9ed0-007d-4b08-941a-030265d534ff",
+++++  "tables": {
+++++    "review_checklists": {
+++++      "name": "review_checklists",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "review_history_id": {
+++++          "name": "review_history_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "content": {
+++++          "name": "content",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "evaluation": {
+++++          "name": "evaluation",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "comment": {
+++++          "name": "comment",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "created_by": {
+++++          "name": "created_by",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_checklists_review_history_id_review_histories_id_fk": {
+++++          "name": "review_checklists_review_history_id_review_histories_id_fk",
+++++          "tableFrom": "review_checklists",
+++++          "tableTo": "review_histories",
+++++          "columnsFrom": [
+++++            "review_history_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_histories": {
+++++      "name": "review_histories",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "text",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "title": {
+++++          "name": "title",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "target_document_name": {
+++++          "name": "target_document_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "additional_instructions": {
+++++          "name": "additional_instructions",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "comment_format": {
+++++          "name": "comment_format",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "evaluation_settings": {
+++++          "name": "evaluation_settings",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "processing_status": {
+++++          "name": "processing_status",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "'idle'"
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {},
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "sources": {
+++++      "name": "sources",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "path": {
+++++          "name": "path",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "title": {
+++++          "name": "title",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "summary": {
+++++          "name": "summary",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "status": {
+++++          "name": "status",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "'idle'"
+++++        },
+++++        "error": {
+++++          "name": "error",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "is_enabled": {
+++++          "name": "is_enabled",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": 1
+++++        }
+++++      },
+++++      "indexes": {
+++++        "sources_path_unique": {
+++++          "name": "sources_path_unique",
+++++          "columns": [
+++++            "path"
+++++          ],
+++++          "isUnique": true
+++++        }
+++++      },
+++++      "foreignKeys": {},
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "topics": {
+++++      "name": "topics",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "source_id": {
+++++          "name": "source_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "name": {
+++++          "name": "name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "summary": {
+++++          "name": "summary",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "topics_source_id_sources_id_fk": {
+++++          "name": "topics_source_id_sources_id_fk",
+++++          "tableFrom": "topics",
+++++          "tableTo": "sources",
+++++          "columnsFrom": [
+++++            "source_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    }
+++++  },
+++++  "views": {},
+++++  "enums": {},
+++++  "_meta": {
+++++    "schemas": {},
+++++    "tables": {},
+++++    "columns": {}
+++++  },
+++++  "internal": {
+++++    "indexes": {}
+++++  }
+++++}
++++\ No newline at end of file
++++diff --git a/drizzle/migrations/meta/0009_snapshot.json b/drizzle/migrations/meta/0009_snapshot.json
++++new file mode 100644
++++index 000000000..0f58c9424
++++--- /dev/null
+++++++ b/drizzle/migrations/meta/0009_snapshot.json
++++@@ -0,0 +1,491 @@
+++++{
+++++  "version": "6",
+++++  "dialect": "sqlite",
+++++  "id": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
+++++  "prevId": "e0ad999a-87f1-4f45-b070-a32c673d6352",
+++++  "tables": {
+++++    "review_checklist_result_caches": {
+++++      "name": "review_checklist_result_caches",
+++++      "columns": {
+++++        "review_document_cache_id": {
+++++          "name": "review_document_cache_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "review_checklist_id": {
+++++          "name": "review_checklist_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "comment": {
+++++          "name": "comment",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+++++          "name": "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk",
+++++          "tableFrom": "review_checklist_result_caches",
+++++          "tableTo": "review_document_caches",
+++++          "columnsFrom": [
+++++            "review_document_cache_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        },
+++++        "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk": {
+++++          "name": "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk",
+++++          "tableFrom": "review_checklist_result_caches",
+++++          "tableTo": "review_checklists",
+++++          "columnsFrom": [
+++++            "review_checklist_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {
+++++        "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk": {
+++++          "columns": [
+++++            "review_document_cache_id",
+++++            "review_checklist_id"
+++++          ],
+++++          "name": "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk"
+++++        }
+++++      },
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_checklists": {
+++++      "name": "review_checklists",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "review_history_id": {
+++++          "name": "review_history_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "content": {
+++++          "name": "content",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "evaluation": {
+++++          "name": "evaluation",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "comment": {
+++++          "name": "comment",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "created_by": {
+++++          "name": "created_by",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_checklists_review_history_id_review_histories_id_fk": {
+++++          "name": "review_checklists_review_history_id_review_histories_id_fk",
+++++          "tableFrom": "review_checklists",
+++++          "tableTo": "review_histories",
+++++          "columnsFrom": [
+++++            "review_history_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_document_caches": {
+++++      "name": "review_document_caches",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "review_history_id": {
+++++          "name": "review_history_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "document_id": {
+++++          "name": "document_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "original_file_name": {
+++++          "name": "original_file_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "file_name": {
+++++          "name": "file_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "process_mode": {
+++++          "name": "process_mode",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "cache_path": {
+++++          "name": "cache_path",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_document_caches_review_history_id_review_histories_id_fk": {
+++++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+++++          "tableFrom": "review_document_caches",
+++++          "tableTo": "review_histories",
+++++          "columnsFrom": [
+++++            "review_history_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_histories": {
+++++      "name": "review_histories",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "text",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "title": {
+++++          "name": "title",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "target_document_name": {
+++++          "name": "target_document_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "additional_instructions": {
+++++          "name": "additional_instructions",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "comment_format": {
+++++          "name": "comment_format",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "evaluation_settings": {
+++++          "name": "evaluation_settings",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "document_mode": {
+++++          "name": "document_mode",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "processing_status": {
+++++          "name": "processing_status",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "'idle'"
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {},
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "sources": {
+++++      "name": "sources",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "path": {
+++++          "name": "path",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "title": {
+++++          "name": "title",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "summary": {
+++++          "name": "summary",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "status": {
+++++          "name": "status",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "'idle'"
+++++        },
+++++        "error": {
+++++          "name": "error",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "is_enabled": {
+++++          "name": "is_enabled",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": 1
+++++        }
+++++      },
+++++      "indexes": {
+++++        "sources_path_unique": {
+++++          "name": "sources_path_unique",
+++++          "columns": [
+++++            "path"
+++++          ],
+++++          "isUnique": true
+++++        }
+++++      },
+++++      "foreignKeys": {},
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "topics": {
+++++      "name": "topics",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "source_id": {
+++++          "name": "source_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "name": {
+++++          "name": "name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "summary": {
+++++          "name": "summary",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "topics_source_id_sources_id_fk": {
+++++          "name": "topics_source_id_sources_id_fk",
+++++          "tableFrom": "topics",
+++++          "tableTo": "sources",
+++++          "columnsFrom": [
+++++            "source_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    }
+++++  },
+++++  "views": {},
+++++  "enums": {},
+++++  "_meta": {
+++++    "schemas": {},
+++++    "tables": {},
+++++    "columns": {}
+++++  },
+++++  "internal": {
+++++    "indexes": {}
+++++  }
+++++}
++++\ No newline at end of file
++++diff --git a/drizzle/migrations/meta/0010_snapshot.json b/drizzle/migrations/meta/0010_snapshot.json
++++new file mode 100644
++++index 000000000..cf557a34d
++++--- /dev/null
+++++++ b/drizzle/migrations/meta/0010_snapshot.json
++++@@ -0,0 +1,506 @@
+++++{
+++++  "version": "6",
+++++  "dialect": "sqlite",
+++++  "id": "64a4c44b-83f4-4cca-b0a7-5e1962a1f61b",
+++++  "prevId": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
+++++  "tables": {
+++++    "review_checklists": {
+++++      "name": "review_checklists",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "review_history_id": {
+++++          "name": "review_history_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "content": {
+++++          "name": "content",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "evaluation": {
+++++          "name": "evaluation",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "comment": {
+++++          "name": "comment",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "created_by": {
+++++          "name": "created_by",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_checklists_review_history_id_review_histories_id_fk": {
+++++          "name": "review_checklists_review_history_id_review_histories_id_fk",
+++++          "tableFrom": "review_checklists",
+++++          "tableTo": "review_histories",
+++++          "columnsFrom": [
+++++            "review_history_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_document_caches": {
+++++      "name": "review_document_caches",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "review_history_id": {
+++++          "name": "review_history_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "document_id": {
+++++          "name": "document_id",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "file_name": {
+++++          "name": "file_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "process_mode": {
+++++          "name": "process_mode",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "cache_path": {
+++++          "name": "cache_path",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_document_caches_review_history_id_review_histories_id_fk": {
+++++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+++++          "tableFrom": "review_document_caches",
+++++          "tableTo": "review_histories",
+++++          "columnsFrom": [
+++++            "review_history_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_histories": {
+++++      "name": "review_histories",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "text",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "title": {
+++++          "name": "title",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "target_document_name": {
+++++          "name": "target_document_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "additional_instructions": {
+++++          "name": "additional_instructions",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "comment_format": {
+++++          "name": "comment_format",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "evaluation_settings": {
+++++          "name": "evaluation_settings",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "document_mode": {
+++++          "name": "document_mode",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "processing_status": {
+++++          "name": "processing_status",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "'idle'"
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {},
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "review_largedocument_result_caches": {
+++++      "name": "review_largedocument_result_caches",
+++++      "columns": {
+++++        "review_document_cache_id": {
+++++          "name": "review_document_cache_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "review_checklist_id": {
+++++          "name": "review_checklist_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "comment": {
+++++          "name": "comment",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "total_chunks": {
+++++          "name": "total_chunks",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "chunk_index": {
+++++          "name": "chunk_index",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "individual_file_name": {
+++++          "name": "individual_file_name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+++++          "name": "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk",
+++++          "tableFrom": "review_largedocument_result_caches",
+++++          "tableTo": "review_document_caches",
+++++          "columnsFrom": [
+++++            "review_document_cache_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        },
+++++        "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk": {
+++++          "name": "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk",
+++++          "tableFrom": "review_largedocument_result_caches",
+++++          "tableTo": "review_checklists",
+++++          "columnsFrom": [
+++++            "review_checklist_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {
+++++        "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk": {
+++++          "columns": [
+++++            "review_document_cache_id",
+++++            "review_checklist_id",
+++++            "chunk_index"
+++++          ],
+++++          "name": "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk"
+++++        }
+++++      },
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "sources": {
+++++      "name": "sources",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "path": {
+++++          "name": "path",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "title": {
+++++          "name": "title",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "summary": {
+++++          "name": "summary",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "status": {
+++++          "name": "status",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "'idle'"
+++++        },
+++++        "error": {
+++++          "name": "error",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": false,
+++++          "autoincrement": false
+++++        },
+++++        "is_enabled": {
+++++          "name": "is_enabled",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": 1
+++++        }
+++++      },
+++++      "indexes": {
+++++        "sources_path_unique": {
+++++          "name": "sources_path_unique",
+++++          "columns": [
+++++            "path"
+++++          ],
+++++          "isUnique": true
+++++        }
+++++      },
+++++      "foreignKeys": {},
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    },
+++++    "topics": {
+++++      "name": "topics",
+++++      "columns": {
+++++        "id": {
+++++          "name": "id",
+++++          "type": "integer",
+++++          "primaryKey": true,
+++++          "notNull": true,
+++++          "autoincrement": true
+++++        },
+++++        "source_id": {
+++++          "name": "source_id",
+++++          "type": "integer",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "name": {
+++++          "name": "name",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "summary": {
+++++          "name": "summary",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false
+++++        },
+++++        "created_at": {
+++++          "name": "created_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        },
+++++        "updated_at": {
+++++          "name": "updated_at",
+++++          "type": "text",
+++++          "primaryKey": false,
+++++          "notNull": true,
+++++          "autoincrement": false,
+++++          "default": "(current_timestamp)"
+++++        }
+++++      },
+++++      "indexes": {},
+++++      "foreignKeys": {
+++++        "topics_source_id_sources_id_fk": {
+++++          "name": "topics_source_id_sources_id_fk",
+++++          "tableFrom": "topics",
+++++          "tableTo": "sources",
+++++          "columnsFrom": [
+++++            "source_id"
+++++          ],
+++++          "columnsTo": [
+++++            "id"
+++++          ],
+++++          "onDelete": "cascade",
+++++          "onUpdate": "no action"
+++++        }
+++++      },
+++++      "compositePrimaryKeys": {},
+++++      "uniqueConstraints": {},
+++++      "checkConstraints": {}
+++++    }
+++++  },
+++++  "views": {},
+++++  "enums": {},
+++++  "_meta": {
+++++    "schemas": {},
+++++    "tables": {},
+++++    "columns": {}
+++++  },
+++++  "internal": {
+++++    "indexes": {}
+++++  }
+++++}
++++\ No newline at end of file
++++diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
++++index 18a6e2692..2c49cc99a 100644
++++--- a/drizzle/migrations/meta/_journal.json
+++++++ b/drizzle/migrations/meta/_journal.json
++++@@ -57,6 +57,27 @@
++++       "when": 1758023792722,
++++       "tag": "0007_awesome_caretaker",
++++       "breakpoints": true
+++++    },
+++++    {
+++++      "idx": 8,
+++++      "version": "6",
+++++      "when": 1759653362189,
+++++      "tag": "0008_pink_ezekiel",
+++++      "breakpoints": true
+++++    },
+++++    {
+++++      "idx": 9,
+++++      "version": "6",
+++++      "when": 1759674897312,
+++++      "tag": "0009_keen_radioactive_man",
+++++      "breakpoints": true
+++++    },
+++++    {
+++++      "idx": 10,
+++++      "version": "6",
+++++      "when": 1760147587193,
+++++      "tag": "0010_wet_shooting_star",
+++++      "breakpoints": true
++++     }
++++   ]
++++ }
++++\ No newline at end of file
++++diff --git a/src/adapter/db/drizzle/repository/reviewRepository.ts b/src/adapter/db/drizzle/repository/reviewRepository.ts
++++index 572c1e214..cd8949e13 100644
++++--- a/src/adapter/db/drizzle/repository/reviewRepository.ts
+++++++ b/src/adapter/db/drizzle/repository/reviewRepository.ts
++++@@ -1,10 +1,13 @@
++++-import { eq, and } from 'drizzle-orm';
+++++import { eq, and, inArray, max } from 'drizzle-orm';
++++ import {
++++   reviewHistories,
++++   reviewChecklists,
++++-  reviewChecklistResults,
+++++  reviewDocumentCaches,
+++++  reviewLargedocumentResultCaches,
++++   ReviewChecklistEntity,
++++   ReviewHistoryEntity,
+++++  ReviewDocumentCacheEntity,
+++++  ReviewLargedocumentResultCacheEntity,
++++ } from '../schema';
++++ import getDb from '..';
++++ import type {
++++@@ -15,10 +18,15 @@ import type {
++++   ReviewChecklistCreatedBy,
++++   CustomEvaluationSettings,
++++   ProcessingStatus,
+++++  DocumentMode,
+++++  ReviewDocumentCache,
+++++  ReviewLargedocumentResultCache,
+++++  ProcessMode,
++++ } from '@/types';
++++-import { AppError } from '@/main/lib/error';
+++++import { AppError, internalError } from '@/main/lib/error';
++++ import { repositoryError } from '@/main/lib/error';
++++ import { IReviewRepository } from '@/main/service/port/repository';
+++++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
++++ 
++++ /**
++++  * Drizzle ORM を使用したレビューリポジトリの実装
++++@@ -31,6 +39,8 @@ export class DrizzleReviewRepository implements IReviewRepository {
++++       id: reviewChecklistEntity.id,
++++       reviewHistoryId: reviewChecklistEntity.reviewHistoryId,
++++       content: reviewChecklistEntity.content,
+++++      evaluation: reviewChecklistEntity.evaluation as ReviewEvaluation | null,
+++++      comment: reviewChecklistEntity.comment,
++++       createdBy: reviewChecklistEntity.createdBy as ReviewChecklistCreatedBy,
++++       createdAt: reviewChecklistEntity.createdAt,
++++       updatedAt: reviewChecklistEntity.updatedAt,
++++@@ -43,6 +53,7 @@ export class DrizzleReviewRepository implements IReviewRepository {
++++     const reviewHistory = {
++++       id: reviewHistoryEntity.id,
++++       title: reviewHistoryEntity.title,
+++++      targetDocumentName: reviewHistoryEntity.targetDocumentName,
++++       additionalInstructions: reviewHistoryEntity.additionalInstructions,
++++       commentFormat: reviewHistoryEntity.commentFormat,
++++       evaluationSettings: null,
++++@@ -189,6 +200,27 @@ export class DrizzleReviewRepository implements IReviewRepository {
++++     }
++++   }
++++ 
+++++  /** レビュー対象ドキュメント名を更新 */
+++++  async updateReviewHistoryTargetDocumentName(
+++++    id: string,
+++++    targetDocumentName: string,
+++++  ): Promise<void> {
+++++    try {
+++++      const db = await getDb();
+++++      await db
+++++        .update(reviewHistories)
+++++        .set({
+++++          targetDocumentName,
+++++        })
+++++        .where(eq(reviewHistories.id, id));
+++++    } catch (err) {
+++++      throw repositoryError(
+++++        'レビュー対象ドキュメント名の更新に失敗しました',
+++++        err,
+++++      );
+++++    }
+++++  }
+++++
++++   /** レビュー履歴を削除 */
++++   async deleteReviewHistory(id: string): Promise<void> {
++++     try {
++++@@ -284,121 +316,426 @@ export class DrizzleReviewRepository implements IReviewRepository {
++++       reviewChecklistId: number;
++++       evaluation: ReviewEvaluation;
++++       comment: string;
++++-      fileId: string;
++++-      fileName: string;
++++     }[],
++++   ): Promise<void> {
++++     try {
++++       const db = await getDb();
++++       for (const result of results) {
++++-        const [upserted] = await db
++++-          .insert(reviewChecklistResults)
++++-          .values(result)
++++-          .onConflictDoUpdate({
++++-            target: [
++++-              reviewChecklistResults.reviewChecklistId,
++++-              reviewChecklistResults.fileId,
++++-            ],
++++-            set: {
++++-              evaluation: result.evaluation,
++++-              comment: result.comment,
++++-            },
+++++        await db
+++++          .update(reviewChecklists)
+++++          .set({
+++++            evaluation: result.evaluation,
+++++            comment: result.comment,
++++           })
++++-          .returning();
+++++          .where(eq(reviewChecklists.id, result.reviewChecklistId));
++++       }
++++     } catch (err) {
++++       throw repositoryError('レビュー結果の保存に失敗しました', err);
++++     }
++++   }
++++ 
++++-  /** レビュー結果を削除 */
++++-  async deleteReviewResults(
++++-    reviewChecklistId: number,
++++-    sourceId: number,
+++++  /** チェックリスト結果を取得してグルーピング */
+++++  async getReviewChecklistResults(
+++++    reviewHistoryId: string,
+++++  ): Promise<ReviewChecklistResult[]> {
+++++    try {
+++++      const db = await getDb();
+++++      const rows = await db
+++++        .select()
+++++        .from(reviewChecklists)
+++++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+++++        .orderBy(reviewChecklists.createdAt);
+++++
+++++      return rows.map((row) => ({
+++++        id: row.id,
+++++        content: row.content,
+++++        sourceEvaluation: row.evaluation
+++++          ? {
+++++              evaluation: row.evaluation as ReviewEvaluation,
+++++              comment: row.comment ?? undefined,
+++++            }
+++++          : undefined,
+++++      }));
+++++    } catch (err) {
+++++      throw repositoryError('レビュー結果の取得に失敗しました', err);
+++++    }
+++++  }
+++++
+++++  /** すべてのレビュー結果を削除 */
+++++  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
+++++    try {
+++++      const db = await getDb();
+++++      await db
+++++        .update(reviewChecklists)
+++++        .set({
+++++          evaluation: null,
+++++          comment: null,
+++++        })
+++++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
+++++    } catch (err) {
+++++      throw repositoryError('レビュー結果の削除に失敗しました', err);
+++++    }
+++++  }
+++++
+++++  /** documentModeを更新 */
+++++  async updateReviewHistoryDocumentMode(
+++++    id: string,
+++++    documentMode: DocumentMode,
++++   ): Promise<void> {
++++     try {
++++       const db = await getDb();
++++       await db
++++-        .delete(reviewChecklistResults)
+++++        .update(reviewHistories)
+++++        .set({
+++++          documentMode,
+++++        })
+++++        .where(eq(reviewHistories.id, id));
+++++    } catch (err) {
+++++      throw repositoryError('ドキュメントモードの更新に失敗しました', err);
+++++    }
+++++  }
+++++
+++++  /**
+++++   * ReviewDocumentCacheEntity → ReviewDocumentCache の変換
+++++   * cachePathからファイルを読み込んでtextContent/imageDataに変換
+++++   */
+++++  private async convertDocumentCacheEntityToDomain(
+++++    entity: ReviewDocumentCacheEntity,
+++++  ): Promise<ReviewDocumentCache> {
+++++    const base = {
+++++      id: entity.id,
+++++      reviewHistoryId: entity.reviewHistoryId,
+++++      documentId: entity.documentId,
+++++      fileName: entity.fileName,
+++++      processMode: entity.processMode as ProcessMode,
+++++      createdAt: entity.createdAt,
+++++      updatedAt: entity.updatedAt,
+++++    };
+++++
+++++    try {
+++++      // cachePathからファイルを読み込む
+++++      if (entity.processMode === 'text') {
+++++        const textContent = await ReviewCacheHelper.loadTextCache(
+++++          entity.cachePath,
+++++        );
+++++        return { ...base, textContent };
+++++      } else if (entity.processMode === 'image') {
+++++        const imageData = await ReviewCacheHelper.loadImageCache(
+++++          entity.cachePath,
+++++        );
+++++        return { ...base, imageData };
+++++      }
+++++
+++++      throw repositoryError('無効なprocessModeです', null);
+++++    } catch (error) {
+++++      // キャッシュファイル読み込みエラーの場合は専用のエラーメッセージを返す
+++++      if (error instanceof Error && error.message.includes('Failed to load')) {
+++++        throw internalError({
+++++          expose: true,
+++++          messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
+++++          cause: error,
+++++        });
+++++      }
+++++      // その他のエラーはそのまま再スロー
+++++      throw error;
+++++    }
+++++  }
+++++
+++++  /** ドキュメントキャッシュを作成 */
+++++  async createReviewDocumentCache(
+++++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
+++++  ): Promise<ReviewDocumentCache> {
+++++    try {
+++++      // 1. ファイルシステムにキャッシュを保存
+++++      let cachePath: string;
+++++
+++++      if (cache.processMode === 'text' && cache.textContent) {
+++++        cachePath = await ReviewCacheHelper.saveTextCache(
+++++          cache.reviewHistoryId,
+++++          cache.documentId,
+++++          cache.textContent,
+++++        );
+++++      } else if (cache.processMode === 'image' && cache.imageData) {
+++++        cachePath = await ReviewCacheHelper.saveImageCache(
+++++          cache.reviewHistoryId,
+++++          cache.documentId,
+++++          cache.imageData,
+++++        );
+++++      } else {
+++++        throw repositoryError(
+++++          '無効なprocessModeまたはデータが不足しています',
+++++          null,
+++++        );
+++++      }
+++++
+++++      // 2. DBにメタデータを保存
+++++      const db = await getDb();
+++++      const [entity] = await db
+++++        .insert(reviewDocumentCaches)
+++++        .values({
+++++          reviewHistoryId: cache.reviewHistoryId,
+++++          documentId: cache.documentId,
+++++          fileName: cache.fileName,
+++++          processMode: cache.processMode,
+++++          cachePath,
+++++        })
+++++        .returning();
+++++
+++++      // 3. ファイルから読み込んでドメイン型に変換して返す
+++++      return this.convertDocumentCacheEntityToDomain(entity);
+++++    } catch (err) {
+++++      if (err instanceof AppError) throw err;
+++++      throw repositoryError('ドキュメントキャッシュの作成に失敗しました', err);
+++++    }
+++++  }
+++++
+++++  /** ドキュメントキャッシュ一覧を取得 */
+++++  async getReviewDocumentCaches(
+++++    reviewHistoryId: string,
+++++  ): Promise<ReviewDocumentCache[]> {
+++++    try {
+++++      const db = await getDb();
+++++      const entities = await db
+++++        .select()
+++++        .from(reviewDocumentCaches)
+++++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId))
+++++        .orderBy(reviewDocumentCaches.createdAt);
+++++
+++++      // 各EntityをDomain型に変換（ファイル読み込み含む）
+++++      return Promise.all(
+++++        entities.map((entity) =>
+++++          this.convertDocumentCacheEntityToDomain(entity),
+++++        ),
+++++      );
+++++    } catch (err) {
+++++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+++++    }
+++++  }
+++++
+++++  /** documentIdでドキュメントキャッシュを取得 */
+++++  async getReviewDocumentCacheByDocumentId(
+++++    reviewHistoryId: string,
+++++    documentId: string,
+++++  ): Promise<ReviewDocumentCache | null> {
+++++    try {
+++++      const db = await getDb();
+++++      const [entity] = await db
+++++        .select()
+++++        .from(reviewDocumentCaches)
++++         .where(
++++           and(
++++-            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
++++-            eq(reviewChecklistResults.fileId, sourceId.toString()),
+++++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
+++++            eq(reviewDocumentCaches.documentId, documentId),
++++           ),
++++         );
+++++
+++++      if (!entity) return null;
+++++
+++++      return this.convertDocumentCacheEntityToDomain(entity);
++++     } catch (err) {
++++-      throw repositoryError('レビュー結果の削除に失敗しました', err);
+++++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
++++     }
++++   }
++++ 
++++-  /** チェックリスト結果を取得してグルーピング */
++++-  async getReviewChecklistResults(
+++++  /** ドキュメントキャッシュを取得（複数ID対応） */
+++++  async getReviewDocumentCacheByDocumentIds(
++++     reviewHistoryId: string,
++++-  ): Promise<ReviewChecklistResult[]> {
+++++    documentIds: string[],
+++++  ): Promise<ReviewDocumentCache[]> {
++++     try {
++++       const db = await getDb();
++++-      const rows = await db
+++++      const entities = await db
+++++        .select()
+++++        .from(reviewDocumentCaches)
+++++        .where(
+++++          and(
+++++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
+++++            inArray(reviewDocumentCaches.documentId, documentIds),
+++++          ),
+++++        );
+++++
+++++      // 各EntityをDomain型に変換（ファイル読み込み含む）
+++++      return Promise.all(
+++++        entities.map((entity) =>
+++++          this.convertDocumentCacheEntityToDomain(entity),
+++++        ),
+++++      );
+++++    } catch (err) {
+++++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+++++    }
+++++  }
+++++
+++++  /** チェックリスト結果キャッシュを作成 */
+++++  async createReviewLargedocumentResultCache(
+++++    cache: ReviewLargedocumentResultCache,
+++++  ): Promise<void> {
+++++    try {
+++++      const db = await getDb();
+++++      await db.insert(reviewLargedocumentResultCaches).values({
+++++        reviewDocumentCacheId: cache.reviewDocumentCacheId,
+++++        reviewChecklistId: cache.reviewChecklistId,
+++++        comment: cache.comment,
+++++        totalChunks: cache.totalChunks,
+++++        chunkIndex: cache.chunkIndex,
+++++        individualFileName: cache.individualFileName,
+++++      });
+++++    } catch (err) {
+++++      throw repositoryError(
+++++        '大量ドキュメント結果キャッシュの作成に失敗しました',
+++++        err,
+++++      );
+++++    }
+++++  }
+++++
+++++  /** チェックリスト結果キャッシュ一覧を取得 */
+++++  async getReviewLargedocumentResultCaches(
+++++    reviewHistoryId: string,
+++++  ): Promise<ReviewLargedocumentResultCache[]> {
+++++    try {
+++++      const db = await getDb();
+++++      // reviewDocumentCachesとjoinしてreviewHistoryIdで絞り込む
+++++      const results = await db
++++         .select({
++++-          checklistId: reviewChecklists.id,
++++-          content: reviewChecklists.content,
++++-          fileId: reviewChecklistResults.fileId,
++++-          fileName: reviewChecklistResults.fileName,
++++-          evaluation: reviewChecklistResults.evaluation,
++++-          comment: reviewChecklistResults.comment,
+++++          reviewDocumentCacheId:
+++++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+++++          reviewChecklistId: reviewLargedocumentResultCaches.reviewChecklistId,
+++++          comment: reviewLargedocumentResultCaches.comment,
+++++          totalChunks: reviewLargedocumentResultCaches.totalChunks,
+++++          chunkIndex: reviewLargedocumentResultCaches.chunkIndex,
+++++          individualFileName:
+++++            reviewLargedocumentResultCaches.individualFileName,
++++         })
++++-        .from(reviewChecklists)
++++-        .leftJoin(
++++-          reviewChecklistResults,
++++-          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
+++++        .from(reviewLargedocumentResultCaches)
+++++        .innerJoin(
+++++          reviewDocumentCaches,
+++++          eq(
+++++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+++++            reviewDocumentCaches.id,
+++++          ),
++++         )
++++-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
++++-        .orderBy(reviewChecklists.createdAt);
+++++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
+++++
+++++      return results.map((row) => ({
+++++        reviewDocumentCacheId: row.reviewDocumentCacheId,
+++++        reviewChecklistId: row.reviewChecklistId,
+++++        comment: row.comment,
+++++        totalChunks: row.totalChunks,
+++++        chunkIndex: row.chunkIndex,
+++++        individualFileName: row.individualFileName,
+++++      }));
+++++    } catch (err) {
+++++      throw repositoryError(
+++++        '大量ドキュメント結果キャッシュの取得に失敗しました',
+++++        err,
+++++      );
+++++    }
+++++  }
+++++
+++++  /** 特定ドキュメントの最大totalChunks数を取得（レビューチャット用） */
+++++  async getMaxTotalChunksForDocument(
+++++    reviewHistoryId: string,
+++++    documentId: string,
+++++  ): Promise<number> {
+++++    try {
+++++      const db = await getDb();
++++ 
++++-      const map = new Map<number, ReviewChecklistResult>();
++++-      for (const row of rows) {
++++-        let group = map.get(row.checklistId);
++++-        if (!group) {
++++-          group = {
++++-            id: row.checklistId,
++++-            content: row.content,
++++-            sourceEvaluations: [],
++++-          };
++++-          map.set(row.checklistId, group);
++++-        }
++++-        if (row.fileId !== null && row.fileName !== null) {
++++-          group.sourceEvaluations!.push({
++++-            fileId: row.fileId,
++++-            fileName: row.fileName,
++++-            evaluation: row.evaluation as ReviewEvaluation,
++++-            comment: row.comment ?? undefined,
++++-          });
++++-        }
+++++      // まずdocumentIdからreviewDocumentCacheIdを取得
+++++      const [cache] = await db
+++++        .select({ id: reviewDocumentCaches.id })
+++++        .from(reviewDocumentCaches)
+++++        .where(
+++++          and(
+++++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
+++++            eq(reviewDocumentCaches.documentId, documentId),
+++++          ),
+++++        );
+++++
+++++      if (!cache) {
+++++        // ドキュメントキャッシュが存在しない場合は1を返す
+++++        return 1;
++++       }
++++-      return Array.from(map.values());
+++++
+++++      // 該当ドキュメントのtotalChunksの最大値を取得
+++++      const result = await db
+++++        .select({ maxChunks: max(reviewLargedocumentResultCaches.totalChunks) })
+++++        .from(reviewLargedocumentResultCaches)
+++++        .where(
+++++          eq(reviewLargedocumentResultCaches.reviewDocumentCacheId, cache.id),
+++++        );
+++++
+++++      const maxChunks = result[0]?.maxChunks;
+++++
+++++      // レコードが存在しない場合は1を返す（初回処理）
+++++      return maxChunks ?? 1;
++++     } catch (err) {
++++-      throw repositoryError('レビュー結果の取得に失敗しました', err);
+++++      throw repositoryError(
+++++        'ドキュメントの最大チャンク数取得に失敗しました',
+++++        err,
+++++      );
++++     }
++++   }
++++ 
++++-  /** すべてのレビュー結果を削除 */
++++-  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
+++++  /** レビューチャット用: チェックリストと結果を取得 */
+++++  async getChecklistResultsWithIndividualResults(
+++++    reviewHistoryId: string,
+++++    checklistIds: number[],
+++++  ): Promise<
+++++    Array<{
+++++      checklistResult: ReviewChecklistResult;
+++++      individualResults?: Array<{
+++++        documentId: number;
+++++        comment: string;
+++++        individualFileName: string;
+++++      }>;
+++++    }>
+++++  > {
++++     try {
++++       const db = await getDb();
++++-      const checklists = await db
++++-        .select({ id: reviewChecklists.id })
+++++
+++++      // チェックリストを取得
+++++      const checklistEntities = await db
+++++        .select()
++++         .from(reviewChecklists)
++++-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
+++++        .where(
+++++          and(
+++++            eq(reviewChecklists.reviewHistoryId, reviewHistoryId),
+++++            inArray(reviewChecklists.id, checklistIds),
+++++          ),
+++++        );
++++ 
++++-      // チェックリストが無ければ何もしない
++++-      if (checklists.length === 0) return;
+++++      // 個別レビュー結果キャッシュを取得
+++++      const individualCaches =
+++++        await this.getReviewLargedocumentResultCaches(reviewHistoryId);
++++ 
++++-      for (const { id } of checklists) {
++++-        await db
++++-          .delete(reviewChecklistResults)
++++-          .where(eq(reviewChecklistResults.reviewChecklistId, id));
++++-      }
+++++      // 結果を組み立て
+++++      return checklistEntities.map((entity) => {
+++++        // 個別レビュー結果を抽出
+++++        const individualResults = individualCaches
+++++          .filter((cache) => cache.reviewChecklistId === entity.id)
+++++          .map((cache) => ({
+++++            documentId: cache.reviewDocumentCacheId,
+++++            comment: cache.comment,
+++++            individualFileName: cache.individualFileName,
+++++          }));
+++++
+++++        // ReviewChecklistResult型を構築
+++++        const checklistResult: ReviewChecklistResult = {
+++++          id: entity.id,
+++++          content: entity.content,
+++++          sourceEvaluation: {
+++++            evaluation: entity.evaluation ?? undefined,
+++++            comment: entity.comment ?? undefined,
+++++          },
+++++        };
+++++
+++++        return {
+++++          checklistResult,
+++++          individualResults:
+++++            individualResults.length > 0 ? individualResults : undefined,
+++++        };
+++++      });
++++     } catch (err) {
++++-      throw repositoryError('レビュー結果の削除に失敗しました', err);
+++++      throw repositoryError('チェックリストと結果の取得に失敗しました', err);
++++     }
++++   }
++++ }
++++diff --git a/src/adapter/db/drizzle/schema.ts b/src/adapter/db/drizzle/schema.ts
++++index 39ffd9c64..20643f956 100644
++++--- a/src/adapter/db/drizzle/schema.ts
+++++++ b/src/adapter/db/drizzle/schema.ts
++++@@ -59,9 +59,11 @@ export const reviewHistories = sqliteTable('review_histories', {
++++     .primaryKey()
++++     .$default(() => uuidv4()), // 汎用チャット機能のコードを活用できるように、MastraのThreadと同じく主キーは文字列とする
++++   title: text('title').notNull(), // ソースのtitleを/区切りで結合
+++++  targetDocumentName: text('target_document_name'), // レビュー対象の統合ドキュメント名
++++   additionalInstructions: text('additional_instructions'), // レビューの追加指示
++++   commentFormat: text('comment_format'), // レビューのコメントフォーマット
++++   evaluationSettings: text('evaluation_settings'), // 評定項目設定（JSON形式）
+++++  documentMode: text('document_mode'), // レビュー実行方法: small, large
++++   processingStatus: text('processing_status').notNull().default('idle'), // 処理ステータス: idle, extracting, extracted, reviewing, completed
++++   createdAt: text('created_at')
++++     .notNull()
++++@@ -79,6 +81,8 @@ export const reviewChecklists = sqliteTable('review_checklists', {
++++     .notNull()
++++     .references(() => reviewHistories.id, { onDelete: 'cascade' }),
++++   content: text('content').notNull(), // チェックリスト項目
+++++  evaluation: text('evaluation'), // A, B, C, - 評価
+++++  comment: text('comment'), // レビューコメント
++++   createdBy: text('created_by').notNull(), // 'user' or 'system'
++++   createdAt: text('created_at')
++++     .notNull()
++++@@ -89,26 +93,49 @@ export const reviewChecklists = sqliteTable('review_checklists', {
++++     .$onUpdate(() => sql`(current_timestamp)`),
++++ });
++++ 
++++-// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
++++-export const reviewChecklistResults = sqliteTable(
++++-  'review_checklist_results',
+++++// レビュードキュメントキャッシュを格納するテーブル
+++++export const reviewDocumentCaches = sqliteTable('review_document_caches', {
+++++  id: integer('id').primaryKey({ autoIncrement: true }),
+++++  reviewHistoryId: text('review_history_id')
+++++    .notNull()
+++++    .references(() => reviewHistories.id, { onDelete: 'cascade' }),
+++++  documentId: text('document_id').notNull(), // ワークフロー内のドキュメントID
+++++  fileName: text('file_name').notNull(), // ワークフロー内での名前（分割時は "xxx (part 1)" など）
+++++  processMode: text('process_mode').notNull(), // 'text' or 'image'
+++++  cachePath: text('cache_path').notNull(), // ファイル/ディレクトリパス
+++++  createdAt: text('created_at')
+++++    .notNull()
+++++    .default(sql`(current_timestamp)`),
+++++  updatedAt: text('updated_at')
+++++    .notNull()
+++++    .default(sql`(current_timestamp)`)
+++++    .$onUpdate(() => sql`(current_timestamp)`),
+++++});
+++++
+++++// レビュー大量ドキュメント結果キャッシュを格納するテーブル（大量ドキュメントレビューの個別レビュー結果）
+++++export const reviewLargedocumentResultCaches = sqliteTable(
+++++  'review_largedocument_result_caches',
++++   {
+++++    reviewDocumentCacheId: integer('review_document_cache_id')
+++++      .notNull()
+++++      .references(() => reviewDocumentCaches.id, { onDelete: 'cascade' }),
++++     reviewChecklistId: integer('review_checklist_id')
++++       .notNull()
++++       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
++++-    fileId: text('file_id').notNull(), // アップロードファイルのID
++++-    fileName: text('file_name').notNull(), // ファイル名
++++-    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
++++-    comment: text('comment'), // レビューコメント
++++-    createdAt: text('created_at')
++++-      .notNull()
++++-      .default(sql`(current_timestamp)`),
++++-    updatedAt: text('updated_at')
++++-      .notNull()
++++-      .default(sql`(current_timestamp)`)
++++-      .$onUpdate(() => sql`(current_timestamp)`),
+++++    comment: text('comment').notNull(), // 個別レビューコメント
+++++    totalChunks: integer('total_chunks').notNull(), // ドキュメント分割総数
+++++    chunkIndex: integer('chunk_index').notNull(), // 何番目のチャンクか（0から始まる）
+++++    individualFileName: text('individual_file_name').notNull(), // 分割後の個別ドキュメント名（"xxx (part 1)" など）
++++   },
++++-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
+++++  (table) => ({
+++++    pk: primaryKey({
+++++      columns: [
+++++        table.reviewDocumentCacheId,
+++++        table.reviewChecklistId,
+++++        table.chunkIndex,
+++++      ],
+++++    }),
+++++  }),
++++ );
++++ 
++++ // 型定義
++++@@ -120,6 +147,11 @@ export type ReviewHistoryEntity = typeof reviewHistories.$inferSelect;
++++ export type InsertReviewHistoryEntity = typeof reviewHistories.$inferInsert;
++++ export type ReviewChecklistEntity = typeof reviewChecklists.$inferSelect;
++++ export type InsertReviewChecklistEntity = typeof reviewChecklists.$inferInsert;
++++-export type ReviewChecklistResultEntity = typeof reviewChecklistResults.$inferSelect;
++++-export type InsertReviewChecklistResultEntity =
++++-  typeof reviewChecklistResults.$inferInsert;
+++++export type ReviewDocumentCacheEntity =
+++++  typeof reviewDocumentCaches.$inferSelect;
+++++export type InsertReviewDocumentCacheEntity =
+++++  typeof reviewDocumentCaches.$inferInsert;
+++++export type ReviewLargedocumentResultCacheEntity =
+++++  typeof reviewLargedocumentResultCaches.$inferSelect;
+++++export type InsertReviewLargedocumentResultCacheEntity =
+++++  typeof reviewLargedocumentResultCaches.$inferInsert;
++++diff --git a/src/main/lib/utils/reviewCacheHelper.ts b/src/main/lib/utils/reviewCacheHelper.ts
++++new file mode 100644
++++index 000000000..51f5d16d4
++++--- /dev/null
+++++++ b/src/main/lib/utils/reviewCacheHelper.ts
++++@@ -0,0 +1,123 @@
+++++import * as fs from 'fs/promises';
+++++import * as path from 'path';
+++++import { app } from 'electron';
+++++
+++++/**
+++++ * レビュー機能で使用するキャッシュファイルの管理ヘルパークラス
+++++ */
+++++export class ReviewCacheHelper {
+++++  /**
+++++   * キャッシュベースディレクトリ取得
+++++   */
+++++  private static getCacheBaseDir(reviewHistoryId: string): string {
+++++    return path.join(
+++++      app.getPath('userData'),
+++++      'review_cache',
+++++      reviewHistoryId,
+++++      'file_cache',
+++++    );
+++++  }
+++++
+++++  /**
+++++   * テキストキャッシュ保存
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   * @param documentId ドキュメントID
+++++   * @param content テキスト内容
+++++   * @returns ファイルパス
+++++   */
+++++  static async saveTextCache(
+++++    reviewHistoryId: string,
+++++    documentId: string,
+++++    content: string,
+++++  ): Promise<string> {
+++++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
+++++    await fs.mkdir(baseDir, { recursive: true });
+++++
+++++    const cachePath = path.join(baseDir, `${documentId}.txt`);
+++++    await fs.writeFile(cachePath, content, 'utf-8');
+++++
+++++    return cachePath;
+++++  }
+++++
+++++  /**
+++++   * 画像キャッシュ保存（複数ページ対応）
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   * @param documentId ドキュメントID
+++++   * @param imageData Base64画像データ配列
+++++   * @returns ディレクトリパス
+++++   */
+++++  static async saveImageCache(
+++++    reviewHistoryId: string,
+++++    documentId: string,
+++++    imageData: string[],
+++++  ): Promise<string> {
+++++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
+++++    const imageCacheDir = path.join(baseDir, documentId);
+++++    await fs.mkdir(imageCacheDir, { recursive: true });
+++++
+++++    for (let i = 0; i < imageData.length; i++) {
+++++      const pagePath = path.join(imageCacheDir, `page_${i}.b64`);
+++++      await fs.writeFile(pagePath, imageData[i], 'utf-8');
+++++    }
+++++
+++++    return imageCacheDir;
+++++  }
+++++
+++++  /**
+++++   * テキストキャッシュ読み込み
+++++   * @param cachePath ファイルパス
+++++   * @returns テキスト内容
+++++   * @throws ファイルが存在しない場合やアクセスできない場合にエラーをスロー
+++++   */
+++++  static async loadTextCache(cachePath: string): Promise<string> {
+++++    try {
+++++      return await fs.readFile(cachePath, 'utf-8');
+++++    } catch (error) {
+++++      // ファイルが存在しない、またはアクセスできない場合
+++++      throw new Error(`Failed to load text cache from ${cachePath}: ${error instanceof Error ? error.message : String(error)}`);
+++++    }
+++++  }
+++++
+++++  /**
+++++   * 画像キャッシュ読み込み
+++++   * @param cacheDir ディレクトリパス
+++++   * @returns Base64画像データ配列
+++++   * @throws ディレクトリが存在しない場合やアクセスできない場合にエラーをスロー
+++++   */
+++++  static async loadImageCache(cacheDir: string): Promise<string[]> {
+++++    try {
+++++      const files = await fs.readdir(cacheDir);
+++++      const imageFiles = files
+++++        .filter((f) => f.endsWith('.b64'))
+++++        .sort((a, b) => {
+++++          const aNum = parseInt(a.match(/page_(\d+)\.b64/)?.[1] || '0');
+++++          const bNum = parseInt(b.match(/page_(\d+)\.b64/)?.[1] || '0');
+++++          return aNum - bNum;
+++++        });
+++++
+++++      const imageData: string[] = [];
+++++      for (const file of imageFiles) {
+++++        const content = await fs.readFile(path.join(cacheDir, file), 'utf-8');
+++++        imageData.push(content);
+++++      }
+++++
+++++      return imageData;
+++++    } catch (error) {
+++++      // ディレクトリが存在しない、またはアクセスできない場合
+++++      throw new Error(`Failed to load image cache from ${cacheDir}: ${error instanceof Error ? error.message : String(error)}`);
+++++    }
+++++  }
+++++
+++++  /**
+++++   * キャッシュディレクトリ削除
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   */
+++++  static async deleteCacheDirectory(reviewHistoryId: string): Promise<void> {
+++++    const cacheDir = path.join(
+++++      app.getPath('userData'),
+++++      'review_cache',
+++++      reviewHistoryId,
+++++    );
+++++    await fs.rm(cacheDir, { recursive: true, force: true });
+++++  }
+++++}
++++diff --git a/src/main/main.ts b/src/main/main.ts
++++index 047392026..cb2d17db4 100644
++++--- a/src/main/main.ts
+++++++ b/src/main/main.ts
++++@@ -276,7 +276,6 @@ const setupChatHandlers = () => {
++++           userId,
++++           roomId,
++++           messages,
++++-          event,
++++         );
++++ 
++++         // テキストストリームを処理
++++@@ -542,6 +541,44 @@ const setupReviewHandlers = () => {
++++     }
++++     return undefined as never;
++++   });
+++++
+++++  // レビューチャットメッセージ送信ハンドラ
+++++  handleIpc(
+++++    IpcChannels.REVIEW_CHAT_SEND_MESSAGE,
+++++    async ({ reviewHistoryId, checklistIds, question }) => {
+++++      try {
+++++        const dataStream = await reviewService.chatWithReview(
+++++          reviewHistoryId,
+++++          checklistIds,
+++++          question,
+++++        );
+++++
+++++        // テキストストリームを処理
+++++        // @ts-ignore
+++++        for await (const chunk of dataStream) {
+++++          // チャンクをフロントエンドに送信
+++++          publishEvent(IpcChannels.REVIEW_CHAT_STREAM_RESPONSE, chunk);
+++++        }
+++++
+++++        return undefined as never;
+++++      } catch (error) {
+++++        // エラー時もAbortControllerを削除
+++++        reviewService.abortReviewChat(reviewHistoryId);
+++++        const normalizedError = normalizeUnknownError(error);
+++++        publishEvent(
+++++          IpcChannels.REVIEW_CHAT_ERROR,
+++++          { message: normalizedError.message },
+++++        );
+++++        throw normalizedError;
+++++      }
+++++    },
+++++  );
+++++
+++++  // レビューチャット中断ハンドラ
+++++  handleIpc(IpcChannels.REVIEW_CHAT_ABORT, async (reviewHistoryId) => {
+++++    const result = reviewService.abortReviewChat(reviewHistoryId);
+++++    return undefined as never;
+++++  });
++++ };
++++ 
++++ // ソース登録処理の実行
++++diff --git a/src/main/preload.ts b/src/main/preload.ts
++++index fa8d0f9c8..c32d7113f 100644
++++--- a/src/main/preload.ts
+++++++ b/src/main/preload.ts
++++@@ -147,6 +147,13 @@ const electronHandler = {
++++     /** レビュー実行キャンセル */
++++     abortExecute: (reviewHistoryId: string) =>
++++       invokeIpc(IpcChannels.REVIEW_EXECUTE_ABORT, reviewHistoryId),
+++++    /** レビューチャットメッセージ送信 */
+++++    sendChatMessage: (
+++++      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE],
+++++    ) => invokeIpc(IpcChannels.REVIEW_CHAT_SEND_MESSAGE, params),
+++++    /** レビューチャット中断 */
+++++    abortChat: (reviewHistoryId: string) =>
+++++      invokeIpc(IpcChannels.REVIEW_CHAT_ABORT, reviewHistoryId),
++++   },
++++   pushApi: {
++++     async subscribe<C extends EventChannel>(
++++diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
++++index 43df9c6a8..625443fe6 100644
++++--- a/src/main/service/chatService.ts
+++++++ b/src/main/service/chatService.ts
++++@@ -120,7 +120,6 @@ export class ChatService implements IChatService {
++++     userId: string,
++++     threadId: string,
++++     messages: ChatMessage[],
++++-    event: Electron.IpcMainInvokeEvent,
++++   ) {
++++     // 新しいAbortControllerを作成
++++     const controller = this.abortControllerManager.getOrCreateAbortController(
++++diff --git a/src/main/service/port/repository/IReviewRepository.ts b/src/main/service/port/repository/IReviewRepository.ts
++++index b558873e1..60b64222e 100644
++++--- a/src/main/service/port/repository/IReviewRepository.ts
+++++++ b/src/main/service/port/repository/IReviewRepository.ts
++++@@ -1,10 +1,13 @@
++++ import {
++++   CustomEvaluationSettings,
+++++  DocumentMode,
++++   ProcessingStatus,
++++   RevieHistory,
++++   ReviewChecklist,
++++   ReviewChecklistCreatedBy,
++++   ReviewChecklistResult,
+++++  ReviewDocumentCache,
+++++  ReviewLargedocumentResultCache,
++++   ReviewEvaluation,
++++ } from '@/types';
++++ 
++++@@ -30,6 +33,10 @@ export interface IReviewRepository {
++++     id: string,
++++     processingStatus: ProcessingStatus,
++++   ): Promise<void>;
+++++  updateReviewHistoryTargetDocumentName(
+++++    id: string,
+++++    targetDocumentName: string,
+++++  ): Promise<void>;
++++   deleteReviewHistory(id: string): Promise<void>;
++++ 
++++   // チェックリスト
++++@@ -49,16 +56,59 @@ export interface IReviewRepository {
++++       reviewChecklistId: number;
++++       evaluation: ReviewEvaluation;
++++       comment: string;
++++-      fileId: string;
++++-      fileName: string;
++++     }[],
++++   ): Promise<void>;
++++-  deleteReviewResults(
++++-    reviewChecklistId: number,
++++-    sourceId: number,
++++-  ): Promise<void>;
++++   getReviewChecklistResults(
++++     reviewHistoryId: string,
++++   ): Promise<ReviewChecklistResult[]>;
++++   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
+++++
+++++  // documentModeの保存
+++++  updateReviewHistoryDocumentMode(
+++++    id: string,
+++++    documentMode: DocumentMode,
+++++  ): Promise<void>;
+++++
+++++  // ドキュメントキャッシュ管理
+++++  createReviewDocumentCache(
+++++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
+++++  ): Promise<ReviewDocumentCache>;
+++++  getReviewDocumentCaches(
+++++    reviewHistoryId: string,
+++++  ): Promise<ReviewDocumentCache[]>;
+++++  getReviewDocumentCacheByDocumentId(
+++++    reviewHistoryId: string,
+++++    documentId: string,
+++++  ): Promise<ReviewDocumentCache | null>;
+++++  getReviewDocumentCacheByDocumentIds(
+++++    reviewHistoryId: string,
+++++    documentIds: string[],
+++++  ): Promise<ReviewDocumentCache[]>;
+++++
+++++  // 大量ドキュメント結果キャッシュ管理
+++++  createReviewLargedocumentResultCache(
+++++    cache: ReviewLargedocumentResultCache,
+++++  ): Promise<void>;
+++++  getReviewLargedocumentResultCaches(
+++++    reviewHistoryId: string,
+++++  ): Promise<ReviewLargedocumentResultCache[]>;
+++++  getMaxTotalChunksForDocument(
+++++    reviewHistoryId: string,
+++++    documentId: string,
+++++  ): Promise<number>;
+++++
+++++  // レビューチャット用: チェックリスト結果と個別レビュー結果を取得
+++++  getChecklistResultsWithIndividualResults(
+++++    reviewHistoryId: string,
+++++    checklistIds: number[],
+++++  ): Promise<
+++++    Array<{
+++++      checklistResult: ReviewChecklistResult;
+++++      individualResults?: Array<{
+++++        documentId: number;
+++++        comment: string;
+++++        individualFileName: string;
+++++      }>;
+++++    }>
+++++  >;
++++ }
++++diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
++++index c65bd4539..8ced9789e 100644
++++--- a/src/main/service/reviewService.ts
+++++++ b/src/main/service/reviewService.ts
++++@@ -1,3 +1,7 @@
+++++import { createDataStream } from 'ai';
+++++// @ts-ignore
+++++import { RuntimeContext } from '@mastra/core/runtime-context';
+++++import { v4 as uuid } from 'uuid';
++++ import { getReviewRepository } from '@/adapter/db';
++++ import {
++++   ReviewChecklistEdit,
++++@@ -20,11 +24,14 @@ import { getMainLogger } from '../lib/logger';
++++ import { mastra } from '@/mastra';
++++ import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
++++ import { formatMessage } from '../lib/messages';
+++++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
+++++import { ReviewChatWorkflowRuntimeContext } from '@/mastra/workflows/reviewChat';
++++ 
++++ export interface IReviewService {
++++   getReviewHistories(): Promise<RevieHistory[]>;
++++   getReviewHistoryDetail(reviewHistoryId: string): Promise<{
++++     checklistResults: ReviewChecklistResult[];
+++++    targetDocumentName?: string | null;
++++   }>;
++++   getReviewInstruction(reviewHistoryId: string): Promise<{
++++     additionalInstructions?: string;
++++@@ -49,6 +56,15 @@ export interface IReviewService {
++++     reviewHistoryId: string,
++++     files: UploadFile[],
++++   ): Promise<void>;
+++++  chatWithReview(
+++++    reviewHistoryId: string,
+++++    checklistIds: number[],
+++++    question: string,
+++++  ): Promise<ReturnType<typeof createDataStream>>;
+++++  abortReviewChat(reviewHistoryId: string): {
+++++    success: boolean;
+++++    error?: string;
+++++  };
++++ }
++++ 
++++ const logger = getMainLogger();
++++@@ -82,8 +98,11 @@ export class ReviewService implements IReviewService {
++++   public async getReviewHistoryDetail(reviewHistoryId: string) {
++++     const checklistResults =
++++       await this.reviewRepository.getReviewChecklistResults(reviewHistoryId);
+++++    const reviewHistory =
+++++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
++++     return {
++++       checklistResults: checklistResults,
+++++      targetDocumentName: reviewHistory?.targetDocumentName,
++++     };
++++   }
++++ 
++++@@ -105,7 +124,18 @@ export class ReviewService implements IReviewService {
++++    * レビュー履歴を削除
++++    */
++++   public async deleteReviewHistory(reviewHistoryId: string) {
++++-    return this.reviewRepository.deleteReviewHistory(reviewHistoryId);
+++++    await this.reviewRepository.deleteReviewHistory(reviewHistoryId);
+++++
+++++    // キャッシュディレクトリも削除
+++++    try {
+++++      await ReviewCacheHelper.deleteCacheDirectory(reviewHistoryId);
+++++    } catch (err) {
+++++      // キャッシュ削除失敗はログのみ（DB削除は成功しているため）
+++++      logger.warn(
+++++        err,
+++++        `キャッシュディレクトリの削除に失敗しました: ${reviewHistoryId}`,
+++++      );
+++++    }
++++   }
++++ 
++++   /**
++++@@ -116,7 +146,8 @@ export class ReviewService implements IReviewService {
++++     checklistEdits: ReviewChecklistEdit[],
++++   ) {
++++     // レビュー履歴が存在しない場合は新規作成
++++-    let reviewHistory = await this.reviewRepository.getReviewHistory(reviewHistoryId);
+++++    let reviewHistory =
+++++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
++++     if (reviewHistory === null) {
++++       reviewHistory = await this.reviewRepository.createReviewHistory(
++++         generateReviewTitle(),
++++@@ -197,7 +228,9 @@ export class ReviewService implements IReviewService {
++++       }
++++ 
++++       // システム作成のチェックリストを削除（手動作成分は保持）
++++-      await this.reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
+++++      await this.reviewRepository.deleteSystemCreatedChecklists(
+++++        reviewHistoryId,
+++++      );
++++ 
++++       const allChecklistItems: string[] = [];
++++ 
++++@@ -223,7 +256,11 @@ export class ReviewService implements IReviewService {
++++ 
++++       // チェックリスト項目をDBに保存
++++       for (const item of uniqueChecklistItems) {
++++-        await this.reviewRepository.createChecklist(reviewHistoryId, item, 'system');
+++++        await this.reviewRepository.createChecklist(
+++++          reviewHistoryId,
+++++          item,
+++++          'system',
+++++        );
++++       }
++++       // AI処理と同様のイベント通知を発火
++++       publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
++++@@ -660,4 +697,147 @@ export class ReviewService implements IReviewService {
++++       return { success: false, error: err.message };
++++     }
++++   }
+++++
+++++  /**
+++++   * レビューチャット実行
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   * @param checklistIds チェックリストID配列
+++++   * @param question ユーザからの質問
+++++   * @returns DataStream
+++++   */
+++++  public async chatWithReview(
+++++    reviewHistoryId: string,
+++++    checklistIds: number[],
+++++    question: string,
+++++  ): Promise<ReturnType<typeof createDataStream>> {
+++++    // DataStreamを生成
+++++    const dataStream = createDataStream({
+++++      execute: async (writer) => {
+++++        try {
+++++          // Mastraワークフローを取得
+++++          const workflow = mastra.getWorkflow('reviewChatWorkflow');
+++++
+++++          if (!workflow) {
+++++            logger.error('レビュー実行ワークフローが見つかりません');
+++++            throw internalError({
+++++              expose: false,
+++++            });
+++++          }
+++++
+++++          // 質問テキストから本文のみを抽出
+++++          // フォーマット: @チェックリスト行 + 空行 + 本文
+++++          const lines = question.split('\n');
+++++          const bodyLines: string[] = [];
+++++          let foundEmptyLine = false;
+++++
+++++          for (const line of lines) {
+++++            // @で始まる行は除外
+++++            if (line.trim().startsWith('@')) {
+++++              continue;
+++++            }
+++++
+++++            // 最初の空行を見つけた後から本文開始
+++++            if (!foundEmptyLine && line.trim() === '') {
+++++              foundEmptyLine = true;
+++++              continue;
+++++            }
+++++
+++++            // 空行を見つけた後の行を本文として抽出
+++++            if (foundEmptyLine) {
+++++              bodyLines.push(line);
+++++            }
+++++          }
+++++
+++++          const bodyText = bodyLines.join('\n').trim();
+++++
+++++          // ランタイムコンテキストを作成
+++++          const runtimeContext =
+++++            new RuntimeContext<ReviewChatWorkflowRuntimeContext>();
+++++          runtimeContext.set('dataStreamWriter', writer);
+++++          runtimeContext.set('toolCallId', uuid());
+++++
+++++          const run = await workflow.createRunAsync();
+++++
+++++          // workflowをrunningWorkflowsに登録
+++++          const workflowKey = `chat_${reviewHistoryId}`;
+++++
+++++          // 実行中のワークフローを管理
+++++          this.runningWorkflows.set(workflowKey, {
+++++            cancel: () => run.cancel(),
+++++          });
+++++
+++++          // ストリーミングはworkflow内部で実行されるため、ここでは結果を待つだけ
+++++          const result = await run.start({
+++++            inputData: {
+++++              reviewHistoryId,
+++++              checklistIds,
+++++              question: bodyText,
+++++            },
+++++            runtimeContext,
+++++          });
+++++
+++++          const checkResult = checkWorkflowResult(result);
+++++
+++++          // 処理が完了したらworkflowを削除
+++++          this.runningWorkflows.delete(workflowKey);
+++++
+++++          if (checkResult.status !== 'success') {
+++++            throw internalError({
+++++              expose: true,
+++++              messageCode: 'PLAIN_MESSAGE',
+++++              messageParams: {
+++++                message: checkResult.errorMessage || '不明なエラー',
+++++              },
+++++            });
+++++          }
+++++        } catch (error) {
+++++          logger.error(error, 'レビューチャット実行に失敗しました');
+++++          // エラー時もworkflowを削除
+++++          this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
+++++          throw error;
+++++        }
+++++      },
+++++      onError: (error) => {
+++++        logger.error(error, 'レビューチャット中にエラーが発生');
+++++        // エラー時もworkflowを削除
+++++        this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
+++++        const normalizedError = normalizeUnknownError(error);
+++++        return normalizedError.message;
+++++      },
+++++    });
+++++
+++++    return dataStream;
+++++  }
+++++
+++++  /**
+++++   * レビューチャット中断
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   */
+++++  public abortReviewChat(reviewHistoryId: string): {
+++++    success: boolean;
+++++    error?: string;
+++++  } {
+++++    try {
+++++      const workflowKey = `chat_${reviewHistoryId}`;
+++++      const runningWorkflow = this.runningWorkflows.get(workflowKey);
+++++      if (runningWorkflow) {
+++++        runningWorkflow.cancel();
+++++        this.runningWorkflows.delete(workflowKey);
+++++        logger.info(`レビューチャットをキャンセルしました: ${reviewHistoryId}`);
+++++        return { success: true };
+++++      } else {
+++++        logger.warn(
+++++          `キャンセル対象のレビューチャットが見つかりません: ${reviewHistoryId}`,
+++++        );
+++++        return {
+++++          success: false,
+++++          error: 'キャンセル対象の処理が見つかりません',
+++++        };
+++++      }
+++++    } catch (error) {
+++++      logger.error(error, 'レビューチャットのキャンセルに失敗しました');
+++++      const err = normalizeUnknownError(error);
+++++      return { success: false, error: err.message };
+++++    }
+++++  }
++++ }
++++diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
++++index ed443613a..55849f942 100644
++++--- a/src/mastra/agents/prompts.ts
+++++++ b/src/mastra/agents/prompts.ts
++++@@ -8,11 +8,11 @@ import {
++++   ReviewExecuteAgentRuntimeContext,
++++   TopicExtractionAgentRuntimeContext,
++++   TopicChecklistAgentRuntimeContext,
++++-  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
++++-  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
++++-  ReviewAnswerQuestionAgentRuntimeContext,
++++   IndividualDocumentReviewAgentRuntimeContext,
++++   ConsolidateReviewAgentRuntimeContext,
+++++  ReviewChatPlanningAgentRuntimeContext,
+++++  ReviewChatResearchAgentRuntimeContext,
+++++  ReviewChatAnswerAgentRuntimeContext,
++++ } from './workflowAgents';
++++ 
++++ /**
++++@@ -576,6 +576,237 @@ ${additionalInstructions}
++++ Remember: Your thorough analysis of this document part is crucial for achieving an excellent final consolidated review. Include all relevant details that will contribute to the overall document assessment.`;
++++ }
++++ 
+++++// レビューチャット：調査計画作成用のプロンプト
+++++export function getReviewChatPlanningPrompt({
+++++  runtimeContext,
+++++}: {
+++++  runtimeContext: RuntimeContext<ReviewChatPlanningAgentRuntimeContext>;
+++++}): string {
+++++  const availableDocuments = runtimeContext.get('availableDocuments');
+++++  const checklistInfo = runtimeContext.get('checklistInfo');
+++++
+++++  const documentList = availableDocuments
+++++    .map(doc => `- ID: ${doc.id}, Name: ${doc.fileName}`)
+++++    .join('\n');
+++++
+++++  return `You are a professional document analysis coordinator specializing in review result investigation.
+++++
+++++CONTEXT:
+++++You are helping answer user questions about document review results. You have access to:
+++++1. The original reviewed documents
+++++2. Review results including evaluations and comments for specific checklist items
+++++
+++++AVAILABLE DOCUMENTS:
+++++${documentList}
+++++
+++++CHECKLIST REVIEW INFORMATION:
+++++${checklistInfo}
+++++
+++++YOUR TASK:
+++++Create an efficient research plan to answer the user's question by identifying:
+++++1. Which documents contain relevant information
+++++2. What specific aspects to investigate in each document
+++++3. How the investigation relates to the review results
+++++
+++++STRATEGIC PLANNING GUIDELINES:
+++++
+++++**Question Analysis:**
+++++- Understand the user's intent: Are they asking about evaluation reasoning, improvement suggestions, specific document content, or discrepancies in the review?
+++++- Identify keywords and concepts that connect to the checklist items and review comments
+++++- Determine if the question relates to specific checklist items or general document content
+++++
+++++**Document Selection Strategy:**
+++++- **Prioritize efficiency**: Select ONLY documents that are likely to contain relevant information
+++++- Use the review results to guide your selection:
+++++  * If asking about a specific evaluation or comment, focus on documents mentioned in those review results
+++++  * If asking about document content, identify which documents are most likely to contain that information
+++++  * Consider the review context: documents with lower ratings or specific comments may need investigation
+++++
+++++**Research Instructions Quality:**
+++++- Be SPECIFIC and FOCUSED in your research instructions
+++++- Clearly state what information to extract (e.g., "Find the section describing the testing methodology and extract the specific test types mentioned")
+++++- Connect the research to the review context when relevant (e.g., "Verify the claim in the review comment that the security measures are incomplete")
+++++- Prioritize targeted investigation over broad exploration
+++++
+++++**Efficiency Considerations:**
+++++- Minimize the number of documents to investigate (only select what's necessary)
+++++- Avoid redundant investigations across multiple documents unless truly needed
+++++- Focus research instructions on finding specific information rather than general overviews
+++++
+++++OUTPUT REQUIREMENTS:
+++++For each document that needs investigation, provide:
+++++- **Document ID**: The exact ID from the available documents list above
+++++- **Research Instructions**: Detailed, focused instructions explaining:
+++++  * What specific information to look for
+++++  * How it relates to the user's question
+++++  * Connection to review results if applicable
+++++- **Reasoning**: Brief explanation (1-2 sentences) of why this document is necessary for answering the question
+++++
+++++IMPORTANT:
+++++- Create a focused, efficient plan - quality over quantity
+++++- Your research plan will be executed in parallel across multiple documents
+++++- Each investigation will be conducted independently, so make instructions self-contained and clear`;
+++++}
+++++
+++++// レビューチャット：個別ドキュメント調査用のプロンプト
+++++export function getReviewChatResearchPrompt({
+++++  runtimeContext,
+++++}: {
+++++  runtimeContext: RuntimeContext<ReviewChatResearchAgentRuntimeContext>;
+++++}): string {
+++++  const totalChunks = runtimeContext.get('totalChunks');
+++++  const chunkIndex = runtimeContext.get('chunkIndex');
+++++  const fileName = runtimeContext.get('fileName');
+++++  const checklistInfo = runtimeContext.get('checklistInfo');
+++++  const userQuestion = runtimeContext.get('userQuestion');
+++++
+++++  // ドキュメントが分割されているかどうかで異なるプロンプトを生成
+++++  const isChunked = totalChunks > 1;
+++++
+++++  const contextSection = isChunked
+++++    ? `
+++++IMPORTANT DOCUMENT CONTEXT:
+++++- You are reviewing a PORTION (chunk ${chunkIndex + 1} of ${totalChunks}) of the document "${fileName}"
+++++- This document has been split into ${totalChunks} parts due to length constraints
+++++- You can ONLY see the content of this specific chunk (${chunkIndex + 1}/${totalChunks})
+++++- Other parts of the document exist but are NOT visible to you in this analysis
+++++- Information may be incomplete or cut off at chunk boundaries
+++++
+++++CRITICAL INSTRUCTIONS FOR CHUNKED DOCUMENTS:
+++++- Report ONLY what you can find in THIS chunk
+++++- If the requested information is not in this chunk, clearly state: "The information is not found in this portion (chunk ${chunkIndex + 1}/${totalChunks}) of the document"
+++++- Do NOT speculate about what might be in other chunks
+++++- If information appears to be cut off or incomplete at the beginning or end, note this explicitly
+++++- Be aware that context from previous or subsequent chunks may be missing
+++++`
+++++    : `
+++++DOCUMENT CONTEXT:
+++++- You are reviewing the complete document "${fileName}"
+++++- The full document content is available for your analysis
+++++- You have access to all information needed to answer the research question
+++++`;
+++++
+++++  return `You are a professional document researcher specializing in detailed document analysis.
+++++
+++++Your task is to conduct a specific investigation on the provided document based on the given research instructions.
+++++
+++++BACKGROUND CONTEXT:
+++++This research is being conducted to help answer the following user question about a document review:
+++++
+++++User Question:
+++++${userQuestion}
+++++
+++++The review was conducted based on the following checklist(s):
+++++${checklistInfo}
+++++
+++++Understanding this context will help you focus your investigation on information that is truly relevant to answering the user's question about the review results.
+++++${contextSection}
+++++RESEARCH GUIDELINES:
+++++1. Carefully read and analyze the provided document content with the user's question and checklist context in mind
+++++2. Follow the specific research instructions precisely
+++++3. Extract all relevant information related to the research topic
+++++4. Consider how your findings relate to the checklist items and review results mentioned above
+++++5. Cite specific sections, headings, page indicators, or other references where information is found
+++++6. If information appears incomplete or ambiguous, note this clearly${isChunked ? ' (especially at chunk boundaries)' : ''}
+++++7. Document your findings comprehensively - do not summarize or omit details
+++++${isChunked ? '8. Remember: you can only report on what is visible in THIS chunk' : ''}
+++++
+++++OUTPUT REQUIREMENTS:
+++++- Provide detailed research findings in Japanese
+++++- Include specific citations and references from the document${isChunked ? ` (mention this is from chunk ${chunkIndex + 1}/${totalChunks} if relevant)` : ''}
+++++- Note any limitations or gaps in the available information${isChunked ? ' within this chunk' : ''}
+++++- Structure your findings clearly for easy integration into the final answer
+++++${isChunked ? `- If the requested information is not in this chunk, explicitly state that it was not found in this portion` : ''}`;
+++++}
+++++
+++++// レビューチャット：最終回答生成用のプロンプト
+++++export function getReviewChatAnswerPrompt({
+++++  runtimeContext,
+++++}: {
+++++  runtimeContext: RuntimeContext<ReviewChatAnswerAgentRuntimeContext>;
+++++}): string {
+++++  const userQuestion = runtimeContext.get('userQuestion');
+++++  const checklistInfo = runtimeContext.get('checklistInfo');
+++++
+++++  return `You are a senior document review specialist responsible for synthesizing research findings into comprehensive answers.
+++++
+++++CONTEXT:
+++++You are answering questions about document review results. You have access to:
+++++1. The user's original question
+++++2. Review results with evaluations and comments for specific checklist items
+++++3. Research findings from individual document investigations
+++++
+++++USER QUESTION:
+++++${userQuestion}
+++++
+++++CHECKLIST CONTEXT:
+++++${checklistInfo}
+++++
+++++YOUR TASK:
+++++Integrate all research findings and provide a clear, accurate, and comprehensive answer to the user's question.
+++++
+++++SYNTHESIS GUIDELINES:
+++++
+++++**Understanding the Research Results:**
+++++- You will receive research findings from one or more documents
+++++- Each finding may come from a complete document OR from a portion of a document (chunk)
+++++- Some findings may indicate "information not found in this portion" - this is expected for chunked documents
+++++- Consider ALL findings together to build a complete picture
+++++
+++++**Integration Strategy:**
+++++1. **Identify Relevant Information:**
+++++   - Extract key information from each research finding that addresses the user's question
+++++   - Pay attention to specific citations, section references, and evidence provided
+++++   - Distinguish between definitive findings and tentative/partial information
+++++
+++++2. **Handle Chunked Document Results:**
+++++   - If research findings mention "chunk X/Y" or "this portion", the document was split for analysis
+++++   - Combine findings from multiple chunks of the same document to form a complete view
+++++   - If some chunks report "information not found", don't assume the information doesn't exist - it may be in other chunks
+++++
+++++3. **Resolve Contradictions:**
+++++   - If findings from different sources contradict each other:
+++++     * Present both perspectives
+++++     * Explain the discrepancy clearly
+++++     * Cite specific sources for each perspective
+++++     * Offer reasoning if one source seems more authoritative
+++++
+++++4. **Synthesize into a Coherent Answer:**
+++++   - Organize information logically to directly answer the question
+++++   - Connect findings to the review context (evaluations, comments) when relevant
+++++   - Build a narrative that flows naturally, not just a list of findings
+++++
+++++**Citation and Reference Guidelines:**
+++++- **Document Names**: Use natural document names without mentioning chunk numbers (e.g., "設計書.pdf" not "設計書.pdf chunk 2/3")
+++++- **Specific Citations**: Include section names, headings, page indicators, or other specific references from the research findings
+++++- **Attribution**: Clearly attribute information to sources (e.g., "設計書.pdfの第3章によると...")
+++++- **Avoid Internal Process Terms**: Do not mention "chunk", "research findings", "investigation" or similar internal process terminology
+++++
+++++**Handling Incomplete Information:**
+++++- If critical information is missing or unclear, state this explicitly in Japanese
+++++- Suggest what additional information would be needed
+++++- Distinguish between:
+++++  * Information that definitely doesn't exist in the documents
+++++  * Information that wasn't found but might exist elsewhere
+++++  * Information that is ambiguous or unclear
+++++
+++++OUTPUT REQUIREMENTS:
+++++- **Language**: Answer in Japanese, matching the style and formality of the user's question
+++++- **Structure**: Organize the answer clearly and logically:
+++++  * Start with a direct answer to the main question if possible
+++++  * Provide supporting details and evidence
+++++  * Conclude with any caveats or additional context
+++++- **Tone**: Professional, informative, and helpful
+++++- **Completeness**: Address all aspects of the user's question
+++++- **Natural Expression**: Write as if you reviewed the documents directly - avoid mentioning the research process
+++++
+++++CRITICAL REMINDERS:
+++++- Your answer represents the final response to the user
+++++- Quality and accuracy are paramount
+++++- Provide value by synthesizing information, not just repeating findings
+++++- Be honest about limitations while maximizing usefulness of available information`;
+++++}
+++++
++++ // レビュー結果統合用のプロンプト
++++ export function getConsolidateReviewPrompt({
++++   runtimeContext,
++++diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
++++index ad0371265..f45e92522 100644
++++--- a/src/mastra/agents/workflowAgents.ts
+++++++ b/src/mastra/agents/workflowAgents.ts
++++@@ -14,6 +14,9 @@ import {
++++   getDocumentReviewExecutionPrompt,
++++   getIndividualDocumentReviewPrompt,
++++   getConsolidateReviewPrompt,
+++++  getReviewChatPlanningPrompt,
+++++  getReviewChatResearchPrompt,
+++++  getReviewChatAnswerPrompt,
++++ } from './prompts';
++++ import { getOpenAICompatibleModel } from './model/openAICompatible';
++++ import { BaseRuntimeContext } from './types';
++++@@ -44,32 +47,37 @@ export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
++++   checklistRequirements?: string;
++++ };
++++ 
++++-export type ReviewCheckReviewReadinessFirstRunAgentRuntimeContext = BaseRuntimeContext & {
+++++export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
++++   checklistItems: { id: number; content: string }[];
++++   additionalInstructions?: string;
+++++  commentFormat?: string;
++++ };
++++ 
++++-export type ReviewCheckReviewReadinessSubsequentAgentRuntimeContext = BaseRuntimeContext & {
+++++export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
++++   checklistItems: { id: number; content: string }[];
++++   additionalInstructions?: string;
++++-  priorQnA: { documentId: string; documentName: string; qna: { question: string; answer: string }[] }[];
+++++  commentFormat?: string;
+++++  evaluationSettings?: CustomEvaluationSettings;
++++ };
++++ 
++++-export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
++++-  checklistItems: { id: number; content: string }[];
+++++// レビューチャット用エージェント
+++++export type ReviewChatPlanningAgentRuntimeContext = BaseRuntimeContext & {
+++++  availableDocuments: { id: string; fileName: string }[];
+++++  checklistInfo: string; // チェックリスト情報のテキスト
++++ };
++++ 
++++-export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
++++-  checklistItems: { id: number; content: string }[];
++++-  additionalInstructions?: string;
++++-  commentFormat?: string;
+++++export type ReviewChatResearchAgentRuntimeContext = BaseRuntimeContext & {
+++++  researchContent: string; // 調査内容
+++++  totalChunks: number; // ドキュメントの総チャンク数
+++++  chunkIndex: number; // 現在のチャンクインデックス
+++++  fileName: string; // ドキュメント名
+++++  checklistInfo: string; // チェックリスト情報（内容とレビュー結果）
+++++  userQuestion: string; // ユーザからの質問
++++ };
++++ 
++++-export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
++++-  checklistItems: { id: number; content: string }[];
++++-  additionalInstructions?: string;
++++-  commentFormat?: string;
++++-  evaluationSettings?: CustomEvaluationSettings;
+++++export type ReviewChatAnswerAgentRuntimeContext = BaseRuntimeContext & {
+++++  userQuestion: string; // ユーザからの質問
+++++  checklistInfo: string; // チェックリスト情報のテキスト
++++ };
++++ 
++++ export const summarizeSourceAgent = new Agent({
++++@@ -139,3 +147,21 @@ export const consolidateReviewAgent = new Agent({
++++   instructions: getConsolidateReviewPrompt,
++++   model: getOpenAICompatibleModel,
++++ });
+++++
+++++export const reviewChatPlanningAgent = new Agent({
+++++  name: 'reviewChatPlanningAgent',
+++++  instructions: getReviewChatPlanningPrompt,
+++++  model: getOpenAICompatibleModel,
+++++});
+++++
+++++export const reviewChatResearchAgent = new Agent({
+++++  name: 'reviewChatResearchAgent',
+++++  instructions: getReviewChatResearchPrompt,
+++++  model: getOpenAICompatibleModel,
+++++});
+++++
+++++export const reviewChatAnswerAgent = new Agent({
+++++  name: 'reviewChatAnswerAgent',
+++++  instructions: getReviewChatAnswerPrompt,
+++++  model: getOpenAICompatibleModel,
+++++});
++++diff --git a/src/mastra/index.ts b/src/mastra/index.ts
++++index d2cd1e327..c287ced13 100644
++++--- a/src/mastra/index.ts
+++++++ b/src/mastra/index.ts
++++@@ -19,10 +19,14 @@ import {
++++   topicChecklistAgent,
++++   individualDocumentReviewAgent,
++++   consolidateReviewAgent,
+++++  reviewChatPlanningAgent,
+++++  reviewChatResearchAgent,
+++++  reviewChatAnswerAgent,
++++ } from './agents/workflowAgents';
++++ import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
++++ import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
++++ import { executeReviewWorkflow } from './workflows/sourceReview/executeReview';
+++++import { reviewChatWorkflow } from './workflows/reviewChat';
++++ import fs from 'fs';
++++ import path from 'path';
++++ import { getLogLevel } from '@/main/lib/logger';
++++@@ -73,11 +77,15 @@ export const mastra: Mastra = new Mastra({
++++     topicChecklistAgent,
++++     individualDocumentReviewAgent,
++++     consolidateReviewAgent,
+++++    reviewChatPlanningAgent,
+++++    reviewChatResearchAgent,
+++++    reviewChatAnswerAgent,
++++   },
++++   workflows: {
++++     sourceRegistrationWorkflow,
++++     checklistExtractionWorkflow,
++++     executeReviewWorkflow,
+++++    reviewChatWorkflow,
++++   },
++++   logger,
++++ });
++++diff --git a/src/mastra/tools/toolDisplayConfig.ts b/src/mastra/tools/toolDisplayConfig.ts
++++index 62ee97da4..9dca7f3da 100644
++++--- a/src/mastra/tools/toolDisplayConfig.ts
+++++++ b/src/mastra/tools/toolDisplayConfig.ts
++++@@ -25,4 +25,8 @@ export const TOOL_NAME_DISPLAY_MAP: Record<string, string> = {
++++   getMergeRequestDetail: 'マージリクエスト詳細取得',
++++   addMergeRequestComment: 'マージリクエストコメント追加',
++++   addMergeRequestDiffComment: 'マージリクエスト差分コメント追加',
+++++
+++++  // レビューチャット用
+++++  researchDocumentStart: 'ドキュメント調査中...',
+++++  researchDocumentComplete: 'ドキュメント調査完了',
++++ };
++++diff --git a/src/mastra/workflows/reviewChat/generateAnswerStep.ts b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
++++new file mode 100644
++++index 000000000..c6a039b9e
++++--- /dev/null
+++++++ b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
++++@@ -0,0 +1,158 @@
+++++// @ts-ignore
+++++import { createStep } from '@mastra/core';
+++++// @ts-ignore
+++++import { RuntimeContext } from '@mastra/core/runtime-context';
+++++import { z } from 'zod';
+++++import { baseStepOutputSchema } from '../schema';
+++++import { stepStatus } from '../types';
+++++import { getReviewRepository } from '@/adapter/db';
+++++import { getMainLogger } from '@/main/lib/logger';
+++++import { normalizeUnknownError, internalError } from '@/main/lib/error';
+++++import { ReviewChatAnswerAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+++++import {
+++++  createRuntimeContext,
+++++  judgeFinishReason,
+++++} from '@/mastra/lib/agentUtils';
+++++import { IpcChannels } from '@/types';
+++++import { publishEvent } from '@/main/lib/eventPayloadHelper';
+++++import { ReviewChatWorkflowRuntimeContext } from '.';
+++++
+++++const logger = getMainLogger();
+++++
+++++export const generateAnswerStepInputSchema = z.object({
+++++  reviewHistoryId: z.string(),
+++++  checklistIds: z.array(z.number()),
+++++  question: z.string(),
+++++  researchResults: z.array(
+++++    z.object({
+++++      documentId: z.string(),
+++++      researchResult: z.string(),
+++++    }),
+++++  ),
+++++});
+++++
+++++export const generateAnswerStepOutputSchema = baseStepOutputSchema.extend({
+++++  answer: z.string().optional(),
+++++});
+++++
+++++export const generateAnswerStep = createStep({
+++++  id: 'generateAnswerStep',
+++++  description: '最終回答を生成するステップ（ストリーミング）',
+++++  inputSchema: generateAnswerStepInputSchema,
+++++  outputSchema: generateAnswerStepOutputSchema,
+++++  execute: async ({
+++++    inputData,
+++++    bail,
+++++    mastra,
+++++    abortSignal,
+++++    runtimeContext: workflowRuntimeContext,
+++++  }) => {
+++++    try {
+++++      const { reviewHistoryId, checklistIds, question, researchResults } =
+++++        inputData;
+++++      const reviewRepository = getReviewRepository();
+++++      const dataStreamWriter = (
+++++        workflowRuntimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++++      ).get('dataStreamWriter');
+++++
+++++      // チェックリスト結果を取得
+++++      const checklistResults =
+++++        await reviewRepository.getChecklistResultsWithIndividualResults(
+++++          reviewHistoryId,
+++++          checklistIds,
+++++        );
+++++
+++++      // ドキュメントキャッシュ情報を取得
+++++      const documentCaches =
+++++        await reviewRepository.getReviewDocumentCacheByDocumentIds(
+++++          reviewHistoryId,
+++++          researchResults.map((r) => r.documentId),
+++++        );
+++++
+++++      const checklistInfo = checklistResults
+++++        .map((item) => {
+++++          let info = `Checklist: ${item.checklistResult.content}\n`;
+++++          if (item.checklistResult.sourceEvaluation) {
+++++            info += `Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}, Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}`;
+++++          }
+++++          return info;
+++++        })
+++++        .join('\n');
+++++
+++++      // 調査結果を統合
+++++      const researchSummary = researchResults
+++++        .map(
+++++          (result) =>
+++++            `Document ID: ${result.documentId}\nDocument Name: ${documentCaches.find((dc) => dc.documentId === result.documentId)?.fileName || 'Unknown'}\nFindings: ${result.researchResult}`,
+++++        )
+++++        .join('\n---\n');
+++++
+++++      // RuntimeContext作成
+++++      const runtimeContext =
+++++        await createRuntimeContext<ReviewChatAnswerAgentRuntimeContext>();
+++++      runtimeContext.set('userQuestion', question);
+++++      runtimeContext.set('checklistInfo', checklistInfo);
+++++
+++++      const promptText = `User Question: ${question}\n\nResearch Findings:\n${researchSummary}`;
+++++
+++++      // Mastraエージェント経由でストリーミングAI呼び出し
+++++      const answerAgent = mastra.getAgent('reviewChatAnswerAgent');
+++++      const result = await answerAgent.generate(promptText, {
+++++        runtimeContext,
+++++        abortSignal,
+++++        onStepFinish: (stepResult) => {
+++++          // AI SDK Data Stream Protocol v1 形式でチャンクを送信
+++++          // https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol
+++++          if (stepResult.text) {
+++++            dataStreamWriter.write(`0:${JSON.stringify(stepResult.text)}\n`);
+++++          }
+++++          stepResult.toolCalls.forEach((toolCall) => {
+++++            dataStreamWriter.write(`9:${JSON.stringify(toolCall)}\n`);
+++++          });
+++++          stepResult.toolResults.forEach((toolResult) => {
+++++            dataStreamWriter.write(`a:${JSON.stringify(toolResult)}\n`);
+++++          });
+++++          dataStreamWriter.write(
+++++            `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
+++++          );
+++++        },
+++++      });
+++++
+++++      const { success, reason } = judgeFinishReason(result.finishReason);
+++++      if (!success) {
+++++        throw internalError({
+++++          expose: true,
+++++          messageCode: 'AI_API_ERROR',
+++++          messageParams: { detail: reason },
+++++        });
+++++      }
+++++
+++++      // 最終的なfinish reasonとusage情報を送信
+++++      publishEvent(
+++++        IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
+++++        `d:${JSON.stringify({ finishReason: result.finishReason, ...result.usage })}\n`,
+++++      );
+++++
+++++      // 完了イベント送信
+++++      publishEvent(IpcChannels.REVIEW_CHAT_COMPLETE, undefined);
+++++
+++++      return {
+++++        status: 'success' as stepStatus,
+++++        answer: result.text,
+++++      };
+++++    } catch (error) {
+++++      logger.error(error, '最終回答の生成に失敗しました');
+++++      const normalizedError = normalizeUnknownError(error);
+++++
+++++      // エラーイベント送信
+++++      publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
+++++        message: normalizedError.message,
+++++      });
+++++
+++++      return bail({
+++++        status: 'failed' as stepStatus,
+++++        errorMessage: normalizedError.message,
+++++      });
+++++    }
+++++  },
+++++});
++++diff --git a/src/mastra/workflows/reviewChat/index.ts b/src/mastra/workflows/reviewChat/index.ts
++++new file mode 100644
++++index 000000000..840d52dde
++++--- /dev/null
+++++++ b/src/mastra/workflows/reviewChat/index.ts
++++@@ -0,0 +1,133 @@
+++++// @ts-ignore
+++++import { createWorkflow } from '@mastra/core';
+++++// @ts-ignore
+++++import { RuntimeContext } from '@mastra/core/runtime-context';
+++++import { DataStreamWriter } from 'ai';
+++++import { z } from 'zod';
+++++import { stepStatus } from '../types';
+++++import { planResearchStep } from './planResearchStep';
+++++import {
+++++  generateAnswerStep,
+++++  generateAnswerStepInputSchema,
+++++  generateAnswerStepOutputSchema,
+++++} from './generateAnswerStep';
+++++import { researchDocumentWithRetryWorkflow } from './researchDocument';
+++++import { getReviewRepository } from '@/adapter/db';
+++++
+++++// ワークフローのラインタイムコンテキスト
+++++export type ReviewChatWorkflowRuntimeContext = {
+++++  dataStreamWriter: DataStreamWriter;
+++++  // 擬似的なtoolCallを表現するためのID
+++++  toolCallId: string;
+++++};
+++++
+++++// 入力スキーマ
+++++export const reviewChatInputSchema = z.object({
+++++  reviewHistoryId: z.string(),
+++++  checklistIds: z.array(z.number()),
+++++  question: z.string(),
+++++});
+++++
+++++// メインワークフロー
+++++export const reviewChatWorkflow = createWorkflow({
+++++  id: 'reviewChatWorkflow',
+++++  inputSchema: reviewChatInputSchema,
+++++  outputSchema: generateAnswerStepOutputSchema,
+++++})
+++++  .then(planResearchStep)
+++++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
+++++    if (inputData.status === 'failed') {
+++++      return bail(inputData);
+++++    }
+++++
+++++    const initData = (await getInitData()) as z.infer<
+++++      typeof reviewChatInputSchema
+++++    >;
+++++
+++++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
+++++    const toolCallId = (
+++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++++    ).get('toolCallId');
+++++    const writer = (
+++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++++    ).get('dataStreamWriter');
+++++    const reviewRepository = getReviewRepository();
+++++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
+++++      initData.reviewHistoryId,
+++++    );
+++++    writer.write(
+++++      `9:${JSON.stringify({
+++++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
+++++        toolName: 'researchDocumentStart',
+++++        args: inputData.researchTasks?.map((task) => {
+++++          return {
+++++            documentName:
+++++              documentCaches.find((d) => d.documentId === task.documentId)
+++++                ?.fileName || 'Unknown',
+++++            researchContent: task.researchContent,
+++++          };
+++++        }),
+++++      })}\n`,
+++++    );
+++++
+++++    return (inputData.researchTasks || []).map((task) => ({
+++++      reviewHistoryId: initData.reviewHistoryId,
+++++      documentId: task.documentId,
+++++      researchContent: task.researchContent,
+++++      checklistIds: initData.checklistIds,
+++++      question: initData.question,
+++++    })) as z.infer<typeof researchDocumentWithRetryWorkflow.inputSchema>[];
+++++  })
+++++  .foreach(researchDocumentWithRetryWorkflow, { concurrency: 5 })
+++++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
+++++    // 失敗があればエラー
+++++    if (inputData.some((item) => item.status === 'failed')) {
+++++      const failed = inputData.find((item) => item.status === 'failed');
+++++      return bail({
+++++        status: 'failed' as stepStatus,
+++++        errorMessage: failed?.errorMessage || '調査に失敗しました',
+++++      });
+++++    }
+++++
+++++    const initData = (await getInitData()) as z.infer<
+++++      typeof reviewChatInputSchema
+++++    >;
+++++
+++++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
+++++    const toolCallId = (
+++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++++    ).get('toolCallId');
+++++    const writer = (
+++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++++    ).get('dataStreamWriter');
+++++    const reviewRepository = getReviewRepository();
+++++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
+++++      initData.reviewHistoryId,
+++++    );
+++++    writer.write(
+++++      `a:${JSON.stringify({
+++++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
+++++        toolName: 'researchDocumentComplete',
+++++        result: inputData.map((item) => ({
+++++          documentName:
+++++            documentCaches.find((d) => d.documentId === item.documentId)
+++++              ?.fileName || 'Unknown',
+++++          researchResult: item.researchResult!,
+++++        })),
+++++      })}\n`,
+++++    );
+++++
+++++    return {
+++++      reviewHistoryId: initData.reviewHistoryId,
+++++      checklistIds: initData.checklistIds,
+++++      question: initData.question,
+++++      researchResults: inputData
+++++        .filter((item) => item.status === 'success')
+++++        .map((item) => ({
+++++          documentId: item.documentId!,
+++++          researchResult: item.researchResult!,
+++++        })),
+++++    } as z.infer<typeof generateAnswerStepInputSchema>;
+++++  })
+++++  .then(generateAnswerStep)
+++++  .commit();
++++diff --git a/src/mastra/workflows/reviewChat/planResearchStep.ts b/src/mastra/workflows/reviewChat/planResearchStep.ts
++++new file mode 100644
++++index 000000000..57df18bce
++++--- /dev/null
+++++++ b/src/mastra/workflows/reviewChat/planResearchStep.ts
++++@@ -0,0 +1,121 @@
+++++// @ts-ignore
+++++import { createStep } from '@mastra/core';
+++++import { z } from 'zod';
+++++import { baseStepOutputSchema } from '../schema';
+++++import { stepStatus } from '../types';
+++++import { getReviewRepository } from '@/adapter/db';
+++++import { getMainLogger } from '@/main/lib/logger';
+++++import { normalizeUnknownError, internalError } from '@/main/lib/error';
+++++import {
+++++  ReviewChatPlanningAgentRuntimeContext,
+++++} from '@/mastra/agents/workflowAgents';
+++++import { createRuntimeContext, judgeFinishReason} from '@/mastra/lib/agentUtils';
+++++import { reviewChatInputSchema } from '.';
+++++
+++++const logger = getMainLogger();
+++++
+++++// Step 1: 調査計画作成
+++++const planResearchStepOutputSchema = baseStepOutputSchema.extend({
+++++  researchTasks: z
+++++    .array(
+++++      z.object({
+++++        documentId: z.string(),
+++++        researchContent: z.string(),
+++++      }),
+++++    )
+++++    .optional(),
+++++});
+++++
+++++export const planResearchStep = createStep({
+++++  id: 'planResearchStep',
+++++  description: '調査計画を作成するステップ',
+++++  inputSchema: reviewChatInputSchema,
+++++  outputSchema: planResearchStepOutputSchema,
+++++  execute: async ({ inputData, bail, mastra }) => {
+++++    try {
+++++      const { reviewHistoryId, checklistIds, question } = inputData;
+++++      const reviewRepository = getReviewRepository();
+++++
+++++      // チェックリスト結果と個別レビュー結果を取得
+++++      const checklistResults =
+++++        await reviewRepository.getChecklistResultsWithIndividualResults(
+++++          reviewHistoryId,
+++++          checklistIds,
+++++        );
+++++
+++++      // ドキュメント一覧を取得
+++++      const documentCaches =
+++++        await reviewRepository.getReviewDocumentCaches(reviewHistoryId);
+++++
+++++      // RuntimeContext作成
+++++      const availableDocuments = documentCaches.map(doc => ({
+++++        id: doc.documentId,
+++++        fileName: doc.fileName,
+++++      }));
+++++
+++++      // チェックリスト情報の文字列を生成
+++++      const checklistInfo = checklistResults
+++++        .map((item) => {
+++++          let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
+++++          if (item.checklistResult.sourceEvaluation) {
+++++            info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
+++++          }
+++++          if (item.individualResults && item.individualResults.length > 0) {
+++++            info += `Individual Review Results:\n`;
+++++            item.individualResults.forEach((result) => {
+++++              info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
+++++            });
+++++          }
+++++          return info;
+++++        })
+++++        .join('\n---\n');
+++++
+++++      // RuntimeContext作成
+++++      const runtimeContext = await createRuntimeContext<ReviewChatPlanningAgentRuntimeContext>();
+++++      runtimeContext.set('availableDocuments', availableDocuments);
+++++      runtimeContext.set('checklistInfo', checklistInfo);
+++++
+++++      // 構造化出力用のスキーマ
+++++      const researchTasksSchema = z.object({
+++++        tasks: z.array(
+++++          z.object({
+++++            reasoning: z.string().describe('Reason for selecting this document for research'),
+++++            documentId: z.string().describe('Document ID to investigate'),
+++++            researchContent: z.string().describe('Detailed research instructions for this document'),
+++++          }),
+++++        ),
+++++      });
+++++
+++++      // Mastraエージェント経由でAI呼び出し（構造化出力）
+++++      const planningAgent = mastra.getAgent('reviewChatPlanningAgent');
+++++      const result = await planningAgent.generate(question, {
+++++        runtimeContext,
+++++        output: researchTasksSchema,
+++++      });
+++++
+++++      const { success, reason } = judgeFinishReason(result.finishReason);
+++++      if (!success) {
+++++        throw internalError({
+++++          expose: true,
+++++          messageCode: 'AI_API_ERROR',
+++++          messageParams: { detail: reason },
+++++        });
+++++      }
+++++
+++++      // 構造化出力から調査タスクを取得
+++++      const researchTasks = result.object?.tasks || [];
+++++
+++++      return {
+++++        status: 'success' as stepStatus,
+++++        researchTasks,
+++++      };
+++++    } catch (error) {
+++++      logger.error(error, '調査計画の作成に失敗しました');
+++++      const normalizedError = normalizeUnknownError(error);
+++++      return bail({
+++++        status: 'failed' as stepStatus,
+++++        errorMessage: normalizedError.message,
+++++      });
+++++    }
+++++  },
+++++});
++++diff --git a/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
++++new file mode 100644
++++index 000000000..dd6e3f661
++++--- /dev/null
+++++++ b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
++++@@ -0,0 +1,57 @@
+++++// @ts-ignore
+++++import { createStep } from '@mastra/core';
+++++import { z } from 'zod';
+++++import { baseStepOutputSchema } from '../../schema';
+++++import { stepStatus } from '../../types';
+++++import { getReviewRepository } from '@/adapter/db';
+++++import { getMainLogger } from '@/main/lib/logger';
+++++import { normalizeUnknownError } from '@/main/lib/error';
+++++
+++++const logger = getMainLogger();
+++++
+++++export const getTotalChunksStepInputSchema = z.object({
+++++  reviewHistoryId: z.string(),
+++++  documentId: z.string(),
+++++  researchContent: z.string(),
+++++});
+++++
+++++export const getTotalChunksStepOutputSchema = baseStepOutputSchema.extend({
+++++  reviewHistoryId: z.string(),
+++++  documentId: z.string(),
+++++  researchContent: z.string(),
+++++  totalChunks: z.number(),
+++++});
+++++
+++++export const getTotalChunksStep = createStep({
+++++  id: 'getTotalChunksStep',
+++++  description: '最大チャンク数を取得するステップ',
+++++  inputSchema: getTotalChunksStepInputSchema,
+++++  outputSchema: getTotalChunksStepOutputSchema,
+++++  execute: async ({ inputData, bail }) => {
+++++    try {
+++++      const { reviewHistoryId, documentId, researchContent } = inputData;
+++++      const reviewRepository = getReviewRepository();
+++++
+++++      // 既存の最大チャンク数を取得
+++++      const totalChunks = await reviewRepository.getMaxTotalChunksForDocument(
+++++        reviewHistoryId,
+++++        documentId,
+++++      );
+++++
+++++      return {
+++++        status: 'success' as stepStatus,
+++++        reviewHistoryId,
+++++        documentId,
+++++        researchContent,
+++++        totalChunks,
+++++      };
+++++    } catch (error) {
+++++      logger.error(error, '最大チャンク数の取得に失敗しました');
+++++      const normalizedError = normalizeUnknownError(error);
+++++      return bail({
+++++        status: 'failed' as stepStatus,
+++++        errorMessage: normalizedError.message,
+++++      });
+++++    }
+++++  },
+++++});
++++diff --git a/src/mastra/workflows/reviewChat/researchDocument/index.ts b/src/mastra/workflows/reviewChat/researchDocument/index.ts
++++new file mode 100644
++++index 000000000..ff668d3c9
++++--- /dev/null
+++++++ b/src/mastra/workflows/reviewChat/researchDocument/index.ts
++++@@ -0,0 +1,175 @@
+++++// @ts-ignore
+++++import { createWorkflow } from '@mastra/core';
+++++import { z } from 'zod';
+++++import { baseStepOutputSchema } from '../../schema';
+++++import { stepStatus } from '../../types';
+++++import { getReviewRepository } from '@/adapter/db';
+++++import { getMainLogger } from '@/main/lib/logger';
+++++import { makeChunksByCount } from '@/mastra/lib/util';
+++++import { getTotalChunksStep, getTotalChunksStepInputSchema, getTotalChunksStepOutputSchema } from './getTotalChunksStep';
+++++import { researchChunkStep, researchChunkStepInputSchema } from './researchDocumentChunk';
+++++import { input } from '@testing-library/user-event/dist/cjs/event/input.js';
+++++
+++++const logger = getMainLogger();
+++++
+++++const researchDocumentWithRetryInputSchema = z.object({
+++++  reviewHistoryId: z.string(),
+++++  documentId: z.string(),
+++++  researchContent: z.string(),
+++++  checklistIds: z.array(z.number()),
+++++  question: z.string(),
+++++});
+++++
+++++const researchDocumentWithRetryOutputSchema = baseStepOutputSchema.extend({
+++++  documentId: z.string().optional(),
+++++  researchResult: z.string().optional(),
+++++});
+++++
+++++export const researchDocumentWithRetryWorkflow = createWorkflow({
+++++  id: 'researchDocumentWithRetryWorkflow',
+++++  inputSchema: researchDocumentWithRetryInputSchema,
+++++  outputSchema: researchDocumentWithRetryOutputSchema,
+++++})
+++++  .map(async ({ inputData }) => {
+++++    return inputData as z.infer<typeof getTotalChunksStepInputSchema>;
+++++  })
+++++  .then(getTotalChunksStep)
+++++  .map(async ({ inputData, getInitData, bail }) => {
+++++    if (inputData.status === 'failed') {
+++++      return bail(inputData);
+++++    }
+++++    const initData = (await getInitData()) as z.infer<typeof researchDocumentWithRetryInputSchema>;
+++++    return {
+++++      ...inputData,
+++++      checklistIds: initData.checklistIds,
+++++      question: initData.question,
+++++    } as z.infer<typeof getTotalChunksStepOutputSchema> & {
+++++      checklistIds: number[];
+++++      question: string;
+++++    };
+++++  })
+++++  .dountil(
+++++    createWorkflow({
+++++      id: 'chunkResearchInnerWorkflow',
+++++      inputSchema: getTotalChunksStepOutputSchema.extend({
+++++        checklistIds: z.array(z.number()),
+++++        question: z.string(),
+++++      }),
+++++      outputSchema: researchDocumentWithRetryOutputSchema,
+++++    })
+++++      .map(async ({ inputData }) => {
+++++        const { reviewHistoryId, documentId, researchContent, totalChunks } = inputData;
+++++        const reviewRepository = getReviewRepository();
+++++
+++++        // ドキュメントキャッシュを取得
+++++        const documentCache = await reviewRepository.getReviewDocumentCacheByDocumentId(
+++++          reviewHistoryId,
+++++          documentId,
+++++        );
+++++
+++++        if (!documentCache) {
+++++          throw new Error(`Document not found: ${documentId}`);
+++++        }
+++++
+++++        // ドキュメントをtotalChunks分に分割
+++++        const chunks: Array<{ text?: string; images?: string[] }> = [];
+++++
+++++        if (documentCache.processMode === 'text' && documentCache.textContent) {
+++++          // テキストをチャンク分割
+++++          const chunkRanges = makeChunksByCount(documentCache.textContent, totalChunks, 0);
+++++          chunkRanges.forEach(range => {
+++++            chunks.push({
+++++              text: documentCache.textContent!.substring(range.start, range.end),
+++++            });
+++++          });
+++++        } else if (documentCache.processMode === 'image' && documentCache.imageData) {
+++++          // 画像配列をチャンク分割
+++++          const chunkRanges = makeChunksByCount(documentCache.imageData, totalChunks, 0);
+++++          chunkRanges.forEach(range => {
+++++            chunks.push({
+++++              images: documentCache.imageData!.slice(range.start, range.end),
+++++            });
+++++          });
+++++        }
+++++
+++++        // 各チャンクに対する調査タスクを作成
+++++        return chunks.map((chunk, index) => ({
+++++          reviewHistoryId,
+++++          documentId,
+++++          researchContent,
+++++          chunkContent: chunk,
+++++          chunkIndex: index,
+++++          totalChunks,
+++++          fileName: documentCache.fileName,
+++++          checklistIds: inputData.checklistIds,
+++++          question: inputData.question,
+++++        })) as z.infer<typeof researchChunkStepInputSchema>[];
+++++      })
+++++      .foreach(researchChunkStep, { concurrency: 5 })
+++++      .map(async ({ inputData, bail, getInitData }) => {
+++++        const results = inputData;
+++++
+++++        // いずれかのチャンクでコンテキスト長エラーがあったかチェック
+++++        const hasContentLengthError = results.some(
+++++          (result) => result.finishReason === 'content_length'
+++++        );
+++++
+++++        // 失敗があればエラー
+++++        if (results.some((result) => result.status === 'failed')) {
+++++          const failed = results.find((result) => result.status === 'failed');
+++++          return bail({
+++++            status: 'failed' as stepStatus,
+++++            errorMessage: failed?.errorMessage || 'チャンク調査に失敗しました',
+++++            finishReason: 'error' as const,
+++++          });
+++++        }
+++++
+++++        const initData = (await getInitData()) as z.infer<typeof getTotalChunksStepOutputSchema>;
+++++
+++++        if (hasContentLengthError) {
+++++          // チャンク数を増やして再試行
+++++          return {
+++++            status: 'success' as stepStatus,
+++++            reviewHistoryId: initData.reviewHistoryId,
+++++            documentId: initData.documentId,
+++++            researchContent: initData.researchContent,
+++++            totalChunks: initData.totalChunks + 1,
+++++            finishReason: 'content_length' as const,
+++++          };
+++++        }
+++++
+++++        // すべて成功したらチャンク結果を統合
+++++        const combinedResult = results
+++++          .filter((result) => result.chunkResult)
+++++          .map((result, index) => `[Chunk ${index + 1}]\n${result.chunkResult}`)
+++++          .join('\n\n');
+++++
+++++        return {
+++++          status: 'success' as stepStatus,
+++++          documentId: initData.documentId,
+++++          researchResult: combinedResult,
+++++          finishReason: 'success' as const,
+++++        };
+++++      })
+++++      .commit(),
+++++    async ({ inputData }) => {
+++++      // 再試行上限または成功したら終了
+++++      if ((inputData as any).totalChunks >= 10) {
+++++        return true;
+++++      }
+++++      if ((inputData as any).finishReason !== 'content_length') {
+++++        return true;
+++++      }
+++++      return false;
+++++    },
+++++  )
+++++  .map(async ({ inputData }) => {
+++++    // 最終結果を返す
+++++    return {
+++++      status: inputData.status,
+++++      documentId: inputData.documentId,
+++++      researchResult: inputData.researchResult,
+++++      errorMessage: (inputData as any).errorMessage,
+++++    };
+++++  })
+++++  .commit();
++++diff --git a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
++++new file mode 100644
++++index 000000000..225e1901f
++++--- /dev/null
+++++++ b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
++++@@ -0,0 +1,181 @@
+++++// @ts-ignore
+++++import { createStep } from '@mastra/core';
+++++import { z } from 'zod';
+++++import { baseStepOutputSchema } from '../../schema';
+++++import { stepStatus } from '../../types';
+++++import { getMainLogger } from '@/main/lib/logger';
+++++import { normalizeUnknownError, internalError } from '@/main/lib/error';
+++++import { ReviewChatResearchAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+++++import {
+++++  createRuntimeContext,
+++++  judgeFinishReason,
+++++  judgeErrorIsContentLengthError,
+++++} from '@/mastra/lib/agentUtils';
+++++import { getReviewRepository } from '@/adapter/db';
+++++
+++++const logger = getMainLogger();
+++++
+++++export const researchChunkStepInputSchema = z.object({
+++++  reviewHistoryId: z.string(),
+++++  documentId: z.string(),
+++++  researchContent: z.string(),
+++++  chunkContent: z.object({
+++++    text: z.string().optional(),
+++++    images: z.array(z.string()).optional(),
+++++  }),
+++++  chunkIndex: z.number(),
+++++  totalChunks: z.number(),
+++++  fileName: z.string(),
+++++  checklistIds: z.array(z.number()),
+++++  question: z.string(),
+++++});
+++++
+++++const researchChunkStepOutputSchema = baseStepOutputSchema.extend({
+++++  chunkResult: z.string().optional(),
+++++  chunkIndex: z.number().optional(),
+++++  finishReason: z.enum(['success', 'error', 'content_length']).optional(),
+++++});
+++++
+++++export const researchChunkStep = createStep({
+++++  id: 'researchChunkStep',
+++++  description: 'チャンク単位でドキュメントを調査するステップ',
+++++  inputSchema: researchChunkStepInputSchema,
+++++  outputSchema: researchChunkStepOutputSchema,
+++++  execute: async ({ inputData, bail, mastra, getInitData }) => {
+++++    try {
+++++      const {
+++++        researchContent,
+++++        chunkContent,
+++++        chunkIndex,
+++++        totalChunks,
+++++        fileName,
+++++        reviewHistoryId,
+++++        checklistIds,
+++++        question,
+++++      } = inputData;
+++++
+++++      // チェックリスト情報を生成（planResearchStepと同じロジック）
+++++      const reviewRepository = getReviewRepository();
+++++      const checklistResults =
+++++        await reviewRepository.getChecklistResultsWithIndividualResults(
+++++          reviewHistoryId,
+++++          checklistIds,
+++++        );
+++++
+++++      const checklistInfo = checklistResults
+++++        .map(
+++++          (item: {
+++++            checklistResult: {
+++++              id: number;
+++++              content: string;
+++++              sourceEvaluation?: { evaluation?: string; comment?: string };
+++++            };
+++++            individualResults?: Array<{
+++++              documentId: number;
+++++              comment: string;
+++++              individualFileName: string;
+++++            }>;
+++++          }) => {
+++++            let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
+++++            if (item.checklistResult.sourceEvaluation) {
+++++              info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
+++++            }
+++++            if (item.individualResults && item.individualResults.length > 0) {
+++++              info += `Individual Review Results:\n`;
+++++              item.individualResults.forEach(
+++++                (result: {
+++++                  documentId: number;
+++++                  comment: string;
+++++                  individualFileName: string;
+++++                }) => {
+++++                  info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
+++++                },
+++++              );
+++++            }
+++++            return info;
+++++          },
+++++        )
+++++        .join('\n---\n');
+++++
+++++      // RuntimeContext作成
+++++      const runtimeContext =
+++++        await createRuntimeContext<ReviewChatResearchAgentRuntimeContext>();
+++++      runtimeContext.set('researchContent', researchContent);
+++++      runtimeContext.set('totalChunks', totalChunks);
+++++      runtimeContext.set('chunkIndex', chunkIndex);
+++++      runtimeContext.set('fileName', fileName);
+++++      runtimeContext.set('checklistInfo', checklistInfo);
+++++      runtimeContext.set('userQuestion', question);
+++++
+++++      // メッセージを作成
+++++      const messageContent = [];
+++++
+++++      if (chunkContent.text) {
+++++        // テキストチャンクの場合
+++++        messageContent.push({
+++++          type: 'text' as const,
+++++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nDocument Content:\n${chunkContent.text}`,
+++++        });
+++++      } else if (chunkContent.images && chunkContent.images.length > 0) {
+++++        // 画像チャンクの場合
+++++        messageContent.push({
+++++          type: 'text' as const,
+++++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nPlease analyze the following document images:`,
+++++        });
+++++
+++++        chunkContent.images.forEach((imageBase64) => {
+++++          messageContent.push({
+++++            type: 'image' as const,
+++++            image: imageBase64,
+++++          });
+++++        });
+++++      }
+++++
+++++      // Mastraエージェント経由でAI呼び出し
+++++      const researchAgent = mastra.getAgent('reviewChatResearchAgent');
+++++      const result = await researchAgent.generate(
+++++        {
+++++          role: 'user',
+++++          content: messageContent,
+++++        },
+++++        {
+++++          runtimeContext,
+++++        },
+++++      );
+++++
+++++      const { success, reason } = judgeFinishReason(result.finishReason);
+++++
+++++      if (!success) {
+++++        throw internalError({
+++++          expose: true,
+++++          messageCode: 'AI_API_ERROR',
+++++          messageParams: { detail: reason },
+++++        });
+++++      }
+++++
+++++      return {
+++++        status: 'success' as stepStatus,
+++++        chunkIndex,
+++++        chunkResult: result.text,
+++++        finishReason: 'success' as const,
+++++      };
+++++    } catch (error) {
+++++      // コンテキスト長エラーの場合は特別な処理
+++++      if (judgeErrorIsContentLengthError(error)) {
+++++        return {
+++++          status: 'success' as stepStatus,
+++++          chunkIndex: inputData.chunkIndex,
+++++          finishReason: 'content_length' as const,
+++++        };
+++++      }
+++++
+++++      logger.error(error, 'チャンク調査に失敗しました');
+++++      const normalizedError = normalizeUnknownError(error);
+++++      return bail({
+++++        status: 'failed' as stepStatus,
+++++        errorMessage: normalizedError.message,
+++++        finishReason: 'error' as const,
+++++      });
+++++    }
+++++  },
+++++});
++++diff --git a/src/mastra/workflows/sourceReview/executeReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/index.ts
++++index 0972e2670..67e557283 100644
++++--- a/src/mastra/workflows/sourceReview/executeReview/index.ts
+++++++ b/src/mastra/workflows/sourceReview/executeReview/index.ts
++++@@ -9,6 +9,7 @@ import { classifyChecklistsByCategoryStep } from './classifyChecklistStep';
++++ import { smallDocumentReviewExecutionStep } from './smallDocumentReviewStep';
++++ import { largeDocumentReviewWorkflow } from './largeDocumentReview';
++++ import { extractedDocumentSchema, uploadedFileSchema } from './schema';
+++++import { getReviewRepository } from '@/adapter/db';
++++ 
++++ const logger = getMainLogger();
++++ 
++++@@ -54,6 +55,7 @@ export const executeReviewWorkflowInputSchema = z.object({
++++ export const executeReviewWorkflowOutputSchema = baseStepOutputSchema;
++++ 
++++ export const documentReviewExecutionInputSchema = z.object({
+++++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
++++   additionalInstructions: z
++++     .string()
++++     .optional()
++++@@ -143,8 +145,46 @@ export const executeReviewWorkflow = createWorkflow({
++++       typeof executeReviewWorkflowInputSchema
++++     >;
++++ 
+++++    // 既存のレビュー結果を全て削除
+++++    const reviewRepository = getReviewRepository();
+++++    await reviewRepository.deleteAllReviewResults(initData.reviewHistoryId);
+++++
+++++    // documentModeを保存
+++++    await reviewRepository.updateReviewHistoryDocumentMode(
+++++      initData.reviewHistoryId,
+++++      initData.documentMode,
+++++    );
+++++
+++++    // ドキュメントキャッシュを保存
+++++    for (const document of textExtractionResult.extractedDocuments || []) {
+++++      if (!document) continue;
+++++      const savedCache = await reviewRepository.createReviewDocumentCache({
+++++        reviewHistoryId: initData.reviewHistoryId,
+++++        documentId: document.id || '',
+++++        fileName: document.name || '',
+++++        processMode: document.processMode || 'text',
+++++        textContent: document.textContent,
+++++        imageData: document.imageData,
+++++      });
+++++      // キャッシュIDを付与
+++++      document.cacheId = savedCache.id;
+++++    }
+++++
+++++    // レビュー対象の統合ドキュメント名を保存
+++++    const targetDocumentName = (textExtractionResult.extractedDocuments || [])
+++++      .map((doc) => doc?.name || '')
+++++      .filter((name) => name)
+++++      .join('/');
+++++    if (targetDocumentName) {
+++++      await reviewRepository.updateReviewHistoryTargetDocumentName(
+++++        initData.reviewHistoryId,
+++++        targetDocumentName,
+++++      );
+++++    }
+++++
++++     return classifyChecklistsResult.categories!.map((category) => {
++++       return {
+++++        reviewHistoryId: initData.reviewHistoryId,
++++         documents: textExtractionResult.extractedDocuments!,
++++         checklists: category.checklists,
++++         additionalInstructions: initData.additionalInstructions,
+++ diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+++-index 60120af8d..cafb8793c 100644
++++index cafb8793c..98e7dc709 100644
+++ --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+++ +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+++-@@ -198,9 +198,13 @@ Please provide a consolidated review that synthesizes all individual document re
+++-           const idsHash = createHash('md5')
+++-             .update(combinedFileIds)
+++-             .digest('hex');
+++--          const combinedFileNames = documentsWithReviewResults
+++--            .map((f) => f.name)
+++--            .join('/');
+++-+          const combinedFileNames = [
+++-+            ...new Set(
+++-+              documentsWithReviewResults.map(
+++-+                (f) => f.originalName || f.name,
+++-+              ),
+++-+            ),
+++-+          ].join('/');
++++@@ -187,32 +187,16 @@ Please provide a consolidated review that synthesizes all individual document re
++++           });
++++         }
+++  
++++-        // 統合レビュー結果をDBに保存（複数ファイルの情報を統合）
+++++        // 統合レビュー結果をDBに保存
++++         if (
++++           consolidatedResult.object &&
++++           Array.isArray(consolidatedResult.object)
++++         ) {
++++-          const combinedFileIds = documentsWithReviewResults
++++-            .map((f) => f.id)
++++-            .join('/');
++++-          const idsHash = createHash('md5')
++++-            .update(combinedFileIds)
++++-            .digest('hex');
++++-          const combinedFileNames = [
++++-            ...new Set(
++++-              documentsWithReviewResults.map(
++++-                (f) => f.originalName || f.name,
++++-              ),
++++-            ),
++++-          ].join('/');
++++-
+++            await reviewRepository.upsertReviewResult(
+++              consolidatedResult.object.map((result) => ({
++++               reviewChecklistId: result.checklistId,
++++               evaluation: result.evaluation as ReviewEvaluation,
++++               comment: result.comment,
++++-              fileId: idsHash,
++++-              fileName: combinedFileNames,
++++             })),
++++           );
++++         }
+++ diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+++-index 3e9bea206..c6f8371b8 100644
++++index c6f8371b8..642d295ca 100644
+++ --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+++ +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+++-@@ -108,7 +108,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++-           }
+++-           return {
+++-             originalDocument: initData.originalDocument,
+++--            reviewInput: [],
+++-+            reviewInput: initData.reviewInput,
+++-             retryCount: nextRetryCount,
+++-             status: isFailed
+++-               ? ('failed' as stepStatus)
+++-@@ -124,7 +124,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++-         if (initData.retryCount >= 5) {
+++-           return {
+++-             originalDocument: initData.originalDocument,
+++--            reviewInput: [],
+++-+            reviewInput: initData.reviewInput,
+++-             retryCount: nextRetryCount,
+++-             status: 'failed' as stepStatus,
+++-             errorMessage:
+++-@@ -155,6 +155,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++-                 ...initData.originalDocument,
+++-                 id: `${initData.originalDocument.id}_part${index + 1}`,
++++@@ -157,6 +157,8 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
+++-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++++                 originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+++                  textContent: chunk,
+++++                totalChunks: splitCount,
+++++                chunkIndex: index,
+++                },
+++              })),
+++-@@ -181,6 +182,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++-                 ...initData.originalDocument,
+++-                 id: `${initData.originalDocument.id}_part${index + 1}`,
++++             retryCount: nextRetryCount,
++++@@ -184,6 +186,8 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
+++-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++++                 originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+++                  imageData: chunk,
+++++                totalChunks: splitCount,
+++++                chunkIndex: index,
+++                },
+++              })),
+++-@@ -227,6 +229,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
++++             retryCount: nextRetryCount,
++++@@ -251,9 +255,12 @@ export const largeDocumentReviewWorkflow = createWorkflow({
++++     return inputData.documents.map(
++++       (document) =>
++++         ({
+++++          reviewHistoryId: inputData.reviewHistoryId,
++++           document: {
++++             ...document,
++++             originalName: document.name, // 分割された場合に元の名前を保持するため
+++++            totalChunks: 1,
+++++            chunkIndex: 0,
++++           },
++++           checklists: inputData.checklists,
++++           additionalInstructions: inputData.additionalInstructions,
++++diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
++++index 4416735c4..f8602fc3d 100644
++++--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+++++++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
++++@@ -15,13 +15,17 @@ import { getMainLogger } from '@/main/lib/logger';
++++ import { createCombinedMessageFromExtractedDocument } from '../../lib';
++++ import { getChecklistsErrorMessage } from '../lib';
++++ import { extractedDocumentSchema } from '../schema';
+++++import { getReviewRepository } from '@/adapter/db';
++++ 
++++ const logger = getMainLogger();
++++ 
++++ // 個別ドキュメントレビューステップの入力スキーマ
++++ export const individualDocumentReviewStepInputSchema = z.object({
+++++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
++++   document: extractedDocumentSchema.extend({
++++     originalName: z.string(),
+++++    totalChunks: z.number().optional(), // ドキュメント分割総数
+++++    chunkIndex: z.number().optional(), // 何番目のチャンクか（0から始まる）
++++   }),
++++   // チェックリスト
++++   checklists: z.array(
++++@@ -189,6 +193,20 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
++++       }
++++ 
++++       // 全てのレビューが成功した場合
+++++
+++++      // 個別レビュー結果を保存
+++++      const reviewRepository = getReviewRepository();
+++++      for (const result of allReviewResults) {
+++++        await reviewRepository.createReviewLargedocumentResultCache({
+++++          reviewDocumentCacheId: document.cacheId!,
+++++          reviewChecklistId: result.checklistId,
+++++          comment: result.comment,
+++++          totalChunks: document.totalChunks ?? 1,
+++++          chunkIndex: document.chunkIndex ?? 0,
+++++          individualFileName: document.name,
+++++        });
+++++      }
+++++
++++       return {
++++         status: 'success' as stepStatus,
++++         documentId: document.id,
++++diff --git a/src/mastra/workflows/sourceReview/executeReview/schema.ts b/src/mastra/workflows/sourceReview/executeReview/schema.ts
++++index 18b138b5d..e663cbe5a 100644
++++--- a/src/mastra/workflows/sourceReview/executeReview/schema.ts
+++++++ b/src/mastra/workflows/sourceReview/executeReview/schema.ts
++++@@ -12,6 +12,7 @@ export const uploadedFileSchema = z.object({
++++ 
++++ export const extractedDocumentSchema = z.object({
++++   id: z.string(),
+++++  cacheId: z.number().optional(),
++++   name: z.string(),
++++   path: z.string(),
++++   type: z.string(),
++++diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
++++index 33bc9e881..17cbf273e 100644
++++--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++++++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
++++@@ -133,20 +133,13 @@ Please review the document against the above checklist items.`;
++++             messageParams: { detail: reason },
++++           });
++++         }
++++-        // レビュー結果をDBに保存（複数ファイルの情報を統合）
+++++        // レビュー結果をDBに保存
++++         if (reviewResult.object && Array.isArray(reviewResult.object)) {
++++-          const combinedFileIds = documents.map((f) => f.id).join('/');
++++-          const idsHash = createHash('md5')
++++-            .update(combinedFileIds)
++++-            .digest('hex');
++++-          const combinedFileNames = documents.map((f) => f.name).join('/');
++++           await reviewRepository.upsertReviewResult(
++++             reviewResult.object.map((result) => ({
++++               reviewChecklistId: result.checklistId,
++++               evaluation: result.evaluation as ReviewEvaluation,
++++               comment: result.comment,
++++-              fileId: idsHash,
++++-              fileName: combinedFileNames,
++++             })),
++++           );
++++         }
++++diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
++++index 9af029444..aec3ea97f 100644
++++--- a/src/messages/ja/template.ts
+++++++ b/src/messages/ja/template.ts
++++@@ -33,4 +33,5 @@ export const template = {
++++   REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR: `CSVファイルからのチェックリスト抽出中に予期せぬエラーが発生しました`,
++++   AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
++++   AI_MESSAGE_TOO_LARGE: `AIへの入力データが大きすぎます。入力データを減らしてください。`,
+++++  REVIEW_DOCUMENT_CACHE_NOT_FOUND: `レビュー時にアップロードしたドキュメント情報が失われています。レビューを再実行してください`,
++++ } as const;
++++diff --git a/src/renderer/components/chat/MessageItem.tsx b/src/renderer/components/chat/MessageItem.tsx
++++index 4a8877c44..5345514e0 100644
++++--- a/src/renderer/components/chat/MessageItem.tsx
+++++++ b/src/renderer/components/chat/MessageItem.tsx
++++@@ -313,7 +313,8 @@ const renderPart = (
++++         <Accordion sx={{ width: '100%' }} key={ti.toolCallId}>
++++           <AccordionSummary expandIcon={<ExpandMoreIcon />}>
++++             <Box sx={{ display: 'flex', alignItems: 'center' }}>
++++-              {ti.toolName === 'documentQueryTool' ? (
+++++              {ti.toolName === 'documentQueryTool' ||
+++++              ti.toolCallId.startsWith('reviewChatResearchDocument-') ? (
++++                 <SearchIcon sx={{ mr: 1 }} />
++++               ) : (
++++                 <SmartToyOutlinedIcon sx={{ mr: 1 }} />
++++@@ -387,6 +388,7 @@ interface MessageProps {
++++   onEditStart: (messageId: string) => void;
++++   onEditContentChange: (content: string) => void;
++++   onEditCancel: () => void;
+++++  disableEdit?: boolean;
++++ }
++++ 
++++ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++++@@ -400,6 +402,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++++       onEditStart,
++++       onEditCancel,
++++       onEditContentChange,
+++++      disableEdit = false,
++++     },
++++     ref,
++++   ) => {
++++@@ -420,7 +423,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++++               maxWidth: isUser && !isEditing ? '70%' : '100%',
++++               width: isUser && !isEditing ? undefined : '100%',
++++               textAlign: 'left',
++++-              '&:hover .editBtn': { opacity: 1 },
+++++              ...(!disableEdit && { '&:hover .editBtn': { opacity: 1 } }),
++++             }}
++++           >
++++             <Paper
++++@@ -432,28 +435,31 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++++                 position: 'relative',
++++               }}
++++             >
++++-              {isUser && !message.experimental_attachments && !isEditing && (
++++-                <IconButton
++++-                  className="editBtn"
++++-                  size="small"
++++-                  onClick={() => {
++++-                    onEditStart?.(message.id);
++++-                    onEditContentChange(message.content ?? '');
++++-                  }}
++++-                  sx={{
++++-                    position: 'absolute',
++++-                    right: -36,
++++-                    top: '50%',
++++-                    transform: 'translateY(-50%)',
++++-                    opacity: 0,
++++-                    transition: 'opacity 0.2s',
++++-                    bgcolor: 'background.paper',
++++-                  }}
++++-                  data-testid={`edit-message-button-${message.id}`}
++++-                >
++++-                  <EditIcon fontSize="small" />
++++-                </IconButton>
++++-              )}
+++++              {isUser &&
+++++                !message.experimental_attachments &&
+++++                !isEditing &&
+++++                !disableEdit && (
+++++                  <IconButton
+++++                    className="editBtn"
+++++                    size="small"
+++++                    onClick={() => {
+++++                      onEditStart?.(message.id);
+++++                      onEditContentChange(message.content ?? '');
+++++                    }}
+++++                    sx={{
+++++                      position: 'absolute',
+++++                      right: -36,
+++++                      top: '50%',
+++++                      transform: 'translateY(-50%)',
+++++                      opacity: 0,
+++++                      transition: 'opacity 0.2s',
+++++                      bgcolor: 'background.paper',
+++++                    }}
+++++                    data-testid={`edit-message-button-${message.id}`}
+++++                  >
+++++                    <EditIcon fontSize="small" />
+++++                  </IconButton>
+++++                )}
++++               {/* eslint-disable-next-line */}
++++               {isEditing && !message.experimental_attachments && isUser ? (
++++                 <Box sx={{ p: 1, width: '100%' }}>
++++diff --git a/src/renderer/components/chat/MessageList.tsx b/src/renderer/components/chat/MessageList.tsx
++++index e8325677a..321206563 100644
++++--- a/src/renderer/components/chat/MessageList.tsx
+++++++ b/src/renderer/components/chat/MessageList.tsx
++++@@ -14,6 +14,8 @@ interface MessageListProps {
++++   onEditSubmit: () => void;
++++   onEditContentChange: (ontent: string) => void;
++++   onEditCancel: () => void;
+++++  loadingMessage?: string;
+++++  disableEdit?: boolean;
++++ }
++++ 
++++ const MessageList: React.FC<MessageListProps> = ({
++++@@ -27,6 +29,8 @@ const MessageList: React.FC<MessageListProps> = ({
++++   onEditSubmit,
++++   onEditContentChange,
++++   onEditCancel,
+++++  loadingMessage = 'AIKATA作業中…',
+++++  disableEdit = false,
++++ }) => {
++++   const bottomRef = useRef<HTMLDivElement>(null);
++++ 
++++@@ -64,12 +68,13 @@ const MessageList: React.FC<MessageListProps> = ({
++++               onEditSubmit={onEditSubmit}
++++               onEditContentChange={onEditContentChange}
++++               onEditCancel={onEditCancel}
+++++              disableEdit={disableEdit}
++++             />
++++           </Box>
+++          );
+++-         return {
+++-           ...input.document,
+++-+          originalName: input.document.originalName || input.document.name,
+++-           reviewResults: reviewResult || [],
+++-         };
+++-       }),
++++       })}
++++ 
++++-      {status === 'streaming' && (
+++++      {(status === 'streaming' || status === 'submitted') && (
++++         <Box
++++           sx={{
++++             display: 'flex',
++++@@ -80,7 +85,7 @@ const MessageList: React.FC<MessageListProps> = ({
++++         >
++++           <CircularProgress size={24} />
++++           <Box component="span" sx={{ ml: 1 }}>
++++-            AIKATA作業中…
+++++            {loadingMessage}
++++           </Box>
++++         </Box>
++++       )}
++++diff --git a/src/renderer/components/review/ChecklistMentionInput.tsx b/src/renderer/components/review/ChecklistMentionInput.tsx
++++new file mode 100644
++++index 000000000..978c8d7be
++++--- /dev/null
+++++++ b/src/renderer/components/review/ChecklistMentionInput.tsx
++++@@ -0,0 +1,364 @@
+++++import React, { useState, useCallback, useMemo, useRef } from 'react';
+++++import {
+++++  Box,
+++++  IconButton,
+++++  InputAdornment,
+++++  Paper,
+++++  TextField,
+++++  Chip,
+++++  Popover,
+++++  List,
+++++  ListItem,
+++++  ListItemButton,
+++++  ListItemText,
+++++} from '@mui/material';
+++++import {
+++++  Send as SendIcon,
+++++  StopCircleOutlined as StopIcon,
+++++} from '@mui/icons-material';
+++++import { useAlertStore } from '@/renderer/stores/alertStore';
+++++
+++++/* ---------- 型定義 ---------- */
+++++
+++++export interface ChecklistOption {
+++++  id: number;
+++++  content: string;
+++++}
+++++
+++++interface ChecklistMentionInputProps {
+++++  handleSubmit: (e: React.FormEvent) => void;
+++++  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
+++++  message: string;
+++++  disabled?: boolean;
+++++  placeholder?: string;
+++++  isStreaming?: boolean;
+++++  onStop?: () => void;
+++++  checklists: ChecklistOption[];
+++++  selectedChecklistIds: number[];
+++++  onChecklistSelect: (ids: number[]) => void;
+++++}
+++++
+++++const ChecklistMentionInput: React.FC<ChecklistMentionInputProps> = ({
+++++  handleSubmit,
+++++  handleInputChange,
+++++  message,
+++++  disabled = false,
+++++  placeholder = 'メッセージを入力...',
+++++  isStreaming = false,
+++++  onStop,
+++++  checklists,
+++++  selectedChecklistIds,
+++++  onChecklistSelect,
+++++}) => {
+++++  const [isComposing, setIsComposing] = useState(false);
+++++  const [showMentionMenu, setShowMentionMenu] = useState(false);
+++++  const [mentionSearchText, setMentionSearchText] = useState('');
+++++  const inputRef = useRef<HTMLDivElement>(null);
+++++  const addAlert = useAlertStore((state) => state.addAlert);
+++++
+++++  /* ---------- チェックリストオプション ---------- */
+++++  const checklistOptions = useMemo(() => {
+++++    return checklists.map((cl) => ({ id: cl.id, content: cl.content }));
+++++  }, [checklists]);
+++++
+++++  /* ---------- フィルタリングされたチェックリストオプション ---------- */
+++++  const filteredOptions = useMemo(() => {
+++++    if (!mentionSearchText) return checklistOptions;
+++++    const lowerSearch = mentionSearchText.toLowerCase();
+++++    return checklistOptions.filter((option) =>
+++++      option.content.toLowerCase().includes(lowerSearch),
+++++    );
+++++  }, [checklistOptions, mentionSearchText]);
+++++
+++++  /* ---------- @メンション検出 ---------- */
+++++  const detectMention = useCallback((text: string) => {
+++++    const atIndex = text.lastIndexOf('@');
+++++    if (atIndex === -1) return null;
+++++
+++++    // @が行の先頭にあるかチェック
+++++    if (atIndex > 0) {
+++++      const beforeAt = text[atIndex - 1];
+++++      // @の直前が改行でない場合はnullを返す
+++++      if (beforeAt !== '\n') return null;
+++++    }
+++++
+++++    // @以降の文字列を取得
+++++    const afterAt = text.slice(atIndex + 1);
+++++    // 空白や改行があれば@メンション終了とみなす
+++++    if (/\s/.test(afterAt)) return null;
+++++
+++++    return { atIndex, searchText: afterAt };
+++++  }, []);
+++++
+++++  /* ---------- 入力変更ハンドラ ---------- */
+++++  const handleChange = useCallback(
+++++    (e: React.ChangeEvent<HTMLInputElement>) => {
+++++      const newValue = e.target.value;
+++++      handleInputChange(e);
+++++
+++++      // @メンション検出
+++++      const mention = detectMention(newValue);
+++++      if (mention) {
+++++        setShowMentionMenu(true);
+++++        setMentionSearchText(mention.searchText);
+++++      } else {
+++++        setShowMentionMenu(false);
+++++        setMentionSearchText('');
+++++      }
+++++    },
+++++    [handleInputChange, detectMention],
+++++  );
+++++
+++++  /* ---------- チェックリスト選択ハンドラ ---------- */
+++++  const handleChecklistSelect = useCallback(
+++++    (checklist: ChecklistOption | null) => {
+++++      if (!checklist) return;
+++++
+++++      const mention = detectMention(message);
+++++      if (!mention) return;
+++++
+++++      // @検索文字列を削除
+++++      const beforeAt = message.slice(0, mention.atIndex);
+++++      const afterMention = message.slice(
+++++        mention.atIndex + 1 + mention.searchText.length,
+++++      );
+++++      const newMessage = beforeAt + afterMention;
+++++
+++++      // 入力値を更新
+++++      const syntheticEvent = {
+++++        target: { value: newMessage },
+++++      } as React.ChangeEvent<HTMLInputElement>;
+++++      handleInputChange(syntheticEvent);
+++++
+++++      // 選択リストに追加（重複チェック）
+++++      if (!selectedChecklistIds.includes(checklist.id)) {
+++++        onChecklistSelect([...selectedChecklistIds, checklist.id]);
+++++      }
+++++
+++++      // メニューを閉じる
+++++      setShowMentionMenu(false);
+++++      setMentionSearchText('');
+++++    },
+++++    [
+++++      message,
+++++      detectMention,
+++++      handleInputChange,
+++++      selectedChecklistIds,
+++++      onChecklistSelect,
+++++    ],
+++++  );
+++++
+++++  /* ---------- 送信ハンドラ（バリデーション付き） ---------- */
+++++  const handleSubmitWithValidation = useCallback(
+++++    (e: React.FormEvent) => {
+++++      e.preventDefault();
+++++
+++++      // チェックリストが一つも選択されていない場合は警告
+++++      if (selectedChecklistIds.length === 0) {
+++++        addAlert({
+++++          message: '@でチェックリストを一つ以上選択してください',
+++++          severity: 'warning',
+++++        });
+++++        return;
+++++      }
+++++      handleSubmit(e);
+++++    },
+++++    [selectedChecklistIds, handleSubmit, addAlert],
+++++  );
+++++
+++++  /* ---------- Enter キー送信（Shift+Enter で改行） ---------- */
+++++  const handleKeyDown = (e: React.KeyboardEvent) => {
+++++    if (e.key === 'Enter' && !isComposing) {
+++++      // @メンションメニューが表示されている場合は完全一致をチェック
+++++      if (showMentionMenu && mentionSearchText) {
+++++        const exactMatch = filteredOptions.find(
+++++          (option) =>
+++++            option.content.toLowerCase() === mentionSearchText.toLowerCase(),
+++++        );
+++++        if (exactMatch) {
+++++          // 完全一致した場合は自動選択
+++++          e.preventDefault();
+++++          handleChecklistSelect(exactMatch);
+++++          return;
+++++        }
+++++      }
+++++
+++++      // Shift+Enterの場合は改行を許可（preventDefaultしない）
+++++      if (!e.shiftKey) {
+++++        e.preventDefault();
+++++        handleSubmitWithValidation(e);
+++++      }
+++++    }
+++++  };
+++++
+++++  /* ---------- IME 制御 ---------- */
+++++  const handleCompositionStart = () => setIsComposing(true);
+++++  const handleCompositionEnd = () => setIsComposing(false);
+++++
+++++  /* ============================================================= */
+++++
+++++  return (
+++++    <Box sx={{ p: 2, width: '100%', mx: 'auto' }}>
+++++      {/* 選択中のチェックリスト表示 */}
+++++      {selectedChecklistIds.length > 0 && (
+++++        <Box
+++++          sx={{
+++++            mb: 1,
+++++            display: 'flex',
+++++            flexDirection: 'column',
+++++            alignItems: 'flex-start',
+++++            gap: 0.5,
+++++            overflow: 'auto',
+++++            maxHeight: 100,
+++++            pb: 0.5,
+++++          }}
+++++        >
+++++          {selectedChecklistIds.map((id) => {
+++++            const checklist = checklists.find((cl) => cl.id === id);
+++++            if (!checklist) return null;
+++++            return (
+++++              <Chip
+++++                key={id}
+++++                label={checklist.content}
+++++                size="small"
+++++                color="primary"
+++++                variant="outlined"
+++++                onDelete={() => {
+++++                  onChecklistSelect(
+++++                    selectedChecklistIds.filter((cid) => cid !== id),
+++++                  );
+++++                }}
+++++              />
+++++            );
+++++          })}
+++++        </Box>
+++++      )}
+++++
+++++      {/* 入力欄 ----------------------------------------------------------- */}
+++++      <Paper
+++++        component="form"
+++++        onSubmit={handleSubmitWithValidation}
+++++        elevation={3}
+++++        sx={{
+++++          p: '2px 4px',
+++++          display: 'flex',
+++++          alignItems: 'center',
+++++          borderRadius: 2,
+++++          position: 'relative',
+++++        }}
+++++      >
+++++        {/* メインのテキストフィールド */}
+++++        <TextField
+++++          ref={inputRef}
+++++          fullWidth
+++++          multiline
+++++          minRows={1}
+++++          maxRows={6}
+++++          placeholder={placeholder}
+++++          variant="outlined"
+++++          value={message}
+++++          onChange={handleChange}
+++++          onKeyDown={handleKeyDown}
+++++          onCompositionStart={handleCompositionStart}
+++++          onCompositionEnd={handleCompositionEnd}
+++++          disabled={disabled}
+++++          slotProps={{
+++++            input: {
+++++              sx: {
+++++                p: 1,
+++++                '& fieldset': { border: 'none' },
+++++              },
+++++              endAdornment: (
+++++                <InputAdornment position="end">
+++++                  {isStreaming ? (
+++++                    <IconButton
+++++                      color="primary"
+++++                      onClick={onStop}
+++++                      data-testid="review-chat-stop-button"
+++++                    >
+++++                      <StopIcon />
+++++                    </IconButton>
+++++                  ) : (
+++++                    <IconButton
+++++                      color="primary"
+++++                      type="submit"
+++++                      disabled={disabled || !message.trim()}
+++++                      data-testid="review-chat-send-button"
+++++                    >
+++++                      <SendIcon />
+++++                    </IconButton>
+++++                  )}
+++++                </InputAdornment>
+++++              ),
+++++            },
+++++          }}
+++++        />
+++++
+++++        {/* @メンション選択メニュー */}
+++++        <Popover
+++++          open={showMentionMenu}
+++++          anchorEl={inputRef.current}
+++++          onClose={() => {
+++++            setShowMentionMenu(false);
+++++            setMentionSearchText('');
+++++          }}
+++++          anchorOrigin={{
+++++            vertical: 'top',
+++++            horizontal: 'left',
+++++          }}
+++++          transformOrigin={{
+++++            vertical: 'bottom',
+++++            horizontal: 'left',
+++++          }}
+++++          disableAutoFocus
+++++          disableEnforceFocus
+++++          disableRestoreFocus
+++++          slotProps={{
+++++            paper: {
+++++              sx: {
+++++                maxHeight: 200,
+++++                width: inputRef.current?.offsetWidth || 300,
+++++                overflow: 'auto',
+++++              },
+++++            },
+++++          }}
+++++        >
+++++          <List dense>
+++++            {filteredOptions.length > 0 ? (
+++++              filteredOptions.map((option) => (
+++++                <ListItem key={option.id} disablePadding>
+++++                  <ListItemButton
+++++                    onClick={() => handleChecklistSelect(option)}
+++++                    selected={selectedChecklistIds.includes(option.id)}
+++++                  >
+++++                    <ListItemText
+++++                      primary={`@${option.content}`}
+++++                      primaryTypographyProps={{
+++++                        sx: {
+++++                          fontWeight:
+++++                            option.content.toLowerCase() ===
+++++                            mentionSearchText.toLowerCase()
+++++                              ? 'bold'
+++++                              : 'normal',
+++++                        },
+++++                      }}
+++++                    />
+++++                  </ListItemButton>
+++++                </ListItem>
+++++              ))
+++++            ) : (
+++++              <ListItem>
+++++                <ListItemText
+++++                  primary="該当するチェックリストがありません"
+++++                  sx={{ color: 'text.secondary', fontStyle: 'italic' }}
+++++                />
+++++              </ListItem>
+++++            )}
+++++          </List>
+++++        </Popover>
+++++      </Paper>
+++++    </Box>
+++++  );
+++++};
+++++
+++++export default ChecklistMentionInput;
++++diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
++++index 2d2322987..927817d83 100644
++++--- a/src/renderer/components/review/ReviewArea.tsx
+++++++ b/src/renderer/components/review/ReviewArea.tsx
++++@@ -6,11 +6,11 @@ import {
++++   Stack,
++++   Typography,
++++   LinearProgress,
++++-  Alert,
++++ } from '@mui/material';
++++ import CheckBoxIcon from '@mui/icons-material/CheckBox';
++++ import RateReviewIcon from '@mui/icons-material/RateReview';
++++ import StopIcon from '@mui/icons-material/Stop';
+++++import ChatIcon from '@mui/icons-material/Chat';
++++ import {
++++   ReviewChecklistEdit,
++++   ReviewChecklistResult,
++++@@ -25,6 +25,7 @@ import {
++++ import { ReviewAreaProps } from './types';
++++ import ReviewChecklistSection from './ReviewChecklistSection';
++++ import ReviewSourceModal from './ReviewSourceModal';
+++++import ReviewChatPanel from './ReviewChatPanel';
++++ import { ReviewApi } from '../../service/reviewApi';
++++ import { useAlertStore } from '../../stores/alertStore';
++++ import { getSafeErrorMessage } from '../../lib/error';
++++@@ -47,6 +48,9 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++++   const [checklistResults, setChecklistResults] = useState<
++++     ReviewChecklistResult[]
++++   >([]);
+++++  const [targetDocumentName, setTargetDocumentName] = useState<
+++++    string | null
+++++  >(null);
++++   // チェックリスト更新処理中であるかどうか
++++   const [isSaving, setIsSaving] = useState(false);
++++   const [isExtracting, setIsExtracting] = useState(false);
++++@@ -58,6 +62,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++++   const [evaluationSettings, setEvaluationSettings] =
++++     useState<CustomEvaluationSettings>(defaultEvaluationSettings);
++++ 
+++++  // チャット関連の状態管理
+++++  const [chatPanelOpen, setChatPanelOpen] = useState(false);
+++++  const [chatPanelWidth, setChatPanelWidth] = useState(500);
+++++  const [isResizing, setIsResizing] = useState(false);
+++++
++++   const addAlert = useAlertStore((state) => state.addAlert);
++++ 
++++   // イベント購読の解除関数を管理
++++@@ -73,6 +82,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++++       { throwError: true, showAlert: true },
++++     );
++++     setChecklistResults(result?.checklistResults || []);
+++++    setTargetDocumentName(result?.targetDocumentName || null);
++++   }, [selectedReviewHistoryId]);
++++ 
++++   // チェックリスト抽出完了の共通処理ハンドラー
++++@@ -526,6 +536,38 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++++     setIsSaving(false);
++++   };
++++ 
+++++  // リサイズハンドラ
+++++  const handleMouseDown = (e: React.MouseEvent) => {
+++++    setIsResizing(true);
+++++    e.preventDefault();
+++++  };
+++++
+++++  useEffect(() => {
+++++    if (!isResizing) return;
+++++
+++++    const handleMouseMove = (e: MouseEvent) => {
+++++      // 画面右端からのマウス位置を計算
+++++      const newWidth = window.innerWidth - e.clientX;
+++++      // 最小幅350px、最大幅は画面の65%まで
+++++      const minWidth = 350;
+++++      const maxWidth = window.innerWidth * 0.65;
+++++      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
+++++      setChatPanelWidth(clampedWidth);
+++++    };
+++++
+++++    const handleMouseUp = () => {
+++++      setIsResizing(false);
+++++    };
+++++
+++++    document.addEventListener('mousemove', handleMouseMove);
+++++    document.addEventListener('mouseup', handleMouseUp);
+++++
+++++    return () => {
+++++      document.removeEventListener('mousemove', handleMouseMove);
+++++      document.removeEventListener('mouseup', handleMouseUp);
+++++    };
+++++  }, [isResizing]);
+++++
++++   return (
++++     <Box
++++       sx={{
++++@@ -548,15 +590,10 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++++           {(isExtracting || isReviewing) && (
++++             <Box sx={{ mb: 2 }}>
++++               <LinearProgress />
++++-              {/* <Alert severity="info" sx={{ mt: 1 }}>
++++-                {isExtracting
++++-                  ? 'チェックリスト抽出実行中...'
++++-                  : 'レビュー実行中...'}
++++-              </Alert> */}
++++             </Box>
++++           )}
++++ 
++++-          {/* ヘッダー部分 */}
+++++          {/* ヘッダー部分 - 主要アクションボタン */}
++++           <Stack
++++             direction="row"
++++             justifyContent="space-between"
++++@@ -600,25 +637,85 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++++               >
++++                 {isReviewing ? 'キャンセル' : 'レビュー実行'}
++++               </Button>
+++++              <Button
+++++                variant="contained"
+++++                color="primary"
+++++                startIcon={<ChatIcon />}
+++++                onClick={() => setChatPanelOpen(true)}
+++++                disabled={
+++++                  !selectedReviewHistoryId ||
+++++                  isExtracting ||
+++++                  isReviewing ||
+++++                  checklistResults.filter((cl) => cl.sourceEvaluation?.comment)
+++++                    .length === 0
+++++                }
+++++              >
+++++                質問
+++++              </Button>
++++             </Stack>
++++           </Stack>
++++ 
++++-          {/* メインコンテンツ */}
++++-          <Paper
+++++          {/* メインコンテンツ - Split View */}
+++++          <Box
++++             sx={{
++++-              p: 2,
++++-              flex: 1,
++++               display: 'flex',
++++-              flexDirection: 'column',
+++++              flexDirection: 'row',
+++++              flex: 1,
++++               minHeight: 0,
+++++              gap: 0,
++++             }}
++++           >
++++-            <ReviewChecklistSection
++++-              checklistResults={checklistResults}
++++-              isLoading={isExtracting || isReviewing}
++++-              onSave={handleSaveChecklist}
++++-            />
++++-          </Paper>
+++++            {/* レビュー結果エリア */}
+++++            <Paper
+++++              sx={{
+++++                p: 2,
+++++                flex: 1,
+++++                display: 'flex',
+++++                flexDirection: 'column',
+++++                minHeight: 0,
+++++                minWidth: chatPanelOpen ? 400 : 0,
+++++                overflow: 'hidden',
+++++              }}
+++++            >
+++++              <ReviewChecklistSection
+++++                checklistResults={checklistResults}
+++++                isLoading={isExtracting || isReviewing}
+++++                onSave={handleSaveChecklist}
+++++                targetDocumentName={targetDocumentName}
+++++              />
+++++            </Paper>
+++++
+++++            {/* リサイズハンドル */}
+++++            {chatPanelOpen && (
+++++              <Box
+++++                onMouseDown={handleMouseDown}
+++++                sx={{
+++++                  width: '6px',
+++++                  cursor: 'col-resize',
+++++                  bgcolor: 'divider',
+++++                  transition: 'background-color 0.2s',
+++++                  flexShrink: 0,
+++++                  userSelect: 'none',
+++++                }}
+++++              />
+++++            )}
+++++
+++++            {/* チャットパネル */}
+++++            {selectedReviewHistoryId && (
+++++              <ReviewChatPanel
+++++                open={chatPanelOpen}
+++++                onClose={() => setChatPanelOpen(false)}
+++++                reviewHistoryId={selectedReviewHistoryId}
+++++                checklists={checklistResults
+++++                  .filter((cl) => cl.sourceEvaluation?.comment)
+++++                  .map((cl) => ({
+++++                    id: cl.id,
+++++                    content: cl.content,
+++++                  }))}
+++++                width={chatPanelWidth}
+++++              />
+++++            )}
+++++          </Box>
++++ 
++++           {/* モーダル */}
++++           <ReviewSourceModal
++++diff --git a/src/renderer/components/review/ReviewChatPanel.tsx b/src/renderer/components/review/ReviewChatPanel.tsx
++++new file mode 100644
++++index 000000000..525cfea7b
++++--- /dev/null
+++++++ b/src/renderer/components/review/ReviewChatPanel.tsx
++++@@ -0,0 +1,265 @@
+++++import React, { useState, useEffect, useCallback } from 'react';
+++++import { useChat } from '@ai-sdk/react';
+++++import { Box, Divider, IconButton } from '@mui/material';
+++++import CloseIcon from '@mui/icons-material/Close';
+++++import { v4 as uuid } from 'uuid';
+++++import { ChatMessage } from '@/types';
+++++import { IpcRequestPayload, IpcChannels } from '@/types/ipc';
+++++import { useAlertStore } from '@/renderer/stores/alertStore';
+++++import { getSafeErrorMessage } from '@/renderer/lib/error';
+++++import MessageList from '../chat/MessageList';
+++++import ChecklistMentionInput, {
+++++  ChecklistOption,
+++++} from './ChecklistMentionInput';
+++++import { ReviewChatApi } from '../../service/reviewChatApi';
+++++
+++++interface ReviewChatPanelProps {
+++++  open: boolean;
+++++  onClose: () => void;
+++++  reviewHistoryId: string;
+++++  checklists: ChecklistOption[];
+++++  width?: number;
+++++}
+++++
+++++// customFetch関数 - ChatArea.tsxを参考に実装
+++++const customFetch: typeof fetch = async (input, init) => {
+++++  if (typeof input === 'string' && input === '/api/review-chat') {
+++++    let unsubscribe: () => void;
+++++    const encoder = new TextEncoder();
+++++    const reviewChatApi = ReviewChatApi.getInstance();
+++++
+++++    const stream = new ReadableStream({
+++++      start(controller) {
+++++        unsubscribe = reviewChatApi.streamResponse({
+++++          onMessage(raw) {
+++++            controller.enqueue(encoder.encode(raw));
+++++          },
+++++          onDone() {
+++++            controller.close();
+++++          },
+++++          onError(err) {
+++++            controller.error(err);
+++++          },
+++++        });
+++++
+++++        const { reviewHistoryId, checklistIds, question } = JSON.parse(
+++++          init!.body as string,
+++++        ) as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
+++++
+++++        init?.signal?.addEventListener('abort', () => {
+++++          reviewChatApi.abortChat(reviewHistoryId, {
+++++            showAlert: false,
+++++            throwError: true,
+++++          });
+++++          unsubscribe();
+++++          controller.close();
+++++        });
+++++
+++++        reviewChatApi.sendMessage(reviewHistoryId, checklistIds, question, {
+++++          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
+++++          showAlert: false,
+++++          throwError: false,
+++++        });
+++++      },
+++++      cancel() {
+++++        unsubscribe();
+++++      },
+++++    });
+++++
+++++    return new Response(stream, {
+++++      headers: {
+++++        // SSE＋Data Stream Protocol ヘッダ
+++++        'Content-Type': 'text/event-stream; charset=utf-8',
+++++        'x-vercel-ai-data-stream': 'v1',
+++++      },
+++++    });
+++++  }
+++++
+++++  return fetch(input, init);
+++++};
+++++
+++++// プレースホルダーテキストを取得する関数
+++++const getPlaceholderText = (status: string): string => {
+++++  if (status === 'submitted') return 'メッセージ送信中…';
+++++  return '@でチェックリストを選択して質問してください';
+++++};
+++++
+++++const ReviewChatPanel: React.FC<ReviewChatPanelProps> = ({
+++++  open,
+++++  onClose,
+++++  reviewHistoryId,
+++++  checklists,
+++++  width = 500,
+++++}) => {
+++++  const [input, setInput] = useState<string>('');
+++++  const [selectedChecklistIds, setSelectedChecklistIds] = useState<number[]>(
+++++    [],
+++++  );
+++++  const addAlert = useAlertStore((state) => state.addAlert);
+++++
+++++  const { messages, setMessages, reload, status, error, stop } = useChat({
+++++    id: reviewHistoryId,
+++++    api: '/api/review-chat',
+++++    fetch: customFetch,
+++++    experimental_throttle: 75,
+++++    experimental_prepareRequestBody: (request) => {
+++++      // Ensure messages array is not empty and get the last message
+++++      const lastMessage =
+++++        request.messages.length > 0
+++++          ? request.messages[request.messages.length - 1]
+++++          : null;
+++++      if (!lastMessage) {
+++++        throw new Error('送信メッセージの取得に失敗しました');
+++++      }
+++++
+++++      // Return the structured body for API route
+++++      return {
+++++        reviewHistoryId,
+++++        checklistIds: selectedChecklistIds,
+++++        question: lastMessage.content,
+++++      } as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
+++++    },
+++++    onError(err) {
+++++      console.error('useChat error:', err);
+++++    },
+++++  });
+++++
+++++  // useChatのエラーをアラートとして表示
+++++  useEffect(() => {
+++++    if (error) {
+++++      addAlert({
+++++        message: getSafeErrorMessage(error),
+++++        severity: 'error',
+++++      });
+++++    }
+++++  }, [error, addAlert]);
+++++
+++++  // レビューID変更時にチャット内容を初期化
+++++  useEffect(() => {
+++++    setMessages([]);
+++++    setInput('');
+++++    setSelectedChecklistIds([]);
+++++  }, [reviewHistoryId, setMessages]);
+++++
+++++  /* ---------- メッセージ送信処理 ---------- */
+++++  const handleInputChange = useCallback(
+++++    (e: React.ChangeEvent<HTMLInputElement>) => {
+++++      setInput(e.target.value);
+++++    },
+++++    [],
+++++  );
+++++
+++++  const handleSubmit = useCallback(
+++++    async (e: React.FormEvent) => {
+++++      e.preventDefault();
+++++      if (!input.trim()) return;
+++++
+++++      // チェックリスト未選択の場合は警告
+++++      if (selectedChecklistIds.length === 0) {
+++++        addAlert({
+++++          message: '@でチェックリストを選択してください',
+++++          severity: 'warning',
+++++        });
+++++        return;
+++++      }
+++++
+++++      // 選択されたチェックリストの内容を取得してフォーマット
+++++      const selectedChecklistContents = selectedChecklistIds
+++++        .map((id) => {
+++++          const checklist = checklists.find((cl) => cl.id === id);
+++++          return checklist ? `@${checklist.content}` : null;
+++++        })
+++++        .filter((content): content is string => content !== null);
+++++
+++++      // チェックリスト部分 + 空行 + 本文の形式でメッセージを構築
+++++      const formattedContent =
+++++        selectedChecklistContents.length > 0
+++++          ? `${selectedChecklistContents.join('\n')}\n\n${input}`
+++++          : input;
+++++
+++++      const newMessage: ChatMessage = {
+++++        id: uuid(),
+++++        role: 'user',
+++++        content: formattedContent,
+++++        parts: [
+++++          {
+++++            type: 'text',
+++++            text: formattedContent,
+++++          },
+++++        ],
+++++      };
+++++
+++++      setInput('');
+++++      setMessages((prev) => [...prev, newMessage]);
+++++      reload();
+++++    },
+++++    [input, selectedChecklistIds, checklists, addAlert, setMessages, reload],
+++++  );
+++++
+++++  if (!open) return null;
+++++
+++++  return (
+++++    <Box
+++++      sx={{
+++++        width,
+++++        minWidth: 300,
+++++        height: '100%',
+++++        display: 'flex',
+++++        flexDirection: 'column',
+++++        borderLeft: 1,
+++++        borderColor: 'divider',
+++++        bgcolor: 'background.paper',
+++++        position: 'relative',
+++++      }}
+++++    >
+++++      {/* ヘッダー（閉じるボタン） */}
+++++      <Box
+++++        sx={{
+++++          display: 'flex',
+++++          justifyContent: 'flex-end',
+++++          p: 1,
+++++          borderBottom: 1,
+++++          borderColor: 'divider',
+++++        }}
+++++      >
+++++        <IconButton size="small" onClick={onClose}>
+++++          <CloseIcon />
+++++        </IconButton>
+++++      </Box>
+++++
+++++      {/* メッセージリスト */}
+++++      <MessageList
+++++        messages={messages}
+++++        loading={false}
+++++        status={status}
+++++        editContent=""
+++++        disabled={status === 'submitted' || status === 'streaming'}
+++++        editingMessageId=""
+++++        onEditStart={() => {}}
+++++        onEditContentChange={() => {}}
+++++        onEditSubmit={async () => {}}
+++++        onEditCancel={() => {}}
+++++        loadingMessage="ドキュメントの調査中..."
+++++        disableEdit
+++++      />
+++++
+++++      <Divider />
+++++
+++++      {/* メッセージ入力 */}
+++++      <ChecklistMentionInput
+++++        handleSubmit={handleSubmit}
+++++        handleInputChange={handleInputChange}
+++++        message={input}
+++++        disabled={status === 'submitted' || status === 'streaming'}
+++++        placeholder={getPlaceholderText(status)}
+++++        isStreaming={status === 'streaming'}
+++++        onStop={stop}
+++++        checklists={checklists}
+++++        selectedChecklistIds={selectedChecklistIds}
+++++        onChecklistSelect={setSelectedChecklistIds}
+++++      />
+++++    </Box>
+++++  );
+++++};
+++++
+++++export default ReviewChatPanel;
++++diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
++++index d37a5b5c9..7b00c802b 100644
++++--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++++++ b/src/renderer/components/review/ReviewChecklistSection.tsx
++++@@ -58,6 +58,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++++   checklistResults,
++++   isLoading,
++++   onSave,
+++++  targetDocumentName,
++++ }) => {
++++   // --- ステート ---
++++   const [editingId, setEditingId] = useState<number | null>(null);
++++@@ -94,11 +95,11 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++++     setIsAddingNew(false);
++++     setNewContent('');
++++   };
++++-  const handleSort = (fileId: string) => {
++++-    if (sortBy === fileId) {
+++++  const handleSort = () => {
+++++    if (sortBy === 'evaluation') {
++++       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
++++     } else {
++++-      setSortBy(fileId);
+++++      setSortBy('evaluation');
++++       setSortDirection('desc');
++++     }
++++   };
++++@@ -110,35 +111,15 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++++     downloadCSV(csvContent, filename);
++++   };
++++ 
++++-  // --- ユニークファイル抽出 ---
++++-  const uniqueSources = useMemo(() => {
++++-    const map = new Map<string, { id: string; fileName: string }>();
++++-    checklistResults.forEach((cl) => {
++++-      cl.sourceEvaluations?.forEach((ev) => {
++++-        if (!map.has(ev.fileId)) {
++++-          map.set(ev.fileId, {
++++-            id: ev.fileId,
++++-            fileName: ev.fileName,
++++-          });
++++-        }
++++-      });
++++-    });
++++-    return Array.from(map.values());
++++-  }, [checklistResults]);
++++-
++++   // --- ソート ---
++++   // 動的評価項目対応のため、文字列順ソートを使用
++++   const sortedResults = useMemo(() => {
++++-    if (sortBy == null) return checklistResults;
+++++    if (sortBy !== 'evaluation') return checklistResults;
++++ 
++++     return [...checklistResults].sort((a, b) => {
++++-      // 対象ファイルの評価を取得。未評価は空文字扱い
++++-      const aEv =
++++-        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
++++-        '';
++++-      const bEv =
++++-        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
++++-        '';
+++++      // 評価を取得。未評価は空文字扱い
+++++      const aEv = a.sourceEvaluation?.evaluation ?? '';
+++++      const bEv = b.sourceEvaluation?.evaluation ?? '';
++++ 
++++       // 文字列順で比較
++++       if (sortDirection === 'desc') {
++++@@ -169,41 +150,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++++         >
++++           チェックリスト
++++         </TableCell>
++++-        {uniqueSources.map((src) => (
++++-          <TableCell
++++-            key={src.id}
++++-            align="center"
++++-            sx={{
++++-              minWidth: 200,
++++-            }}
+++++        <TableCell
+++++          align="center"
+++++          sx={{
+++++            minWidth: 300,
+++++          }}
+++++        >
+++++          <TableSortLabel
+++++            active={sortBy === 'evaluation'}
+++++            direction={sortBy === 'evaluation' ? sortDirection : 'desc'}
+++++            onClick={() => handleSort()}
++++           >
++++-            <Box
++++-              sx={{
++++-                maxHeight: '4.5em',
++++-                overflow: 'hidden',
++++-                overflowY: 'auto',
++++-                lineHeight: '1.5em',
++++-                whiteSpace: 'normal',
++++-                wordBreak: 'break-all',
++++-                '&:hover': {
++++-                  overflowY: 'auto',
++++-                },
++++-              }}
++++-            >
++++-              <Tooltip title={src.fileName} placement="top">
++++-                <div>
++++-                  <TableSortLabel
++++-                    active={sortBy === src.id}
++++-                    direction={sortBy === src.id ? sortDirection : 'desc'}
++++-                    onClick={() => handleSort(src.id)}
++++-                  >
++++-                    {src.fileName}
++++-                  </TableSortLabel>
++++-                </div>
+++++            {targetDocumentName ? (
+++++              <Tooltip title={targetDocumentName} placement="top">
+++++                <Box
+++++                  component="span"
+++++                  sx={{
+++++                    maxHeight: '4.5em',
+++++                    overflow: 'hidden',
+++++                    textOverflow: 'ellipsis',
+++++                    wordBreak: 'break-all',
+++++                    whiteSpace: 'normal',
+++++                  }}
+++++                >
+++++                  レビュー結果 ({targetDocumentName})
+++++                </Box>
++++               </Tooltip>
++++-            </Box>
++++-          </TableCell>
++++-        ))}
+++++            ) : (
+++++              'レビュー結果'
+++++            )}
+++++          </TableSortLabel>
+++++        </TableCell>
++++         <TableCell align="center" sx={{ minWidth: 120 }}>
++++           操作
++++         </TableCell>
++++@@ -231,44 +208,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++++           )}
++++         </Box>
++++       </TableCell>
++++-      {/* 評価列 */}
++++-      {uniqueSources.map((src) => {
++++-        const ev = checklist.sourceEvaluations?.find(
++++-          (x) => x.fileId === src.id,
++++-        );
++++-        return (
++++-          <TableCell
++++-            key={src.id}
++++-            align="center"
++++-            sx={{ p: 1, verticalAlign: 'top' }}
++++-          >
++++-            <Box>
++++-              {ev?.evaluation && (
++++-                <Stack spacing={1} alignItems="center">
++++-                  <Typography
++++-                    variant="body2"
++++-                    sx={{
++++-                      color: getEvaluationColor(ev.evaluation),
++++-                      fontWeight: 'bold',
++++-                      textDecoration: 'underline',
++++-                      textDecorationColor: getEvaluationColor(ev.evaluation),
++++-                      textDecorationThickness: '2px',
++++-                      textUnderlineOffset: '3px',
++++-                    }}
++++-                  >
++++-                    {ev.evaluation}
++++-                  </Typography>
++++-                  {ev.comment && (
++++-                    <Typography variant="body2" sx={commentBoxSx}>
++++-                      {ev.comment}
++++-                    </Typography>
++++-                  )}
++++-                </Stack>
+++++      {/* レビュー結果列 */}
+++++      <TableCell align="center" sx={{ p: 1, verticalAlign: 'top' }}>
+++++        <Box>
+++++          {checklist.sourceEvaluation?.evaluation && (
+++++            <Stack spacing={1} alignItems="center">
+++++              <Typography
+++++                variant="body2"
+++++                sx={{
+++++                  color: getEvaluationColor(
+++++                    checklist.sourceEvaluation.evaluation,
+++++                  ),
+++++                  fontWeight: 'bold',
+++++                  textDecoration: 'underline',
+++++                  textDecorationColor: getEvaluationColor(
+++++                    checklist.sourceEvaluation.evaluation,
+++++                  ),
+++++                  textDecorationThickness: '2px',
+++++                  textUnderlineOffset: '3px',
+++++                }}
+++++              >
+++++                {checklist.sourceEvaluation.evaluation}
+++++              </Typography>
+++++              {checklist.sourceEvaluation.comment && (
+++++                <Typography variant="body2" sx={commentBoxSx}>
+++++                  {checklist.sourceEvaluation.comment}
+++++                </Typography>
++++               )}
++++-            </Box>
++++-          </TableCell>
++++-        );
++++-      })}
+++++            </Stack>
+++++          )}
+++++        </Box>
+++++      </TableCell>
++++       {/* 操作 */}
++++       <TableCell align="center" sx={{ p: 1 }}>
++++         <Stack direction="row" spacing={1} justifyContent="center">
++++@@ -321,10 +291,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++++           />
++++         </Box>
++++       </TableCell>
++++-      {uniqueSources.map((_, i) => (
++++-        // eslint-disable-next-line
++++-        <TableCell key={i} />
++++-      ))}
+++++      <TableCell />
++++       <TableCell align="center" sx={{ p: 1 }}>
++++         <Stack direction="row" spacing={1} justifyContent="center">
++++           <IconButton
++++diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
++++index 2599bdf7c..1f662086c 100644
++++--- a/src/renderer/components/review/types.ts
+++++++ b/src/renderer/components/review/types.ts
++++@@ -18,6 +18,7 @@ export interface ReviewChecklistSectionProps {
++++   checklistResults: ReviewChecklistResult[];
++++   isLoading: boolean;
++++   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
+++++  targetDocumentName?: string | null;
++++ }
++++ 
++++ // ReviewSourceModalのProps型
++++diff --git a/src/renderer/lib/csvUtils.ts b/src/renderer/lib/csvUtils.ts
++++index 7cfdefb6c..c5aac8405 100644
++++--- a/src/renderer/lib/csvUtils.ts
+++++++ b/src/renderer/lib/csvUtils.ts
++++@@ -36,27 +36,8 @@ export const convertReviewResultsToCSV = (
++++     return 'チェックリスト\n';
++++   }
++++ 
++++-  // ユニークなソースファイルを抽出
++++-  const uniqueSources = new Map<string, { id: string; fileName: string }>();
++++-  checklistResults.forEach((checklist) => {
++++-    checklist.sourceEvaluations?.forEach((ev) => {
++++-      if (!uniqueSources.has(ev.fileId)) {
++++-        uniqueSources.set(ev.fileId, {
++++-          id: ev.fileId,
++++-          fileName: ev.fileName,
++++-        });
++++-      }
++++-    });
++++-  });
++++-
++++-  const sources = Array.from(uniqueSources.values());
++++-
++++   // ヘッダー行を構築
++++-  const headers = ['チェックリスト'];
++++-  sources.forEach((source) => {
++++-    headers.push(`${source.fileName}_評価`);
++++-    headers.push(`${source.fileName}_コメント`);
++++-  });
+++++  const headers = ['チェックリスト', '評価', 'コメント'];
++++ 
++++   const csvRows: string[] = [];
++++ 
++++@@ -65,18 +46,11 @@ export const convertReviewResultsToCSV = (
++++ 
++++   // データ行を追加
++++   checklistResults.forEach((checklist) => {
++++-    const row: string[] = [checklist.content];
++++-
++++-    sources.forEach((source) => {
++++-      const evaluation = checklist.sourceEvaluations?.find(
++++-        (ev) => ev.fileId === source.id,
++++-      );
++++-
++++-      // 評価値
++++-      row.push(evaluation?.evaluation || '');
++++-      // コメント
++++-      row.push(evaluation?.comment || '');
++++-    });
+++++    const row: string[] = [
+++++      checklist.content,
+++++      checklist.sourceEvaluation?.evaluation || '',
+++++      checklist.sourceEvaluation?.comment || '',
+++++    ];
++++ 
++++     csvRows.push(row.map(escapeCSVField).join(','));
++++   });
++++diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
++++index 02fc24edb..1ed208b6f 100644
++++--- a/src/renderer/service/reviewApi.ts
+++++++ b/src/renderer/service/reviewApi.ts
++++@@ -27,6 +27,7 @@ export interface IReviewApi {
++++     options?: ApiServiceDefaultOptions,
++++   ): Promise<{
++++     checklistResults?: ReviewChecklistResult[];
+++++    targetDocumentName?: string | null;
++++   } | null>;
++++   getReviewInstruction(
++++     historyId: string,
++++@@ -118,6 +119,7 @@ export class ReviewApi implements IReviewApi {
++++     options?: ApiServiceDefaultOptions,
++++   ): Promise<{
++++     checklistResults?: ReviewChecklistResult[];
+++++    targetDocumentName?: string | null;
++++   } | null> {
++++     return invokeApi(
++++       () => window.electron.review.getHistoryDetail(historyId),
++++diff --git a/src/renderer/service/reviewChatApi.ts b/src/renderer/service/reviewChatApi.ts
++++new file mode 100644
++++index 000000000..f3da0c3d2
++++--- /dev/null
+++++++ b/src/renderer/service/reviewChatApi.ts
++++@@ -0,0 +1,136 @@
+++++import { IpcChannels, IpcEventPayload } from '@/types';
+++++import { invokeApi } from '../lib/apiUtils';
+++++import { ApiServiceDefaultOptions } from '../types';
+++++import { ElectronPushClient } from '../lib/ElectronPushClient';
+++++
+++++export interface IReviewChatApi {
+++++  streamResponse(callbacks: {
+++++    onMessage: (
+++++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
+++++    ) => void;
+++++    onDone: () => void;
+++++    onError: (error: Error) => void;
+++++  }): () => void;
+++++  abortChat(
+++++    reviewHistoryId: string,
+++++    options?: ApiServiceDefaultOptions,
+++++  ): Promise<void>;
+++++  sendMessage(
+++++    reviewHistoryId: string,
+++++    checklistIds: number[],
+++++    question: string,
+++++    options?: ApiServiceDefaultOptions,
+++++  ): Promise<void>;
+++++}
+++++
+++++// IPC通信を使用してレビューチャット機能を提供するAPIサービス
+++++export class ReviewChatApi implements IReviewChatApi {
+++++  // シングルトン変数
+++++  private static instance: ReviewChatApi;
+++++
+++++  // コンストラクタをprivateにして外部からのインスタンス化を防止
+++++  private constructor() {}
+++++
+++++  // シングルトンインスタンスを取得するための静的メソッド
+++++  public static getInstance(): ReviewChatApi {
+++++    if (!ReviewChatApi.instance) {
+++++      ReviewChatApi.instance = new ReviewChatApi();
+++++    }
+++++    return ReviewChatApi.instance;
+++++  }
+++++
+++++  /**
+++++   * ストリーミング応答の購読
+++++   * @param callbacks ストリーミングイベントのコールバック
+++++   * @returns 購読解除用の関数
+++++   */
+++++  public streamResponse(callbacks: {
+++++    onMessage: (
+++++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
+++++    ) => void;
+++++    onDone: () => void;
+++++    onError: (error: Error) => void;
+++++  }): () => void {
+++++    const pushClient = new ElectronPushClient();
+++++    const abortController = new AbortController();
+++++
+++++    // ストリーミングイベントの購読
+++++    pushClient.subscribe(
+++++      IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
+++++      (event) => {
+++++        callbacks.onMessage(event.payload);
+++++      },
+++++      { signal: abortController.signal },
+++++    );
+++++
+++++    // 完了イベント（レビューチャット専用）
+++++    pushClient.subscribe(
+++++      IpcChannels.REVIEW_CHAT_COMPLETE,
+++++      () => {
+++++        // 購読を解除
+++++        abortController.abort();
+++++        // 完了コールバックを呼び出し
+++++        callbacks.onDone();
+++++      },
+++++      { signal: abortController.signal },
+++++    );
+++++
+++++    // エラーイベント（レビューチャット専用）
+++++    pushClient.subscribe(
+++++      IpcChannels.REVIEW_CHAT_ERROR,
+++++      (event) => {
+++++        // 購読を解除
+++++        abortController.abort();
+++++        // エラーコールバックを呼び出し
+++++        callbacks.onError(
+++++          new Error(event.payload.message || '予期せぬエラーが発生しました'),
+++++        );
+++++      },
+++++      { signal: abortController.signal },
+++++    );
+++++
+++++    // 購読解除のためのクリーンアップ
+++++    return () => {
+++++      abortController.abort();
+++++    };
+++++  }
+++++
+++++  /**
+++++   * レビューチャットの中断
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   * @param options APIサービスのオプション
+++++   */
+++++  public async abortChat(
+++++    reviewHistoryId: string,
+++++    options?: ApiServiceDefaultOptions,
+++++  ): Promise<void> {
+++++    await invokeApi(
+++++      () => window.electron.review.abortChat(reviewHistoryId),
+++++      options,
+++++    );
+++++  }
+++++
+++++  /**
+++++   * レビューチャットメッセージ送信
+++++   * @param reviewHistoryId レビュー履歴ID
+++++   * @param checklistIds チェックリストID配列
+++++   * @param question ユーザからの質問
+++++   * @param options APIサービスのオプション
+++++   */
+++++  public async sendMessage(
+++++    reviewHistoryId: string,
+++++    checklistIds: number[],
+++++    question: string,
+++++    options?: ApiServiceDefaultOptions,
+++++  ): Promise<void> {
+++++    await invokeApi(
+++++      () =>
+++++        window.electron.review.sendChatMessage({
+++++          reviewHistoryId,
+++++          checklistIds,
+++++          question,
+++++        }),
+++++      options,
+++++    );
+++++  }
+++++}
++++diff --git a/src/types/ipc.ts b/src/types/ipc.ts
++++index 0fc449d82..69d3b10bd 100644
++++--- a/src/types/ipc.ts
+++++++ b/src/types/ipc.ts
++++@@ -81,6 +81,11 @@ export const IpcChannels = {
++++   REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
++++   REVIEW_EXECUTE_ABORT: 'review-execute-abort', // レビュー実行処理をキャンセルする
++++   REVIEW_HISTORY_UPDATED: 'review-history-updated', // レビュー履歴が更新された際の通知
+++++  REVIEW_CHAT_SEND_MESSAGE: 'review-chat-send-message', // レビューチャットメッセージ送信
+++++  REVIEW_CHAT_STREAM_RESPONSE: 'review-chat-stream-response', // レビューチャットストリーミング応答
+++++  REVIEW_CHAT_COMPLETE: 'review-chat-complete', // レビューチャット完了
+++++  REVIEW_CHAT_ERROR: 'review-chat-error', // レビューチャットエラー
+++++  REVIEW_CHAT_ABORT: 'review-chat-abort', // レビューチャット中断
++++ } as const;
++++ 
++++ export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
++++@@ -150,6 +155,12 @@ export type IpcRequestPayloadMap = {
++++     documentMode: DocumentMode;
++++   };
++++   [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
+++++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: {
+++++    reviewHistoryId: string;
+++++    checklistIds: number[];
+++++    question: string;
+++++  };
+++++  [IpcChannels.REVIEW_CHAT_ABORT]: string; // review history id
++++ };
++++ 
++++ export type IpcResponsePayloadMap = {
++++@@ -189,6 +200,7 @@ export type IpcResponsePayloadMap = {
++++   [IpcChannels.REVIEW_GET_HISTORIES]: IpcResult<RevieHistory[]>;
++++   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: IpcResult<{
++++     checklistResults?: ReviewChecklistResult[];
+++++    targetDocumentName?: string | null;
++++   }>;
++++   [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: IpcResult<{
++++     additionalInstructions?: string;
++++@@ -201,6 +213,8 @@ export type IpcResponsePayloadMap = {
++++   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: IpcResult;
++++   [IpcChannels.REVIEW_EXECUTE_CALL]: IpcResult;
++++   [IpcChannels.REVIEW_EXECUTE_ABORT]: IpcResult;
+++++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: IpcResult;
+++++  [IpcChannels.REVIEW_CHAT_ABORT]: IpcResult;
++++ };
++++ 
++++ export type IpcEventPayloadMap = {
++++@@ -227,6 +241,9 @@ export type IpcEventPayloadMap = {
++++     currentSheet?: number;
++++     totalSheets?: number;
++++   };
+++++  [IpcChannels.REVIEW_CHAT_STREAM_RESPONSE]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
+++++  [IpcChannels.REVIEW_CHAT_COMPLETE]: unknown;
+++++  [IpcChannels.REVIEW_CHAT_ERROR]: { message: string };
++++ };
++++ 
++++ /**
++++@@ -287,4 +304,8 @@ export const IpcNameMap = {
++++   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: 'チェックリストの更新',
++++   [IpcChannels.REVIEW_EXECUTE_CALL]: 'ドキュメントレビューの実行',
++++   [IpcChannels.REVIEW_EXECUTE_ABORT]: 'ドキュメントレビューの中断',
+++++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: 'レビューチャットメッセージ送信',
+++++  [IpcChannels.REVIEW_CHAT_COMPLETE]: 'レビューチャット完了',
+++++  [IpcChannels.REVIEW_CHAT_ERROR]: 'レビューチャットエラー',
+++++  [IpcChannels.REVIEW_CHAT_ABORT]: 'レビューチャット中断',
++++ };
++++diff --git a/src/types/message.ts b/src/types/message.ts
++++index 979bb1cda..a4065ae2e 100644
++++--- a/src/types/message.ts
+++++++ b/src/types/message.ts
++++@@ -11,6 +11,7 @@ export type MessageCode =
++++   | 'GITLAB_API_CONNECTION_ERROR'
++++   | 'REDMINE_API_CONNECTION_ERROR'
++++   | 'REDMINE_API_ERROR'
+++++  | 'FS_OPEN_DIALOG_ERROR'
++++   | 'FILE_TEXT_EXTRACTION_ERROR'
++++   | 'FS_CONVERT_OFFICE_TO_PDF_ERROR'
++++   | 'SOURCE_REGISTRATION_DIR_READING_ERROR'
++++@@ -18,8 +19,10 @@ export type MessageCode =
++++   | 'REVIEW_CHECKLIST_EXTRACTION_ERROR'
++++   | 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS'
++++   | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
+++++  | 'REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM'
++++   | 'REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR'
++++   | 'REVIEW_EXECUTION_ERROR'
++++   | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
++++   | 'AI_API_ERROR'
++++-  | 'AI_MESSAGE_TOO_LARGE';
+++++  | 'AI_MESSAGE_TOO_LARGE'
+++++  | 'REVIEW_DOCUMENT_CACHE_NOT_FOUND';
++++diff --git a/src/types/review.ts b/src/types/review.ts
++++index 52578ffaa..46765ab32 100644
++++--- a/src/types/review.ts
+++++++ b/src/types/review.ts
++++@@ -1,6 +1,7 @@
++++ export interface RevieHistory {
++++   id: string; // reviewHistoriesのid
++++   title: string;
+++++  targetDocumentName?: string | null; // レビュー対象の統合ドキュメント名
++++   additionalInstructions: string | null;
++++   commentFormat?: string | null;
++++   evaluationSettings?: CustomEvaluationSettings | null; // カスタム評定項目設定
++++@@ -13,6 +14,8 @@ export interface ReviewChecklist {
++++   id: number;
++++   reviewHistoryId: string;
++++   content: string;
+++++  evaluation?: ReviewEvaluation | null; // A, B, C, - 評価
+++++  comment?: string | null; // レビューコメント
++++   createdBy: ReviewChecklistCreatedBy;
++++   createdAt: string;
++++   updatedAt: string;
++++@@ -39,12 +42,10 @@ export type ReviewChecklistCreatedBy = 'user' | 'system';
++++ export type ReviewChecklistResult = {
++++   id: number; // チェックリストのID
++++   content: string;
++++-  sourceEvaluations?: {
++++-    fileId: string;
++++-    fileName: string;
+++++  sourceEvaluation?: {
++++     evaluation?: ReviewEvaluation; // カスタム評定項目対応
++++     comment?: string;
++++-  }[];
+++++  };
++++ };
++++ 
++++ // チェックリストの編集内容を表す型
++++@@ -97,3 +98,26 @@ export type ProcessingStatus =
++++   | 'extracted'   // チェックリスト抽出完了
++++   | 'reviewing'   // レビュー実行中
++++   | 'completed';  // レビュー完了
+++++
+++++// レビュードキュメントキャッシュ（サービス層で使用）
+++++export interface ReviewDocumentCache {
+++++  id: number;
+++++  reviewHistoryId: string;
+++++  documentId: string; // ワークフロー内のドキュメントID
+++++  fileName: string; // ワークフロー内での名前（分割時は "xxx (part 1)" など）
+++++  processMode: ProcessMode;
+++++  textContent?: string; // processMode='text'の場合
+++++  imageData?: string[]; // processMode='image'の場合
+++++  createdAt: string;
+++++  updatedAt: string;
+++++}
+++++
+++++// レビュー大量ドキュメント結果キャッシュ（大量ドキュメントレビューの個別レビュー結果）
+++++export interface ReviewLargedocumentResultCache {
+++++  reviewDocumentCacheId: number;
+++++  reviewChecklistId: number;
+++++  comment: string;
+++++  totalChunks: number; // ドキュメント分割総数
+++++  chunkIndex: number; // 何番目のチャンクか（0から始まる）
+++++  individualFileName: string; // 分割後の個別ドキュメント名（"xxx (part 1)" など）
+++++}
+++diff --git a/drizzle.config.ts b/drizzle.config.ts
+++index 36ebf09d3..f73e59241 100644
+++--- a/drizzle.config.ts
++++++ b/drizzle.config.ts
+++@@ -12,7 +12,7 @@ console.log(
+++ );
+++ 
+++ export default {
+++-  schema: './src/db/schema.ts',
++++  schema: './src/adapter/db/drizzle/schema.ts',
+++   out: './drizzle/migrations',
+++   dialect: 'sqlite',
+++   dbCredentials: {
+++diff --git a/drizzle/migrations/0008_pink_ezekiel.sql b/drizzle/migrations/0008_pink_ezekiel.sql
+++new file mode 100644
+++index 000000000..8169d2866
+++--- /dev/null
++++++ b/drizzle/migrations/0008_pink_ezekiel.sql
+++@@ -0,0 +1,4 @@
++++DROP TABLE `review_checklist_results`;--> statement-breakpoint
++++ALTER TABLE `review_checklists` ADD `evaluation` text;--> statement-breakpoint
++++ALTER TABLE `review_checklists` ADD `comment` text;--> statement-breakpoint
++++ALTER TABLE `review_histories` ADD `target_document_name` text;
+++\ No newline at end of file
+++diff --git a/drizzle/migrations/0009_keen_radioactive_man.sql b/drizzle/migrations/0009_keen_radioactive_man.sql
+++new file mode 100644
+++index 000000000..999bdbbd9
+++--- /dev/null
++++++ b/drizzle/migrations/0009_keen_radioactive_man.sql
+++@@ -0,0 +1,23 @@
++++CREATE TABLE `review_checklist_result_caches` (
++++	`review_document_cache_id` integer NOT NULL,
++++	`review_checklist_id` integer NOT NULL,
++++	`comment` text NOT NULL,
++++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`),
++++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
++++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
++++);
++++--> statement-breakpoint
++++CREATE TABLE `review_document_caches` (
++++	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
++++	`review_history_id` text NOT NULL,
++++	`document_id` text NOT NULL,
++++	`original_file_name` text NOT NULL,
++++	`file_name` text NOT NULL,
++++	`process_mode` text NOT NULL,
++++	`cache_path` text NOT NULL,
++++	`created_at` text DEFAULT (current_timestamp) NOT NULL,
++++	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
++++	FOREIGN KEY (`review_history_id`) REFERENCES `review_histories`(`id`) ON UPDATE no action ON DELETE cascade
++++);
++++--> statement-breakpoint
++++ALTER TABLE `review_histories` ADD `document_mode` text;
+++\ No newline at end of file
+++diff --git a/drizzle/migrations/0010_wet_shooting_star.sql b/drizzle/migrations/0010_wet_shooting_star.sql
+++new file mode 100644
+++index 000000000..49668f9f0
+++--- /dev/null
++++++ b/drizzle/migrations/0010_wet_shooting_star.sql
+++@@ -0,0 +1,14 @@
++++CREATE TABLE `review_largedocument_result_caches` (
++++	`review_document_cache_id` integer NOT NULL,
++++	`review_checklist_id` integer NOT NULL,
++++	`comment` text NOT NULL,
++++	`total_chunks` integer NOT NULL,
++++	`chunk_index` integer NOT NULL,
++++	`individual_file_name` text NOT NULL,
++++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`, `chunk_index`),
++++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
++++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
++++);
++++--> statement-breakpoint
++++DROP TABLE `review_checklist_result_caches`;--> statement-breakpoint
++++ALTER TABLE `review_document_caches` DROP COLUMN `original_file_name`;
+++\ No newline at end of file
+++diff --git a/drizzle/migrations/meta/0008_snapshot.json b/drizzle/migrations/meta/0008_snapshot.json
+++new file mode 100644
+++index 000000000..5148d151e
+++--- /dev/null
++++++ b/drizzle/migrations/meta/0008_snapshot.json
+++@@ -0,0 +1,329 @@
++++{
++++  "version": "6",
++++  "dialect": "sqlite",
++++  "id": "e0ad999a-87f1-4f45-b070-a32c673d6352",
++++  "prevId": "f10b9ed0-007d-4b08-941a-030265d534ff",
++++  "tables": {
++++    "review_checklists": {
++++      "name": "review_checklists",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "review_history_id": {
++++          "name": "review_history_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "content": {
++++          "name": "content",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "evaluation": {
++++          "name": "evaluation",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "comment": {
++++          "name": "comment",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "created_by": {
++++          "name": "created_by",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_checklists_review_history_id_review_histories_id_fk": {
++++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++++          "tableFrom": "review_checklists",
++++          "tableTo": "review_histories",
++++          "columnsFrom": [
++++            "review_history_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_histories": {
++++      "name": "review_histories",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "text",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "title": {
++++          "name": "title",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "target_document_name": {
++++          "name": "target_document_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "additional_instructions": {
++++          "name": "additional_instructions",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "comment_format": {
++++          "name": "comment_format",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "evaluation_settings": {
++++          "name": "evaluation_settings",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "processing_status": {
++++          "name": "processing_status",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "'idle'"
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {},
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "sources": {
++++      "name": "sources",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "path": {
++++          "name": "path",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "title": {
++++          "name": "title",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "summary": {
++++          "name": "summary",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "status": {
++++          "name": "status",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "'idle'"
++++        },
++++        "error": {
++++          "name": "error",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "is_enabled": {
++++          "name": "is_enabled",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": 1
++++        }
++++      },
++++      "indexes": {
++++        "sources_path_unique": {
++++          "name": "sources_path_unique",
++++          "columns": [
++++            "path"
++++          ],
++++          "isUnique": true
++++        }
++++      },
++++      "foreignKeys": {},
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "topics": {
++++      "name": "topics",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "source_id": {
++++          "name": "source_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "name": {
++++          "name": "name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "summary": {
++++          "name": "summary",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "topics_source_id_sources_id_fk": {
++++          "name": "topics_source_id_sources_id_fk",
++++          "tableFrom": "topics",
++++          "tableTo": "sources",
++++          "columnsFrom": [
++++            "source_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    }
++++  },
++++  "views": {},
++++  "enums": {},
++++  "_meta": {
++++    "schemas": {},
++++    "tables": {},
++++    "columns": {}
++++  },
++++  "internal": {
++++    "indexes": {}
++++  }
++++}
+++\ No newline at end of file
+++diff --git a/drizzle/migrations/meta/0009_snapshot.json b/drizzle/migrations/meta/0009_snapshot.json
+++new file mode 100644
+++index 000000000..0f58c9424
+++--- /dev/null
++++++ b/drizzle/migrations/meta/0009_snapshot.json
+++@@ -0,0 +1,491 @@
++++{
++++  "version": "6",
++++  "dialect": "sqlite",
++++  "id": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
++++  "prevId": "e0ad999a-87f1-4f45-b070-a32c673d6352",
++++  "tables": {
++++    "review_checklist_result_caches": {
++++      "name": "review_checklist_result_caches",
++++      "columns": {
++++        "review_document_cache_id": {
++++          "name": "review_document_cache_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "review_checklist_id": {
++++          "name": "review_checklist_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "comment": {
++++          "name": "comment",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk": {
++++          "name": "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk",
++++          "tableFrom": "review_checklist_result_caches",
++++          "tableTo": "review_document_caches",
++++          "columnsFrom": [
++++            "review_document_cache_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        },
++++        "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk": {
++++          "name": "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk",
++++          "tableFrom": "review_checklist_result_caches",
++++          "tableTo": "review_checklists",
++++          "columnsFrom": [
++++            "review_checklist_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {
++++        "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk": {
++++          "columns": [
++++            "review_document_cache_id",
++++            "review_checklist_id"
++++          ],
++++          "name": "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk"
++++        }
++++      },
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_checklists": {
++++      "name": "review_checklists",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "review_history_id": {
++++          "name": "review_history_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "content": {
++++          "name": "content",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "evaluation": {
++++          "name": "evaluation",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "comment": {
++++          "name": "comment",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "created_by": {
++++          "name": "created_by",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_checklists_review_history_id_review_histories_id_fk": {
++++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++++          "tableFrom": "review_checklists",
++++          "tableTo": "review_histories",
++++          "columnsFrom": [
++++            "review_history_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_document_caches": {
++++      "name": "review_document_caches",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "review_history_id": {
++++          "name": "review_history_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "document_id": {
++++          "name": "document_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "original_file_name": {
++++          "name": "original_file_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "file_name": {
++++          "name": "file_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "process_mode": {
++++          "name": "process_mode",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "cache_path": {
++++          "name": "cache_path",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_document_caches_review_history_id_review_histories_id_fk": {
++++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
++++          "tableFrom": "review_document_caches",
++++          "tableTo": "review_histories",
++++          "columnsFrom": [
++++            "review_history_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_histories": {
++++      "name": "review_histories",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "text",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "title": {
++++          "name": "title",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "target_document_name": {
++++          "name": "target_document_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "additional_instructions": {
++++          "name": "additional_instructions",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "comment_format": {
++++          "name": "comment_format",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "evaluation_settings": {
++++          "name": "evaluation_settings",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "document_mode": {
++++          "name": "document_mode",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "processing_status": {
++++          "name": "processing_status",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "'idle'"
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {},
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "sources": {
++++      "name": "sources",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "path": {
++++          "name": "path",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "title": {
++++          "name": "title",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "summary": {
++++          "name": "summary",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "status": {
++++          "name": "status",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "'idle'"
++++        },
++++        "error": {
++++          "name": "error",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "is_enabled": {
++++          "name": "is_enabled",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": 1
++++        }
++++      },
++++      "indexes": {
++++        "sources_path_unique": {
++++          "name": "sources_path_unique",
++++          "columns": [
++++            "path"
++++          ],
++++          "isUnique": true
++++        }
++++      },
++++      "foreignKeys": {},
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "topics": {
++++      "name": "topics",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "source_id": {
++++          "name": "source_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "name": {
++++          "name": "name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "summary": {
++++          "name": "summary",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "topics_source_id_sources_id_fk": {
++++          "name": "topics_source_id_sources_id_fk",
++++          "tableFrom": "topics",
++++          "tableTo": "sources",
++++          "columnsFrom": [
++++            "source_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    }
++++  },
++++  "views": {},
++++  "enums": {},
++++  "_meta": {
++++    "schemas": {},
++++    "tables": {},
++++    "columns": {}
++++  },
++++  "internal": {
++++    "indexes": {}
++++  }
++++}
+++\ No newline at end of file
+++diff --git a/drizzle/migrations/meta/0010_snapshot.json b/drizzle/migrations/meta/0010_snapshot.json
+++new file mode 100644
+++index 000000000..cf557a34d
+++--- /dev/null
++++++ b/drizzle/migrations/meta/0010_snapshot.json
+++@@ -0,0 +1,506 @@
++++{
++++  "version": "6",
++++  "dialect": "sqlite",
++++  "id": "64a4c44b-83f4-4cca-b0a7-5e1962a1f61b",
++++  "prevId": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
++++  "tables": {
++++    "review_checklists": {
++++      "name": "review_checklists",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "review_history_id": {
++++          "name": "review_history_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "content": {
++++          "name": "content",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "evaluation": {
++++          "name": "evaluation",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "comment": {
++++          "name": "comment",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "created_by": {
++++          "name": "created_by",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_checklists_review_history_id_review_histories_id_fk": {
++++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++++          "tableFrom": "review_checklists",
++++          "tableTo": "review_histories",
++++          "columnsFrom": [
++++            "review_history_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_document_caches": {
++++      "name": "review_document_caches",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "review_history_id": {
++++          "name": "review_history_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "document_id": {
++++          "name": "document_id",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "file_name": {
++++          "name": "file_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "process_mode": {
++++          "name": "process_mode",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "cache_path": {
++++          "name": "cache_path",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_document_caches_review_history_id_review_histories_id_fk": {
++++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
++++          "tableFrom": "review_document_caches",
++++          "tableTo": "review_histories",
++++          "columnsFrom": [
++++            "review_history_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_histories": {
++++      "name": "review_histories",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "text",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "title": {
++++          "name": "title",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "target_document_name": {
++++          "name": "target_document_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "additional_instructions": {
++++          "name": "additional_instructions",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "comment_format": {
++++          "name": "comment_format",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "evaluation_settings": {
++++          "name": "evaluation_settings",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "document_mode": {
++++          "name": "document_mode",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "processing_status": {
++++          "name": "processing_status",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "'idle'"
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {},
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "review_largedocument_result_caches": {
++++      "name": "review_largedocument_result_caches",
++++      "columns": {
++++        "review_document_cache_id": {
++++          "name": "review_document_cache_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "review_checklist_id": {
++++          "name": "review_checklist_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "comment": {
++++          "name": "comment",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "total_chunks": {
++++          "name": "total_chunks",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "chunk_index": {
++++          "name": "chunk_index",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "individual_file_name": {
++++          "name": "individual_file_name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk": {
++++          "name": "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk",
++++          "tableFrom": "review_largedocument_result_caches",
++++          "tableTo": "review_document_caches",
++++          "columnsFrom": [
++++            "review_document_cache_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        },
++++        "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk": {
++++          "name": "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk",
++++          "tableFrom": "review_largedocument_result_caches",
++++          "tableTo": "review_checklists",
++++          "columnsFrom": [
++++            "review_checklist_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {
++++        "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk": {
++++          "columns": [
++++            "review_document_cache_id",
++++            "review_checklist_id",
++++            "chunk_index"
++++          ],
++++          "name": "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk"
++++        }
++++      },
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "sources": {
++++      "name": "sources",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "path": {
++++          "name": "path",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "title": {
++++          "name": "title",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "summary": {
++++          "name": "summary",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "status": {
++++          "name": "status",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "'idle'"
++++        },
++++        "error": {
++++          "name": "error",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": false,
++++          "autoincrement": false
++++        },
++++        "is_enabled": {
++++          "name": "is_enabled",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": 1
++++        }
++++      },
++++      "indexes": {
++++        "sources_path_unique": {
++++          "name": "sources_path_unique",
++++          "columns": [
++++            "path"
++++          ],
++++          "isUnique": true
++++        }
++++      },
++++      "foreignKeys": {},
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    },
++++    "topics": {
++++      "name": "topics",
++++      "columns": {
++++        "id": {
++++          "name": "id",
++++          "type": "integer",
++++          "primaryKey": true,
++++          "notNull": true,
++++          "autoincrement": true
++++        },
++++        "source_id": {
++++          "name": "source_id",
++++          "type": "integer",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "name": {
++++          "name": "name",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "summary": {
++++          "name": "summary",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false
++++        },
++++        "created_at": {
++++          "name": "created_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        },
++++        "updated_at": {
++++          "name": "updated_at",
++++          "type": "text",
++++          "primaryKey": false,
++++          "notNull": true,
++++          "autoincrement": false,
++++          "default": "(current_timestamp)"
++++        }
++++      },
++++      "indexes": {},
++++      "foreignKeys": {
++++        "topics_source_id_sources_id_fk": {
++++          "name": "topics_source_id_sources_id_fk",
++++          "tableFrom": "topics",
++++          "tableTo": "sources",
++++          "columnsFrom": [
++++            "source_id"
++++          ],
++++          "columnsTo": [
++++            "id"
++++          ],
++++          "onDelete": "cascade",
++++          "onUpdate": "no action"
++++        }
++++      },
++++      "compositePrimaryKeys": {},
++++      "uniqueConstraints": {},
++++      "checkConstraints": {}
++++    }
++++  },
++++  "views": {},
++++  "enums": {},
++++  "_meta": {
++++    "schemas": {},
++++    "tables": {},
++++    "columns": {}
++++  },
++++  "internal": {
++++    "indexes": {}
++++  }
++++}
+++\ No newline at end of file
+++diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
+++index 18a6e2692..2c49cc99a 100644
+++--- a/drizzle/migrations/meta/_journal.json
++++++ b/drizzle/migrations/meta/_journal.json
+++@@ -57,6 +57,27 @@
+++       "when": 1758023792722,
+++       "tag": "0007_awesome_caretaker",
+++       "breakpoints": true
++++    },
++++    {
++++      "idx": 8,
++++      "version": "6",
++++      "when": 1759653362189,
++++      "tag": "0008_pink_ezekiel",
++++      "breakpoints": true
++++    },
++++    {
++++      "idx": 9,
++++      "version": "6",
++++      "when": 1759674897312,
++++      "tag": "0009_keen_radioactive_man",
++++      "breakpoints": true
++++    },
++++    {
++++      "idx": 10,
++++      "version": "6",
++++      "when": 1760147587193,
++++      "tag": "0010_wet_shooting_star",
++++      "breakpoints": true
+++     }
+++   ]
+++ }
+++\ No newline at end of file
+++diff --git a/src/adapter/db/drizzle/repository/reviewRepository.ts b/src/adapter/db/drizzle/repository/reviewRepository.ts
+++index 572c1e214..cd8949e13 100644
+++--- a/src/adapter/db/drizzle/repository/reviewRepository.ts
++++++ b/src/adapter/db/drizzle/repository/reviewRepository.ts
+++@@ -1,10 +1,13 @@
+++-import { eq, and } from 'drizzle-orm';
++++import { eq, and, inArray, max } from 'drizzle-orm';
+++ import {
+++   reviewHistories,
+++   reviewChecklists,
+++-  reviewChecklistResults,
++++  reviewDocumentCaches,
++++  reviewLargedocumentResultCaches,
+++   ReviewChecklistEntity,
+++   ReviewHistoryEntity,
++++  ReviewDocumentCacheEntity,
++++  ReviewLargedocumentResultCacheEntity,
+++ } from '../schema';
+++ import getDb from '..';
+++ import type {
+++@@ -15,10 +18,15 @@ import type {
+++   ReviewChecklistCreatedBy,
+++   CustomEvaluationSettings,
+++   ProcessingStatus,
++++  DocumentMode,
++++  ReviewDocumentCache,
++++  ReviewLargedocumentResultCache,
++++  ProcessMode,
+++ } from '@/types';
+++-import { AppError } from '@/main/lib/error';
++++import { AppError, internalError } from '@/main/lib/error';
+++ import { repositoryError } from '@/main/lib/error';
+++ import { IReviewRepository } from '@/main/service/port/repository';
++++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
+++ 
+++ /**
+++  * Drizzle ORM を使用したレビューリポジトリの実装
+++@@ -31,6 +39,8 @@ export class DrizzleReviewRepository implements IReviewRepository {
+++       id: reviewChecklistEntity.id,
+++       reviewHistoryId: reviewChecklistEntity.reviewHistoryId,
+++       content: reviewChecklistEntity.content,
++++      evaluation: reviewChecklistEntity.evaluation as ReviewEvaluation | null,
++++      comment: reviewChecklistEntity.comment,
+++       createdBy: reviewChecklistEntity.createdBy as ReviewChecklistCreatedBy,
+++       createdAt: reviewChecklistEntity.createdAt,
+++       updatedAt: reviewChecklistEntity.updatedAt,
+++@@ -43,6 +53,7 @@ export class DrizzleReviewRepository implements IReviewRepository {
+++     const reviewHistory = {
+++       id: reviewHistoryEntity.id,
+++       title: reviewHistoryEntity.title,
++++      targetDocumentName: reviewHistoryEntity.targetDocumentName,
+++       additionalInstructions: reviewHistoryEntity.additionalInstructions,
+++       commentFormat: reviewHistoryEntity.commentFormat,
+++       evaluationSettings: null,
+++@@ -189,6 +200,27 @@ export class DrizzleReviewRepository implements IReviewRepository {
+++     }
+++   }
+++ 
++++  /** レビュー対象ドキュメント名を更新 */
++++  async updateReviewHistoryTargetDocumentName(
++++    id: string,
++++    targetDocumentName: string,
++++  ): Promise<void> {
++++    try {
++++      const db = await getDb();
++++      await db
++++        .update(reviewHistories)
++++        .set({
++++          targetDocumentName,
++++        })
++++        .where(eq(reviewHistories.id, id));
++++    } catch (err) {
++++      throw repositoryError(
++++        'レビュー対象ドキュメント名の更新に失敗しました',
++++        err,
++++      );
++++    }
++++  }
++++
+++   /** レビュー履歴を削除 */
+++   async deleteReviewHistory(id: string): Promise<void> {
+++     try {
+++@@ -284,121 +316,426 @@ export class DrizzleReviewRepository implements IReviewRepository {
+++       reviewChecklistId: number;
+++       evaluation: ReviewEvaluation;
+++       comment: string;
+++-      fileId: string;
+++-      fileName: string;
+++     }[],
+++   ): Promise<void> {
+++     try {
+++       const db = await getDb();
+++       for (const result of results) {
+++-        const [upserted] = await db
+++-          .insert(reviewChecklistResults)
+++-          .values(result)
+++-          .onConflictDoUpdate({
+++-            target: [
+++-              reviewChecklistResults.reviewChecklistId,
+++-              reviewChecklistResults.fileId,
+++-            ],
+++-            set: {
+++-              evaluation: result.evaluation,
+++-              comment: result.comment,
+++-            },
++++        await db
++++          .update(reviewChecklists)
++++          .set({
++++            evaluation: result.evaluation,
++++            comment: result.comment,
+++           })
+++-          .returning();
++++          .where(eq(reviewChecklists.id, result.reviewChecklistId));
+++       }
+++     } catch (err) {
+++       throw repositoryError('レビュー結果の保存に失敗しました', err);
+++     }
+++   }
+++ 
+++-  /** レビュー結果を削除 */
+++-  async deleteReviewResults(
+++-    reviewChecklistId: number,
+++-    sourceId: number,
++++  /** チェックリスト結果を取得してグルーピング */
++++  async getReviewChecklistResults(
++++    reviewHistoryId: string,
++++  ): Promise<ReviewChecklistResult[]> {
++++    try {
++++      const db = await getDb();
++++      const rows = await db
++++        .select()
++++        .from(reviewChecklists)
++++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
++++        .orderBy(reviewChecklists.createdAt);
++++
++++      return rows.map((row) => ({
++++        id: row.id,
++++        content: row.content,
++++        sourceEvaluation: row.evaluation
++++          ? {
++++              evaluation: row.evaluation as ReviewEvaluation,
++++              comment: row.comment ?? undefined,
++++            }
++++          : undefined,
++++      }));
++++    } catch (err) {
++++      throw repositoryError('レビュー結果の取得に失敗しました', err);
++++    }
++++  }
++++
++++  /** すべてのレビュー結果を削除 */
++++  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
++++    try {
++++      const db = await getDb();
++++      await db
++++        .update(reviewChecklists)
++++        .set({
++++          evaluation: null,
++++          comment: null,
++++        })
++++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
++++    } catch (err) {
++++      throw repositoryError('レビュー結果の削除に失敗しました', err);
++++    }
++++  }
++++
++++  /** documentModeを更新 */
++++  async updateReviewHistoryDocumentMode(
++++    id: string,
++++    documentMode: DocumentMode,
+++   ): Promise<void> {
+++     try {
+++       const db = await getDb();
+++       await db
+++-        .delete(reviewChecklistResults)
++++        .update(reviewHistories)
++++        .set({
++++          documentMode,
++++        })
++++        .where(eq(reviewHistories.id, id));
++++    } catch (err) {
++++      throw repositoryError('ドキュメントモードの更新に失敗しました', err);
++++    }
++++  }
++++
++++  /**
++++   * ReviewDocumentCacheEntity → ReviewDocumentCache の変換
++++   * cachePathからファイルを読み込んでtextContent/imageDataに変換
++++   */
++++  private async convertDocumentCacheEntityToDomain(
++++    entity: ReviewDocumentCacheEntity,
++++  ): Promise<ReviewDocumentCache> {
++++    const base = {
++++      id: entity.id,
++++      reviewHistoryId: entity.reviewHistoryId,
++++      documentId: entity.documentId,
++++      fileName: entity.fileName,
++++      processMode: entity.processMode as ProcessMode,
++++      createdAt: entity.createdAt,
++++      updatedAt: entity.updatedAt,
++++    };
++++
++++    try {
++++      // cachePathからファイルを読み込む
++++      if (entity.processMode === 'text') {
++++        const textContent = await ReviewCacheHelper.loadTextCache(
++++          entity.cachePath,
++++        );
++++        return { ...base, textContent };
++++      } else if (entity.processMode === 'image') {
++++        const imageData = await ReviewCacheHelper.loadImageCache(
++++          entity.cachePath,
++++        );
++++        return { ...base, imageData };
++++      }
++++
++++      throw repositoryError('無効なprocessModeです', null);
++++    } catch (error) {
++++      // キャッシュファイル読み込みエラーの場合は専用のエラーメッセージを返す
++++      if (error instanceof Error && error.message.includes('Failed to load')) {
++++        throw internalError({
++++          expose: true,
++++          messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
++++          cause: error,
++++        });
++++      }
++++      // その他のエラーはそのまま再スロー
++++      throw error;
++++    }
++++  }
++++
++++  /** ドキュメントキャッシュを作成 */
++++  async createReviewDocumentCache(
++++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
++++  ): Promise<ReviewDocumentCache> {
++++    try {
++++      // 1. ファイルシステムにキャッシュを保存
++++      let cachePath: string;
++++
++++      if (cache.processMode === 'text' && cache.textContent) {
++++        cachePath = await ReviewCacheHelper.saveTextCache(
++++          cache.reviewHistoryId,
++++          cache.documentId,
++++          cache.textContent,
++++        );
++++      } else if (cache.processMode === 'image' && cache.imageData) {
++++        cachePath = await ReviewCacheHelper.saveImageCache(
++++          cache.reviewHistoryId,
++++          cache.documentId,
++++          cache.imageData,
++++        );
++++      } else {
++++        throw repositoryError(
++++          '無効なprocessModeまたはデータが不足しています',
++++          null,
++++        );
++++      }
++++
++++      // 2. DBにメタデータを保存
++++      const db = await getDb();
++++      const [entity] = await db
++++        .insert(reviewDocumentCaches)
++++        .values({
++++          reviewHistoryId: cache.reviewHistoryId,
++++          documentId: cache.documentId,
++++          fileName: cache.fileName,
++++          processMode: cache.processMode,
++++          cachePath,
++++        })
++++        .returning();
++++
++++      // 3. ファイルから読み込んでドメイン型に変換して返す
++++      return this.convertDocumentCacheEntityToDomain(entity);
++++    } catch (err) {
++++      if (err instanceof AppError) throw err;
++++      throw repositoryError('ドキュメントキャッシュの作成に失敗しました', err);
++++    }
++++  }
++++
++++  /** ドキュメントキャッシュ一覧を取得 */
++++  async getReviewDocumentCaches(
++++    reviewHistoryId: string,
++++  ): Promise<ReviewDocumentCache[]> {
++++    try {
++++      const db = await getDb();
++++      const entities = await db
++++        .select()
++++        .from(reviewDocumentCaches)
++++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId))
++++        .orderBy(reviewDocumentCaches.createdAt);
++++
++++      // 各EntityをDomain型に変換（ファイル読み込み含む）
++++      return Promise.all(
++++        entities.map((entity) =>
++++          this.convertDocumentCacheEntityToDomain(entity),
++++        ),
++++      );
++++    } catch (err) {
++++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
++++    }
++++  }
++++
++++  /** documentIdでドキュメントキャッシュを取得 */
++++  async getReviewDocumentCacheByDocumentId(
++++    reviewHistoryId: string,
++++    documentId: string,
++++  ): Promise<ReviewDocumentCache | null> {
++++    try {
++++      const db = await getDb();
++++      const [entity] = await db
++++        .select()
++++        .from(reviewDocumentCaches)
+++         .where(
+++           and(
+++-            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
+++-            eq(reviewChecklistResults.fileId, sourceId.toString()),
++++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
++++            eq(reviewDocumentCaches.documentId, documentId),
+++           ),
+++         );
++++
++++      if (!entity) return null;
++++
++++      return this.convertDocumentCacheEntityToDomain(entity);
+++     } catch (err) {
+++-      throw repositoryError('レビュー結果の削除に失敗しました', err);
++++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+++     }
+++   }
+++ 
+++-  /** チェックリスト結果を取得してグルーピング */
+++-  async getReviewChecklistResults(
++++  /** ドキュメントキャッシュを取得（複数ID対応） */
++++  async getReviewDocumentCacheByDocumentIds(
+++     reviewHistoryId: string,
+++-  ): Promise<ReviewChecklistResult[]> {
++++    documentIds: string[],
++++  ): Promise<ReviewDocumentCache[]> {
+++     try {
+++       const db = await getDb();
+++-      const rows = await db
++++      const entities = await db
++++        .select()
++++        .from(reviewDocumentCaches)
++++        .where(
++++          and(
++++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
++++            inArray(reviewDocumentCaches.documentId, documentIds),
++++          ),
++++        );
++++
++++      // 各EntityをDomain型に変換（ファイル読み込み含む）
++++      return Promise.all(
++++        entities.map((entity) =>
++++          this.convertDocumentCacheEntityToDomain(entity),
++++        ),
++++      );
++++    } catch (err) {
++++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
++++    }
++++  }
++++
++++  /** チェックリスト結果キャッシュを作成 */
++++  async createReviewLargedocumentResultCache(
++++    cache: ReviewLargedocumentResultCache,
++++  ): Promise<void> {
++++    try {
++++      const db = await getDb();
++++      await db.insert(reviewLargedocumentResultCaches).values({
++++        reviewDocumentCacheId: cache.reviewDocumentCacheId,
++++        reviewChecklistId: cache.reviewChecklistId,
++++        comment: cache.comment,
++++        totalChunks: cache.totalChunks,
++++        chunkIndex: cache.chunkIndex,
++++        individualFileName: cache.individualFileName,
++++      });
++++    } catch (err) {
++++      throw repositoryError(
++++        '大量ドキュメント結果キャッシュの作成に失敗しました',
++++        err,
++++      );
++++    }
++++  }
++++
++++  /** チェックリスト結果キャッシュ一覧を取得 */
++++  async getReviewLargedocumentResultCaches(
++++    reviewHistoryId: string,
++++  ): Promise<ReviewLargedocumentResultCache[]> {
++++    try {
++++      const db = await getDb();
++++      // reviewDocumentCachesとjoinしてreviewHistoryIdで絞り込む
++++      const results = await db
+++         .select({
+++-          checklistId: reviewChecklists.id,
+++-          content: reviewChecklists.content,
+++-          fileId: reviewChecklistResults.fileId,
+++-          fileName: reviewChecklistResults.fileName,
+++-          evaluation: reviewChecklistResults.evaluation,
+++-          comment: reviewChecklistResults.comment,
++++          reviewDocumentCacheId:
++++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
++++          reviewChecklistId: reviewLargedocumentResultCaches.reviewChecklistId,
++++          comment: reviewLargedocumentResultCaches.comment,
++++          totalChunks: reviewLargedocumentResultCaches.totalChunks,
++++          chunkIndex: reviewLargedocumentResultCaches.chunkIndex,
++++          individualFileName:
++++            reviewLargedocumentResultCaches.individualFileName,
+++         })
+++-        .from(reviewChecklists)
+++-        .leftJoin(
+++-          reviewChecklistResults,
+++-          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
++++        .from(reviewLargedocumentResultCaches)
++++        .innerJoin(
++++          reviewDocumentCaches,
++++          eq(
++++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
++++            reviewDocumentCaches.id,
++++          ),
+++         )
+++-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+++-        .orderBy(reviewChecklists.createdAt);
++++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
++++
++++      return results.map((row) => ({
++++        reviewDocumentCacheId: row.reviewDocumentCacheId,
++++        reviewChecklistId: row.reviewChecklistId,
++++        comment: row.comment,
++++        totalChunks: row.totalChunks,
++++        chunkIndex: row.chunkIndex,
++++        individualFileName: row.individualFileName,
++++      }));
++++    } catch (err) {
++++      throw repositoryError(
++++        '大量ドキュメント結果キャッシュの取得に失敗しました',
++++        err,
++++      );
++++    }
++++  }
++++
++++  /** 特定ドキュメントの最大totalChunks数を取得（レビューチャット用） */
++++  async getMaxTotalChunksForDocument(
++++    reviewHistoryId: string,
++++    documentId: string,
++++  ): Promise<number> {
++++    try {
++++      const db = await getDb();
+++ 
+++-      const map = new Map<number, ReviewChecklistResult>();
+++-      for (const row of rows) {
+++-        let group = map.get(row.checklistId);
+++-        if (!group) {
+++-          group = {
+++-            id: row.checklistId,
+++-            content: row.content,
+++-            sourceEvaluations: [],
+++-          };
+++-          map.set(row.checklistId, group);
+++-        }
+++-        if (row.fileId !== null && row.fileName !== null) {
+++-          group.sourceEvaluations!.push({
+++-            fileId: row.fileId,
+++-            fileName: row.fileName,
+++-            evaluation: row.evaluation as ReviewEvaluation,
+++-            comment: row.comment ?? undefined,
+++-          });
+++-        }
++++      // まずdocumentIdからreviewDocumentCacheIdを取得
++++      const [cache] = await db
++++        .select({ id: reviewDocumentCaches.id })
++++        .from(reviewDocumentCaches)
++++        .where(
++++          and(
++++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
++++            eq(reviewDocumentCaches.documentId, documentId),
++++          ),
++++        );
++++
++++      if (!cache) {
++++        // ドキュメントキャッシュが存在しない場合は1を返す
++++        return 1;
+++       }
+++-      return Array.from(map.values());
++++
++++      // 該当ドキュメントのtotalChunksの最大値を取得
++++      const result = await db
++++        .select({ maxChunks: max(reviewLargedocumentResultCaches.totalChunks) })
++++        .from(reviewLargedocumentResultCaches)
++++        .where(
++++          eq(reviewLargedocumentResultCaches.reviewDocumentCacheId, cache.id),
++++        );
++++
++++      const maxChunks = result[0]?.maxChunks;
++++
++++      // レコードが存在しない場合は1を返す（初回処理）
++++      return maxChunks ?? 1;
+++     } catch (err) {
+++-      throw repositoryError('レビュー結果の取得に失敗しました', err);
++++      throw repositoryError(
++++        'ドキュメントの最大チャンク数取得に失敗しました',
++++        err,
++++      );
+++     }
+++   }
+++ 
+++-  /** すべてのレビュー結果を削除 */
+++-  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
++++  /** レビューチャット用: チェックリストと結果を取得 */
++++  async getChecklistResultsWithIndividualResults(
++++    reviewHistoryId: string,
++++    checklistIds: number[],
++++  ): Promise<
++++    Array<{
++++      checklistResult: ReviewChecklistResult;
++++      individualResults?: Array<{
++++        documentId: number;
++++        comment: string;
++++        individualFileName: string;
++++      }>;
++++    }>
++++  > {
+++     try {
+++       const db = await getDb();
+++-      const checklists = await db
+++-        .select({ id: reviewChecklists.id })
++++
++++      // チェックリストを取得
++++      const checklistEntities = await db
++++        .select()
+++         .from(reviewChecklists)
+++-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
++++        .where(
++++          and(
++++            eq(reviewChecklists.reviewHistoryId, reviewHistoryId),
++++            inArray(reviewChecklists.id, checklistIds),
++++          ),
++++        );
+++ 
+++-      // チェックリストが無ければ何もしない
+++-      if (checklists.length === 0) return;
++++      // 個別レビュー結果キャッシュを取得
++++      const individualCaches =
++++        await this.getReviewLargedocumentResultCaches(reviewHistoryId);
+++ 
+++-      for (const { id } of checklists) {
+++-        await db
+++-          .delete(reviewChecklistResults)
+++-          .where(eq(reviewChecklistResults.reviewChecklistId, id));
+++-      }
++++      // 結果を組み立て
++++      return checklistEntities.map((entity) => {
++++        // 個別レビュー結果を抽出
++++        const individualResults = individualCaches
++++          .filter((cache) => cache.reviewChecklistId === entity.id)
++++          .map((cache) => ({
++++            documentId: cache.reviewDocumentCacheId,
++++            comment: cache.comment,
++++            individualFileName: cache.individualFileName,
++++          }));
++++
++++        // ReviewChecklistResult型を構築
++++        const checklistResult: ReviewChecklistResult = {
++++          id: entity.id,
++++          content: entity.content,
++++          sourceEvaluation: {
++++            evaluation: entity.evaluation ?? undefined,
++++            comment: entity.comment ?? undefined,
++++          },
++++        };
++++
++++        return {
++++          checklistResult,
++++          individualResults:
++++            individualResults.length > 0 ? individualResults : undefined,
++++        };
++++      });
+++     } catch (err) {
+++-      throw repositoryError('レビュー結果の削除に失敗しました', err);
++++      throw repositoryError('チェックリストと結果の取得に失敗しました', err);
+++     }
+++   }
+++ }
+++diff --git a/src/adapter/db/drizzle/schema.ts b/src/adapter/db/drizzle/schema.ts
+++index 39ffd9c64..20643f956 100644
+++--- a/src/adapter/db/drizzle/schema.ts
++++++ b/src/adapter/db/drizzle/schema.ts
+++@@ -59,9 +59,11 @@ export const reviewHistories = sqliteTable('review_histories', {
+++     .primaryKey()
+++     .$default(() => uuidv4()), // 汎用チャット機能のコードを活用できるように、MastraのThreadと同じく主キーは文字列とする
+++   title: text('title').notNull(), // ソースのtitleを/区切りで結合
++++  targetDocumentName: text('target_document_name'), // レビュー対象の統合ドキュメント名
+++   additionalInstructions: text('additional_instructions'), // レビューの追加指示
+++   commentFormat: text('comment_format'), // レビューのコメントフォーマット
+++   evaluationSettings: text('evaluation_settings'), // 評定項目設定（JSON形式）
++++  documentMode: text('document_mode'), // レビュー実行方法: small, large
+++   processingStatus: text('processing_status').notNull().default('idle'), // 処理ステータス: idle, extracting, extracted, reviewing, completed
+++   createdAt: text('created_at')
+++     .notNull()
+++@@ -79,6 +81,8 @@ export const reviewChecklists = sqliteTable('review_checklists', {
+++     .notNull()
+++     .references(() => reviewHistories.id, { onDelete: 'cascade' }),
+++   content: text('content').notNull(), // チェックリスト項目
++++  evaluation: text('evaluation'), // A, B, C, - 評価
++++  comment: text('comment'), // レビューコメント
+++   createdBy: text('created_by').notNull(), // 'user' or 'system'
+++   createdAt: text('created_at')
+++     .notNull()
+++@@ -89,26 +93,49 @@ export const reviewChecklists = sqliteTable('review_checklists', {
+++     .$onUpdate(() => sql`(current_timestamp)`),
+++ });
+++ 
+++-// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
+++-export const reviewChecklistResults = sqliteTable(
+++-  'review_checklist_results',
++++// レビュードキュメントキャッシュを格納するテーブル
++++export const reviewDocumentCaches = sqliteTable('review_document_caches', {
++++  id: integer('id').primaryKey({ autoIncrement: true }),
++++  reviewHistoryId: text('review_history_id')
++++    .notNull()
++++    .references(() => reviewHistories.id, { onDelete: 'cascade' }),
++++  documentId: text('document_id').notNull(), // ワークフロー内のドキュメントID
++++  fileName: text('file_name').notNull(), // ワークフロー内での名前（分割時は "xxx (part 1)" など）
++++  processMode: text('process_mode').notNull(), // 'text' or 'image'
++++  cachePath: text('cache_path').notNull(), // ファイル/ディレクトリパス
++++  createdAt: text('created_at')
++++    .notNull()
++++    .default(sql`(current_timestamp)`),
++++  updatedAt: text('updated_at')
++++    .notNull()
++++    .default(sql`(current_timestamp)`)
++++    .$onUpdate(() => sql`(current_timestamp)`),
++++});
++++
++++// レビュー大量ドキュメント結果キャッシュを格納するテーブル（大量ドキュメントレビューの個別レビュー結果）
++++export const reviewLargedocumentResultCaches = sqliteTable(
++++  'review_largedocument_result_caches',
+++   {
++++    reviewDocumentCacheId: integer('review_document_cache_id')
++++      .notNull()
++++      .references(() => reviewDocumentCaches.id, { onDelete: 'cascade' }),
+++     reviewChecklistId: integer('review_checklist_id')
+++       .notNull()
+++       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
+++-    fileId: text('file_id').notNull(), // アップロードファイルのID
+++-    fileName: text('file_name').notNull(), // ファイル名
+++-    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
+++-    comment: text('comment'), // レビューコメント
+++-    createdAt: text('created_at')
+++-      .notNull()
+++-      .default(sql`(current_timestamp)`),
+++-    updatedAt: text('updated_at')
+++-      .notNull()
+++-      .default(sql`(current_timestamp)`)
+++-      .$onUpdate(() => sql`(current_timestamp)`),
++++    comment: text('comment').notNull(), // 個別レビューコメント
++++    totalChunks: integer('total_chunks').notNull(), // ドキュメント分割総数
++++    chunkIndex: integer('chunk_index').notNull(), // 何番目のチャンクか（0から始まる）
++++    individualFileName: text('individual_file_name').notNull(), // 分割後の個別ドキュメント名（"xxx (part 1)" など）
+++   },
+++-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
++++  (table) => ({
++++    pk: primaryKey({
++++      columns: [
++++        table.reviewDocumentCacheId,
++++        table.reviewChecklistId,
++++        table.chunkIndex,
++++      ],
++++    }),
++++  }),
+++ );
+++ 
+++ // 型定義
+++@@ -120,6 +147,11 @@ export type ReviewHistoryEntity = typeof reviewHistories.$inferSelect;
+++ export type InsertReviewHistoryEntity = typeof reviewHistories.$inferInsert;
+++ export type ReviewChecklistEntity = typeof reviewChecklists.$inferSelect;
+++ export type InsertReviewChecklistEntity = typeof reviewChecklists.$inferInsert;
+++-export type ReviewChecklistResultEntity = typeof reviewChecklistResults.$inferSelect;
+++-export type InsertReviewChecklistResultEntity =
+++-  typeof reviewChecklistResults.$inferInsert;
++++export type ReviewDocumentCacheEntity =
++++  typeof reviewDocumentCaches.$inferSelect;
++++export type InsertReviewDocumentCacheEntity =
++++  typeof reviewDocumentCaches.$inferInsert;
++++export type ReviewLargedocumentResultCacheEntity =
++++  typeof reviewLargedocumentResultCaches.$inferSelect;
++++export type InsertReviewLargedocumentResultCacheEntity =
++++  typeof reviewLargedocumentResultCaches.$inferInsert;
+++diff --git a/src/main/lib/csvParser.ts b/src/main/lib/csvParser.ts
+++index 5a7817356..c2f82751c 100644
+++--- a/src/main/lib/csvParser.ts
++++++ b/src/main/lib/csvParser.ts
+++@@ -101,7 +101,7 @@ export class CsvParser {
+++    * @returns 空行の場合true
+++    */
+++   private static isEmptyRow(row: string[]): boolean {
+++-    return row.every(cell => cell.trim() === '');
++++    return row.every((cell) => cell.trim() === '');
+++   }
+++ 
+++   /**
+++@@ -109,7 +109,10 @@ export class CsvParser {
+++    * @param csvText CSVテキスト
+++    * @returns 検証結果
+++    */
+++-  public static validate(csvText: string): { isValid: boolean; error?: string } {
++++  public static validate(csvText: string): {
++++    isValid: boolean;
++++    error?: string;
++++  } {
+++     try {
+++       let inQuotes = false;
+++       let quoteCount = 0;
+++@@ -139,4 +142,4 @@ export class CsvParser {
+++       return { isValid: false, error: `CSV解析エラー: ${error}` };
+++     }
+++   }
+++-}
+++\ No newline at end of file
++++}
+++diff --git a/src/main/lib/fileExtractor.ts b/src/main/lib/fileExtractor.ts
+++index f7f136069..d57d7f454 100644
+++--- a/src/main/lib/fileExtractor.ts
++++++ b/src/main/lib/fileExtractor.ts
+++@@ -166,7 +166,10 @@ export default class FileExtractor {
+++ 
+++       // ファイルが更新されている場合はキャッシュを無効とする
+++       if (stats.mtimeMs !== cacheData.metadata.lastModified) {
+++-        logger.debug({ filePath, cachePath }, 'ファイルが更新されているためキャッシュを無効化します');
++++        logger.debug(
++++          { filePath, cachePath },
++++          'ファイルが更新されているためキャッシュを無効化します',
++++        );
+++         await this.deleteCache(filePath);
+++         return null;
+++       }
+++@@ -200,7 +203,11 @@ export default class FileExtractor {
+++           extractedAt: Date.now(),
+++         },
+++       };
+++-      await fs.writeFile(cachePath, JSON.stringify(cacheData, null, 2), 'utf-8');
++++      await fs.writeFile(
++++        cachePath,
++++        JSON.stringify(cacheData, null, 2),
++++        'utf-8',
++++      );
+++     } catch (error) {
+++       // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
+++       logger.error({ error, filePath }, 'キャッシュの保存に失敗しました');
+++@@ -738,14 +745,18 @@ try {
+++             if (stats.mtimeMs !== cacheData.metadata.lastModified) {
+++               await fs.unlink(cacheFilePath);
+++               deletedCount++;
+++-              logger.debug(`ファイル更新日時が古いキャッシュを削除: ${fileName}`);
++++              logger.debug(
++++                `ファイル更新日時が古いキャッシュを削除: ${fileName}`,
++++              );
+++             }
+++           } catch (statError) {
+++             // 元ファイルが存在しない場合は削除
+++             if ((statError as NodeJS.ErrnoException).code === 'ENOENT') {
+++               await fs.unlink(cacheFilePath);
+++               deletedCount++;
+++-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
++++              logger.debug(
++++                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
++++              );
+++             }
+++           }
+++         } catch (processError) {
+++@@ -755,14 +766,22 @@ try {
+++             deletedCount++;
+++             logger.debug(`不正なキャッシュファイルを削除: ${fileName}`);
+++           } catch (unlinkError) {
+++-            logger.error({ error: unlinkError, fileName }, 'キャッシュファイルの削除に失敗');
++++            logger.error(
++++              { error: unlinkError, fileName },
++++              'キャッシュファイルの削除に失敗',
++++            );
+++           }
+++         }
+++       }
+++ 
+++-      logger.info(`キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`);
++++      logger.info(
++++        `キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`,
++++      );
+++     } catch (error) {
+++-      logger.error({ error }, 'キャッシュディレクトリのクリーニングに失敗しました');
++++      logger.error(
++++        { error },
++++        'キャッシュディレクトリのクリーニングに失敗しました',
++++      );
+++     }
+++   }
+++ }
+++diff --git a/src/main/lib/logger.ts b/src/main/lib/logger.ts
+++index 0aa5282a2..b55e75012 100644
+++--- a/src/main/lib/logger.ts
++++++ b/src/main/lib/logger.ts
+++@@ -6,7 +6,8 @@ import path from 'path';
+++ const logLevel = getLogLevel();
+++ log.transports.file.level = logLevel;
+++ log.transports.console.level = logLevel;
+++-log.transports.file.resolvePathFn = () => path.join(getCustomAppDataDir(), 'main.log');
++++log.transports.file.resolvePathFn = () =>
++++  path.join(getCustomAppDataDir(), 'main.log');
+++ 
+++ // シングルトン変数
+++ let _mainLogger: Logger.MainLogger | null = null;
+++diff --git a/src/main/lib/officeConverter.ts b/src/main/lib/officeConverter.ts
+++index 55663f57a..fc8d0147a 100644
+++--- a/src/main/lib/officeConverter.ts
++++++ b/src/main/lib/officeConverter.ts
+++@@ -199,9 +199,16 @@ async function saveCache(
+++       cachePdfPath,
+++       cachedAt: Date.now(),
+++     };
+++-    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf-8');
++++    await fs.writeFile(
++++      metadataPath,
++++      JSON.stringify(metadata, null, 2),
++++      'utf-8',
++++    );
+++ 
+++-    logger.debug({ originalFilePath, cachePdfPath }, 'PDFキャッシュを保存しました');
++++    logger.debug(
++++      { originalFilePath, cachePdfPath },
++++      'PDFキャッシュを保存しました',
++++    );
+++   } catch (error) {
+++     // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
+++     logger.error({ error, originalFilePath }, 'キャッシュの保存に失敗しました');
+++@@ -789,7 +796,9 @@ export async function cleanCacheDirectory(): Promise<void> {
+++               // 対応するPDFファイルも削除
+++               await fs.unlink(metadata.cachePdfPath).catch(() => void 0);
+++               deletedCount++;
+++-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
++++              logger.debug(
++++                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
++++              );
+++             }
+++           }
+++         }
+++diff --git a/src/main/lib/util.ts b/src/main/lib/util.ts
+++index e3c43a641..9544e872f 100644
+++--- a/src/main/lib/util.ts
++++++ b/src/main/lib/util.ts
+++@@ -32,7 +32,9 @@ export function toAbsolutePath(dirOrPath: string, fileName?: string): string {
+++       throw internalError({
+++         expose: false,
+++         messageCode: 'VALIDATION_ERROR',
+++-        messageParams: { detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。` },
++++        messageParams: {
++++          detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。`,
++++        },
+++       });
+++     }
+++     // ディレクトリ部を取り出して結合
+++@@ -68,7 +70,9 @@ export function isPathExists(dirOrPath: string): boolean {
+++     throw internalError({
+++       expose: true,
+++       messageCode: 'VALIDATION_ERROR',
+++-      messageParams: { detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}` },
++++      messageParams: {
++++        detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
++++      },
+++     });
+++   }
+++ }
+++diff --git a/src/main/lib/utils/reviewCacheHelper.ts b/src/main/lib/utils/reviewCacheHelper.ts
+++new file mode 100644
+++index 000000000..fd2f7659b
+++--- /dev/null
++++++ b/src/main/lib/utils/reviewCacheHelper.ts
+++@@ -0,0 +1,127 @@
++++import * as fs from 'fs/promises';
++++import * as path from 'path';
++++import { app } from 'electron';
++++
++++/**
++++ * レビュー機能で使用するキャッシュファイルの管理ヘルパークラス
++++ */
++++export class ReviewCacheHelper {
++++  /**
++++   * キャッシュベースディレクトリ取得
++++   */
++++  private static getCacheBaseDir(reviewHistoryId: string): string {
++++    return path.join(
++++      app.getPath('userData'),
++++      'review_cache',
++++      reviewHistoryId,
++++      'file_cache',
++++    );
++++  }
++++
++++  /**
++++   * テキストキャッシュ保存
++++   * @param reviewHistoryId レビュー履歴ID
++++   * @param documentId ドキュメントID
++++   * @param content テキスト内容
++++   * @returns ファイルパス
++++   */
++++  static async saveTextCache(
++++    reviewHistoryId: string,
++++    documentId: string,
++++    content: string,
++++  ): Promise<string> {
++++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
++++    await fs.mkdir(baseDir, { recursive: true });
++++
++++    const cachePath = path.join(baseDir, `${documentId}.txt`);
++++    await fs.writeFile(cachePath, content, 'utf-8');
++++
++++    return cachePath;
++++  }
++++
++++  /**
++++   * 画像キャッシュ保存（複数ページ対応）
++++   * @param reviewHistoryId レビュー履歴ID
++++   * @param documentId ドキュメントID
++++   * @param imageData Base64画像データ配列
++++   * @returns ディレクトリパス
++++   */
++++  static async saveImageCache(
++++    reviewHistoryId: string,
++++    documentId: string,
++++    imageData: string[],
++++  ): Promise<string> {
++++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
++++    const imageCacheDir = path.join(baseDir, documentId);
++++    await fs.mkdir(imageCacheDir, { recursive: true });
++++
++++    for (let i = 0; i < imageData.length; i++) {
++++      const pagePath = path.join(imageCacheDir, `page_${i}.b64`);
++++      await fs.writeFile(pagePath, imageData[i], 'utf-8');
++++    }
++++
++++    return imageCacheDir;
++++  }
++++
++++  /**
++++   * テキストキャッシュ読み込み
++++   * @param cachePath ファイルパス
++++   * @returns テキスト内容
++++   * @throws ファイルが存在しない場合やアクセスできない場合にエラーをスロー
++++   */
++++  static async loadTextCache(cachePath: string): Promise<string> {
++++    try {
++++      return await fs.readFile(cachePath, 'utf-8');
++++    } catch (error) {
++++      // ファイルが存在しない、またはアクセスできない場合
++++      throw new Error(
++++        `Failed to load text cache from ${cachePath}: ${error instanceof Error ? error.message : String(error)}`,
++++      );
++++    }
++++  }
++++
++++  /**
++++   * 画像キャッシュ読み込み
++++   * @param cacheDir ディレクトリパス
++++   * @returns Base64画像データ配列
++++   * @throws ディレクトリが存在しない場合やアクセスできない場合にエラーをスロー
++++   */
++++  static async loadImageCache(cacheDir: string): Promise<string[]> {
++++    try {
++++      const files = await fs.readdir(cacheDir);
++++      const imageFiles = files
++++        .filter((f) => f.endsWith('.b64'))
++++        .sort((a, b) => {
++++          const aNum = parseInt(a.match(/page_(\d+)\.b64/)?.[1] || '0');
++++          const bNum = parseInt(b.match(/page_(\d+)\.b64/)?.[1] || '0');
++++          return aNum - bNum;
++++        });
++++
++++      const imageData: string[] = [];
++++      for (const file of imageFiles) {
++++        const content = await fs.readFile(path.join(cacheDir, file), 'utf-8');
++++        imageData.push(content);
++++      }
++++
++++      return imageData;
++++    } catch (error) {
++++      // ディレクトリが存在しない、またはアクセスできない場合
++++      throw new Error(
++++        `Failed to load image cache from ${cacheDir}: ${error instanceof Error ? error.message : String(error)}`,
++++      );
++++    }
++++  }
++++
++++  /**
++++   * キャッシュディレクトリ削除
++++   * @param reviewHistoryId レビュー履歴ID
++++   */
++++  static async deleteCacheDirectory(reviewHistoryId: string): Promise<void> {
++++    const cacheDir = path.join(
++++      app.getPath('userData'),
++++      'review_cache',
++++      reviewHistoryId,
++++    );
++++    await fs.rm(cacheDir, { recursive: true, force: true });
++++  }
++++}
+++diff --git a/src/main/main.ts b/src/main/main.ts
+++index 047392026..605d337f2 100644
+++--- a/src/main/main.ts
++++++ b/src/main/main.ts
+++@@ -272,12 +272,7 @@ const setupChatHandlers = () => {
+++     IpcChannels.CHAT_SEND_MESSAGE,
+++     async ({ roomId, messages }, { event }) => {
+++       try {
+++-        const dataStream = await chatService.generate(
+++-          userId,
+++-          roomId,
+++-          messages,
+++-          event,
+++-        );
++++        const dataStream = await chatService.generate(userId, roomId, messages);
+++ 
+++         // テキストストリームを処理
+++         // @ts-ignore
+++@@ -542,6 +537,43 @@ const setupReviewHandlers = () => {
+++     }
+++     return undefined as never;
+++   });
++++
++++  // レビューチャットメッセージ送信ハンドラ
++++  handleIpc(
++++    IpcChannels.REVIEW_CHAT_SEND_MESSAGE,
++++    async ({ reviewHistoryId, checklistIds, question }) => {
++++      try {
++++        const dataStream = await reviewService.chatWithReview(
++++          reviewHistoryId,
++++          checklistIds,
++++          question,
++++        );
++++
++++        // テキストストリームを処理
++++        // @ts-ignore
++++        for await (const chunk of dataStream) {
++++          // チャンクをフロントエンドに送信
++++          publishEvent(IpcChannels.REVIEW_CHAT_STREAM_RESPONSE, chunk);
++++        }
++++
++++        return undefined as never;
++++      } catch (error) {
++++        // エラー時もAbortControllerを削除
++++        reviewService.abortReviewChat(reviewHistoryId);
++++        const normalizedError = normalizeUnknownError(error);
++++        publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
++++          message: normalizedError.message,
++++        });
++++        throw normalizedError;
++++      }
++++    },
++++  );
++++
++++  // レビューチャット中断ハンドラ
++++  handleIpc(IpcChannels.REVIEW_CHAT_ABORT, async (reviewHistoryId) => {
++++    const result = reviewService.abortReviewChat(reviewHistoryId);
++++    return undefined as never;
++++  });
+++ };
+++ 
+++ // ソース登録処理の実行
+++diff --git a/src/main/preload.ts b/src/main/preload.ts
+++index fa8d0f9c8..c32d7113f 100644
+++--- a/src/main/preload.ts
++++++ b/src/main/preload.ts
+++@@ -147,6 +147,13 @@ const electronHandler = {
+++     /** レビュー実行キャンセル */
+++     abortExecute: (reviewHistoryId: string) =>
+++       invokeIpc(IpcChannels.REVIEW_EXECUTE_ABORT, reviewHistoryId),
++++    /** レビューチャットメッセージ送信 */
++++    sendChatMessage: (
++++      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE],
++++    ) => invokeIpc(IpcChannels.REVIEW_CHAT_SEND_MESSAGE, params),
++++    /** レビューチャット中断 */
++++    abortChat: (reviewHistoryId: string) =>
++++      invokeIpc(IpcChannels.REVIEW_CHAT_ABORT, reviewHistoryId),
+++   },
+++   pushApi: {
+++     async subscribe<C extends EventChannel>(
+++diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
+++index 43df9c6a8..625443fe6 100644
+++--- a/src/main/service/chatService.ts
++++++ b/src/main/service/chatService.ts
+++@@ -120,7 +120,6 @@ export class ChatService implements IChatService {
+++     userId: string,
+++     threadId: string,
+++     messages: ChatMessage[],
+++-    event: Electron.IpcMainInvokeEvent,
+++   ) {
+++     // 新しいAbortControllerを作成
+++     const controller = this.abortControllerManager.getOrCreateAbortController(
+++diff --git a/src/main/service/port/repository/IReviewRepository.ts b/src/main/service/port/repository/IReviewRepository.ts
+++index b558873e1..60b64222e 100644
+++--- a/src/main/service/port/repository/IReviewRepository.ts
++++++ b/src/main/service/port/repository/IReviewRepository.ts
+++@@ -1,10 +1,13 @@
+++ import {
+++   CustomEvaluationSettings,
++++  DocumentMode,
+++   ProcessingStatus,
+++   RevieHistory,
+++   ReviewChecklist,
+++   ReviewChecklistCreatedBy,
+++   ReviewChecklistResult,
++++  ReviewDocumentCache,
++++  ReviewLargedocumentResultCache,
+++   ReviewEvaluation,
+++ } from '@/types';
+++ 
+++@@ -30,6 +33,10 @@ export interface IReviewRepository {
+++     id: string,
+++     processingStatus: ProcessingStatus,
+++   ): Promise<void>;
++++  updateReviewHistoryTargetDocumentName(
++++    id: string,
++++    targetDocumentName: string,
++++  ): Promise<void>;
+++   deleteReviewHistory(id: string): Promise<void>;
+++ 
+++   // チェックリスト
+++@@ -49,16 +56,59 @@ export interface IReviewRepository {
+++       reviewChecklistId: number;
+++       evaluation: ReviewEvaluation;
+++       comment: string;
+++-      fileId: string;
+++-      fileName: string;
+++     }[],
+++   ): Promise<void>;
+++-  deleteReviewResults(
+++-    reviewChecklistId: number,
+++-    sourceId: number,
+++-  ): Promise<void>;
+++   getReviewChecklistResults(
+++     reviewHistoryId: string,
+++   ): Promise<ReviewChecklistResult[]>;
+++   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
++++
++++  // documentModeの保存
++++  updateReviewHistoryDocumentMode(
++++    id: string,
++++    documentMode: DocumentMode,
++++  ): Promise<void>;
++++
++++  // ドキュメントキャッシュ管理
++++  createReviewDocumentCache(
++++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
++++  ): Promise<ReviewDocumentCache>;
++++  getReviewDocumentCaches(
++++    reviewHistoryId: string,
++++  ): Promise<ReviewDocumentCache[]>;
++++  getReviewDocumentCacheByDocumentId(
++++    reviewHistoryId: string,
++++    documentId: string,
++++  ): Promise<ReviewDocumentCache | null>;
++++  getReviewDocumentCacheByDocumentIds(
++++    reviewHistoryId: string,
++++    documentIds: string[],
++++  ): Promise<ReviewDocumentCache[]>;
++++
++++  // 大量ドキュメント結果キャッシュ管理
++++  createReviewLargedocumentResultCache(
++++    cache: ReviewLargedocumentResultCache,
++++  ): Promise<void>;
++++  getReviewLargedocumentResultCaches(
++++    reviewHistoryId: string,
++++  ): Promise<ReviewLargedocumentResultCache[]>;
++++  getMaxTotalChunksForDocument(
++++    reviewHistoryId: string,
++++    documentId: string,
++++  ): Promise<number>;
++++
++++  // レビューチャット用: チェックリスト結果と個別レビュー結果を取得
++++  getChecklistResultsWithIndividualResults(
++++    reviewHistoryId: string,
++++    checklistIds: number[],
++++  ): Promise<
++++    Array<{
++++      checklistResult: ReviewChecklistResult;
++++      individualResults?: Array<{
++++        documentId: number;
++++        comment: string;
++++        individualFileName: string;
++++      }>;
++++    }>
++++  >;
+++ }
+++diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
+++index c65bd4539..8ced9789e 100644
+++--- a/src/main/service/reviewService.ts
++++++ b/src/main/service/reviewService.ts
+++@@ -1,3 +1,7 @@
++++import { createDataStream } from 'ai';
++++// @ts-ignore
++++import { RuntimeContext } from '@mastra/core/runtime-context';
++++import { v4 as uuid } from 'uuid';
+++ import { getReviewRepository } from '@/adapter/db';
+++ import {
+++   ReviewChecklistEdit,
+++@@ -20,11 +24,14 @@ import { getMainLogger } from '../lib/logger';
+++ import { mastra } from '@/mastra';
+++ import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
+++ import { formatMessage } from '../lib/messages';
++++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
++++import { ReviewChatWorkflowRuntimeContext } from '@/mastra/workflows/reviewChat';
+++ 
+++ export interface IReviewService {
+++   getReviewHistories(): Promise<RevieHistory[]>;
+++   getReviewHistoryDetail(reviewHistoryId: string): Promise<{
+++     checklistResults: ReviewChecklistResult[];
++++    targetDocumentName?: string | null;
+++   }>;
+++   getReviewInstruction(reviewHistoryId: string): Promise<{
+++     additionalInstructions?: string;
+++@@ -49,6 +56,15 @@ export interface IReviewService {
+++     reviewHistoryId: string,
+++     files: UploadFile[],
+++   ): Promise<void>;
++++  chatWithReview(
++++    reviewHistoryId: string,
++++    checklistIds: number[],
++++    question: string,
++++  ): Promise<ReturnType<typeof createDataStream>>;
++++  abortReviewChat(reviewHistoryId: string): {
++++    success: boolean;
++++    error?: string;
++++  };
+++ }
+++ 
+++ const logger = getMainLogger();
+++@@ -82,8 +98,11 @@ export class ReviewService implements IReviewService {
+++   public async getReviewHistoryDetail(reviewHistoryId: string) {
+++     const checklistResults =
+++       await this.reviewRepository.getReviewChecklistResults(reviewHistoryId);
++++    const reviewHistory =
++++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
+++     return {
+++       checklistResults: checklistResults,
++++      targetDocumentName: reviewHistory?.targetDocumentName,
+++     };
+++   }
+++ 
+++@@ -105,7 +124,18 @@ export class ReviewService implements IReviewService {
+++    * レビュー履歴を削除
+++    */
+++   public async deleteReviewHistory(reviewHistoryId: string) {
+++-    return this.reviewRepository.deleteReviewHistory(reviewHistoryId);
++++    await this.reviewRepository.deleteReviewHistory(reviewHistoryId);
++++
++++    // キャッシュディレクトリも削除
++++    try {
++++      await ReviewCacheHelper.deleteCacheDirectory(reviewHistoryId);
++++    } catch (err) {
++++      // キャッシュ削除失敗はログのみ（DB削除は成功しているため）
++++      logger.warn(
++++        err,
++++        `キャッシュディレクトリの削除に失敗しました: ${reviewHistoryId}`,
++++      );
++++    }
+++   }
+++ 
+++   /**
+++@@ -116,7 +146,8 @@ export class ReviewService implements IReviewService {
+++     checklistEdits: ReviewChecklistEdit[],
+++   ) {
+++     // レビュー履歴が存在しない場合は新規作成
+++-    let reviewHistory = await this.reviewRepository.getReviewHistory(reviewHistoryId);
++++    let reviewHistory =
++++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
+++     if (reviewHistory === null) {
+++       reviewHistory = await this.reviewRepository.createReviewHistory(
+++         generateReviewTitle(),
+++@@ -197,7 +228,9 @@ export class ReviewService implements IReviewService {
+++       }
+++ 
+++       // システム作成のチェックリストを削除（手動作成分は保持）
+++-      await this.reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
++++      await this.reviewRepository.deleteSystemCreatedChecklists(
++++        reviewHistoryId,
++++      );
+++ 
+++       const allChecklistItems: string[] = [];
+++ 
+++@@ -223,7 +256,11 @@ export class ReviewService implements IReviewService {
+++ 
+++       // チェックリスト項目をDBに保存
+++       for (const item of uniqueChecklistItems) {
+++-        await this.reviewRepository.createChecklist(reviewHistoryId, item, 'system');
++++        await this.reviewRepository.createChecklist(
++++          reviewHistoryId,
++++          item,
++++          'system',
++++        );
+++       }
+++       // AI処理と同様のイベント通知を発火
+++       publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
+++@@ -660,4 +697,147 @@ export class ReviewService implements IReviewService {
+++       return { success: false, error: err.message };
+++     }
+++   }
++++
++++  /**
++++   * レビューチャット実行
++++   * @param reviewHistoryId レビュー履歴ID
++++   * @param checklistIds チェックリストID配列
++++   * @param question ユーザからの質問
++++   * @returns DataStream
++++   */
++++  public async chatWithReview(
++++    reviewHistoryId: string,
++++    checklistIds: number[],
++++    question: string,
++++  ): Promise<ReturnType<typeof createDataStream>> {
++++    // DataStreamを生成
++++    const dataStream = createDataStream({
++++      execute: async (writer) => {
++++        try {
++++          // Mastraワークフローを取得
++++          const workflow = mastra.getWorkflow('reviewChatWorkflow');
++++
++++          if (!workflow) {
++++            logger.error('レビュー実行ワークフローが見つかりません');
++++            throw internalError({
++++              expose: false,
++++            });
++++          }
++++
++++          // 質問テキストから本文のみを抽出
++++          // フォーマット: @チェックリスト行 + 空行 + 本文
++++          const lines = question.split('\n');
++++          const bodyLines: string[] = [];
++++          let foundEmptyLine = false;
++++
++++          for (const line of lines) {
++++            // @で始まる行は除外
++++            if (line.trim().startsWith('@')) {
++++              continue;
++++            }
++++
++++            // 最初の空行を見つけた後から本文開始
++++            if (!foundEmptyLine && line.trim() === '') {
++++              foundEmptyLine = true;
++++              continue;
++++            }
++++
++++            // 空行を見つけた後の行を本文として抽出
++++            if (foundEmptyLine) {
++++              bodyLines.push(line);
++++            }
++++          }
++++
++++          const bodyText = bodyLines.join('\n').trim();
++++
++++          // ランタイムコンテキストを作成
++++          const runtimeContext =
++++            new RuntimeContext<ReviewChatWorkflowRuntimeContext>();
++++          runtimeContext.set('dataStreamWriter', writer);
++++          runtimeContext.set('toolCallId', uuid());
++++
++++          const run = await workflow.createRunAsync();
++++
++++          // workflowをrunningWorkflowsに登録
++++          const workflowKey = `chat_${reviewHistoryId}`;
++++
++++          // 実行中のワークフローを管理
++++          this.runningWorkflows.set(workflowKey, {
++++            cancel: () => run.cancel(),
++++          });
++++
++++          // ストリーミングはworkflow内部で実行されるため、ここでは結果を待つだけ
++++          const result = await run.start({
++++            inputData: {
++++              reviewHistoryId,
++++              checklistIds,
++++              question: bodyText,
++++            },
++++            runtimeContext,
++++          });
++++
++++          const checkResult = checkWorkflowResult(result);
++++
++++          // 処理が完了したらworkflowを削除
++++          this.runningWorkflows.delete(workflowKey);
++++
++++          if (checkResult.status !== 'success') {
++++            throw internalError({
++++              expose: true,
++++              messageCode: 'PLAIN_MESSAGE',
++++              messageParams: {
++++                message: checkResult.errorMessage || '不明なエラー',
++++              },
++++            });
++++          }
++++        } catch (error) {
++++          logger.error(error, 'レビューチャット実行に失敗しました');
++++          // エラー時もworkflowを削除
++++          this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
++++          throw error;
++++        }
++++      },
++++      onError: (error) => {
++++        logger.error(error, 'レビューチャット中にエラーが発生');
++++        // エラー時もworkflowを削除
++++        this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
++++        const normalizedError = normalizeUnknownError(error);
++++        return normalizedError.message;
++++      },
++++    });
++++
++++    return dataStream;
++++  }
++++
++++  /**
++++   * レビューチャット中断
++++   * @param reviewHistoryId レビュー履歴ID
++++   */
++++  public abortReviewChat(reviewHistoryId: string): {
++++    success: boolean;
++++    error?: string;
++++  } {
++++    try {
++++      const workflowKey = `chat_${reviewHistoryId}`;
++++      const runningWorkflow = this.runningWorkflows.get(workflowKey);
++++      if (runningWorkflow) {
++++        runningWorkflow.cancel();
++++        this.runningWorkflows.delete(workflowKey);
++++        logger.info(`レビューチャットをキャンセルしました: ${reviewHistoryId}`);
++++        return { success: true };
++++      } else {
++++        logger.warn(
++++          `キャンセル対象のレビューチャットが見つかりません: ${reviewHistoryId}`,
++++        );
++++        return {
++++          success: false,
++++          error: 'キャンセル対象の処理が見つかりません',
++++        };
++++      }
++++    } catch (error) {
++++      logger.error(error, 'レビューチャットのキャンセルに失敗しました');
++++      const err = normalizeUnknownError(error);
++++      return { success: false, error: err.message };
++++    }
++++  }
+++ }
+++diff --git a/src/main/service/settingsService.ts b/src/main/service/settingsService.ts
+++index 5882d1d96..682726a8a 100644
+++--- a/src/main/service/settingsService.ts
++++++ b/src/main/service/settingsService.ts
+++@@ -257,13 +257,17 @@ export class SettingsService implements ISettingsService {
+++       publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: true });
+++     } catch (error) {
+++       // 設定更新完了イベントを発行（失敗）
+++-      const errorMessage = error instanceof Error ? error.message : '不明なエラーが発生しました';
+++-      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: false, error: errorMessage });
++++      const errorMessage =
++++        error instanceof Error ? error.message : '不明なエラーが発生しました';
++++      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, {
++++        success: false,
++++        error: errorMessage,
++++      });
+++ 
+++       // エラーを再throw
+++       throw error;
+++     }
+++-  }
++++  };
+++   /**
+++    * 設定を取得する
+++    */
+++diff --git a/src/mastra/agents/model/openAICompatible.ts b/src/mastra/agents/model/openAICompatible.ts
+++index c741004b1..158e92301 100644
+++--- a/src/mastra/agents/model/openAICompatible.ts
++++++ b/src/mastra/agents/model/openAICompatible.ts
+++@@ -14,7 +14,10 @@ export const getOpenAICompatibleModel = ({
+++     throw internalError({
+++       expose: true,
+++       messageCode: 'VALIDATION_ERROR',
+++-      messageParams: { detail: 'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。' },
++++      messageParams: {
++++        detail:
++++          'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。',
++++      },
+++     });
+++   }
+++ 
+++diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
+++index ed443613a..9f5ce1fa5 100644
+++--- a/src/mastra/agents/prompts.ts
++++++ b/src/mastra/agents/prompts.ts
+++@@ -8,11 +8,11 @@ import {
+++   ReviewExecuteAgentRuntimeContext,
+++   TopicExtractionAgentRuntimeContext,
+++   TopicChecklistAgentRuntimeContext,
+++-  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
+++-  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
+++-  ReviewAnswerQuestionAgentRuntimeContext,
+++   IndividualDocumentReviewAgentRuntimeContext,
+++   ConsolidateReviewAgentRuntimeContext,
++++  ReviewChatPlanningAgentRuntimeContext,
++++  ReviewChatResearchAgentRuntimeContext,
++++  ReviewChatAnswerAgentRuntimeContext,
+++ } from './workflowAgents';
+++ 
+++ /**
+++@@ -576,6 +576,237 @@ ${additionalInstructions}
+++ Remember: Your thorough analysis of this document part is crucial for achieving an excellent final consolidated review. Include all relevant details that will contribute to the overall document assessment.`;
+++ }
+++ 
++++// レビューチャット：調査計画作成用のプロンプト
++++export function getReviewChatPlanningPrompt({
++++  runtimeContext,
++++}: {
++++  runtimeContext: RuntimeContext<ReviewChatPlanningAgentRuntimeContext>;
++++}): string {
++++  const availableDocuments = runtimeContext.get('availableDocuments');
++++  const checklistInfo = runtimeContext.get('checklistInfo');
++++
++++  const documentList = availableDocuments
++++    .map((doc) => `- ID: ${doc.id}, Name: ${doc.fileName}`)
++++    .join('\n');
++++
++++  return `You are a professional document analysis coordinator specializing in review result investigation.
++++
++++CONTEXT:
++++You are helping answer user questions about document review results. You have access to:
++++1. The original reviewed documents
++++2. Review results including evaluations and comments for specific checklist items
++++
++++AVAILABLE DOCUMENTS:
++++${documentList}
++++
++++CHECKLIST REVIEW INFORMATION:
++++${checklistInfo}
++++
++++YOUR TASK:
++++Create an efficient research plan to answer the user's question by identifying:
++++1. Which documents contain relevant information
++++2. What specific aspects to investigate in each document
++++3. How the investigation relates to the review results
++++
++++STRATEGIC PLANNING GUIDELINES:
++++
++++**Question Analysis:**
++++- Understand the user's intent: Are they asking about evaluation reasoning, improvement suggestions, specific document content, or discrepancies in the review?
++++- Identify keywords and concepts that connect to the checklist items and review comments
++++- Determine if the question relates to specific checklist items or general document content
++++
++++**Document Selection Strategy:**
++++- **Prioritize efficiency**: Select ONLY documents that are likely to contain relevant information
++++- Use the review results to guide your selection:
++++  * If asking about a specific evaluation or comment, focus on documents mentioned in those review results
++++  * If asking about document content, identify which documents are most likely to contain that information
++++  * Consider the review context: documents with lower ratings or specific comments may need investigation
++++
++++**Research Instructions Quality:**
++++- Be SPECIFIC and FOCUSED in your research instructions
++++- Clearly state what information to extract (e.g., "Find the section describing the testing methodology and extract the specific test types mentioned")
++++- Connect the research to the review context when relevant (e.g., "Verify the claim in the review comment that the security measures are incomplete")
++++- Prioritize targeted investigation over broad exploration
++++
++++**Efficiency Considerations:**
++++- Minimize the number of documents to investigate (only select what's necessary)
++++- Avoid redundant investigations across multiple documents unless truly needed
++++- Focus research instructions on finding specific information rather than general overviews
++++
++++OUTPUT REQUIREMENTS:
++++For each document that needs investigation, provide:
++++- **Document ID**: The exact ID from the available documents list above
++++- **Research Instructions**: Detailed, focused instructions explaining:
++++  * What specific information to look for
++++  * How it relates to the user's question
++++  * Connection to review results if applicable
++++- **Reasoning**: Brief explanation (1-2 sentences) of why this document is necessary for answering the question
++++
++++IMPORTANT:
++++- Create a focused, efficient plan - quality over quantity
++++- Your research plan will be executed in parallel across multiple documents
++++- Each investigation will be conducted independently, so make instructions self-contained and clear`;
++++}
++++
++++// レビューチャット：個別ドキュメント調査用のプロンプト
++++export function getReviewChatResearchPrompt({
++++  runtimeContext,
++++}: {
++++  runtimeContext: RuntimeContext<ReviewChatResearchAgentRuntimeContext>;
++++}): string {
++++  const totalChunks = runtimeContext.get('totalChunks');
++++  const chunkIndex = runtimeContext.get('chunkIndex');
++++  const fileName = runtimeContext.get('fileName');
++++  const checklistInfo = runtimeContext.get('checklistInfo');
++++  const userQuestion = runtimeContext.get('userQuestion');
++++
++++  // ドキュメントが分割されているかどうかで異なるプロンプトを生成
++++  const isChunked = totalChunks > 1;
++++
++++  const contextSection = isChunked
++++    ? `
++++IMPORTANT DOCUMENT CONTEXT:
++++- You are reviewing a PORTION (chunk ${chunkIndex + 1} of ${totalChunks}) of the document "${fileName}"
++++- This document has been split into ${totalChunks} parts due to length constraints
++++- You can ONLY see the content of this specific chunk (${chunkIndex + 1}/${totalChunks})
++++- Other parts of the document exist but are NOT visible to you in this analysis
++++- Information may be incomplete or cut off at chunk boundaries
++++
++++CRITICAL INSTRUCTIONS FOR CHUNKED DOCUMENTS:
++++- Report ONLY what you can find in THIS chunk
++++- If the requested information is not in this chunk, clearly state: "The information is not found in this portion (chunk ${chunkIndex + 1}/${totalChunks}) of the document"
++++- Do NOT speculate about what might be in other chunks
++++- If information appears to be cut off or incomplete at the beginning or end, note this explicitly
++++- Be aware that context from previous or subsequent chunks may be missing
++++`
++++    : `
++++DOCUMENT CONTEXT:
++++- You are reviewing the complete document "${fileName}"
++++- The full document content is available for your analysis
++++- You have access to all information needed to answer the research question
++++`;
++++
++++  return `You are a professional document researcher specializing in detailed document analysis.
++++
++++Your task is to conduct a specific investigation on the provided document based on the given research instructions.
++++
++++BACKGROUND CONTEXT:
++++This research is being conducted to help answer the following user question about a document review:
++++
++++User Question:
++++${userQuestion}
++++
++++The review was conducted based on the following checklist(s):
++++${checklistInfo}
++++
++++Understanding this context will help you focus your investigation on information that is truly relevant to answering the user's question about the review results.
++++${contextSection}
++++RESEARCH GUIDELINES:
++++1. Carefully read and analyze the provided document content with the user's question and checklist context in mind
++++2. Follow the specific research instructions precisely
++++3. Extract all relevant information related to the research topic
++++4. Consider how your findings relate to the checklist items and review results mentioned above
++++5. Cite specific sections, headings, page indicators, or other references where information is found
++++6. If information appears incomplete or ambiguous, note this clearly${isChunked ? ' (especially at chunk boundaries)' : ''}
++++7. Document your findings comprehensively - do not summarize or omit details
++++${isChunked ? '8. Remember: you can only report on what is visible in THIS chunk' : ''}
++++
++++OUTPUT REQUIREMENTS:
++++- Provide detailed research findings in Japanese
++++- Include specific citations and references from the document${isChunked ? ` (mention this is from chunk ${chunkIndex + 1}/${totalChunks} if relevant)` : ''}
++++- Note any limitations or gaps in the available information${isChunked ? ' within this chunk' : ''}
++++- Structure your findings clearly for easy integration into the final answer
++++${isChunked ? `- If the requested information is not in this chunk, explicitly state that it was not found in this portion` : ''}`;
++++}
++++
++++// レビューチャット：最終回答生成用のプロンプト
++++export function getReviewChatAnswerPrompt({
++++  runtimeContext,
++++}: {
++++  runtimeContext: RuntimeContext<ReviewChatAnswerAgentRuntimeContext>;
++++}): string {
++++  const userQuestion = runtimeContext.get('userQuestion');
++++  const checklistInfo = runtimeContext.get('checklistInfo');
++++
++++  return `You are a senior document review specialist responsible for synthesizing research findings into comprehensive answers.
++++
++++CONTEXT:
++++You are answering questions about document review results. You have access to:
++++1. The user's original question
++++2. Review results with evaluations and comments for specific checklist items
++++3. Research findings from individual document investigations
++++
++++USER QUESTION:
++++${userQuestion}
++++
++++CHECKLIST CONTEXT:
++++${checklistInfo}
++++
++++YOUR TASK:
++++Integrate all research findings and provide a clear, accurate, and comprehensive answer to the user's question.
++++
++++SYNTHESIS GUIDELINES:
++++
++++**Understanding the Research Results:**
++++- You will receive research findings from one or more documents
++++- Each finding may come from a complete document OR from a portion of a document (chunk)
++++- Some findings may indicate "information not found in this portion" - this is expected for chunked documents
++++- Consider ALL findings together to build a complete picture
++++
++++**Integration Strategy:**
++++1. **Identify Relevant Information:**
++++   - Extract key information from each research finding that addresses the user's question
++++   - Pay attention to specific citations, section references, and evidence provided
++++   - Distinguish between definitive findings and tentative/partial information
++++
++++2. **Handle Chunked Document Results:**
++++   - If research findings mention "chunk X/Y" or "this portion", the document was split for analysis
++++   - Combine findings from multiple chunks of the same document to form a complete view
++++   - If some chunks report "information not found", don't assume the information doesn't exist - it may be in other chunks
++++
++++3. **Resolve Contradictions:**
++++   - If findings from different sources contradict each other:
++++     * Present both perspectives
++++     * Explain the discrepancy clearly
++++     * Cite specific sources for each perspective
++++     * Offer reasoning if one source seems more authoritative
++++
++++4. **Synthesize into a Coherent Answer:**
++++   - Organize information logically to directly answer the question
++++   - Connect findings to the review context (evaluations, comments) when relevant
++++   - Build a narrative that flows naturally, not just a list of findings
++++
++++**Citation and Reference Guidelines:**
++++- **Document Names**: Use natural document names without mentioning chunk numbers (e.g., "設計書.pdf" not "設計書.pdf chunk 2/3")
++++- **Specific Citations**: Include section names, headings, page indicators, or other specific references from the research findings
++++- **Attribution**: Clearly attribute information to sources (e.g., "設計書.pdfの第3章によると...")
++++- **Avoid Internal Process Terms**: Do not mention "chunk", "research findings", "investigation" or similar internal process terminology
++++
++++**Handling Incomplete Information:**
++++- If critical information is missing or unclear, state this explicitly in Japanese
++++- Suggest what additional information would be needed
++++- Distinguish between:
++++  * Information that definitely doesn't exist in the documents
++++  * Information that wasn't found but might exist elsewhere
++++  * Information that is ambiguous or unclear
++++
++++OUTPUT REQUIREMENTS:
++++- **Language**: Answer in Japanese, matching the style and formality of the user's question
++++- **Structure**: Organize the answer clearly and logically:
++++  * Start with a direct answer to the main question if possible
++++  * Provide supporting details and evidence
++++  * Conclude with any caveats or additional context
++++- **Tone**: Professional, informative, and helpful
++++- **Completeness**: Address all aspects of the user's question
++++- **Natural Expression**: Write as if you reviewed the documents directly - avoid mentioning the research process
++++
++++CRITICAL REMINDERS:
++++- Your answer represents the final response to the user
++++- Quality and accuracy are paramount
++++- Provide value by synthesizing information, not just repeating findings
++++- Be honest about limitations while maximizing usefulness of available information`;
++++}
++++
+++ // レビュー結果統合用のプロンプト
+++ export function getConsolidateReviewPrompt({
+++   runtimeContext,
+++diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
+++index ad0371265..f45e92522 100644
+++--- a/src/mastra/agents/workflowAgents.ts
++++++ b/src/mastra/agents/workflowAgents.ts
+++@@ -14,6 +14,9 @@ import {
+++   getDocumentReviewExecutionPrompt,
+++   getIndividualDocumentReviewPrompt,
+++   getConsolidateReviewPrompt,
++++  getReviewChatPlanningPrompt,
++++  getReviewChatResearchPrompt,
++++  getReviewChatAnswerPrompt,
+++ } from './prompts';
+++ import { getOpenAICompatibleModel } from './model/openAICompatible';
+++ import { BaseRuntimeContext } from './types';
+++@@ -44,32 +47,37 @@ export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
+++   checklistRequirements?: string;
+++ };
+++ 
+++-export type ReviewCheckReviewReadinessFirstRunAgentRuntimeContext = BaseRuntimeContext & {
++++export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
+++   checklistItems: { id: number; content: string }[];
+++   additionalInstructions?: string;
++++  commentFormat?: string;
+++ };
+++ 
+++-export type ReviewCheckReviewReadinessSubsequentAgentRuntimeContext = BaseRuntimeContext & {
++++export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
+++   checklistItems: { id: number; content: string }[];
+++   additionalInstructions?: string;
+++-  priorQnA: { documentId: string; documentName: string; qna: { question: string; answer: string }[] }[];
++++  commentFormat?: string;
++++  evaluationSettings?: CustomEvaluationSettings;
+++ };
+++ 
+++-export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
+++-  checklistItems: { id: number; content: string }[];
++++// レビューチャット用エージェント
++++export type ReviewChatPlanningAgentRuntimeContext = BaseRuntimeContext & {
++++  availableDocuments: { id: string; fileName: string }[];
++++  checklistInfo: string; // チェックリスト情報のテキスト
+++ };
+++ 
+++-export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
+++-  checklistItems: { id: number; content: string }[];
+++-  additionalInstructions?: string;
+++-  commentFormat?: string;
++++export type ReviewChatResearchAgentRuntimeContext = BaseRuntimeContext & {
++++  researchContent: string; // 調査内容
++++  totalChunks: number; // ドキュメントの総チャンク数
++++  chunkIndex: number; // 現在のチャンクインデックス
++++  fileName: string; // ドキュメント名
++++  checklistInfo: string; // チェックリスト情報（内容とレビュー結果）
++++  userQuestion: string; // ユーザからの質問
+++ };
+++ 
+++-export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
+++-  checklistItems: { id: number; content: string }[];
+++-  additionalInstructions?: string;
+++-  commentFormat?: string;
+++-  evaluationSettings?: CustomEvaluationSettings;
++++export type ReviewChatAnswerAgentRuntimeContext = BaseRuntimeContext & {
++++  userQuestion: string; // ユーザからの質問
++++  checklistInfo: string; // チェックリスト情報のテキスト
+++ };
+++ 
+++ export const summarizeSourceAgent = new Agent({
+++@@ -139,3 +147,21 @@ export const consolidateReviewAgent = new Agent({
+++   instructions: getConsolidateReviewPrompt,
+++   model: getOpenAICompatibleModel,
+++ });
++++
++++export const reviewChatPlanningAgent = new Agent({
++++  name: 'reviewChatPlanningAgent',
++++  instructions: getReviewChatPlanningPrompt,
++++  model: getOpenAICompatibleModel,
++++});
++++
++++export const reviewChatResearchAgent = new Agent({
++++  name: 'reviewChatResearchAgent',
++++  instructions: getReviewChatResearchPrompt,
++++  model: getOpenAICompatibleModel,
++++});
++++
++++export const reviewChatAnswerAgent = new Agent({
++++  name: 'reviewChatAnswerAgent',
++++  instructions: getReviewChatAnswerPrompt,
++++  model: getOpenAICompatibleModel,
++++});
+++diff --git a/src/mastra/index.ts b/src/mastra/index.ts
+++index d2cd1e327..976120234 100644
+++--- a/src/mastra/index.ts
++++++ b/src/mastra/index.ts
+++@@ -19,10 +19,14 @@ import {
+++   topicChecklistAgent,
+++   individualDocumentReviewAgent,
+++   consolidateReviewAgent,
++++  reviewChatPlanningAgent,
++++  reviewChatResearchAgent,
++++  reviewChatAnswerAgent,
+++ } from './agents/workflowAgents';
+++ import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
+++ import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
+++ import { executeReviewWorkflow } from './workflows/sourceReview/executeReview';
++++import { reviewChatWorkflow } from './workflows/reviewChat';
+++ import fs from 'fs';
+++ import path from 'path';
+++ import { getLogLevel } from '@/main/lib/logger';
+++@@ -51,7 +55,6 @@ try {
+++   console.error('ログファイル初期化に失敗:', err);
+++ }
+++ 
+++-
+++ // ロガーの作成
+++ export const logger = new PinoLogger({
+++   name: 'AIKATA',
+++@@ -73,11 +76,15 @@ export const mastra: Mastra = new Mastra({
+++     topicChecklistAgent,
+++     individualDocumentReviewAgent,
+++     consolidateReviewAgent,
++++    reviewChatPlanningAgent,
++++    reviewChatResearchAgent,
++++    reviewChatAnswerAgent,
+++   },
+++   workflows: {
+++     sourceRegistrationWorkflow,
+++     checklistExtractionWorkflow,
+++     executeReviewWorkflow,
++++    reviewChatWorkflow,
+++   },
+++   logger,
+++ });
+++diff --git a/src/mastra/lib/util.ts b/src/mastra/lib/util.ts
+++index 57fe0b68c..3438aae8a 100644
+++--- a/src/mastra/lib/util.ts
++++++ b/src/mastra/lib/util.ts
+++@@ -8,7 +8,7 @@
+++ export function makeChunksByCount<T extends { length: number }>(
+++   data: T,
+++   splitCount: number,
+++-  overlap: number
++++  overlap: number,
+++ ): Array<{ start: number; end: number }> {
+++   const total = data.length;
+++ 
+++diff --git a/src/mastra/tools/redmine/redmineClient.ts b/src/mastra/tools/redmine/redmineClient.ts
+++index d383049b7..1f88ac3cb 100644
+++--- a/src/mastra/tools/redmine/redmineClient.ts
++++++ b/src/mastra/tools/redmine/redmineClient.ts
+++@@ -92,7 +92,9 @@ export class RedmineClient {
+++         throw internalError({
+++           expose: true,
+++           messageCode: 'REDMINE_API_ERROR',
+++-          messageParams: { detail: `${response.status} ${response.statusText}` },
++++          messageParams: {
++++            detail: `${response.status} ${response.statusText}`,
++++          },
+++         });
+++       }
+++       if (response.status === 204) {
+++diff --git a/src/mastra/tools/toolDisplayConfig.ts b/src/mastra/tools/toolDisplayConfig.ts
+++index 62ee97da4..9dca7f3da 100644
+++--- a/src/mastra/tools/toolDisplayConfig.ts
++++++ b/src/mastra/tools/toolDisplayConfig.ts
+++@@ -25,4 +25,8 @@ export const TOOL_NAME_DISPLAY_MAP: Record<string, string> = {
+++   getMergeRequestDetail: 'マージリクエスト詳細取得',
+++   addMergeRequestComment: 'マージリクエストコメント追加',
+++   addMergeRequestDiffComment: 'マージリクエスト差分コメント追加',
++++
++++  // レビューチャット用
++++  researchDocumentStart: 'ドキュメント調査中...',
++++  researchDocumentComplete: 'ドキュメント調査完了',
+++ };
+++diff --git a/src/mastra/workflows/reviewChat/generateAnswerStep.ts b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
+++new file mode 100644
+++index 000000000..c6a039b9e
+++--- /dev/null
++++++ b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
+++@@ -0,0 +1,158 @@
++++// @ts-ignore
++++import { createStep } from '@mastra/core';
++++// @ts-ignore
++++import { RuntimeContext } from '@mastra/core/runtime-context';
++++import { z } from 'zod';
++++import { baseStepOutputSchema } from '../schema';
++++import { stepStatus } from '../types';
++++import { getReviewRepository } from '@/adapter/db';
++++import { getMainLogger } from '@/main/lib/logger';
++++import { normalizeUnknownError, internalError } from '@/main/lib/error';
++++import { ReviewChatAnswerAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++++import {
++++  createRuntimeContext,
++++  judgeFinishReason,
++++} from '@/mastra/lib/agentUtils';
++++import { IpcChannels } from '@/types';
++++import { publishEvent } from '@/main/lib/eventPayloadHelper';
++++import { ReviewChatWorkflowRuntimeContext } from '.';
++++
++++const logger = getMainLogger();
++++
++++export const generateAnswerStepInputSchema = z.object({
++++  reviewHistoryId: z.string(),
++++  checklistIds: z.array(z.number()),
++++  question: z.string(),
++++  researchResults: z.array(
++++    z.object({
++++      documentId: z.string(),
++++      researchResult: z.string(),
++++    }),
++++  ),
++++});
++++
++++export const generateAnswerStepOutputSchema = baseStepOutputSchema.extend({
++++  answer: z.string().optional(),
++++});
++++
++++export const generateAnswerStep = createStep({
++++  id: 'generateAnswerStep',
++++  description: '最終回答を生成するステップ（ストリーミング）',
++++  inputSchema: generateAnswerStepInputSchema,
++++  outputSchema: generateAnswerStepOutputSchema,
++++  execute: async ({
++++    inputData,
++++    bail,
++++    mastra,
++++    abortSignal,
++++    runtimeContext: workflowRuntimeContext,
++++  }) => {
++++    try {
++++      const { reviewHistoryId, checklistIds, question, researchResults } =
++++        inputData;
++++      const reviewRepository = getReviewRepository();
++++      const dataStreamWriter = (
++++        workflowRuntimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++++      ).get('dataStreamWriter');
++++
++++      // チェックリスト結果を取得
++++      const checklistResults =
++++        await reviewRepository.getChecklistResultsWithIndividualResults(
++++          reviewHistoryId,
++++          checklistIds,
++++        );
++++
++++      // ドキュメントキャッシュ情報を取得
++++      const documentCaches =
++++        await reviewRepository.getReviewDocumentCacheByDocumentIds(
++++          reviewHistoryId,
++++          researchResults.map((r) => r.documentId),
++++        );
++++
++++      const checklistInfo = checklistResults
++++        .map((item) => {
++++          let info = `Checklist: ${item.checklistResult.content}\n`;
++++          if (item.checklistResult.sourceEvaluation) {
++++            info += `Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}, Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}`;
++++          }
++++          return info;
++++        })
++++        .join('\n');
++++
++++      // 調査結果を統合
++++      const researchSummary = researchResults
++++        .map(
++++          (result) =>
++++            `Document ID: ${result.documentId}\nDocument Name: ${documentCaches.find((dc) => dc.documentId === result.documentId)?.fileName || 'Unknown'}\nFindings: ${result.researchResult}`,
++++        )
++++        .join('\n---\n');
++++
++++      // RuntimeContext作成
++++      const runtimeContext =
++++        await createRuntimeContext<ReviewChatAnswerAgentRuntimeContext>();
++++      runtimeContext.set('userQuestion', question);
++++      runtimeContext.set('checklistInfo', checklistInfo);
++++
++++      const promptText = `User Question: ${question}\n\nResearch Findings:\n${researchSummary}`;
++++
++++      // Mastraエージェント経由でストリーミングAI呼び出し
++++      const answerAgent = mastra.getAgent('reviewChatAnswerAgent');
++++      const result = await answerAgent.generate(promptText, {
++++        runtimeContext,
++++        abortSignal,
++++        onStepFinish: (stepResult) => {
++++          // AI SDK Data Stream Protocol v1 形式でチャンクを送信
++++          // https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol
++++          if (stepResult.text) {
++++            dataStreamWriter.write(`0:${JSON.stringify(stepResult.text)}\n`);
++++          }
++++          stepResult.toolCalls.forEach((toolCall) => {
++++            dataStreamWriter.write(`9:${JSON.stringify(toolCall)}\n`);
++++          });
++++          stepResult.toolResults.forEach((toolResult) => {
++++            dataStreamWriter.write(`a:${JSON.stringify(toolResult)}\n`);
++++          });
++++          dataStreamWriter.write(
++++            `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
++++          );
++++        },
++++      });
++++
++++      const { success, reason } = judgeFinishReason(result.finishReason);
++++      if (!success) {
++++        throw internalError({
++++          expose: true,
++++          messageCode: 'AI_API_ERROR',
++++          messageParams: { detail: reason },
++++        });
++++      }
++++
++++      // 最終的なfinish reasonとusage情報を送信
++++      publishEvent(
++++        IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
++++        `d:${JSON.stringify({ finishReason: result.finishReason, ...result.usage })}\n`,
++++      );
++++
++++      // 完了イベント送信
++++      publishEvent(IpcChannels.REVIEW_CHAT_COMPLETE, undefined);
++++
++++      return {
++++        status: 'success' as stepStatus,
++++        answer: result.text,
++++      };
++++    } catch (error) {
++++      logger.error(error, '最終回答の生成に失敗しました');
++++      const normalizedError = normalizeUnknownError(error);
++++
++++      // エラーイベント送信
++++      publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
++++        message: normalizedError.message,
++++      });
++++
++++      return bail({
++++        status: 'failed' as stepStatus,
++++        errorMessage: normalizedError.message,
++++      });
++++    }
++++  },
++++});
+++diff --git a/src/mastra/workflows/reviewChat/index.ts b/src/mastra/workflows/reviewChat/index.ts
+++new file mode 100644
+++index 000000000..840d52dde
+++--- /dev/null
++++++ b/src/mastra/workflows/reviewChat/index.ts
+++@@ -0,0 +1,133 @@
++++// @ts-ignore
++++import { createWorkflow } from '@mastra/core';
++++// @ts-ignore
++++import { RuntimeContext } from '@mastra/core/runtime-context';
++++import { DataStreamWriter } from 'ai';
++++import { z } from 'zod';
++++import { stepStatus } from '../types';
++++import { planResearchStep } from './planResearchStep';
++++import {
++++  generateAnswerStep,
++++  generateAnswerStepInputSchema,
++++  generateAnswerStepOutputSchema,
++++} from './generateAnswerStep';
++++import { researchDocumentWithRetryWorkflow } from './researchDocument';
++++import { getReviewRepository } from '@/adapter/db';
++++
++++// ワークフローのラインタイムコンテキスト
++++export type ReviewChatWorkflowRuntimeContext = {
++++  dataStreamWriter: DataStreamWriter;
++++  // 擬似的なtoolCallを表現するためのID
++++  toolCallId: string;
++++};
++++
++++// 入力スキーマ
++++export const reviewChatInputSchema = z.object({
++++  reviewHistoryId: z.string(),
++++  checklistIds: z.array(z.number()),
++++  question: z.string(),
++++});
++++
++++// メインワークフロー
++++export const reviewChatWorkflow = createWorkflow({
++++  id: 'reviewChatWorkflow',
++++  inputSchema: reviewChatInputSchema,
++++  outputSchema: generateAnswerStepOutputSchema,
++++})
++++  .then(planResearchStep)
++++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
++++    if (inputData.status === 'failed') {
++++      return bail(inputData);
++++    }
++++
++++    const initData = (await getInitData()) as z.infer<
++++      typeof reviewChatInputSchema
++++    >;
++++
++++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
++++    const toolCallId = (
++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++++    ).get('toolCallId');
++++    const writer = (
++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++++    ).get('dataStreamWriter');
++++    const reviewRepository = getReviewRepository();
++++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
++++      initData.reviewHistoryId,
++++    );
++++    writer.write(
++++      `9:${JSON.stringify({
++++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
++++        toolName: 'researchDocumentStart',
++++        args: inputData.researchTasks?.map((task) => {
++++          return {
++++            documentName:
++++              documentCaches.find((d) => d.documentId === task.documentId)
++++                ?.fileName || 'Unknown',
++++            researchContent: task.researchContent,
++++          };
++++        }),
++++      })}\n`,
++++    );
++++
++++    return (inputData.researchTasks || []).map((task) => ({
++++      reviewHistoryId: initData.reviewHistoryId,
++++      documentId: task.documentId,
++++      researchContent: task.researchContent,
++++      checklistIds: initData.checklistIds,
++++      question: initData.question,
++++    })) as z.infer<typeof researchDocumentWithRetryWorkflow.inputSchema>[];
++++  })
++++  .foreach(researchDocumentWithRetryWorkflow, { concurrency: 5 })
++++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
++++    // 失敗があればエラー
++++    if (inputData.some((item) => item.status === 'failed')) {
++++      const failed = inputData.find((item) => item.status === 'failed');
++++      return bail({
++++        status: 'failed' as stepStatus,
++++        errorMessage: failed?.errorMessage || '調査に失敗しました',
++++      });
++++    }
++++
++++    const initData = (await getInitData()) as z.infer<
++++      typeof reviewChatInputSchema
++++    >;
++++
++++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
++++    const toolCallId = (
++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++++    ).get('toolCallId');
++++    const writer = (
++++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++++    ).get('dataStreamWriter');
++++    const reviewRepository = getReviewRepository();
++++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
++++      initData.reviewHistoryId,
++++    );
++++    writer.write(
++++      `a:${JSON.stringify({
++++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
++++        toolName: 'researchDocumentComplete',
++++        result: inputData.map((item) => ({
++++          documentName:
++++            documentCaches.find((d) => d.documentId === item.documentId)
++++              ?.fileName || 'Unknown',
++++          researchResult: item.researchResult!,
++++        })),
++++      })}\n`,
++++    );
++++
++++    return {
++++      reviewHistoryId: initData.reviewHistoryId,
++++      checklistIds: initData.checklistIds,
++++      question: initData.question,
++++      researchResults: inputData
++++        .filter((item) => item.status === 'success')
++++        .map((item) => ({
++++          documentId: item.documentId!,
++++          researchResult: item.researchResult!,
++++        })),
++++    } as z.infer<typeof generateAnswerStepInputSchema>;
++++  })
++++  .then(generateAnswerStep)
++++  .commit();
+++diff --git a/src/mastra/workflows/reviewChat/planResearchStep.ts b/src/mastra/workflows/reviewChat/planResearchStep.ts
+++new file mode 100644
+++index 000000000..fac9a8c13
+++--- /dev/null
++++++ b/src/mastra/workflows/reviewChat/planResearchStep.ts
+++@@ -0,0 +1,127 @@
++++// @ts-ignore
++++import { createStep } from '@mastra/core';
++++import { z } from 'zod';
++++import { baseStepOutputSchema } from '../schema';
++++import { stepStatus } from '../types';
++++import { getReviewRepository } from '@/adapter/db';
++++import { getMainLogger } from '@/main/lib/logger';
++++import { normalizeUnknownError, internalError } from '@/main/lib/error';
++++import { ReviewChatPlanningAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++++import {
++++  createRuntimeContext,
++++  judgeFinishReason,
++++} from '@/mastra/lib/agentUtils';
++++import { reviewChatInputSchema } from '.';
++++
++++const logger = getMainLogger();
++++
++++// Step 1: 調査計画作成
++++const planResearchStepOutputSchema = baseStepOutputSchema.extend({
++++  researchTasks: z
++++    .array(
++++      z.object({
++++        documentId: z.string(),
++++        researchContent: z.string(),
++++      }),
++++    )
++++    .optional(),
++++});
++++
++++export const planResearchStep = createStep({
++++  id: 'planResearchStep',
++++  description: '調査計画を作成するステップ',
++++  inputSchema: reviewChatInputSchema,
++++  outputSchema: planResearchStepOutputSchema,
++++  execute: async ({ inputData, bail, mastra }) => {
++++    try {
++++      const { reviewHistoryId, checklistIds, question } = inputData;
++++      const reviewRepository = getReviewRepository();
++++
++++      // チェックリスト結果と個別レビュー結果を取得
++++      const checklistResults =
++++        await reviewRepository.getChecklistResultsWithIndividualResults(
++++          reviewHistoryId,
++++          checklistIds,
++++        );
++++
++++      // ドキュメント一覧を取得
++++      const documentCaches =
++++        await reviewRepository.getReviewDocumentCaches(reviewHistoryId);
++++
++++      // RuntimeContext作成
++++      const availableDocuments = documentCaches.map((doc) => ({
++++        id: doc.documentId,
++++        fileName: doc.fileName,
++++      }));
++++
++++      // チェックリスト情報の文字列を生成
++++      const checklistInfo = checklistResults
++++        .map((item) => {
++++          let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
++++          if (item.checklistResult.sourceEvaluation) {
++++            info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
++++          }
++++          if (item.individualResults && item.individualResults.length > 0) {
++++            info += `Individual Review Results:\n`;
++++            item.individualResults.forEach((result) => {
++++              info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
++++            });
++++          }
++++          return info;
++++        })
++++        .join('\n---\n');
++++
++++      // RuntimeContext作成
++++      const runtimeContext =
++++        await createRuntimeContext<ReviewChatPlanningAgentRuntimeContext>();
++++      runtimeContext.set('availableDocuments', availableDocuments);
++++      runtimeContext.set('checklistInfo', checklistInfo);
++++
++++      // 構造化出力用のスキーマ
++++      const researchTasksSchema = z.object({
++++        tasks: z.array(
++++          z.object({
++++            reasoning: z
++++              .string()
++++              .describe('Reason for selecting this document for research'),
++++            documentId: z.string().describe('Document ID to investigate'),
++++            researchContent: z
++++              .string()
++++              .describe('Detailed research instructions for this document'),
++++          }),
++++        ),
++++      });
++++
++++      // Mastraエージェント経由でAI呼び出し（構造化出力）
++++      const planningAgent = mastra.getAgent('reviewChatPlanningAgent');
++++      const result = await planningAgent.generate(question, {
++++        runtimeContext,
++++        output: researchTasksSchema,
++++      });
++++
++++      const { success, reason } = judgeFinishReason(result.finishReason);
++++      if (!success) {
++++        throw internalError({
++++          expose: true,
++++          messageCode: 'AI_API_ERROR',
++++          messageParams: { detail: reason },
++++        });
++++      }
++++
++++      // 構造化出力から調査タスクを取得
++++      const researchTasks = result.object?.tasks || [];
++++
++++      return {
++++        status: 'success' as stepStatus,
++++        researchTasks,
++++      };
++++    } catch (error) {
++++      logger.error(error, '調査計画の作成に失敗しました');
++++      const normalizedError = normalizeUnknownError(error);
++++      return bail({
++++        status: 'failed' as stepStatus,
++++        errorMessage: normalizedError.message,
++++      });
++++    }
++++  },
++++});
+++diff --git a/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
+++new file mode 100644
+++index 000000000..dd6e3f661
+++--- /dev/null
++++++ b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
+++@@ -0,0 +1,57 @@
++++// @ts-ignore
++++import { createStep } from '@mastra/core';
++++import { z } from 'zod';
++++import { baseStepOutputSchema } from '../../schema';
++++import { stepStatus } from '../../types';
++++import { getReviewRepository } from '@/adapter/db';
++++import { getMainLogger } from '@/main/lib/logger';
++++import { normalizeUnknownError } from '@/main/lib/error';
++++
++++const logger = getMainLogger();
++++
++++export const getTotalChunksStepInputSchema = z.object({
++++  reviewHistoryId: z.string(),
++++  documentId: z.string(),
++++  researchContent: z.string(),
++++});
++++
++++export const getTotalChunksStepOutputSchema = baseStepOutputSchema.extend({
++++  reviewHistoryId: z.string(),
++++  documentId: z.string(),
++++  researchContent: z.string(),
++++  totalChunks: z.number(),
++++});
++++
++++export const getTotalChunksStep = createStep({
++++  id: 'getTotalChunksStep',
++++  description: '最大チャンク数を取得するステップ',
++++  inputSchema: getTotalChunksStepInputSchema,
++++  outputSchema: getTotalChunksStepOutputSchema,
++++  execute: async ({ inputData, bail }) => {
++++    try {
++++      const { reviewHistoryId, documentId, researchContent } = inputData;
++++      const reviewRepository = getReviewRepository();
++++
++++      // 既存の最大チャンク数を取得
++++      const totalChunks = await reviewRepository.getMaxTotalChunksForDocument(
++++        reviewHistoryId,
++++        documentId,
++++      );
++++
++++      return {
++++        status: 'success' as stepStatus,
++++        reviewHistoryId,
++++        documentId,
++++        researchContent,
++++        totalChunks,
++++      };
++++    } catch (error) {
++++      logger.error(error, '最大チャンク数の取得に失敗しました');
++++      const normalizedError = normalizeUnknownError(error);
++++      return bail({
++++        status: 'failed' as stepStatus,
++++        errorMessage: normalizedError.message,
++++      });
++++    }
++++  },
++++});
+++diff --git a/src/mastra/workflows/reviewChat/researchDocument/index.ts b/src/mastra/workflows/reviewChat/researchDocument/index.ts
+++new file mode 100644
+++index 000000000..d5367757e
+++--- /dev/null
++++++ b/src/mastra/workflows/reviewChat/researchDocument/index.ts
+++@@ -0,0 +1,202 @@
++++// @ts-ignore
++++import { createWorkflow } from '@mastra/core';
++++import { z } from 'zod';
++++import { baseStepOutputSchema } from '../../schema';
++++import { stepStatus } from '../../types';
++++import { getReviewRepository } from '@/adapter/db';
++++import { getMainLogger } from '@/main/lib/logger';
++++import { makeChunksByCount } from '@/mastra/lib/util';
++++import {
++++  getTotalChunksStep,
++++  getTotalChunksStepInputSchema,
++++  getTotalChunksStepOutputSchema,
++++} from './getTotalChunksStep';
++++import {
++++  researchChunkStep,
++++  researchChunkStepInputSchema,
++++} from './researchDocumentChunk';
++++import { input } from '@testing-library/user-event/dist/cjs/event/input.js';
++++
++++const logger = getMainLogger();
++++
++++const researchDocumentWithRetryInputSchema = z.object({
++++  reviewHistoryId: z.string(),
++++  documentId: z.string(),
++++  researchContent: z.string(),
++++  checklistIds: z.array(z.number()),
++++  question: z.string(),
++++});
++++
++++const researchDocumentWithRetryOutputSchema = baseStepOutputSchema.extend({
++++  documentId: z.string().optional(),
++++  researchResult: z.string().optional(),
++++});
++++
++++export const researchDocumentWithRetryWorkflow = createWorkflow({
++++  id: 'researchDocumentWithRetryWorkflow',
++++  inputSchema: researchDocumentWithRetryInputSchema,
++++  outputSchema: researchDocumentWithRetryOutputSchema,
++++})
++++  .map(async ({ inputData }) => {
++++    return inputData as z.infer<typeof getTotalChunksStepInputSchema>;
++++  })
++++  .then(getTotalChunksStep)
++++  .map(async ({ inputData, getInitData, bail }) => {
++++    if (inputData.status === 'failed') {
++++      return bail(inputData);
++++    }
++++    const initData = (await getInitData()) as z.infer<
++++      typeof researchDocumentWithRetryInputSchema
++++    >;
++++    return {
++++      ...inputData,
++++      checklistIds: initData.checklistIds,
++++      question: initData.question,
++++    } as z.infer<typeof getTotalChunksStepOutputSchema> & {
++++      checklistIds: number[];
++++      question: string;
++++    };
++++  })
++++  .dountil(
++++    createWorkflow({
++++      id: 'chunkResearchInnerWorkflow',
++++      inputSchema: getTotalChunksStepOutputSchema.extend({
++++        checklistIds: z.array(z.number()),
++++        question: z.string(),
++++      }),
++++      outputSchema: researchDocumentWithRetryOutputSchema,
++++    })
++++      .map(async ({ inputData }) => {
++++        const { reviewHistoryId, documentId, researchContent, totalChunks } =
++++          inputData;
++++        const reviewRepository = getReviewRepository();
++++
++++        // ドキュメントキャッシュを取得
++++        const documentCache =
++++          await reviewRepository.getReviewDocumentCacheByDocumentId(
++++            reviewHistoryId,
++++            documentId,
++++          );
++++
++++        if (!documentCache) {
++++          throw new Error(`Document not found: ${documentId}`);
++++        }
++++
++++        // ドキュメントをtotalChunks分に分割
++++        const chunks: Array<{ text?: string; images?: string[] }> = [];
++++
++++        if (documentCache.processMode === 'text' && documentCache.textContent) {
++++          // テキストをチャンク分割
++++          const chunkRanges = makeChunksByCount(
++++            documentCache.textContent,
++++            totalChunks,
++++            0,
++++          );
++++          chunkRanges.forEach((range) => {
++++            chunks.push({
++++              text: documentCache.textContent!.substring(
++++                range.start,
++++                range.end,
++++              ),
++++            });
++++          });
++++        } else if (
++++          documentCache.processMode === 'image' &&
++++          documentCache.imageData
++++        ) {
++++          // 画像配列をチャンク分割
++++          const chunkRanges = makeChunksByCount(
++++            documentCache.imageData,
++++            totalChunks,
++++            0,
++++          );
++++          chunkRanges.forEach((range) => {
++++            chunks.push({
++++              images: documentCache.imageData!.slice(range.start, range.end),
++++            });
++++          });
++++        }
++++
++++        // 各チャンクに対する調査タスクを作成
++++        return chunks.map((chunk, index) => ({
++++          reviewHistoryId,
++++          documentId,
++++          researchContent,
++++          chunkContent: chunk,
++++          chunkIndex: index,
++++          totalChunks,
++++          fileName: documentCache.fileName,
++++          checklistIds: inputData.checklistIds,
++++          question: inputData.question,
++++        })) as z.infer<typeof researchChunkStepInputSchema>[];
++++      })
++++      .foreach(researchChunkStep, { concurrency: 5 })
++++      .map(async ({ inputData, bail, getInitData }) => {
++++        const results = inputData;
++++
++++        // いずれかのチャンクでコンテキスト長エラーがあったかチェック
++++        const hasContentLengthError = results.some(
++++          (result) => result.finishReason === 'content_length',
++++        );
++++
++++        // 失敗があればエラー
++++        if (results.some((result) => result.status === 'failed')) {
++++          const failed = results.find((result) => result.status === 'failed');
++++          return bail({
++++            status: 'failed' as stepStatus,
++++            errorMessage: failed?.errorMessage || 'チャンク調査に失敗しました',
++++            finishReason: 'error' as const,
++++          });
++++        }
++++
++++        const initData = (await getInitData()) as z.infer<
++++          typeof getTotalChunksStepOutputSchema
++++        >;
++++
++++        if (hasContentLengthError) {
++++          // チャンク数を増やして再試行
++++          return {
++++            status: 'success' as stepStatus,
++++            reviewHistoryId: initData.reviewHistoryId,
++++            documentId: initData.documentId,
++++            researchContent: initData.researchContent,
++++            totalChunks: initData.totalChunks + 1,
++++            finishReason: 'content_length' as const,
++++          };
++++        }
++++
++++        // すべて成功したらチャンク結果を統合
++++        const combinedResult = results
++++          .filter((result) => result.chunkResult)
++++          .map((result, index) => `[Chunk ${index + 1}]\n${result.chunkResult}`)
++++          .join('\n\n');
++++
++++        return {
++++          status: 'success' as stepStatus,
++++          documentId: initData.documentId,
++++          researchResult: combinedResult,
++++          finishReason: 'success' as const,
++++        };
++++      })
++++      .commit(),
++++    async ({ inputData }) => {
++++      // 再試行上限または成功したら終了
++++      if ((inputData as any).totalChunks >= 10) {
++++        return true;
++++      }
++++      if ((inputData as any).finishReason !== 'content_length') {
++++        return true;
++++      }
++++      return false;
++++    },
++++  )
++++  .map(async ({ inputData }) => {
++++    // 最終結果を返す
++++    return {
++++      status: inputData.status,
++++      documentId: inputData.documentId,
++++      researchResult: inputData.researchResult,
++++      errorMessage: (inputData as any).errorMessage,
++++    };
++++  })
++++  .commit();
+++diff --git a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
+++new file mode 100644
+++index 000000000..225e1901f
+++--- /dev/null
++++++ b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
+++@@ -0,0 +1,181 @@
++++// @ts-ignore
++++import { createStep } from '@mastra/core';
++++import { z } from 'zod';
++++import { baseStepOutputSchema } from '../../schema';
++++import { stepStatus } from '../../types';
++++import { getMainLogger } from '@/main/lib/logger';
++++import { normalizeUnknownError, internalError } from '@/main/lib/error';
++++import { ReviewChatResearchAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++++import {
++++  createRuntimeContext,
++++  judgeFinishReason,
++++  judgeErrorIsContentLengthError,
++++} from '@/mastra/lib/agentUtils';
++++import { getReviewRepository } from '@/adapter/db';
++++
++++const logger = getMainLogger();
++++
++++export const researchChunkStepInputSchema = z.object({
++++  reviewHistoryId: z.string(),
++++  documentId: z.string(),
++++  researchContent: z.string(),
++++  chunkContent: z.object({
++++    text: z.string().optional(),
++++    images: z.array(z.string()).optional(),
++++  }),
++++  chunkIndex: z.number(),
++++  totalChunks: z.number(),
++++  fileName: z.string(),
++++  checklistIds: z.array(z.number()),
++++  question: z.string(),
++++});
++++
++++const researchChunkStepOutputSchema = baseStepOutputSchema.extend({
++++  chunkResult: z.string().optional(),
++++  chunkIndex: z.number().optional(),
++++  finishReason: z.enum(['success', 'error', 'content_length']).optional(),
++++});
++++
++++export const researchChunkStep = createStep({
++++  id: 'researchChunkStep',
++++  description: 'チャンク単位でドキュメントを調査するステップ',
++++  inputSchema: researchChunkStepInputSchema,
++++  outputSchema: researchChunkStepOutputSchema,
++++  execute: async ({ inputData, bail, mastra, getInitData }) => {
++++    try {
++++      const {
++++        researchContent,
++++        chunkContent,
++++        chunkIndex,
++++        totalChunks,
++++        fileName,
++++        reviewHistoryId,
++++        checklistIds,
++++        question,
++++      } = inputData;
++++
++++      // チェックリスト情報を生成（planResearchStepと同じロジック）
++++      const reviewRepository = getReviewRepository();
++++      const checklistResults =
++++        await reviewRepository.getChecklistResultsWithIndividualResults(
++++          reviewHistoryId,
++++          checklistIds,
++++        );
++++
++++      const checklistInfo = checklistResults
++++        .map(
++++          (item: {
++++            checklistResult: {
++++              id: number;
++++              content: string;
++++              sourceEvaluation?: { evaluation?: string; comment?: string };
++++            };
++++            individualResults?: Array<{
++++              documentId: number;
++++              comment: string;
++++              individualFileName: string;
++++            }>;
++++          }) => {
++++            let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
++++            if (item.checklistResult.sourceEvaluation) {
++++              info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
++++            }
++++            if (item.individualResults && item.individualResults.length > 0) {
++++              info += `Individual Review Results:\n`;
++++              item.individualResults.forEach(
++++                (result: {
++++                  documentId: number;
++++                  comment: string;
++++                  individualFileName: string;
++++                }) => {
++++                  info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
++++                },
++++              );
++++            }
++++            return info;
++++          },
++++        )
++++        .join('\n---\n');
++++
++++      // RuntimeContext作成
++++      const runtimeContext =
++++        await createRuntimeContext<ReviewChatResearchAgentRuntimeContext>();
++++      runtimeContext.set('researchContent', researchContent);
++++      runtimeContext.set('totalChunks', totalChunks);
++++      runtimeContext.set('chunkIndex', chunkIndex);
++++      runtimeContext.set('fileName', fileName);
++++      runtimeContext.set('checklistInfo', checklistInfo);
++++      runtimeContext.set('userQuestion', question);
++++
++++      // メッセージを作成
++++      const messageContent = [];
++++
++++      if (chunkContent.text) {
++++        // テキストチャンクの場合
++++        messageContent.push({
++++          type: 'text' as const,
++++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nDocument Content:\n${chunkContent.text}`,
++++        });
++++      } else if (chunkContent.images && chunkContent.images.length > 0) {
++++        // 画像チャンクの場合
++++        messageContent.push({
++++          type: 'text' as const,
++++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nPlease analyze the following document images:`,
++++        });
++++
++++        chunkContent.images.forEach((imageBase64) => {
++++          messageContent.push({
++++            type: 'image' as const,
++++            image: imageBase64,
++++          });
++++        });
++++      }
++++
++++      // Mastraエージェント経由でAI呼び出し
++++      const researchAgent = mastra.getAgent('reviewChatResearchAgent');
++++      const result = await researchAgent.generate(
++++        {
++++          role: 'user',
++++          content: messageContent,
++++        },
++++        {
++++          runtimeContext,
++++        },
++++      );
++++
++++      const { success, reason } = judgeFinishReason(result.finishReason);
++++
++++      if (!success) {
++++        throw internalError({
++++          expose: true,
++++          messageCode: 'AI_API_ERROR',
++++          messageParams: { detail: reason },
++++        });
++++      }
++++
++++      return {
++++        status: 'success' as stepStatus,
++++        chunkIndex,
++++        chunkResult: result.text,
++++        finishReason: 'success' as const,
++++      };
++++    } catch (error) {
++++      // コンテキスト長エラーの場合は特別な処理
++++      if (judgeErrorIsContentLengthError(error)) {
++++        return {
++++          status: 'success' as stepStatus,
++++          chunkIndex: inputData.chunkIndex,
++++          finishReason: 'content_length' as const,
++++        };
++++      }
++++
++++      logger.error(error, 'チャンク調査に失敗しました');
++++      const normalizedError = normalizeUnknownError(error);
++++      return bail({
++++        status: 'failed' as stepStatus,
++++        errorMessage: normalizedError.message,
++++        finishReason: 'error' as const,
++++      });
++++    }
++++  },
++++});
+++diff --git a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+++index 14ac3da86..e477a12a4 100644
+++--- a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
++++++ b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+++@@ -1,40 +1,46 @@
+++-import { z } from "zod";
+++-import { baseStepOutputSchema } from "../../schema";
++++import { z } from 'zod';
++++import { baseStepOutputSchema } from '../../schema';
+++ // @ts-ignore
+++-import { createStep } from "@mastra/core";
++++import { createStep } from '@mastra/core';
+++ // @ts-ignore
+++-import { MastraError } from "@mastra/core/error";
++++import { MastraError } from '@mastra/core/error';
+++ import { NoObjectGeneratedError } from 'ai';
+++-import { getReviewRepository } from "@/adapter/db";
+++-import { extractAIAPISafeError, internalError, normalizeUnknownError } from "@/main/lib/error";
+++-import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from ".";
+++-import { stepStatus } from "../../types";
+++-import { splitChecklistEquallyByMaxSize } from "../lib";
+++-import { createRuntimeContext } from "@/mastra/lib/agentUtils";
+++-import { ClassifyCategoryAgentRuntimeContext } from "@/mastra/agents/workflowAgents";
+++-import { getMainLogger } from "@/main/lib/logger";
++++import { getReviewRepository } from '@/adapter/db';
++++import {
++++  extractAIAPISafeError,
++++  internalError,
++++  normalizeUnknownError,
++++} from '@/main/lib/error';
++++import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from '.';
++++import { stepStatus } from '../../types';
++++import { splitChecklistEquallyByMaxSize } from '../lib';
++++import { createRuntimeContext } from '@/mastra/lib/agentUtils';
++++import { ClassifyCategoryAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++++import { getMainLogger } from '@/main/lib/logger';
+++ 
+++ const logger = getMainLogger();
+++ 
+++ export const classifyChecklistsByCategoryInputSchema = z.object({
+++-  reviewHistoryId: z.string().describe("レビュー履歴ID"),
++++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+++ });
+++ 
+++ // カテゴリ分類ステップの出力スキーマ
+++-export const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
+++-  categories: z
+++-    .array(
+++-      z.object({
+++-        name: z.string(),
+++-        checklists: z.array(
+++-          z.object({
+++-            id: z.number(),
+++-            content: z.string().describe('チェックリストの内容'),
+++-          }),
+++-        ),
+++-      }),
+++-    ).optional(),
+++-});
++++export const classifyChecklistsByCategoryOutputSchema =
++++  baseStepOutputSchema.extend({
++++    categories: z
++++      .array(
++++        z.object({
++++          name: z.string(),
++++          checklists: z.array(
++++            z.object({
++++              id: z.number(),
++++              content: z.string().describe('チェックリストの内容'),
++++            }),
++++          ),
++++        }),
++++      )
++++      .optional(),
++++  });
+++ 
+++ export const classifyChecklistsByCategoryStep = createStep({
+++   id: 'classifyChecklistsByCategoryStep',
+++diff --git a/src/mastra/workflows/sourceReview/executeReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/index.ts
+++index 0972e2670..67e557283 100644
+++--- a/src/mastra/workflows/sourceReview/executeReview/index.ts
++++++ b/src/mastra/workflows/sourceReview/executeReview/index.ts
+++@@ -9,6 +9,7 @@ import { classifyChecklistsByCategoryStep } from './classifyChecklistStep';
+++ import { smallDocumentReviewExecutionStep } from './smallDocumentReviewStep';
+++ import { largeDocumentReviewWorkflow } from './largeDocumentReview';
+++ import { extractedDocumentSchema, uploadedFileSchema } from './schema';
++++import { getReviewRepository } from '@/adapter/db';
+++ 
+++ const logger = getMainLogger();
+++ 
+++@@ -54,6 +55,7 @@ export const executeReviewWorkflowInputSchema = z.object({
+++ export const executeReviewWorkflowOutputSchema = baseStepOutputSchema;
+++ 
+++ export const documentReviewExecutionInputSchema = z.object({
++++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+++   additionalInstructions: z
+++     .string()
+++     .optional()
+++@@ -143,8 +145,46 @@ export const executeReviewWorkflow = createWorkflow({
+++       typeof executeReviewWorkflowInputSchema
+++     >;
+++ 
++++    // 既存のレビュー結果を全て削除
++++    const reviewRepository = getReviewRepository();
++++    await reviewRepository.deleteAllReviewResults(initData.reviewHistoryId);
++++
++++    // documentModeを保存
++++    await reviewRepository.updateReviewHistoryDocumentMode(
++++      initData.reviewHistoryId,
++++      initData.documentMode,
++++    );
++++
++++    // ドキュメントキャッシュを保存
++++    for (const document of textExtractionResult.extractedDocuments || []) {
++++      if (!document) continue;
++++      const savedCache = await reviewRepository.createReviewDocumentCache({
++++        reviewHistoryId: initData.reviewHistoryId,
++++        documentId: document.id || '',
++++        fileName: document.name || '',
++++        processMode: document.processMode || 'text',
++++        textContent: document.textContent,
++++        imageData: document.imageData,
++++      });
++++      // キャッシュIDを付与
++++      document.cacheId = savedCache.id;
++++    }
++++
++++    // レビュー対象の統合ドキュメント名を保存
++++    const targetDocumentName = (textExtractionResult.extractedDocuments || [])
++++      .map((doc) => doc?.name || '')
++++      .filter((name) => name)
++++      .join('/');
++++    if (targetDocumentName) {
++++      await reviewRepository.updateReviewHistoryTargetDocumentName(
++++        initData.reviewHistoryId,
++++        targetDocumentName,
++++      );
++++    }
++++
+++     return classifyChecklistsResult.categories!.map((category) => {
+++       return {
++++        reviewHistoryId: initData.reviewHistoryId,
+++         documents: textExtractionResult.extractedDocuments!,
+++         checklists: category.checklists,
+++         additionalInstructions: initData.additionalInstructions,
++ diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
++-index 60120af8d..cafb8793c 100644
+++index cafb8793c..e1187dce7 100644
++ --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
++ +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
++-@@ -198,9 +198,13 @@ Please provide a consolidated review that synthesizes all individual document re
++-           const idsHash = createHash('md5')
++-             .update(combinedFileIds)
++-             .digest('hex');
++--          const combinedFileNames = documentsWithReviewResults
++--            .map((f) => f.name)
++--            .join('/');
++-+          const combinedFileNames = [
++-+            ...new Set(
++-+              documentsWithReviewResults.map(
++-+                (f) => f.originalName || f.name,
++-+              ),
++-+            ),
++-+          ].join('/');
+++@@ -87,7 +87,10 @@ export const consolidateReviewStep = createStep({
+++       // 個別レビュー結果を整理
+++       const consolidatedInput = documentsWithReviewResults.map((docResult) => {
+++         return {
+++-          originalName: docResult?.originalName || docResult?.name || `Document ${docResult.id}`,
++++          originalName:
++++            docResult?.originalName ||
++++            docResult?.name ||
++++            `Document ${docResult.id}`,
+++           documentName: docResult?.name || `Document ${docResult.id}`,
+++           reviewResults: docResult.reviewResults,
+++         };
+++@@ -102,7 +105,7 @@ export const consolidateReviewStep = createStep({
+++             text: `Please consolidate the following individual document review results into a comprehensive final review.
+++ 
+++ ## Document Set Information:
+++-Original Files: ${[...new Set(consolidatedInput.map(doc => doc.originalName))].join(', ')}
++++Original Files: ${[...new Set(consolidatedInput.map((doc) => doc.originalName))].join(', ')}
++  
+++ ## Individual Document Review Results:
+++ ${consolidatedInput
+++@@ -187,32 +190,16 @@ Please provide a consolidated review that synthesizes all individual document re
+++           });
+++         }
+++ 
+++-        // 統合レビュー結果をDBに保存（複数ファイルの情報を統合）
++++        // 統合レビュー結果をDBに保存
+++         if (
+++           consolidatedResult.object &&
+++           Array.isArray(consolidatedResult.object)
+++         ) {
+++-          const combinedFileIds = documentsWithReviewResults
+++-            .map((f) => f.id)
+++-            .join('/');
+++-          const idsHash = createHash('md5')
+++-            .update(combinedFileIds)
+++-            .digest('hex');
+++-          const combinedFileNames = [
+++-            ...new Set(
+++-              documentsWithReviewResults.map(
+++-                (f) => f.originalName || f.name,
+++-              ),
+++-            ),
+++-          ].join('/');
+++-
++            await reviewRepository.upsertReviewResult(
++              consolidatedResult.object.map((result) => ({
+++               reviewChecklistId: result.checklistId,
+++               evaluation: result.evaluation as ReviewEvaluation,
+++               comment: result.comment,
+++-              fileId: idsHash,
+++-              fileName: combinedFileNames,
+++             })),
+++           );
+++         }
++ diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
++-index 3e9bea206..c6f8371b8 100644
+++index c6f8371b8..b72315a84 100644
++ --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
++ +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
++-@@ -108,7 +108,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
++-           }
++-           return {
++-             originalDocument: initData.originalDocument,
++--            reviewInput: [],
++-+            reviewInput: initData.reviewInput,
++-             retryCount: nextRetryCount,
++-             status: isFailed
++-               ? ('failed' as stepStatus)
++-@@ -124,7 +124,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
++-         if (initData.retryCount >= 5) {
++-           return {
++-             originalDocument: initData.originalDocument,
++--            reviewInput: [],
++-+            reviewInput: initData.reviewInput,
++-             retryCount: nextRetryCount,
++-             status: 'failed' as stepStatus,
++-             errorMessage:
++-@@ -155,6 +155,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++@@ -155,8 +155,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
++                  ...initData.originalDocument,
++                  id: `${initData.originalDocument.id}_part${index + 1}`,
++                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
++-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+++-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++++                originalName:
++++                  initData.originalDocument.originalName ||
++++                  initData.originalDocument.name,
++                  textContent: chunk,
++++                totalChunks: splitCount,
++++                chunkIndex: index,
++                },
++              })),
++-@@ -181,6 +182,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++             retryCount: nextRetryCount,
+++@@ -182,8 +186,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
++                  ...initData.originalDocument,
++                  id: `${initData.originalDocument.id}_part${index + 1}`,
++                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
++-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+++-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++++                originalName:
++++                  initData.originalDocument.originalName ||
++++                  initData.originalDocument.name,
++                  imageData: chunk,
++++                totalChunks: splitCount,
++++                chunkIndex: index,
++                },
++              })),
++-@@ -227,6 +229,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+++             retryCount: nextRetryCount,
+++@@ -251,9 +259,12 @@ export const largeDocumentReviewWorkflow = createWorkflow({
+++     return inputData.documents.map(
+++       (document) =>
+++         ({
++++          reviewHistoryId: inputData.reviewHistoryId,
+++           document: {
+++             ...document,
+++             originalName: document.name, // 分割された場合に元の名前を保持するため
++++            totalChunks: 1,
++++            chunkIndex: 0,
+++           },
+++           checklists: inputData.checklists,
+++           additionalInstructions: inputData.additionalInstructions,
+++diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+++index 4416735c4..f8602fc3d 100644
+++--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
++++++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+++@@ -15,13 +15,17 @@ import { getMainLogger } from '@/main/lib/logger';
+++ import { createCombinedMessageFromExtractedDocument } from '../../lib';
+++ import { getChecklistsErrorMessage } from '../lib';
+++ import { extractedDocumentSchema } from '../schema';
++++import { getReviewRepository } from '@/adapter/db';
+++ 
+++ const logger = getMainLogger();
+++ 
+++ // 個別ドキュメントレビューステップの入力スキーマ
+++ export const individualDocumentReviewStepInputSchema = z.object({
++++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+++   document: extractedDocumentSchema.extend({
+++     originalName: z.string(),
++++    totalChunks: z.number().optional(), // ドキュメント分割総数
++++    chunkIndex: z.number().optional(), // 何番目のチャンクか（0から始まる）
+++   }),
+++   // チェックリスト
+++   checklists: z.array(
+++@@ -189,6 +193,20 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
+++       }
+++ 
+++       // 全てのレビューが成功した場合
++++
++++      // 個別レビュー結果を保存
++++      const reviewRepository = getReviewRepository();
++++      for (const result of allReviewResults) {
++++        await reviewRepository.createReviewLargedocumentResultCache({
++++          reviewDocumentCacheId: document.cacheId!,
++++          reviewChecklistId: result.checklistId,
++++          comment: result.comment,
++++          totalChunks: document.totalChunks ?? 1,
++++          chunkIndex: document.chunkIndex ?? 0,
++++          individualFileName: document.name,
++++        });
++++      }
++++
+++       return {
+++         status: 'success' as stepStatus,
+++         documentId: document.id,
+++diff --git a/src/mastra/workflows/sourceReview/executeReview/lib.ts b/src/mastra/workflows/sourceReview/executeReview/lib.ts
+++index b4bde036c..3f303042b 100644
+++--- a/src/mastra/workflows/sourceReview/executeReview/lib.ts
++++++ b/src/mastra/workflows/sourceReview/executeReview/lib.ts
+++@@ -1,7 +1,15 @@
+++-export const getChecklistErrorMesssage = (checklist: { id: number; content: string }, errorMessage: string) => {
++++export const getChecklistErrorMesssage = (
++++  checklist: { id: number; content: string },
++++  errorMessage: string,
++++) => {
+++   return `・${checklist.content}:${errorMessage}`;
+++ };
+++ 
+++-export const getChecklistsErrorMessage = (checklists: { id: number; content: string }[], errorMessage: string) => {
+++-  return checklists.map((checklist) => getChecklistErrorMesssage(checklist, errorMessage)).join('\n');
+++-}
++++export const getChecklistsErrorMessage = (
++++  checklists: { id: number; content: string }[],
++++  errorMessage: string,
++++) => {
++++  return checklists
++++    .map((checklist) => getChecklistErrorMesssage(checklist, errorMessage))
++++    .join('\n');
++++};
+++diff --git a/src/mastra/workflows/sourceReview/executeReview/schema.ts b/src/mastra/workflows/sourceReview/executeReview/schema.ts
+++index 18b138b5d..e663cbe5a 100644
+++--- a/src/mastra/workflows/sourceReview/executeReview/schema.ts
++++++ b/src/mastra/workflows/sourceReview/executeReview/schema.ts
+++@@ -12,6 +12,7 @@ export const uploadedFileSchema = z.object({
+++ 
+++ export const extractedDocumentSchema = z.object({
+++   id: z.string(),
++++  cacheId: z.number().optional(),
+++   name: z.string(),
+++   path: z.string(),
+++   type: z.string(),
+++diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++index 33bc9e881..0b1e0746a 100644
+++--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
++++++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++@@ -133,20 +133,13 @@ Please review the document against the above checklist items.`;
+++             messageParams: { detail: reason },
+++           });
+++         }
+++-        // レビュー結果をDBに保存（複数ファイルの情報を統合）
++++        // レビュー結果をDBに保存
+++         if (reviewResult.object && Array.isArray(reviewResult.object)) {
+++-          const combinedFileIds = documents.map((f) => f.id).join('/');
+++-          const idsHash = createHash('md5')
+++-            .update(combinedFileIds)
+++-            .digest('hex');
+++-          const combinedFileNames = documents.map((f) => f.name).join('/');
+++           await reviewRepository.upsertReviewResult(
+++             reviewResult.object.map((result) => ({
+++               reviewChecklistId: result.checklistId,
+++               evaluation: result.evaluation as ReviewEvaluation,
+++               comment: result.comment,
+++-              fileId: idsHash,
+++-              fileName: combinedFileNames,
+++             })),
+++           );
+++         }
+++@@ -169,7 +162,10 @@ Please review the document against the above checklist items.`;
+++         // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
+++         return bail({
+++           status: 'failed' as stepStatus,
+++-          errorMessage: getChecklistsErrorMessage(targetChecklists, 'AIの出力にレビュー結果が含まれませんでした'),
++++          errorMessage: getChecklistsErrorMessage(
++++            targetChecklists,
++++            'AIの出力にレビュー結果が含まれませんでした',
++++          ),
+++         });
+++       }
+++       // 全てのレビューが成功した場合
+++diff --git a/src/mastra/workflows/sourceReview/lib.ts b/src/mastra/workflows/sourceReview/lib.ts
+++index 4eed29a81..9518de038 100644
+++--- a/src/mastra/workflows/sourceReview/lib.ts
++++++ b/src/mastra/workflows/sourceReview/lib.ts
+++@@ -122,7 +122,9 @@ export async function createCombinedMessage(
+++       }
+++     } else {
+++       // テキスト抽出処理
+++-      const { content: fileContent } = await FileExtractor.extractText(file.path);
++++      const { content: fileContent } = await FileExtractor.extractText(
++++        file.path,
++++      );
+++ 
+++       // ファイルごとに個別のcontent要素として追加
+++       content.push({
+++@@ -181,7 +183,11 @@ export function createCombinedMessageFromExtractedDocument(
+++     if (document.imageData && document.imageData.length > 0) {
+++       // 各ページごとに個別の説明と画像を追加
+++       const totalPages = document.imageData.length;
+++-      for (let pageIndex = 0; pageIndex < document.imageData.length; pageIndex++) {
++++      for (
++++        let pageIndex = 0;
++++        pageIndex < document.imageData.length;
++++        pageIndex++
++++      ) {
+++         const currentPage = pageIndex + 1;
+++ 
+++         // ページ番号を含むテキスト説明を追加
+++diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
+++index 9af029444..aec3ea97f 100644
+++--- a/src/messages/ja/template.ts
++++++ b/src/messages/ja/template.ts
+++@@ -33,4 +33,5 @@ export const template = {
+++   REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR: `CSVファイルからのチェックリスト抽出中に予期せぬエラーが発生しました`,
+++   AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
+++   AI_MESSAGE_TOO_LARGE: `AIへの入力データが大きすぎます。入力データを減らしてください。`,
++++  REVIEW_DOCUMENT_CACHE_NOT_FOUND: `レビュー時にアップロードしたドキュメント情報が失われています。レビューを再実行してください`,
+++ } as const;
+++diff --git a/src/renderer/components/chat/MessageItem.tsx b/src/renderer/components/chat/MessageItem.tsx
+++index 4a8877c44..5345514e0 100644
+++--- a/src/renderer/components/chat/MessageItem.tsx
++++++ b/src/renderer/components/chat/MessageItem.tsx
+++@@ -313,7 +313,8 @@ const renderPart = (
+++         <Accordion sx={{ width: '100%' }} key={ti.toolCallId}>
+++           <AccordionSummary expandIcon={<ExpandMoreIcon />}>
+++             <Box sx={{ display: 'flex', alignItems: 'center' }}>
+++-              {ti.toolName === 'documentQueryTool' ? (
++++              {ti.toolName === 'documentQueryTool' ||
++++              ti.toolCallId.startsWith('reviewChatResearchDocument-') ? (
+++                 <SearchIcon sx={{ mr: 1 }} />
+++               ) : (
+++                 <SmartToyOutlinedIcon sx={{ mr: 1 }} />
+++@@ -387,6 +388,7 @@ interface MessageProps {
+++   onEditStart: (messageId: string) => void;
+++   onEditContentChange: (content: string) => void;
+++   onEditCancel: () => void;
++++  disableEdit?: boolean;
+++ }
+++ 
+++ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+++@@ -400,6 +402,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+++       onEditStart,
+++       onEditCancel,
+++       onEditContentChange,
++++      disableEdit = false,
+++     },
+++     ref,
+++   ) => {
+++@@ -420,7 +423,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+++               maxWidth: isUser && !isEditing ? '70%' : '100%',
+++               width: isUser && !isEditing ? undefined : '100%',
+++               textAlign: 'left',
+++-              '&:hover .editBtn': { opacity: 1 },
++++              ...(!disableEdit && { '&:hover .editBtn': { opacity: 1 } }),
+++             }}
+++           >
+++             <Paper
+++@@ -432,28 +435,31 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+++                 position: 'relative',
+++               }}
+++             >
+++-              {isUser && !message.experimental_attachments && !isEditing && (
+++-                <IconButton
+++-                  className="editBtn"
+++-                  size="small"
+++-                  onClick={() => {
+++-                    onEditStart?.(message.id);
+++-                    onEditContentChange(message.content ?? '');
+++-                  }}
+++-                  sx={{
+++-                    position: 'absolute',
+++-                    right: -36,
+++-                    top: '50%',
+++-                    transform: 'translateY(-50%)',
+++-                    opacity: 0,
+++-                    transition: 'opacity 0.2s',
+++-                    bgcolor: 'background.paper',
+++-                  }}
+++-                  data-testid={`edit-message-button-${message.id}`}
+++-                >
+++-                  <EditIcon fontSize="small" />
+++-                </IconButton>
+++-              )}
++++              {isUser &&
++++                !message.experimental_attachments &&
++++                !isEditing &&
++++                !disableEdit && (
++++                  <IconButton
++++                    className="editBtn"
++++                    size="small"
++++                    onClick={() => {
++++                      onEditStart?.(message.id);
++++                      onEditContentChange(message.content ?? '');
++++                    }}
++++                    sx={{
++++                      position: 'absolute',
++++                      right: -36,
++++                      top: '50%',
++++                      transform: 'translateY(-50%)',
++++                      opacity: 0,
++++                      transition: 'opacity 0.2s',
++++                      bgcolor: 'background.paper',
++++                    }}
++++                    data-testid={`edit-message-button-${message.id}`}
++++                  >
++++                    <EditIcon fontSize="small" />
++++                  </IconButton>
++++                )}
+++               {/* eslint-disable-next-line */}
+++               {isEditing && !message.experimental_attachments && isUser ? (
+++                 <Box sx={{ p: 1, width: '100%' }}>
+++diff --git a/src/renderer/components/chat/MessageList.tsx b/src/renderer/components/chat/MessageList.tsx
+++index e8325677a..321206563 100644
+++--- a/src/renderer/components/chat/MessageList.tsx
++++++ b/src/renderer/components/chat/MessageList.tsx
+++@@ -14,6 +14,8 @@ interface MessageListProps {
+++   onEditSubmit: () => void;
+++   onEditContentChange: (ontent: string) => void;
+++   onEditCancel: () => void;
++++  loadingMessage?: string;
++++  disableEdit?: boolean;
+++ }
+++ 
+++ const MessageList: React.FC<MessageListProps> = ({
+++@@ -27,6 +29,8 @@ const MessageList: React.FC<MessageListProps> = ({
+++   onEditSubmit,
+++   onEditContentChange,
+++   onEditCancel,
++++  loadingMessage = 'AIKATA作業中…',
++++  disableEdit = false,
+++ }) => {
+++   const bottomRef = useRef<HTMLDivElement>(null);
+++ 
+++@@ -64,12 +68,13 @@ const MessageList: React.FC<MessageListProps> = ({
+++               onEditSubmit={onEditSubmit}
+++               onEditContentChange={onEditContentChange}
+++               onEditCancel={onEditCancel}
++++              disableEdit={disableEdit}
+++             />
+++           </Box>
++          );
++-         return {
++-           ...input.document,
++-+          originalName: input.document.originalName || input.document.name,
++-           reviewResults: reviewResult || [],
++-         };
++-       }),
+++       })}
+++ 
+++-      {status === 'streaming' && (
++++      {(status === 'streaming' || status === 'submitted') && (
+++         <Box
+++           sx={{
+++             display: 'flex',
+++@@ -80,7 +85,7 @@ const MessageList: React.FC<MessageListProps> = ({
+++         >
+++           <CircularProgress size={24} />
+++           <Box component="span" sx={{ ml: 1 }}>
+++-            AIKATA作業中…
++++            {loadingMessage}
+++           </Box>
+++         </Box>
+++       )}
+++diff --git a/src/renderer/components/review/ChecklistMentionInput.tsx b/src/renderer/components/review/ChecklistMentionInput.tsx
+++new file mode 100644
+++index 000000000..978c8d7be
+++--- /dev/null
++++++ b/src/renderer/components/review/ChecklistMentionInput.tsx
+++@@ -0,0 +1,364 @@
++++import React, { useState, useCallback, useMemo, useRef } from 'react';
++++import {
++++  Box,
++++  IconButton,
++++  InputAdornment,
++++  Paper,
++++  TextField,
++++  Chip,
++++  Popover,
++++  List,
++++  ListItem,
++++  ListItemButton,
++++  ListItemText,
++++} from '@mui/material';
++++import {
++++  Send as SendIcon,
++++  StopCircleOutlined as StopIcon,
++++} from '@mui/icons-material';
++++import { useAlertStore } from '@/renderer/stores/alertStore';
++++
++++/* ---------- 型定義 ---------- */
++++
++++export interface ChecklistOption {
++++  id: number;
++++  content: string;
++++}
++++
++++interface ChecklistMentionInputProps {
++++  handleSubmit: (e: React.FormEvent) => void;
++++  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
++++  message: string;
++++  disabled?: boolean;
++++  placeholder?: string;
++++  isStreaming?: boolean;
++++  onStop?: () => void;
++++  checklists: ChecklistOption[];
++++  selectedChecklistIds: number[];
++++  onChecklistSelect: (ids: number[]) => void;
++++}
++++
++++const ChecklistMentionInput: React.FC<ChecklistMentionInputProps> = ({
++++  handleSubmit,
++++  handleInputChange,
++++  message,
++++  disabled = false,
++++  placeholder = 'メッセージを入力...',
++++  isStreaming = false,
++++  onStop,
++++  checklists,
++++  selectedChecklistIds,
++++  onChecklistSelect,
++++}) => {
++++  const [isComposing, setIsComposing] = useState(false);
++++  const [showMentionMenu, setShowMentionMenu] = useState(false);
++++  const [mentionSearchText, setMentionSearchText] = useState('');
++++  const inputRef = useRef<HTMLDivElement>(null);
++++  const addAlert = useAlertStore((state) => state.addAlert);
++++
++++  /* ---------- チェックリストオプション ---------- */
++++  const checklistOptions = useMemo(() => {
++++    return checklists.map((cl) => ({ id: cl.id, content: cl.content }));
++++  }, [checklists]);
++++
++++  /* ---------- フィルタリングされたチェックリストオプション ---------- */
++++  const filteredOptions = useMemo(() => {
++++    if (!mentionSearchText) return checklistOptions;
++++    const lowerSearch = mentionSearchText.toLowerCase();
++++    return checklistOptions.filter((option) =>
++++      option.content.toLowerCase().includes(lowerSearch),
++++    );
++++  }, [checklistOptions, mentionSearchText]);
++++
++++  /* ---------- @メンション検出 ---------- */
++++  const detectMention = useCallback((text: string) => {
++++    const atIndex = text.lastIndexOf('@');
++++    if (atIndex === -1) return null;
++++
++++    // @が行の先頭にあるかチェック
++++    if (atIndex > 0) {
++++      const beforeAt = text[atIndex - 1];
++++      // @の直前が改行でない場合はnullを返す
++++      if (beforeAt !== '\n') return null;
++++    }
++++
++++    // @以降の文字列を取得
++++    const afterAt = text.slice(atIndex + 1);
++++    // 空白や改行があれば@メンション終了とみなす
++++    if (/\s/.test(afterAt)) return null;
++++
++++    return { atIndex, searchText: afterAt };
++++  }, []);
++++
++++  /* ---------- 入力変更ハンドラ ---------- */
++++  const handleChange = useCallback(
++++    (e: React.ChangeEvent<HTMLInputElement>) => {
++++      const newValue = e.target.value;
++++      handleInputChange(e);
++++
++++      // @メンション検出
++++      const mention = detectMention(newValue);
++++      if (mention) {
++++        setShowMentionMenu(true);
++++        setMentionSearchText(mention.searchText);
++++      } else {
++++        setShowMentionMenu(false);
++++        setMentionSearchText('');
++++      }
++++    },
++++    [handleInputChange, detectMention],
++++  );
++++
++++  /* ---------- チェックリスト選択ハンドラ ---------- */
++++  const handleChecklistSelect = useCallback(
++++    (checklist: ChecklistOption | null) => {
++++      if (!checklist) return;
++++
++++      const mention = detectMention(message);
++++      if (!mention) return;
++++
++++      // @検索文字列を削除
++++      const beforeAt = message.slice(0, mention.atIndex);
++++      const afterMention = message.slice(
++++        mention.atIndex + 1 + mention.searchText.length,
++++      );
++++      const newMessage = beforeAt + afterMention;
++++
++++      // 入力値を更新
++++      const syntheticEvent = {
++++        target: { value: newMessage },
++++      } as React.ChangeEvent<HTMLInputElement>;
++++      handleInputChange(syntheticEvent);
++++
++++      // 選択リストに追加（重複チェック）
++++      if (!selectedChecklistIds.includes(checklist.id)) {
++++        onChecklistSelect([...selectedChecklistIds, checklist.id]);
++++      }
++++
++++      // メニューを閉じる
++++      setShowMentionMenu(false);
++++      setMentionSearchText('');
++++    },
++++    [
++++      message,
++++      detectMention,
++++      handleInputChange,
++++      selectedChecklistIds,
++++      onChecklistSelect,
++++    ],
++++  );
++++
++++  /* ---------- 送信ハンドラ（バリデーション付き） ---------- */
++++  const handleSubmitWithValidation = useCallback(
++++    (e: React.FormEvent) => {
++++      e.preventDefault();
++++
++++      // チェックリストが一つも選択されていない場合は警告
++++      if (selectedChecklistIds.length === 0) {
++++        addAlert({
++++          message: '@でチェックリストを一つ以上選択してください',
++++          severity: 'warning',
++++        });
++++        return;
++++      }
++++      handleSubmit(e);
++++    },
++++    [selectedChecklistIds, handleSubmit, addAlert],
++++  );
++++
++++  /* ---------- Enter キー送信（Shift+Enter で改行） ---------- */
++++  const handleKeyDown = (e: React.KeyboardEvent) => {
++++    if (e.key === 'Enter' && !isComposing) {
++++      // @メンションメニューが表示されている場合は完全一致をチェック
++++      if (showMentionMenu && mentionSearchText) {
++++        const exactMatch = filteredOptions.find(
++++          (option) =>
++++            option.content.toLowerCase() === mentionSearchText.toLowerCase(),
++++        );
++++        if (exactMatch) {
++++          // 完全一致した場合は自動選択
++++          e.preventDefault();
++++          handleChecklistSelect(exactMatch);
++++          return;
++++        }
++++      }
++++
++++      // Shift+Enterの場合は改行を許可（preventDefaultしない）
++++      if (!e.shiftKey) {
++++        e.preventDefault();
++++        handleSubmitWithValidation(e);
++++      }
++++    }
++++  };
++++
++++  /* ---------- IME 制御 ---------- */
++++  const handleCompositionStart = () => setIsComposing(true);
++++  const handleCompositionEnd = () => setIsComposing(false);
++++
++++  /* ============================================================= */
++++
++++  return (
++++    <Box sx={{ p: 2, width: '100%', mx: 'auto' }}>
++++      {/* 選択中のチェックリスト表示 */}
++++      {selectedChecklistIds.length > 0 && (
++++        <Box
++++          sx={{
++++            mb: 1,
++++            display: 'flex',
++++            flexDirection: 'column',
++++            alignItems: 'flex-start',
++++            gap: 0.5,
++++            overflow: 'auto',
++++            maxHeight: 100,
++++            pb: 0.5,
++++          }}
++++        >
++++          {selectedChecklistIds.map((id) => {
++++            const checklist = checklists.find((cl) => cl.id === id);
++++            if (!checklist) return null;
++++            return (
++++              <Chip
++++                key={id}
++++                label={checklist.content}
++++                size="small"
++++                color="primary"
++++                variant="outlined"
++++                onDelete={() => {
++++                  onChecklistSelect(
++++                    selectedChecklistIds.filter((cid) => cid !== id),
++++                  );
++++                }}
++++              />
++++            );
++++          })}
++++        </Box>
++++      )}
++++
++++      {/* 入力欄 ----------------------------------------------------------- */}
++++      <Paper
++++        component="form"
++++        onSubmit={handleSubmitWithValidation}
++++        elevation={3}
++++        sx={{
++++          p: '2px 4px',
++++          display: 'flex',
++++          alignItems: 'center',
++++          borderRadius: 2,
++++          position: 'relative',
++++        }}
++++      >
++++        {/* メインのテキストフィールド */}
++++        <TextField
++++          ref={inputRef}
++++          fullWidth
++++          multiline
++++          minRows={1}
++++          maxRows={6}
++++          placeholder={placeholder}
++++          variant="outlined"
++++          value={message}
++++          onChange={handleChange}
++++          onKeyDown={handleKeyDown}
++++          onCompositionStart={handleCompositionStart}
++++          onCompositionEnd={handleCompositionEnd}
++++          disabled={disabled}
++++          slotProps={{
++++            input: {
++++              sx: {
++++                p: 1,
++++                '& fieldset': { border: 'none' },
++++              },
++++              endAdornment: (
++++                <InputAdornment position="end">
++++                  {isStreaming ? (
++++                    <IconButton
++++                      color="primary"
++++                      onClick={onStop}
++++                      data-testid="review-chat-stop-button"
++++                    >
++++                      <StopIcon />
++++                    </IconButton>
++++                  ) : (
++++                    <IconButton
++++                      color="primary"
++++                      type="submit"
++++                      disabled={disabled || !message.trim()}
++++                      data-testid="review-chat-send-button"
++++                    >
++++                      <SendIcon />
++++                    </IconButton>
++++                  )}
++++                </InputAdornment>
++++              ),
++++            },
++++          }}
++++        />
++++
++++        {/* @メンション選択メニュー */}
++++        <Popover
++++          open={showMentionMenu}
++++          anchorEl={inputRef.current}
++++          onClose={() => {
++++            setShowMentionMenu(false);
++++            setMentionSearchText('');
++++          }}
++++          anchorOrigin={{
++++            vertical: 'top',
++++            horizontal: 'left',
++++          }}
++++          transformOrigin={{
++++            vertical: 'bottom',
++++            horizontal: 'left',
++++          }}
++++          disableAutoFocus
++++          disableEnforceFocus
++++          disableRestoreFocus
++++          slotProps={{
++++            paper: {
++++              sx: {
++++                maxHeight: 200,
++++                width: inputRef.current?.offsetWidth || 300,
++++                overflow: 'auto',
++++              },
++++            },
++++          }}
++++        >
++++          <List dense>
++++            {filteredOptions.length > 0 ? (
++++              filteredOptions.map((option) => (
++++                <ListItem key={option.id} disablePadding>
++++                  <ListItemButton
++++                    onClick={() => handleChecklistSelect(option)}
++++                    selected={selectedChecklistIds.includes(option.id)}
++++                  >
++++                    <ListItemText
++++                      primary={`@${option.content}`}
++++                      primaryTypographyProps={{
++++                        sx: {
++++                          fontWeight:
++++                            option.content.toLowerCase() ===
++++                            mentionSearchText.toLowerCase()
++++                              ? 'bold'
++++                              : 'normal',
++++                        },
++++                      }}
++++                    />
++++                  </ListItemButton>
++++                </ListItem>
++++              ))
++++            ) : (
++++              <ListItem>
++++                <ListItemText
++++                  primary="該当するチェックリストがありません"
++++                  sx={{ color: 'text.secondary', fontStyle: 'italic' }}
++++                />
++++              </ListItem>
++++            )}
++++          </List>
++++        </Popover>
++++      </Paper>
++++    </Box>
++++  );
++++};
++++
++++export default ChecklistMentionInput;
+++diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
+++index 2d2322987..d75832619 100644
+++--- a/src/renderer/components/review/ReviewArea.tsx
++++++ b/src/renderer/components/review/ReviewArea.tsx
+++@@ -6,11 +6,11 @@ import {
+++   Stack,
+++   Typography,
+++   LinearProgress,
+++-  Alert,
+++ } from '@mui/material';
+++ import CheckBoxIcon from '@mui/icons-material/CheckBox';
+++ import RateReviewIcon from '@mui/icons-material/RateReview';
+++ import StopIcon from '@mui/icons-material/Stop';
++++import ChatIcon from '@mui/icons-material/Chat';
+++ import {
+++   ReviewChecklistEdit,
+++   ReviewChecklistResult,
+++@@ -25,6 +25,7 @@ import {
+++ import { ReviewAreaProps } from './types';
+++ import ReviewChecklistSection from './ReviewChecklistSection';
+++ import ReviewSourceModal from './ReviewSourceModal';
++++import ReviewChatPanel from './ReviewChatPanel';
+++ import { ReviewApi } from '../../service/reviewApi';
+++ import { useAlertStore } from '../../stores/alertStore';
+++ import { getSafeErrorMessage } from '../../lib/error';
+++@@ -47,6 +48,9 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+++   const [checklistResults, setChecklistResults] = useState<
+++     ReviewChecklistResult[]
+++   >([]);
++++  const [targetDocumentName, setTargetDocumentName] = useState<string | null>(
++++    null,
++++  );
+++   // チェックリスト更新処理中であるかどうか
+++   const [isSaving, setIsSaving] = useState(false);
+++   const [isExtracting, setIsExtracting] = useState(false);
+++@@ -58,6 +62,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+++   const [evaluationSettings, setEvaluationSettings] =
+++     useState<CustomEvaluationSettings>(defaultEvaluationSettings);
+++ 
++++  // チャット関連の状態管理
++++  const [chatPanelOpen, setChatPanelOpen] = useState(false);
++++  const [chatPanelWidth, setChatPanelWidth] = useState(500);
++++  const [isResizing, setIsResizing] = useState(false);
++++
+++   const addAlert = useAlertStore((state) => state.addAlert);
+++ 
+++   // イベント購読の解除関数を管理
+++@@ -73,6 +82,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+++       { throwError: true, showAlert: true },
+++     );
+++     setChecklistResults(result?.checklistResults || []);
++++    setTargetDocumentName(result?.targetDocumentName || null);
+++   }, [selectedReviewHistoryId]);
+++ 
+++   // チェックリスト抽出完了の共通処理ハンドラー
+++@@ -526,6 +536,38 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+++     setIsSaving(false);
+++   };
+++ 
++++  // リサイズハンドラ
++++  const handleMouseDown = (e: React.MouseEvent) => {
++++    setIsResizing(true);
++++    e.preventDefault();
++++  };
++++
++++  useEffect(() => {
++++    if (!isResizing) return;
++++
++++    const handleMouseMove = (e: MouseEvent) => {
++++      // 画面右端からのマウス位置を計算
++++      const newWidth = window.innerWidth - e.clientX;
++++      // 最小幅350px、最大幅は画面の65%まで
++++      const minWidth = 350;
++++      const maxWidth = window.innerWidth * 0.65;
++++      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
++++      setChatPanelWidth(clampedWidth);
++++    };
++++
++++    const handleMouseUp = () => {
++++      setIsResizing(false);
++++    };
++++
++++    document.addEventListener('mousemove', handleMouseMove);
++++    document.addEventListener('mouseup', handleMouseUp);
++++
++++    return () => {
++++      document.removeEventListener('mousemove', handleMouseMove);
++++      document.removeEventListener('mouseup', handleMouseUp);
++++    };
++++  }, [isResizing]);
++++
+++   return (
+++     <Box
+++       sx={{
+++@@ -548,15 +590,10 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+++           {(isExtracting || isReviewing) && (
+++             <Box sx={{ mb: 2 }}>
+++               <LinearProgress />
+++-              {/* <Alert severity="info" sx={{ mt: 1 }}>
+++-                {isExtracting
+++-                  ? 'チェックリスト抽出実行中...'
+++-                  : 'レビュー実行中...'}
+++-              </Alert> */}
+++             </Box>
+++           )}
+++ 
+++-          {/* ヘッダー部分 */}
++++          {/* ヘッダー部分 - 主要アクションボタン */}
+++           <Stack
+++             direction="row"
+++             justifyContent="space-between"
+++@@ -600,25 +637,85 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+++               >
+++                 {isReviewing ? 'キャンセル' : 'レビュー実行'}
+++               </Button>
++++              <Button
++++                variant="contained"
++++                color="primary"
++++                startIcon={<ChatIcon />}
++++                onClick={() => setChatPanelOpen(true)}
++++                disabled={
++++                  !selectedReviewHistoryId ||
++++                  isExtracting ||
++++                  isReviewing ||
++++                  checklistResults.filter((cl) => cl.sourceEvaluation?.comment)
++++                    .length === 0
++++                }
++++              >
++++                質問
++++              </Button>
+++             </Stack>
+++           </Stack>
+++ 
+++-          {/* メインコンテンツ */}
+++-          <Paper
++++          {/* メインコンテンツ - Split View */}
++++          <Box
+++             sx={{
+++-              p: 2,
+++-              flex: 1,
+++               display: 'flex',
+++-              flexDirection: 'column',
++++              flexDirection: 'row',
++++              flex: 1,
+++               minHeight: 0,
++++              gap: 0,
+++             }}
+++           >
+++-            <ReviewChecklistSection
+++-              checklistResults={checklistResults}
+++-              isLoading={isExtracting || isReviewing}
+++-              onSave={handleSaveChecklist}
+++-            />
+++-          </Paper>
++++            {/* レビュー結果エリア */}
++++            <Paper
++++              sx={{
++++                p: 2,
++++                flex: 1,
++++                display: 'flex',
++++                flexDirection: 'column',
++++                minHeight: 0,
++++                minWidth: chatPanelOpen ? 400 : 0,
++++                overflow: 'hidden',
++++              }}
++++            >
++++              <ReviewChecklistSection
++++                checklistResults={checklistResults}
++++                isLoading={isExtracting || isReviewing}
++++                onSave={handleSaveChecklist}
++++                targetDocumentName={targetDocumentName}
++++              />
++++            </Paper>
++++
++++            {/* リサイズハンドル */}
++++            {chatPanelOpen && (
++++              <Box
++++                onMouseDown={handleMouseDown}
++++                sx={{
++++                  width: '6px',
++++                  cursor: 'col-resize',
++++                  bgcolor: 'divider',
++++                  transition: 'background-color 0.2s',
++++                  flexShrink: 0,
++++                  userSelect: 'none',
++++                }}
++++              />
++++            )}
++++
++++            {/* チャットパネル */}
++++            {selectedReviewHistoryId && (
++++              <ReviewChatPanel
++++                open={chatPanelOpen}
++++                onClose={() => setChatPanelOpen(false)}
++++                reviewHistoryId={selectedReviewHistoryId}
++++                checklists={checklistResults
++++                  .filter((cl) => cl.sourceEvaluation?.comment)
++++                  .map((cl) => ({
++++                    id: cl.id,
++++                    content: cl.content,
++++                  }))}
++++                width={chatPanelWidth}
++++              />
++++            )}
++++          </Box>
+++ 
+++           {/* モーダル */}
+++           <ReviewSourceModal
+++diff --git a/src/renderer/components/review/ReviewChatPanel.tsx b/src/renderer/components/review/ReviewChatPanel.tsx
+++new file mode 100644
+++index 000000000..525cfea7b
+++--- /dev/null
++++++ b/src/renderer/components/review/ReviewChatPanel.tsx
+++@@ -0,0 +1,265 @@
++++import React, { useState, useEffect, useCallback } from 'react';
++++import { useChat } from '@ai-sdk/react';
++++import { Box, Divider, IconButton } from '@mui/material';
++++import CloseIcon from '@mui/icons-material/Close';
++++import { v4 as uuid } from 'uuid';
++++import { ChatMessage } from '@/types';
++++import { IpcRequestPayload, IpcChannels } from '@/types/ipc';
++++import { useAlertStore } from '@/renderer/stores/alertStore';
++++import { getSafeErrorMessage } from '@/renderer/lib/error';
++++import MessageList from '../chat/MessageList';
++++import ChecklistMentionInput, {
++++  ChecklistOption,
++++} from './ChecklistMentionInput';
++++import { ReviewChatApi } from '../../service/reviewChatApi';
++++
++++interface ReviewChatPanelProps {
++++  open: boolean;
++++  onClose: () => void;
++++  reviewHistoryId: string;
++++  checklists: ChecklistOption[];
++++  width?: number;
++++}
++++
++++// customFetch関数 - ChatArea.tsxを参考に実装
++++const customFetch: typeof fetch = async (input, init) => {
++++  if (typeof input === 'string' && input === '/api/review-chat') {
++++    let unsubscribe: () => void;
++++    const encoder = new TextEncoder();
++++    const reviewChatApi = ReviewChatApi.getInstance();
++++
++++    const stream = new ReadableStream({
++++      start(controller) {
++++        unsubscribe = reviewChatApi.streamResponse({
++++          onMessage(raw) {
++++            controller.enqueue(encoder.encode(raw));
++++          },
++++          onDone() {
++++            controller.close();
++++          },
++++          onError(err) {
++++            controller.error(err);
++++          },
++++        });
++++
++++        const { reviewHistoryId, checklistIds, question } = JSON.parse(
++++          init!.body as string,
++++        ) as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
++++
++++        init?.signal?.addEventListener('abort', () => {
++++          reviewChatApi.abortChat(reviewHistoryId, {
++++            showAlert: false,
++++            throwError: true,
++++          });
++++          unsubscribe();
++++          controller.close();
++++        });
++++
++++        reviewChatApi.sendMessage(reviewHistoryId, checklistIds, question, {
++++          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
++++          showAlert: false,
++++          throwError: false,
++++        });
++++      },
++++      cancel() {
++++        unsubscribe();
++++      },
++++    });
++++
++++    return new Response(stream, {
++++      headers: {
++++        // SSE＋Data Stream Protocol ヘッダ
++++        'Content-Type': 'text/event-stream; charset=utf-8',
++++        'x-vercel-ai-data-stream': 'v1',
++++      },
++++    });
++++  }
++++
++++  return fetch(input, init);
++++};
++++
++++// プレースホルダーテキストを取得する関数
++++const getPlaceholderText = (status: string): string => {
++++  if (status === 'submitted') return 'メッセージ送信中…';
++++  return '@でチェックリストを選択して質問してください';
++++};
++++
++++const ReviewChatPanel: React.FC<ReviewChatPanelProps> = ({
++++  open,
++++  onClose,
++++  reviewHistoryId,
++++  checklists,
++++  width = 500,
++++}) => {
++++  const [input, setInput] = useState<string>('');
++++  const [selectedChecklistIds, setSelectedChecklistIds] = useState<number[]>(
++++    [],
++++  );
++++  const addAlert = useAlertStore((state) => state.addAlert);
++++
++++  const { messages, setMessages, reload, status, error, stop } = useChat({
++++    id: reviewHistoryId,
++++    api: '/api/review-chat',
++++    fetch: customFetch,
++++    experimental_throttle: 75,
++++    experimental_prepareRequestBody: (request) => {
++++      // Ensure messages array is not empty and get the last message
++++      const lastMessage =
++++        request.messages.length > 0
++++          ? request.messages[request.messages.length - 1]
++++          : null;
++++      if (!lastMessage) {
++++        throw new Error('送信メッセージの取得に失敗しました');
++++      }
++++
++++      // Return the structured body for API route
++++      return {
++++        reviewHistoryId,
++++        checklistIds: selectedChecklistIds,
++++        question: lastMessage.content,
++++      } as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
++++    },
++++    onError(err) {
++++      console.error('useChat error:', err);
++++    },
++++  });
++++
++++  // useChatのエラーをアラートとして表示
++++  useEffect(() => {
++++    if (error) {
++++      addAlert({
++++        message: getSafeErrorMessage(error),
++++        severity: 'error',
++++      });
++++    }
++++  }, [error, addAlert]);
++++
++++  // レビューID変更時にチャット内容を初期化
++++  useEffect(() => {
++++    setMessages([]);
++++    setInput('');
++++    setSelectedChecklistIds([]);
++++  }, [reviewHistoryId, setMessages]);
++++
++++  /* ---------- メッセージ送信処理 ---------- */
++++  const handleInputChange = useCallback(
++++    (e: React.ChangeEvent<HTMLInputElement>) => {
++++      setInput(e.target.value);
++++    },
++++    [],
++++  );
++++
++++  const handleSubmit = useCallback(
++++    async (e: React.FormEvent) => {
++++      e.preventDefault();
++++      if (!input.trim()) return;
++++
++++      // チェックリスト未選択の場合は警告
++++      if (selectedChecklistIds.length === 0) {
++++        addAlert({
++++          message: '@でチェックリストを選択してください',
++++          severity: 'warning',
++++        });
++++        return;
++++      }
++++
++++      // 選択されたチェックリストの内容を取得してフォーマット
++++      const selectedChecklistContents = selectedChecklistIds
++++        .map((id) => {
++++          const checklist = checklists.find((cl) => cl.id === id);
++++          return checklist ? `@${checklist.content}` : null;
++++        })
++++        .filter((content): content is string => content !== null);
++++
++++      // チェックリスト部分 + 空行 + 本文の形式でメッセージを構築
++++      const formattedContent =
++++        selectedChecklistContents.length > 0
++++          ? `${selectedChecklistContents.join('\n')}\n\n${input}`
++++          : input;
++++
++++      const newMessage: ChatMessage = {
++++        id: uuid(),
++++        role: 'user',
++++        content: formattedContent,
++++        parts: [
++++          {
++++            type: 'text',
++++            text: formattedContent,
++++          },
++++        ],
++++      };
++++
++++      setInput('');
++++      setMessages((prev) => [...prev, newMessage]);
++++      reload();
++++    },
++++    [input, selectedChecklistIds, checklists, addAlert, setMessages, reload],
++++  );
++++
++++  if (!open) return null;
++++
++++  return (
++++    <Box
++++      sx={{
++++        width,
++++        minWidth: 300,
++++        height: '100%',
++++        display: 'flex',
++++        flexDirection: 'column',
++++        borderLeft: 1,
++++        borderColor: 'divider',
++++        bgcolor: 'background.paper',
++++        position: 'relative',
++++      }}
++++    >
++++      {/* ヘッダー（閉じるボタン） */}
++++      <Box
++++        sx={{
++++          display: 'flex',
++++          justifyContent: 'flex-end',
++++          p: 1,
++++          borderBottom: 1,
++++          borderColor: 'divider',
++++        }}
++++      >
++++        <IconButton size="small" onClick={onClose}>
++++          <CloseIcon />
++++        </IconButton>
++++      </Box>
++++
++++      {/* メッセージリスト */}
++++      <MessageList
++++        messages={messages}
++++        loading={false}
++++        status={status}
++++        editContent=""
++++        disabled={status === 'submitted' || status === 'streaming'}
++++        editingMessageId=""
++++        onEditStart={() => {}}
++++        onEditContentChange={() => {}}
++++        onEditSubmit={async () => {}}
++++        onEditCancel={() => {}}
++++        loadingMessage="ドキュメントの調査中..."
++++        disableEdit
++++      />
++++
++++      <Divider />
++++
++++      {/* メッセージ入力 */}
++++      <ChecklistMentionInput
++++        handleSubmit={handleSubmit}
++++        handleInputChange={handleInputChange}
++++        message={input}
++++        disabled={status === 'submitted' || status === 'streaming'}
++++        placeholder={getPlaceholderText(status)}
++++        isStreaming={status === 'streaming'}
++++        onStop={stop}
++++        checklists={checklists}
++++        selectedChecklistIds={selectedChecklistIds}
++++        onChecklistSelect={setSelectedChecklistIds}
++++      />
++++    </Box>
++++  );
++++};
++++
++++export default ReviewChatPanel;
+++diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
+++index d37a5b5c9..7b00c802b 100644
+++--- a/src/renderer/components/review/ReviewChecklistSection.tsx
++++++ b/src/renderer/components/review/ReviewChecklistSection.tsx
+++@@ -58,6 +58,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+++   checklistResults,
+++   isLoading,
+++   onSave,
++++  targetDocumentName,
+++ }) => {
+++   // --- ステート ---
+++   const [editingId, setEditingId] = useState<number | null>(null);
+++@@ -94,11 +95,11 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+++     setIsAddingNew(false);
+++     setNewContent('');
+++   };
+++-  const handleSort = (fileId: string) => {
+++-    if (sortBy === fileId) {
++++  const handleSort = () => {
++++    if (sortBy === 'evaluation') {
+++       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
+++     } else {
+++-      setSortBy(fileId);
++++      setSortBy('evaluation');
+++       setSortDirection('desc');
+++     }
+++   };
+++@@ -110,35 +111,15 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+++     downloadCSV(csvContent, filename);
+++   };
+++ 
+++-  // --- ユニークファイル抽出 ---
+++-  const uniqueSources = useMemo(() => {
+++-    const map = new Map<string, { id: string; fileName: string }>();
+++-    checklistResults.forEach((cl) => {
+++-      cl.sourceEvaluations?.forEach((ev) => {
+++-        if (!map.has(ev.fileId)) {
+++-          map.set(ev.fileId, {
+++-            id: ev.fileId,
+++-            fileName: ev.fileName,
+++-          });
+++-        }
+++-      });
+++-    });
+++-    return Array.from(map.values());
+++-  }, [checklistResults]);
+++-
+++   // --- ソート ---
+++   // 動的評価項目対応のため、文字列順ソートを使用
+++   const sortedResults = useMemo(() => {
+++-    if (sortBy == null) return checklistResults;
++++    if (sortBy !== 'evaluation') return checklistResults;
+++ 
+++     return [...checklistResults].sort((a, b) => {
+++-      // 対象ファイルの評価を取得。未評価は空文字扱い
+++-      const aEv =
+++-        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
+++-        '';
+++-      const bEv =
+++-        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
+++-        '';
++++      // 評価を取得。未評価は空文字扱い
++++      const aEv = a.sourceEvaluation?.evaluation ?? '';
++++      const bEv = b.sourceEvaluation?.evaluation ?? '';
+++ 
+++       // 文字列順で比較
+++       if (sortDirection === 'desc') {
+++@@ -169,41 +150,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+++         >
+++           チェックリスト
+++         </TableCell>
+++-        {uniqueSources.map((src) => (
+++-          <TableCell
+++-            key={src.id}
+++-            align="center"
+++-            sx={{
+++-              minWidth: 200,
+++-            }}
++++        <TableCell
++++          align="center"
++++          sx={{
++++            minWidth: 300,
++++          }}
++++        >
++++          <TableSortLabel
++++            active={sortBy === 'evaluation'}
++++            direction={sortBy === 'evaluation' ? sortDirection : 'desc'}
++++            onClick={() => handleSort()}
+++           >
+++-            <Box
+++-              sx={{
+++-                maxHeight: '4.5em',
+++-                overflow: 'hidden',
+++-                overflowY: 'auto',
+++-                lineHeight: '1.5em',
+++-                whiteSpace: 'normal',
+++-                wordBreak: 'break-all',
+++-                '&:hover': {
+++-                  overflowY: 'auto',
+++-                },
+++-              }}
+++-            >
+++-              <Tooltip title={src.fileName} placement="top">
+++-                <div>
+++-                  <TableSortLabel
+++-                    active={sortBy === src.id}
+++-                    direction={sortBy === src.id ? sortDirection : 'desc'}
+++-                    onClick={() => handleSort(src.id)}
+++-                  >
+++-                    {src.fileName}
+++-                  </TableSortLabel>
+++-                </div>
++++            {targetDocumentName ? (
++++              <Tooltip title={targetDocumentName} placement="top">
++++                <Box
++++                  component="span"
++++                  sx={{
++++                    maxHeight: '4.5em',
++++                    overflow: 'hidden',
++++                    textOverflow: 'ellipsis',
++++                    wordBreak: 'break-all',
++++                    whiteSpace: 'normal',
++++                  }}
++++                >
++++                  レビュー結果 ({targetDocumentName})
++++                </Box>
+++               </Tooltip>
+++-            </Box>
+++-          </TableCell>
+++-        ))}
++++            ) : (
++++              'レビュー結果'
++++            )}
++++          </TableSortLabel>
++++        </TableCell>
+++         <TableCell align="center" sx={{ minWidth: 120 }}>
+++           操作
+++         </TableCell>
+++@@ -231,44 +208,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+++           )}
+++         </Box>
+++       </TableCell>
+++-      {/* 評価列 */}
+++-      {uniqueSources.map((src) => {
+++-        const ev = checklist.sourceEvaluations?.find(
+++-          (x) => x.fileId === src.id,
+++-        );
+++-        return (
+++-          <TableCell
+++-            key={src.id}
+++-            align="center"
+++-            sx={{ p: 1, verticalAlign: 'top' }}
+++-          >
+++-            <Box>
+++-              {ev?.evaluation && (
+++-                <Stack spacing={1} alignItems="center">
+++-                  <Typography
+++-                    variant="body2"
+++-                    sx={{
+++-                      color: getEvaluationColor(ev.evaluation),
+++-                      fontWeight: 'bold',
+++-                      textDecoration: 'underline',
+++-                      textDecorationColor: getEvaluationColor(ev.evaluation),
+++-                      textDecorationThickness: '2px',
+++-                      textUnderlineOffset: '3px',
+++-                    }}
+++-                  >
+++-                    {ev.evaluation}
+++-                  </Typography>
+++-                  {ev.comment && (
+++-                    <Typography variant="body2" sx={commentBoxSx}>
+++-                      {ev.comment}
+++-                    </Typography>
+++-                  )}
+++-                </Stack>
++++      {/* レビュー結果列 */}
++++      <TableCell align="center" sx={{ p: 1, verticalAlign: 'top' }}>
++++        <Box>
++++          {checklist.sourceEvaluation?.evaluation && (
++++            <Stack spacing={1} alignItems="center">
++++              <Typography
++++                variant="body2"
++++                sx={{
++++                  color: getEvaluationColor(
++++                    checklist.sourceEvaluation.evaluation,
++++                  ),
++++                  fontWeight: 'bold',
++++                  textDecoration: 'underline',
++++                  textDecorationColor: getEvaluationColor(
++++                    checklist.sourceEvaluation.evaluation,
++++                  ),
++++                  textDecorationThickness: '2px',
++++                  textUnderlineOffset: '3px',
++++                }}
++++              >
++++                {checklist.sourceEvaluation.evaluation}
++++              </Typography>
++++              {checklist.sourceEvaluation.comment && (
++++                <Typography variant="body2" sx={commentBoxSx}>
++++                  {checklist.sourceEvaluation.comment}
++++                </Typography>
+++               )}
+++-            </Box>
+++-          </TableCell>
+++-        );
+++-      })}
++++            </Stack>
++++          )}
++++        </Box>
++++      </TableCell>
+++       {/* 操作 */}
+++       <TableCell align="center" sx={{ p: 1 }}>
+++         <Stack direction="row" spacing={1} justifyContent="center">
+++@@ -321,10 +291,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+++           />
+++         </Box>
+++       </TableCell>
+++-      {uniqueSources.map((_, i) => (
+++-        // eslint-disable-next-line
+++-        <TableCell key={i} />
+++-      ))}
++++      <TableCell />
+++       <TableCell align="center" sx={{ p: 1 }}>
+++         <Stack direction="row" spacing={1} justifyContent="center">
+++           <IconButton
+++diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
+++index 2599bdf7c..1f662086c 100644
+++--- a/src/renderer/components/review/types.ts
++++++ b/src/renderer/components/review/types.ts
+++@@ -18,6 +18,7 @@ export interface ReviewChecklistSectionProps {
+++   checklistResults: ReviewChecklistResult[];
+++   isLoading: boolean;
+++   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
++++  targetDocumentName?: string | null;
+++ }
+++ 
+++ // ReviewSourceModalのProps型
+++diff --git a/src/renderer/lib/csvUtils.ts b/src/renderer/lib/csvUtils.ts
+++index 7cfdefb6c..c5aac8405 100644
+++--- a/src/renderer/lib/csvUtils.ts
++++++ b/src/renderer/lib/csvUtils.ts
+++@@ -36,27 +36,8 @@ export const convertReviewResultsToCSV = (
+++     return 'チェックリスト\n';
+++   }
+++ 
+++-  // ユニークなソースファイルを抽出
+++-  const uniqueSources = new Map<string, { id: string; fileName: string }>();
+++-  checklistResults.forEach((checklist) => {
+++-    checklist.sourceEvaluations?.forEach((ev) => {
+++-      if (!uniqueSources.has(ev.fileId)) {
+++-        uniqueSources.set(ev.fileId, {
+++-          id: ev.fileId,
+++-          fileName: ev.fileName,
+++-        });
+++-      }
+++-    });
+++-  });
+++-
+++-  const sources = Array.from(uniqueSources.values());
+++-
+++   // ヘッダー行を構築
+++-  const headers = ['チェックリスト'];
+++-  sources.forEach((source) => {
+++-    headers.push(`${source.fileName}_評価`);
+++-    headers.push(`${source.fileName}_コメント`);
+++-  });
++++  const headers = ['チェックリスト', '評価', 'コメント'];
+++ 
+++   const csvRows: string[] = [];
+++ 
+++@@ -65,18 +46,11 @@ export const convertReviewResultsToCSV = (
+++ 
+++   // データ行を追加
+++   checklistResults.forEach((checklist) => {
+++-    const row: string[] = [checklist.content];
+++-
+++-    sources.forEach((source) => {
+++-      const evaluation = checklist.sourceEvaluations?.find(
+++-        (ev) => ev.fileId === source.id,
+++-      );
+++-
+++-      // 評価値
+++-      row.push(evaluation?.evaluation || '');
+++-      // コメント
+++-      row.push(evaluation?.comment || '');
+++-    });
++++    const row: string[] = [
++++      checklist.content,
++++      checklist.sourceEvaluation?.evaluation || '',
++++      checklist.sourceEvaluation?.comment || '',
++++    ];
+++ 
+++     csvRows.push(row.map(escapeCSVField).join(','));
+++   });
+++diff --git a/src/renderer/service/chatApi.ts b/src/renderer/service/chatApi.ts
+++index 7e99d3fcf..ae3995928 100644
+++--- a/src/renderer/service/chatApi.ts
++++++ b/src/renderer/service/chatApi.ts
+++@@ -129,9 +129,13 @@ export class ChatApi implements IChatApi {
+++     roomId: string,
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<void> {
+++-    await invokeApi(() => window.electron.chat.requestAbort({
+++-      threadId: roomId,
+++-    }), options);
++++    await invokeApi(
++++      () =>
++++        window.electron.chat.requestAbort({
++++          threadId: roomId,
++++        }),
++++      options,
++++    );
+++   }
+++ 
+++   public async getChatMessages(
+++@@ -146,7 +150,10 @@ export class ChatApi implements IChatApi {
+++     title: string,
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<void> {
+++-    await invokeApi(() => window.electron.chat.createThread({ roomId, title }), options);
++++    await invokeApi(
++++      () => window.electron.chat.createThread({ roomId, title }),
++++      options,
++++    );
+++   }
+++ 
+++   public async sendMessage(
+++@@ -154,7 +161,10 @@ export class ChatApi implements IChatApi {
+++     messages: ChatMessage[],
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<void> {
+++-    await invokeApi(() => window.electron.chat.sendMessage({ roomId, messages }), options);
++++    await invokeApi(
++++      () => window.electron.chat.sendMessage({ roomId, messages }),
++++      options,
++++    );
+++     console.log('Message sent via IPC:', { roomId, messages });
+++   }
+++ 
+++@@ -163,9 +173,13 @@ export class ChatApi implements IChatApi {
+++     messageId: string,
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<void> {
+++-    await invokeApi(() => window.electron.chat.deleteMessagesBeforeSpecificId({
+++-      threadId: roomId,
+++-      messageId,
+++-    }), options);
++++    await invokeApi(
++++      () =>
++++        window.electron.chat.deleteMessagesBeforeSpecificId({
++++          threadId: roomId,
++++          messageId,
++++        }),
++++      options,
++++    );
+++   }
+++ }
+++diff --git a/src/renderer/service/fsApi.ts b/src/renderer/service/fsApi.ts
+++index bf8cc05a5..69f5b5f9b 100644
+++--- a/src/renderer/service/fsApi.ts
++++++ b/src/renderer/service/fsApi.ts
+++@@ -40,7 +40,10 @@ export class FsApi implements IFsApi {
+++     options: OpenDialogOptions,
+++     apiOptions?: ApiServiceDefaultOptions,
+++   ): Promise<{ filePaths: string[]; canceled: boolean } | null> {
+++-    return invokeApi(() => window.electron.fs.showOpenDialog(options), apiOptions);
++++    return invokeApi(
++++      () => window.electron.fs.showOpenDialog(options),
++++      apiOptions,
++++    );
+++   }
+++ 
+++   public async readFile(
+++diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
+++index 02fc24edb..1ed208b6f 100644
+++--- a/src/renderer/service/reviewApi.ts
++++++ b/src/renderer/service/reviewApi.ts
+++@@ -27,6 +27,7 @@ export interface IReviewApi {
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<{
+++     checklistResults?: ReviewChecklistResult[];
++++    targetDocumentName?: string | null;
+++   } | null>;
+++   getReviewInstruction(
+++     historyId: string,
+++@@ -118,6 +119,7 @@ export class ReviewApi implements IReviewApi {
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<{
+++     checklistResults?: ReviewChecklistResult[];
++++    targetDocumentName?: string | null;
+++   } | null> {
+++     return invokeApi(
+++       () => window.electron.review.getHistoryDetail(historyId),
+++diff --git a/src/renderer/service/reviewChatApi.ts b/src/renderer/service/reviewChatApi.ts
+++new file mode 100644
+++index 000000000..f3da0c3d2
+++--- /dev/null
++++++ b/src/renderer/service/reviewChatApi.ts
+++@@ -0,0 +1,136 @@
++++import { IpcChannels, IpcEventPayload } from '@/types';
++++import { invokeApi } from '../lib/apiUtils';
++++import { ApiServiceDefaultOptions } from '../types';
++++import { ElectronPushClient } from '../lib/ElectronPushClient';
++++
++++export interface IReviewChatApi {
++++  streamResponse(callbacks: {
++++    onMessage: (
++++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
++++    ) => void;
++++    onDone: () => void;
++++    onError: (error: Error) => void;
++++  }): () => void;
++++  abortChat(
++++    reviewHistoryId: string,
++++    options?: ApiServiceDefaultOptions,
++++  ): Promise<void>;
++++  sendMessage(
++++    reviewHistoryId: string,
++++    checklistIds: number[],
++++    question: string,
++++    options?: ApiServiceDefaultOptions,
++++  ): Promise<void>;
++++}
++++
++++// IPC通信を使用してレビューチャット機能を提供するAPIサービス
++++export class ReviewChatApi implements IReviewChatApi {
++++  // シングルトン変数
++++  private static instance: ReviewChatApi;
++++
++++  // コンストラクタをprivateにして外部からのインスタンス化を防止
++++  private constructor() {}
++++
++++  // シングルトンインスタンスを取得するための静的メソッド
++++  public static getInstance(): ReviewChatApi {
++++    if (!ReviewChatApi.instance) {
++++      ReviewChatApi.instance = new ReviewChatApi();
++++    }
++++    return ReviewChatApi.instance;
++++  }
++++
++++  /**
++++   * ストリーミング応答の購読
++++   * @param callbacks ストリーミングイベントのコールバック
++++   * @returns 購読解除用の関数
++++   */
++++  public streamResponse(callbacks: {
++++    onMessage: (
++++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
++++    ) => void;
++++    onDone: () => void;
++++    onError: (error: Error) => void;
++++  }): () => void {
++++    const pushClient = new ElectronPushClient();
++++    const abortController = new AbortController();
++++
++++    // ストリーミングイベントの購読
++++    pushClient.subscribe(
++++      IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
++++      (event) => {
++++        callbacks.onMessage(event.payload);
++++      },
++++      { signal: abortController.signal },
++++    );
++++
++++    // 完了イベント（レビューチャット専用）
++++    pushClient.subscribe(
++++      IpcChannels.REVIEW_CHAT_COMPLETE,
++++      () => {
++++        // 購読を解除
++++        abortController.abort();
++++        // 完了コールバックを呼び出し
++++        callbacks.onDone();
++++      },
++++      { signal: abortController.signal },
++++    );
++++
++++    // エラーイベント（レビューチャット専用）
++++    pushClient.subscribe(
++++      IpcChannels.REVIEW_CHAT_ERROR,
++++      (event) => {
++++        // 購読を解除
++++        abortController.abort();
++++        // エラーコールバックを呼び出し
++++        callbacks.onError(
++++          new Error(event.payload.message || '予期せぬエラーが発生しました'),
++++        );
++++      },
++++      { signal: abortController.signal },
++++    );
++++
++++    // 購読解除のためのクリーンアップ
++++    return () => {
++++      abortController.abort();
++++    };
++++  }
++++
++++  /**
++++   * レビューチャットの中断
++++   * @param reviewHistoryId レビュー履歴ID
++++   * @param options APIサービスのオプション
++++   */
++++  public async abortChat(
++++    reviewHistoryId: string,
++++    options?: ApiServiceDefaultOptions,
++++  ): Promise<void> {
++++    await invokeApi(
++++      () => window.electron.review.abortChat(reviewHistoryId),
++++      options,
++++    );
++++  }
++++
++++  /**
++++   * レビューチャットメッセージ送信
++++   * @param reviewHistoryId レビュー履歴ID
++++   * @param checklistIds チェックリストID配列
++++   * @param question ユーザからの質問
++++   * @param options APIサービスのオプション
++++   */
++++  public async sendMessage(
++++    reviewHistoryId: string,
++++    checklistIds: number[],
++++    question: string,
++++    options?: ApiServiceDefaultOptions,
++++  ): Promise<void> {
++++    await invokeApi(
++++      () =>
++++        window.electron.review.sendChatMessage({
++++          reviewHistoryId,
++++          checklistIds,
++++          question,
++++        }),
++++      options,
++++    );
++++  }
++++}
+++diff --git a/src/renderer/service/settingsApi.ts b/src/renderer/service/settingsApi.ts
+++index 8ec061cbf..a2cdeecc5 100644
+++--- a/src/renderer/service/settingsApi.ts
++++++ b/src/renderer/service/settingsApi.ts
+++@@ -47,7 +47,10 @@ export class SettingsApi implements ISettingsApi {
+++     messageId: string,
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<void> {
+++-    await invokeApi(() => window.electron.settings.removeMessage(messageId), options);
++++    await invokeApi(
++++      () => window.electron.settings.removeMessage(messageId),
++++      options,
++++    );
+++   }
+++ 
+++   public async reinitialize(options?: ApiServiceDefaultOptions): Promise<void> {
+++@@ -64,7 +67,10 @@ export class SettingsApi implements ISettingsApi {
+++     settings: Settings,
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<boolean | null> {
+++-    return invokeApi(() => window.electron.settings.setSettings(settings), options);
++++    return invokeApi(
++++      () => window.electron.settings.setSettings(settings),
++++      options,
++++    );
+++   }
+++ 
+++   public async subscribeSettingsUpdateFinished(
+++diff --git a/src/renderer/service/sourceApi.ts b/src/renderer/service/sourceApi.ts
+++index 76b2f9c6f..2500ff69b 100644
+++--- a/src/renderer/service/sourceApi.ts
++++++ b/src/renderer/service/sourceApi.ts
+++@@ -49,10 +49,14 @@ export class SourceApi implements ISourceApi {
+++     enabled: boolean,
+++     options?: ApiServiceDefaultOptions,
+++   ): Promise<void> {
+++-    await invokeApi(() => window.electron.source.updateSourceEnabled({
+++-      sourceId: id,
+++-      isEnabled: enabled,
+++-    }), options);
++++    await invokeApi(
++++      () =>
++++        window.electron.source.updateSourceEnabled({
++++          sourceId: id,
++++          isEnabled: enabled,
++++        }),
++++      options,
++++    );
+++   }
+++ 
+++   public async subscribeSourceReloadFinished(
+++diff --git a/src/types/error.ts b/src/types/error.ts
+++index a4fd32185..ad22f0b75 100644
+++--- a/src/types/error.ts
++++++ b/src/types/error.ts
+++@@ -14,10 +14,7 @@ export type ErrorCode =
+++ /**
+++  * フロントエンドで利用するエラーコード
+++  */
+++-export type FrontErrorCode =
+++-  | 'APP_API'
+++-  | 'APP_API_CALL'
+++-  | 'INTERNAL';
++++export type FrontErrorCode = 'APP_API' | 'APP_API_CALL' | 'INTERNAL';
+++ 
+++ /**
+++  * クライアントへ返す標準エラー形
+++diff --git a/src/types/ipc.ts b/src/types/ipc.ts
+++index 0fc449d82..69d3b10bd 100644
+++--- a/src/types/ipc.ts
++++++ b/src/types/ipc.ts
+++@@ -81,6 +81,11 @@ export const IpcChannels = {
+++   REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
+++   REVIEW_EXECUTE_ABORT: 'review-execute-abort', // レビュー実行処理をキャンセルする
+++   REVIEW_HISTORY_UPDATED: 'review-history-updated', // レビュー履歴が更新された際の通知
++++  REVIEW_CHAT_SEND_MESSAGE: 'review-chat-send-message', // レビューチャットメッセージ送信
++++  REVIEW_CHAT_STREAM_RESPONSE: 'review-chat-stream-response', // レビューチャットストリーミング応答
++++  REVIEW_CHAT_COMPLETE: 'review-chat-complete', // レビューチャット完了
++++  REVIEW_CHAT_ERROR: 'review-chat-error', // レビューチャットエラー
++++  REVIEW_CHAT_ABORT: 'review-chat-abort', // レビューチャット中断
+++ } as const;
+++ 
+++ export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
+++@@ -150,6 +155,12 @@ export type IpcRequestPayloadMap = {
+++     documentMode: DocumentMode;
+++   };
+++   [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
++++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: {
++++    reviewHistoryId: string;
++++    checklistIds: number[];
++++    question: string;
++++  };
++++  [IpcChannels.REVIEW_CHAT_ABORT]: string; // review history id
+++ };
+++ 
+++ export type IpcResponsePayloadMap = {
+++@@ -189,6 +200,7 @@ export type IpcResponsePayloadMap = {
+++   [IpcChannels.REVIEW_GET_HISTORIES]: IpcResult<RevieHistory[]>;
+++   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: IpcResult<{
+++     checklistResults?: ReviewChecklistResult[];
++++    targetDocumentName?: string | null;
+++   }>;
+++   [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: IpcResult<{
+++     additionalInstructions?: string;
+++@@ -201,6 +213,8 @@ export type IpcResponsePayloadMap = {
+++   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: IpcResult;
+++   [IpcChannels.REVIEW_EXECUTE_CALL]: IpcResult;
+++   [IpcChannels.REVIEW_EXECUTE_ABORT]: IpcResult;
++++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: IpcResult;
++++  [IpcChannels.REVIEW_CHAT_ABORT]: IpcResult;
+++ };
+++ 
+++ export type IpcEventPayloadMap = {
+++@@ -227,6 +241,9 @@ export type IpcEventPayloadMap = {
+++     currentSheet?: number;
+++     totalSheets?: number;
+++   };
++++  [IpcChannels.REVIEW_CHAT_STREAM_RESPONSE]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
++++  [IpcChannels.REVIEW_CHAT_COMPLETE]: unknown;
++++  [IpcChannels.REVIEW_CHAT_ERROR]: { message: string };
+++ };
+++ 
+++ /**
+++@@ -287,4 +304,8 @@ export const IpcNameMap = {
+++   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: 'チェックリストの更新',
+++   [IpcChannels.REVIEW_EXECUTE_CALL]: 'ドキュメントレビューの実行',
+++   [IpcChannels.REVIEW_EXECUTE_ABORT]: 'ドキュメントレビューの中断',
++++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: 'レビューチャットメッセージ送信',
++++  [IpcChannels.REVIEW_CHAT_COMPLETE]: 'レビューチャット完了',
++++  [IpcChannels.REVIEW_CHAT_ERROR]: 'レビューチャットエラー',
++++  [IpcChannels.REVIEW_CHAT_ABORT]: 'レビューチャット中断',
+++ };
+++diff --git a/src/types/message.ts b/src/types/message.ts
+++index 979bb1cda..a4065ae2e 100644
+++--- a/src/types/message.ts
++++++ b/src/types/message.ts
+++@@ -11,6 +11,7 @@ export type MessageCode =
+++   | 'GITLAB_API_CONNECTION_ERROR'
+++   | 'REDMINE_API_CONNECTION_ERROR'
+++   | 'REDMINE_API_ERROR'
++++  | 'FS_OPEN_DIALOG_ERROR'
+++   | 'FILE_TEXT_EXTRACTION_ERROR'
+++   | 'FS_CONVERT_OFFICE_TO_PDF_ERROR'
+++   | 'SOURCE_REGISTRATION_DIR_READING_ERROR'
+++@@ -18,8 +19,10 @@ export type MessageCode =
+++   | 'REVIEW_CHECKLIST_EXTRACTION_ERROR'
+++   | 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS'
+++   | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
++++  | 'REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM'
+++   | 'REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR'
+++   | 'REVIEW_EXECUTION_ERROR'
+++   | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
+++   | 'AI_API_ERROR'
+++-  | 'AI_MESSAGE_TOO_LARGE';
++++  | 'AI_MESSAGE_TOO_LARGE'
++++  | 'REVIEW_DOCUMENT_CACHE_NOT_FOUND';
+++diff --git a/src/types/review.ts b/src/types/review.ts
+++index 52578ffaa..85bce2524 100644
+++--- a/src/types/review.ts
++++++ b/src/types/review.ts
+++@@ -1,6 +1,7 @@
+++ export interface RevieHistory {
+++   id: string; // reviewHistoriesのid
+++   title: string;
++++  targetDocumentName?: string | null; // レビュー対象の統合ドキュメント名
+++   additionalInstructions: string | null;
+++   commentFormat?: string | null;
+++   evaluationSettings?: CustomEvaluationSettings | null; // カスタム評定項目設定
+++@@ -13,6 +14,8 @@ export interface ReviewChecklist {
+++   id: number;
+++   reviewHistoryId: string;
+++   content: string;
++++  evaluation?: ReviewEvaluation | null; // A, B, C, - 評価
++++  comment?: string | null; // レビューコメント
+++   createdBy: ReviewChecklistCreatedBy;
+++   createdAt: string;
+++   updatedAt: string;
+++@@ -39,12 +42,10 @@ export type ReviewChecklistCreatedBy = 'user' | 'system';
+++ export type ReviewChecklistResult = {
+++   id: number; // チェックリストのID
+++   content: string;
+++-  sourceEvaluations?: {
+++-    fileId: string;
+++-    fileName: string;
++++  sourceEvaluation?: {
+++     evaluation?: ReviewEvaluation; // カスタム評定項目対応
+++     comment?: string;
+++-  }[];
++++  };
+++ };
+++ 
+++ // チェックリストの編集内容を表す型
+++@@ -92,8 +93,31 @@ export type ReviewExecutionResultStatus =
+++ 
+++ // 処理ステータスの型定義
+++ export type ProcessingStatus =
+++-  | 'idle'        // アイドル状態
+++-  | 'extracting'  // チェックリスト抽出中
+++-  | 'extracted'   // チェックリスト抽出完了
+++-  | 'reviewing'   // レビュー実行中
+++-  | 'completed';  // レビュー完了
++++  | 'idle' // アイドル状態
++++  | 'extracting' // チェックリスト抽出中
++++  | 'extracted' // チェックリスト抽出完了
++++  | 'reviewing' // レビュー実行中
++++  | 'completed'; // レビュー完了
++++
++++// レビュードキュメントキャッシュ（サービス層で使用）
++++export interface ReviewDocumentCache {
++++  id: number;
++++  reviewHistoryId: string;
++++  documentId: string; // ワークフロー内のドキュメントID
++++  fileName: string; // ワークフロー内での名前（分割時は "xxx (part 1)" など）
++++  processMode: ProcessMode;
++++  textContent?: string; // processMode='text'の場合
++++  imageData?: string[]; // processMode='image'の場合
++++  createdAt: string;
++++  updatedAt: string;
++++}
++++
++++// レビュー大量ドキュメント結果キャッシュ（大量ドキュメントレビューの個別レビュー結果）
++++export interface ReviewLargedocumentResultCache {
++++  reviewDocumentCacheId: number;
++++  reviewChecklistId: number;
++++  comment: string;
++++  totalChunks: number; // ドキュメント分割総数
++++  chunkIndex: number; // 何番目のチャンクか（0から始まる）
++++  individualFileName: string; // 分割後の個別ドキュメント名（"xxx (part 1)" など）
++++}
++diff --git a/drizzle.config.ts b/drizzle.config.ts
++index 36ebf09d3..f73e59241 100644
++--- a/drizzle.config.ts
+++++ b/drizzle.config.ts
++@@ -12,7 +12,7 @@ console.log(
++ );
++ 
++ export default {
++-  schema: './src/db/schema.ts',
+++  schema: './src/adapter/db/drizzle/schema.ts',
++   out: './drizzle/migrations',
++   dialect: 'sqlite',
++   dbCredentials: {
++diff --git a/drizzle/migrations/0008_pink_ezekiel.sql b/drizzle/migrations/0008_pink_ezekiel.sql
++new file mode 100644
++index 000000000..8169d2866
++--- /dev/null
+++++ b/drizzle/migrations/0008_pink_ezekiel.sql
++@@ -0,0 +1,4 @@
+++DROP TABLE `review_checklist_results`;--> statement-breakpoint
+++ALTER TABLE `review_checklists` ADD `evaluation` text;--> statement-breakpoint
+++ALTER TABLE `review_checklists` ADD `comment` text;--> statement-breakpoint
+++ALTER TABLE `review_histories` ADD `target_document_name` text;
++\ No newline at end of file
++diff --git a/drizzle/migrations/0009_keen_radioactive_man.sql b/drizzle/migrations/0009_keen_radioactive_man.sql
++new file mode 100644
++index 000000000..999bdbbd9
++--- /dev/null
+++++ b/drizzle/migrations/0009_keen_radioactive_man.sql
++@@ -0,0 +1,23 @@
+++CREATE TABLE `review_checklist_result_caches` (
+++	`review_document_cache_id` integer NOT NULL,
+++	`review_checklist_id` integer NOT NULL,
+++	`comment` text NOT NULL,
+++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`),
+++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
+++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+++);
+++--> statement-breakpoint
+++CREATE TABLE `review_document_caches` (
+++	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
+++	`review_history_id` text NOT NULL,
+++	`document_id` text NOT NULL,
+++	`original_file_name` text NOT NULL,
+++	`file_name` text NOT NULL,
+++	`process_mode` text NOT NULL,
+++	`cache_path` text NOT NULL,
+++	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+++	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
+++	FOREIGN KEY (`review_history_id`) REFERENCES `review_histories`(`id`) ON UPDATE no action ON DELETE cascade
+++);
+++--> statement-breakpoint
+++ALTER TABLE `review_histories` ADD `document_mode` text;
++\ No newline at end of file
++diff --git a/drizzle/migrations/0010_wet_shooting_star.sql b/drizzle/migrations/0010_wet_shooting_star.sql
++new file mode 100644
++index 000000000..49668f9f0
++--- /dev/null
+++++ b/drizzle/migrations/0010_wet_shooting_star.sql
++@@ -0,0 +1,14 @@
+++CREATE TABLE `review_largedocument_result_caches` (
+++	`review_document_cache_id` integer NOT NULL,
+++	`review_checklist_id` integer NOT NULL,
+++	`comment` text NOT NULL,
+++	`total_chunks` integer NOT NULL,
+++	`chunk_index` integer NOT NULL,
+++	`individual_file_name` text NOT NULL,
+++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`, `chunk_index`),
+++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
+++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+++);
+++--> statement-breakpoint
+++DROP TABLE `review_checklist_result_caches`;--> statement-breakpoint
+++ALTER TABLE `review_document_caches` DROP COLUMN `original_file_name`;
++\ No newline at end of file
++diff --git a/drizzle/migrations/meta/0008_snapshot.json b/drizzle/migrations/meta/0008_snapshot.json
++new file mode 100644
++index 000000000..5148d151e
++--- /dev/null
+++++ b/drizzle/migrations/meta/0008_snapshot.json
++@@ -0,0 +1,329 @@
+++{
+++  "version": "6",
+++  "dialect": "sqlite",
+++  "id": "e0ad999a-87f1-4f45-b070-a32c673d6352",
+++  "prevId": "f10b9ed0-007d-4b08-941a-030265d534ff",
+++  "tables": {
+++    "review_checklists": {
+++      "name": "review_checklists",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "review_history_id": {
+++          "name": "review_history_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "content": {
+++          "name": "content",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "evaluation": {
+++          "name": "evaluation",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "comment": {
+++          "name": "comment",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "created_by": {
+++          "name": "created_by",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_checklists_review_history_id_review_histories_id_fk": {
+++          "name": "review_checklists_review_history_id_review_histories_id_fk",
+++          "tableFrom": "review_checklists",
+++          "tableTo": "review_histories",
+++          "columnsFrom": [
+++            "review_history_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_histories": {
+++      "name": "review_histories",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "text",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "title": {
+++          "name": "title",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "target_document_name": {
+++          "name": "target_document_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "additional_instructions": {
+++          "name": "additional_instructions",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "comment_format": {
+++          "name": "comment_format",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "evaluation_settings": {
+++          "name": "evaluation_settings",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "processing_status": {
+++          "name": "processing_status",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "'idle'"
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {},
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "sources": {
+++      "name": "sources",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "path": {
+++          "name": "path",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "title": {
+++          "name": "title",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "summary": {
+++          "name": "summary",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "status": {
+++          "name": "status",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "'idle'"
+++        },
+++        "error": {
+++          "name": "error",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "is_enabled": {
+++          "name": "is_enabled",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": 1
+++        }
+++      },
+++      "indexes": {
+++        "sources_path_unique": {
+++          "name": "sources_path_unique",
+++          "columns": [
+++            "path"
+++          ],
+++          "isUnique": true
+++        }
+++      },
+++      "foreignKeys": {},
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "topics": {
+++      "name": "topics",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "source_id": {
+++          "name": "source_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "name": {
+++          "name": "name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "summary": {
+++          "name": "summary",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "topics_source_id_sources_id_fk": {
+++          "name": "topics_source_id_sources_id_fk",
+++          "tableFrom": "topics",
+++          "tableTo": "sources",
+++          "columnsFrom": [
+++            "source_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    }
+++  },
+++  "views": {},
+++  "enums": {},
+++  "_meta": {
+++    "schemas": {},
+++    "tables": {},
+++    "columns": {}
+++  },
+++  "internal": {
+++    "indexes": {}
+++  }
+++}
++\ No newline at end of file
++diff --git a/drizzle/migrations/meta/0009_snapshot.json b/drizzle/migrations/meta/0009_snapshot.json
++new file mode 100644
++index 000000000..0f58c9424
++--- /dev/null
+++++ b/drizzle/migrations/meta/0009_snapshot.json
++@@ -0,0 +1,491 @@
+++{
+++  "version": "6",
+++  "dialect": "sqlite",
+++  "id": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
+++  "prevId": "e0ad999a-87f1-4f45-b070-a32c673d6352",
+++  "tables": {
+++    "review_checklist_result_caches": {
+++      "name": "review_checklist_result_caches",
+++      "columns": {
+++        "review_document_cache_id": {
+++          "name": "review_document_cache_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "review_checklist_id": {
+++          "name": "review_checklist_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "comment": {
+++          "name": "comment",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+++          "name": "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk",
+++          "tableFrom": "review_checklist_result_caches",
+++          "tableTo": "review_document_caches",
+++          "columnsFrom": [
+++            "review_document_cache_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        },
+++        "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk": {
+++          "name": "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk",
+++          "tableFrom": "review_checklist_result_caches",
+++          "tableTo": "review_checklists",
+++          "columnsFrom": [
+++            "review_checklist_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {
+++        "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk": {
+++          "columns": [
+++            "review_document_cache_id",
+++            "review_checklist_id"
+++          ],
+++          "name": "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk"
+++        }
+++      },
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_checklists": {
+++      "name": "review_checklists",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "review_history_id": {
+++          "name": "review_history_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "content": {
+++          "name": "content",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "evaluation": {
+++          "name": "evaluation",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "comment": {
+++          "name": "comment",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "created_by": {
+++          "name": "created_by",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_checklists_review_history_id_review_histories_id_fk": {
+++          "name": "review_checklists_review_history_id_review_histories_id_fk",
+++          "tableFrom": "review_checklists",
+++          "tableTo": "review_histories",
+++          "columnsFrom": [
+++            "review_history_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_document_caches": {
+++      "name": "review_document_caches",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "review_history_id": {
+++          "name": "review_history_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "document_id": {
+++          "name": "document_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "original_file_name": {
+++          "name": "original_file_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "file_name": {
+++          "name": "file_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "process_mode": {
+++          "name": "process_mode",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "cache_path": {
+++          "name": "cache_path",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_document_caches_review_history_id_review_histories_id_fk": {
+++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+++          "tableFrom": "review_document_caches",
+++          "tableTo": "review_histories",
+++          "columnsFrom": [
+++            "review_history_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_histories": {
+++      "name": "review_histories",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "text",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "title": {
+++          "name": "title",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "target_document_name": {
+++          "name": "target_document_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "additional_instructions": {
+++          "name": "additional_instructions",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "comment_format": {
+++          "name": "comment_format",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "evaluation_settings": {
+++          "name": "evaluation_settings",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "document_mode": {
+++          "name": "document_mode",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "processing_status": {
+++          "name": "processing_status",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "'idle'"
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {},
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "sources": {
+++      "name": "sources",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "path": {
+++          "name": "path",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "title": {
+++          "name": "title",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "summary": {
+++          "name": "summary",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "status": {
+++          "name": "status",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "'idle'"
+++        },
+++        "error": {
+++          "name": "error",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "is_enabled": {
+++          "name": "is_enabled",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": 1
+++        }
+++      },
+++      "indexes": {
+++        "sources_path_unique": {
+++          "name": "sources_path_unique",
+++          "columns": [
+++            "path"
+++          ],
+++          "isUnique": true
+++        }
+++      },
+++      "foreignKeys": {},
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "topics": {
+++      "name": "topics",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "source_id": {
+++          "name": "source_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "name": {
+++          "name": "name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "summary": {
+++          "name": "summary",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "topics_source_id_sources_id_fk": {
+++          "name": "topics_source_id_sources_id_fk",
+++          "tableFrom": "topics",
+++          "tableTo": "sources",
+++          "columnsFrom": [
+++            "source_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    }
+++  },
+++  "views": {},
+++  "enums": {},
+++  "_meta": {
+++    "schemas": {},
+++    "tables": {},
+++    "columns": {}
+++  },
+++  "internal": {
+++    "indexes": {}
+++  }
+++}
++\ No newline at end of file
++diff --git a/drizzle/migrations/meta/0010_snapshot.json b/drizzle/migrations/meta/0010_snapshot.json
++new file mode 100644
++index 000000000..cf557a34d
++--- /dev/null
+++++ b/drizzle/migrations/meta/0010_snapshot.json
++@@ -0,0 +1,506 @@
+++{
+++  "version": "6",
+++  "dialect": "sqlite",
+++  "id": "64a4c44b-83f4-4cca-b0a7-5e1962a1f61b",
+++  "prevId": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
+++  "tables": {
+++    "review_checklists": {
+++      "name": "review_checklists",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "review_history_id": {
+++          "name": "review_history_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "content": {
+++          "name": "content",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "evaluation": {
+++          "name": "evaluation",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "comment": {
+++          "name": "comment",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "created_by": {
+++          "name": "created_by",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_checklists_review_history_id_review_histories_id_fk": {
+++          "name": "review_checklists_review_history_id_review_histories_id_fk",
+++          "tableFrom": "review_checklists",
+++          "tableTo": "review_histories",
+++          "columnsFrom": [
+++            "review_history_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_document_caches": {
+++      "name": "review_document_caches",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "review_history_id": {
+++          "name": "review_history_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "document_id": {
+++          "name": "document_id",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "file_name": {
+++          "name": "file_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "process_mode": {
+++          "name": "process_mode",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "cache_path": {
+++          "name": "cache_path",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_document_caches_review_history_id_review_histories_id_fk": {
+++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+++          "tableFrom": "review_document_caches",
+++          "tableTo": "review_histories",
+++          "columnsFrom": [
+++            "review_history_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_histories": {
+++      "name": "review_histories",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "text",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "title": {
+++          "name": "title",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "target_document_name": {
+++          "name": "target_document_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "additional_instructions": {
+++          "name": "additional_instructions",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "comment_format": {
+++          "name": "comment_format",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "evaluation_settings": {
+++          "name": "evaluation_settings",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "document_mode": {
+++          "name": "document_mode",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "processing_status": {
+++          "name": "processing_status",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "'idle'"
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {},
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "review_largedocument_result_caches": {
+++      "name": "review_largedocument_result_caches",
+++      "columns": {
+++        "review_document_cache_id": {
+++          "name": "review_document_cache_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "review_checklist_id": {
+++          "name": "review_checklist_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "comment": {
+++          "name": "comment",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "total_chunks": {
+++          "name": "total_chunks",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "chunk_index": {
+++          "name": "chunk_index",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "individual_file_name": {
+++          "name": "individual_file_name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+++          "name": "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk",
+++          "tableFrom": "review_largedocument_result_caches",
+++          "tableTo": "review_document_caches",
+++          "columnsFrom": [
+++            "review_document_cache_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        },
+++        "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk": {
+++          "name": "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk",
+++          "tableFrom": "review_largedocument_result_caches",
+++          "tableTo": "review_checklists",
+++          "columnsFrom": [
+++            "review_checklist_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {
+++        "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk": {
+++          "columns": [
+++            "review_document_cache_id",
+++            "review_checklist_id",
+++            "chunk_index"
+++          ],
+++          "name": "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk"
+++        }
+++      },
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "sources": {
+++      "name": "sources",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "path": {
+++          "name": "path",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "title": {
+++          "name": "title",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "summary": {
+++          "name": "summary",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "status": {
+++          "name": "status",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "'idle'"
+++        },
+++        "error": {
+++          "name": "error",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": false,
+++          "autoincrement": false
+++        },
+++        "is_enabled": {
+++          "name": "is_enabled",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": 1
+++        }
+++      },
+++      "indexes": {
+++        "sources_path_unique": {
+++          "name": "sources_path_unique",
+++          "columns": [
+++            "path"
+++          ],
+++          "isUnique": true
+++        }
+++      },
+++      "foreignKeys": {},
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    },
+++    "topics": {
+++      "name": "topics",
+++      "columns": {
+++        "id": {
+++          "name": "id",
+++          "type": "integer",
+++          "primaryKey": true,
+++          "notNull": true,
+++          "autoincrement": true
+++        },
+++        "source_id": {
+++          "name": "source_id",
+++          "type": "integer",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "name": {
+++          "name": "name",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "summary": {
+++          "name": "summary",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false
+++        },
+++        "created_at": {
+++          "name": "created_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        },
+++        "updated_at": {
+++          "name": "updated_at",
+++          "type": "text",
+++          "primaryKey": false,
+++          "notNull": true,
+++          "autoincrement": false,
+++          "default": "(current_timestamp)"
+++        }
+++      },
+++      "indexes": {},
+++      "foreignKeys": {
+++        "topics_source_id_sources_id_fk": {
+++          "name": "topics_source_id_sources_id_fk",
+++          "tableFrom": "topics",
+++          "tableTo": "sources",
+++          "columnsFrom": [
+++            "source_id"
+++          ],
+++          "columnsTo": [
+++            "id"
+++          ],
+++          "onDelete": "cascade",
+++          "onUpdate": "no action"
+++        }
+++      },
+++      "compositePrimaryKeys": {},
+++      "uniqueConstraints": {},
+++      "checkConstraints": {}
+++    }
+++  },
+++  "views": {},
+++  "enums": {},
+++  "_meta": {
+++    "schemas": {},
+++    "tables": {},
+++    "columns": {}
+++  },
+++  "internal": {
+++    "indexes": {}
+++  }
+++}
++\ No newline at end of file
++diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
++index 18a6e2692..2c49cc99a 100644
++--- a/drizzle/migrations/meta/_journal.json
+++++ b/drizzle/migrations/meta/_journal.json
++@@ -57,6 +57,27 @@
++       "when": 1758023792722,
++       "tag": "0007_awesome_caretaker",
++       "breakpoints": true
+++    },
+++    {
+++      "idx": 8,
+++      "version": "6",
+++      "when": 1759653362189,
+++      "tag": "0008_pink_ezekiel",
+++      "breakpoints": true
+++    },
+++    {
+++      "idx": 9,
+++      "version": "6",
+++      "when": 1759674897312,
+++      "tag": "0009_keen_radioactive_man",
+++      "breakpoints": true
+++    },
+++    {
+++      "idx": 10,
+++      "version": "6",
+++      "when": 1760147587193,
+++      "tag": "0010_wet_shooting_star",
+++      "breakpoints": true
++     }
++   ]
++ }
++\ No newline at end of file
++diff --git a/src/__tests__/integration/Sidebar.test.tsx b/src/__tests__/integration/Sidebar.test.tsx
++index 00d96f758..a66dd0796 100644
++--- a/src/__tests__/integration/Sidebar.test.tsx
+++++ b/src/__tests__/integration/Sidebar.test.tsx
++@@ -11,7 +11,7 @@ import { v4 as uuidv4 } from 'uuid';
++ import Sidebar from '@/renderer/components/sidebar/Sidebar';
++ import type { ChatRoom, ProcessStatus } from '@/types';
++ import type { Source } from '@/db/schema';
++-import { StoreSchema as Settings } from '@/main/store';
+++import { StoreSchema as Settings } from '@/adapter/db/electron-store/store';
++ import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
++ import ChatRoomList from '@/renderer/components/chat/ChatRoomList';
++ import ReviewHistoryList from '@/renderer/components/review/ReviewHistoryList';
++diff --git a/src/adapter/db/drizzle/index.ts b/src/adapter/db/drizzle/index.ts
++index bf2e952ff..b581c2c5c 100644
++--- a/src/adapter/db/drizzle/index.ts
+++++ b/src/adapter/db/drizzle/index.ts
++@@ -3,7 +3,7 @@ import { join } from 'path';
++ import { drizzle, type LibSQLDatabase } from 'drizzle-orm/libsql';
++ import { migrate } from 'drizzle-orm/libsql/migrator';
++ import * as schema from './schema';
++-import { getStore } from '@/main/store';
+++import { getStore } from '@/adapter/db/electron-store/store';
++ import { toAbsoluteFileURL } from '@/main/lib/util';
++ 
++ // データベースの型定義
++diff --git a/src/adapter/db/drizzle/repository/index.ts b/src/adapter/db/drizzle/repository/index.ts
++index b908a5531..b21f0ddad 100644
++--- a/src/adapter/db/drizzle/repository/index.ts
+++++ b/src/adapter/db/drizzle/repository/index.ts
++@@ -1,3 +1,3 @@
++ export * from './sourceRepository';
++ export * from './reviewRepository';
++-export * from './settingsRepository';
+++export * from '../../electron-store/repository/settingsRepository';
++diff --git a/src/adapter/db/drizzle/repository/reviewRepository.ts b/src/adapter/db/drizzle/repository/reviewRepository.ts
++index 572c1e214..cd8949e13 100644
++--- a/src/adapter/db/drizzle/repository/reviewRepository.ts
+++++ b/src/adapter/db/drizzle/repository/reviewRepository.ts
++@@ -1,10 +1,13 @@
++-import { eq, and } from 'drizzle-orm';
+++import { eq, and, inArray, max } from 'drizzle-orm';
++ import {
++   reviewHistories,
++   reviewChecklists,
++-  reviewChecklistResults,
+++  reviewDocumentCaches,
+++  reviewLargedocumentResultCaches,
++   ReviewChecklistEntity,
++   ReviewHistoryEntity,
+++  ReviewDocumentCacheEntity,
+++  ReviewLargedocumentResultCacheEntity,
++ } from '../schema';
++ import getDb from '..';
++ import type {
++@@ -15,10 +18,15 @@ import type {
++   ReviewChecklistCreatedBy,
++   CustomEvaluationSettings,
++   ProcessingStatus,
+++  DocumentMode,
+++  ReviewDocumentCache,
+++  ReviewLargedocumentResultCache,
+++  ProcessMode,
++ } from '@/types';
++-import { AppError } from '@/main/lib/error';
+++import { AppError, internalError } from '@/main/lib/error';
++ import { repositoryError } from '@/main/lib/error';
++ import { IReviewRepository } from '@/main/service/port/repository';
+++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
++ 
++ /**
++  * Drizzle ORM を使用したレビューリポジトリの実装
++@@ -31,6 +39,8 @@ export class DrizzleReviewRepository implements IReviewRepository {
++       id: reviewChecklistEntity.id,
++       reviewHistoryId: reviewChecklistEntity.reviewHistoryId,
++       content: reviewChecklistEntity.content,
+++      evaluation: reviewChecklistEntity.evaluation as ReviewEvaluation | null,
+++      comment: reviewChecklistEntity.comment,
++       createdBy: reviewChecklistEntity.createdBy as ReviewChecklistCreatedBy,
++       createdAt: reviewChecklistEntity.createdAt,
++       updatedAt: reviewChecklistEntity.updatedAt,
++@@ -43,6 +53,7 @@ export class DrizzleReviewRepository implements IReviewRepository {
++     const reviewHistory = {
++       id: reviewHistoryEntity.id,
++       title: reviewHistoryEntity.title,
+++      targetDocumentName: reviewHistoryEntity.targetDocumentName,
++       additionalInstructions: reviewHistoryEntity.additionalInstructions,
++       commentFormat: reviewHistoryEntity.commentFormat,
++       evaluationSettings: null,
++@@ -189,6 +200,27 @@ export class DrizzleReviewRepository implements IReviewRepository {
++     }
++   }
++ 
+++  /** レビュー対象ドキュメント名を更新 */
+++  async updateReviewHistoryTargetDocumentName(
+++    id: string,
+++    targetDocumentName: string,
+++  ): Promise<void> {
+++    try {
+++      const db = await getDb();
+++      await db
+++        .update(reviewHistories)
+++        .set({
+++          targetDocumentName,
+++        })
+++        .where(eq(reviewHistories.id, id));
+++    } catch (err) {
+++      throw repositoryError(
+++        'レビュー対象ドキュメント名の更新に失敗しました',
+++        err,
+++      );
+++    }
+++  }
+++
++   /** レビュー履歴を削除 */
++   async deleteReviewHistory(id: string): Promise<void> {
++     try {
++@@ -284,121 +316,426 @@ export class DrizzleReviewRepository implements IReviewRepository {
++       reviewChecklistId: number;
++       evaluation: ReviewEvaluation;
++       comment: string;
++-      fileId: string;
++-      fileName: string;
++     }[],
++   ): Promise<void> {
++     try {
++       const db = await getDb();
++       for (const result of results) {
++-        const [upserted] = await db
++-          .insert(reviewChecklistResults)
++-          .values(result)
++-          .onConflictDoUpdate({
++-            target: [
++-              reviewChecklistResults.reviewChecklistId,
++-              reviewChecklistResults.fileId,
++-            ],
++-            set: {
++-              evaluation: result.evaluation,
++-              comment: result.comment,
++-            },
+++        await db
+++          .update(reviewChecklists)
+++          .set({
+++            evaluation: result.evaluation,
+++            comment: result.comment,
++           })
++-          .returning();
+++          .where(eq(reviewChecklists.id, result.reviewChecklistId));
++       }
++     } catch (err) {
++       throw repositoryError('レビュー結果の保存に失敗しました', err);
++     }
++   }
++ 
++-  /** レビュー結果を削除 */
++-  async deleteReviewResults(
++-    reviewChecklistId: number,
++-    sourceId: number,
+++  /** チェックリスト結果を取得してグルーピング */
+++  async getReviewChecklistResults(
+++    reviewHistoryId: string,
+++  ): Promise<ReviewChecklistResult[]> {
+++    try {
+++      const db = await getDb();
+++      const rows = await db
+++        .select()
+++        .from(reviewChecklists)
+++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+++        .orderBy(reviewChecklists.createdAt);
+++
+++      return rows.map((row) => ({
+++        id: row.id,
+++        content: row.content,
+++        sourceEvaluation: row.evaluation
+++          ? {
+++              evaluation: row.evaluation as ReviewEvaluation,
+++              comment: row.comment ?? undefined,
+++            }
+++          : undefined,
+++      }));
+++    } catch (err) {
+++      throw repositoryError('レビュー結果の取得に失敗しました', err);
+++    }
+++  }
+++
+++  /** すべてのレビュー結果を削除 */
+++  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
+++    try {
+++      const db = await getDb();
+++      await db
+++        .update(reviewChecklists)
+++        .set({
+++          evaluation: null,
+++          comment: null,
+++        })
+++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
+++    } catch (err) {
+++      throw repositoryError('レビュー結果の削除に失敗しました', err);
+++    }
+++  }
+++
+++  /** documentModeを更新 */
+++  async updateReviewHistoryDocumentMode(
+++    id: string,
+++    documentMode: DocumentMode,
++   ): Promise<void> {
++     try {
++       const db = await getDb();
++       await db
++-        .delete(reviewChecklistResults)
+++        .update(reviewHistories)
+++        .set({
+++          documentMode,
+++        })
+++        .where(eq(reviewHistories.id, id));
+++    } catch (err) {
+++      throw repositoryError('ドキュメントモードの更新に失敗しました', err);
+++    }
+++  }
+++
+++  /**
+++   * ReviewDocumentCacheEntity → ReviewDocumentCache の変換
+++   * cachePathからファイルを読み込んでtextContent/imageDataに変換
+++   */
+++  private async convertDocumentCacheEntityToDomain(
+++    entity: ReviewDocumentCacheEntity,
+++  ): Promise<ReviewDocumentCache> {
+++    const base = {
+++      id: entity.id,
+++      reviewHistoryId: entity.reviewHistoryId,
+++      documentId: entity.documentId,
+++      fileName: entity.fileName,
+++      processMode: entity.processMode as ProcessMode,
+++      createdAt: entity.createdAt,
+++      updatedAt: entity.updatedAt,
+++    };
+++
+++    try {
+++      // cachePathからファイルを読み込む
+++      if (entity.processMode === 'text') {
+++        const textContent = await ReviewCacheHelper.loadTextCache(
+++          entity.cachePath,
+++        );
+++        return { ...base, textContent };
+++      } else if (entity.processMode === 'image') {
+++        const imageData = await ReviewCacheHelper.loadImageCache(
+++          entity.cachePath,
+++        );
+++        return { ...base, imageData };
+++      }
+++
+++      throw repositoryError('無効なprocessModeです', null);
+++    } catch (error) {
+++      // キャッシュファイル読み込みエラーの場合は専用のエラーメッセージを返す
+++      if (error instanceof Error && error.message.includes('Failed to load')) {
+++        throw internalError({
+++          expose: true,
+++          messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
+++          cause: error,
+++        });
+++      }
+++      // その他のエラーはそのまま再スロー
+++      throw error;
+++    }
+++  }
+++
+++  /** ドキュメントキャッシュを作成 */
+++  async createReviewDocumentCache(
+++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
+++  ): Promise<ReviewDocumentCache> {
+++    try {
+++      // 1. ファイルシステムにキャッシュを保存
+++      let cachePath: string;
+++
+++      if (cache.processMode === 'text' && cache.textContent) {
+++        cachePath = await ReviewCacheHelper.saveTextCache(
+++          cache.reviewHistoryId,
+++          cache.documentId,
+++          cache.textContent,
+++        );
+++      } else if (cache.processMode === 'image' && cache.imageData) {
+++        cachePath = await ReviewCacheHelper.saveImageCache(
+++          cache.reviewHistoryId,
+++          cache.documentId,
+++          cache.imageData,
+++        );
+++      } else {
+++        throw repositoryError(
+++          '無効なprocessModeまたはデータが不足しています',
+++          null,
+++        );
+++      }
+++
+++      // 2. DBにメタデータを保存
+++      const db = await getDb();
+++      const [entity] = await db
+++        .insert(reviewDocumentCaches)
+++        .values({
+++          reviewHistoryId: cache.reviewHistoryId,
+++          documentId: cache.documentId,
+++          fileName: cache.fileName,
+++          processMode: cache.processMode,
+++          cachePath,
+++        })
+++        .returning();
+++
+++      // 3. ファイルから読み込んでドメイン型に変換して返す
+++      return this.convertDocumentCacheEntityToDomain(entity);
+++    } catch (err) {
+++      if (err instanceof AppError) throw err;
+++      throw repositoryError('ドキュメントキャッシュの作成に失敗しました', err);
+++    }
+++  }
+++
+++  /** ドキュメントキャッシュ一覧を取得 */
+++  async getReviewDocumentCaches(
+++    reviewHistoryId: string,
+++  ): Promise<ReviewDocumentCache[]> {
+++    try {
+++      const db = await getDb();
+++      const entities = await db
+++        .select()
+++        .from(reviewDocumentCaches)
+++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId))
+++        .orderBy(reviewDocumentCaches.createdAt);
+++
+++      // 各EntityをDomain型に変換（ファイル読み込み含む）
+++      return Promise.all(
+++        entities.map((entity) =>
+++          this.convertDocumentCacheEntityToDomain(entity),
+++        ),
+++      );
+++    } catch (err) {
+++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+++    }
+++  }
+++
+++  /** documentIdでドキュメントキャッシュを取得 */
+++  async getReviewDocumentCacheByDocumentId(
+++    reviewHistoryId: string,
+++    documentId: string,
+++  ): Promise<ReviewDocumentCache | null> {
+++    try {
+++      const db = await getDb();
+++      const [entity] = await db
+++        .select()
+++        .from(reviewDocumentCaches)
++         .where(
++           and(
++-            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
++-            eq(reviewChecklistResults.fileId, sourceId.toString()),
+++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
+++            eq(reviewDocumentCaches.documentId, documentId),
++           ),
++         );
+++
+++      if (!entity) return null;
+++
+++      return this.convertDocumentCacheEntityToDomain(entity);
++     } catch (err) {
++-      throw repositoryError('レビュー結果の削除に失敗しました', err);
+++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
++     }
++   }
++ 
++-  /** チェックリスト結果を取得してグルーピング */
++-  async getReviewChecklistResults(
+++  /** ドキュメントキャッシュを取得（複数ID対応） */
+++  async getReviewDocumentCacheByDocumentIds(
++     reviewHistoryId: string,
++-  ): Promise<ReviewChecklistResult[]> {
+++    documentIds: string[],
+++  ): Promise<ReviewDocumentCache[]> {
++     try {
++       const db = await getDb();
++-      const rows = await db
+++      const entities = await db
+++        .select()
+++        .from(reviewDocumentCaches)
+++        .where(
+++          and(
+++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
+++            inArray(reviewDocumentCaches.documentId, documentIds),
+++          ),
+++        );
+++
+++      // 各EntityをDomain型に変換（ファイル読み込み含む）
+++      return Promise.all(
+++        entities.map((entity) =>
+++          this.convertDocumentCacheEntityToDomain(entity),
+++        ),
+++      );
+++    } catch (err) {
+++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+++    }
+++  }
+++
+++  /** チェックリスト結果キャッシュを作成 */
+++  async createReviewLargedocumentResultCache(
+++    cache: ReviewLargedocumentResultCache,
+++  ): Promise<void> {
+++    try {
+++      const db = await getDb();
+++      await db.insert(reviewLargedocumentResultCaches).values({
+++        reviewDocumentCacheId: cache.reviewDocumentCacheId,
+++        reviewChecklistId: cache.reviewChecklistId,
+++        comment: cache.comment,
+++        totalChunks: cache.totalChunks,
+++        chunkIndex: cache.chunkIndex,
+++        individualFileName: cache.individualFileName,
+++      });
+++    } catch (err) {
+++      throw repositoryError(
+++        '大量ドキュメント結果キャッシュの作成に失敗しました',
+++        err,
+++      );
+++    }
+++  }
+++
+++  /** チェックリスト結果キャッシュ一覧を取得 */
+++  async getReviewLargedocumentResultCaches(
+++    reviewHistoryId: string,
+++  ): Promise<ReviewLargedocumentResultCache[]> {
+++    try {
+++      const db = await getDb();
+++      // reviewDocumentCachesとjoinしてreviewHistoryIdで絞り込む
+++      const results = await db
++         .select({
++-          checklistId: reviewChecklists.id,
++-          content: reviewChecklists.content,
++-          fileId: reviewChecklistResults.fileId,
++-          fileName: reviewChecklistResults.fileName,
++-          evaluation: reviewChecklistResults.evaluation,
++-          comment: reviewChecklistResults.comment,
+++          reviewDocumentCacheId:
+++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+++          reviewChecklistId: reviewLargedocumentResultCaches.reviewChecklistId,
+++          comment: reviewLargedocumentResultCaches.comment,
+++          totalChunks: reviewLargedocumentResultCaches.totalChunks,
+++          chunkIndex: reviewLargedocumentResultCaches.chunkIndex,
+++          individualFileName:
+++            reviewLargedocumentResultCaches.individualFileName,
++         })
++-        .from(reviewChecklists)
++-        .leftJoin(
++-          reviewChecklistResults,
++-          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
+++        .from(reviewLargedocumentResultCaches)
+++        .innerJoin(
+++          reviewDocumentCaches,
+++          eq(
+++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+++            reviewDocumentCaches.id,
+++          ),
++         )
++-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
++-        .orderBy(reviewChecklists.createdAt);
+++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
+++
+++      return results.map((row) => ({
+++        reviewDocumentCacheId: row.reviewDocumentCacheId,
+++        reviewChecklistId: row.reviewChecklistId,
+++        comment: row.comment,
+++        totalChunks: row.totalChunks,
+++        chunkIndex: row.chunkIndex,
+++        individualFileName: row.individualFileName,
+++      }));
+++    } catch (err) {
+++      throw repositoryError(
+++        '大量ドキュメント結果キャッシュの取得に失敗しました',
+++        err,
+++      );
+++    }
+++  }
+++
+++  /** 特定ドキュメントの最大totalChunks数を取得（レビューチャット用） */
+++  async getMaxTotalChunksForDocument(
+++    reviewHistoryId: string,
+++    documentId: string,
+++  ): Promise<number> {
+++    try {
+++      const db = await getDb();
++ 
++-      const map = new Map<number, ReviewChecklistResult>();
++-      for (const row of rows) {
++-        let group = map.get(row.checklistId);
++-        if (!group) {
++-          group = {
++-            id: row.checklistId,
++-            content: row.content,
++-            sourceEvaluations: [],
++-          };
++-          map.set(row.checklistId, group);
++-        }
++-        if (row.fileId !== null && row.fileName !== null) {
++-          group.sourceEvaluations!.push({
++-            fileId: row.fileId,
++-            fileName: row.fileName,
++-            evaluation: row.evaluation as ReviewEvaluation,
++-            comment: row.comment ?? undefined,
++-          });
++-        }
+++      // まずdocumentIdからreviewDocumentCacheIdを取得
+++      const [cache] = await db
+++        .select({ id: reviewDocumentCaches.id })
+++        .from(reviewDocumentCaches)
+++        .where(
+++          and(
+++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
+++            eq(reviewDocumentCaches.documentId, documentId),
+++          ),
+++        );
+++
+++      if (!cache) {
+++        // ドキュメントキャッシュが存在しない場合は1を返す
+++        return 1;
++       }
++-      return Array.from(map.values());
+++
+++      // 該当ドキュメントのtotalChunksの最大値を取得
+++      const result = await db
+++        .select({ maxChunks: max(reviewLargedocumentResultCaches.totalChunks) })
+++        .from(reviewLargedocumentResultCaches)
+++        .where(
+++          eq(reviewLargedocumentResultCaches.reviewDocumentCacheId, cache.id),
+++        );
+++
+++      const maxChunks = result[0]?.maxChunks;
+++
+++      // レコードが存在しない場合は1を返す（初回処理）
+++      return maxChunks ?? 1;
++     } catch (err) {
++-      throw repositoryError('レビュー結果の取得に失敗しました', err);
+++      throw repositoryError(
+++        'ドキュメントの最大チャンク数取得に失敗しました',
+++        err,
+++      );
++     }
++   }
++ 
++-  /** すべてのレビュー結果を削除 */
++-  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
+++  /** レビューチャット用: チェックリストと結果を取得 */
+++  async getChecklistResultsWithIndividualResults(
+++    reviewHistoryId: string,
+++    checklistIds: number[],
+++  ): Promise<
+++    Array<{
+++      checklistResult: ReviewChecklistResult;
+++      individualResults?: Array<{
+++        documentId: number;
+++        comment: string;
+++        individualFileName: string;
+++      }>;
+++    }>
+++  > {
++     try {
++       const db = await getDb();
++-      const checklists = await db
++-        .select({ id: reviewChecklists.id })
+++
+++      // チェックリストを取得
+++      const checklistEntities = await db
+++        .select()
++         .from(reviewChecklists)
++-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
+++        .where(
+++          and(
+++            eq(reviewChecklists.reviewHistoryId, reviewHistoryId),
+++            inArray(reviewChecklists.id, checklistIds),
+++          ),
+++        );
++ 
++-      // チェックリストが無ければ何もしない
++-      if (checklists.length === 0) return;
+++      // 個別レビュー結果キャッシュを取得
+++      const individualCaches =
+++        await this.getReviewLargedocumentResultCaches(reviewHistoryId);
++ 
++-      for (const { id } of checklists) {
++-        await db
++-          .delete(reviewChecklistResults)
++-          .where(eq(reviewChecklistResults.reviewChecklistId, id));
++-      }
+++      // 結果を組み立て
+++      return checklistEntities.map((entity) => {
+++        // 個別レビュー結果を抽出
+++        const individualResults = individualCaches
+++          .filter((cache) => cache.reviewChecklistId === entity.id)
+++          .map((cache) => ({
+++            documentId: cache.reviewDocumentCacheId,
+++            comment: cache.comment,
+++            individualFileName: cache.individualFileName,
+++          }));
+++
+++        // ReviewChecklistResult型を構築
+++        const checklistResult: ReviewChecklistResult = {
+++          id: entity.id,
+++          content: entity.content,
+++          sourceEvaluation: {
+++            evaluation: entity.evaluation ?? undefined,
+++            comment: entity.comment ?? undefined,
+++          },
+++        };
+++
+++        return {
+++          checklistResult,
+++          individualResults:
+++            individualResults.length > 0 ? individualResults : undefined,
+++        };
+++      });
++     } catch (err) {
++-      throw repositoryError('レビュー結果の削除に失敗しました', err);
+++      throw repositoryError('チェックリストと結果の取得に失敗しました', err);
++     }
++   }
++ }
++diff --git a/src/adapter/db/drizzle/repository/settingsRepository.ts b/src/adapter/db/drizzle/repository/settingsRepository.ts
++deleted file mode 100644
++index c0ef0443c..000000000
++--- a/src/adapter/db/drizzle/repository/settingsRepository.ts
+++++ /dev/null
++@@ -1,73 +0,0 @@
++-import { z } from 'zod';
++-import { Settings, SettingsSchema } from '@/types';
++-import { getStore } from '@/main/store';
++-import { repositoryError } from '@/main/lib/error';
++-import { ISettingsRepository } from '@/main/service/port/repository';
++-
++-/** undefined を保存したら例外になるため、delete に切り替える */
++-function setOrDelete<T>(store: any, key: string, value: T | undefined) {
++-  if (value === undefined) {
++-    store.delete(key);
++-  } else {
++-    store.set(key, value);
++-  }
++-}
++-
++-/**
++- * Electron Storeを使用した設定リポジトリの実装
++- */
++-export class ElectronStoreSettingsRepository implements ISettingsRepository {
++-  private store = getStore();
++-
++-  async getSettings(): Promise<Settings> {
++-    try {
++-      const settings = await SettingsSchema.parseAsync(this.store.store);
++-      return settings;
++-    } catch (err) {
++-      if (err instanceof z.ZodError) {
++-        throw repositoryError('設定情報の形式が不正です', err);
++-      }
++-      throw repositoryError('設定情報の取得に失敗しました', err);
++-    }
++-  }
++-
++-  async saveSettings(settings: Settings): Promise<void> {
++-    try {
++-      // 必須系（undefined にならない想定）
++-      this.store.set('database.dir', settings.database.dir);
++-      this.store.set('api.key', settings.api.key);
++-      this.store.set('api.model', settings.api.model);
++-      this.store.set('api.url', settings.api.url);
++-
++-      // 任意系は undefined の可能性があるため setOrDelete で処理
++-      setOrDelete(
++-        this.store,
++-        'source.registerDir',
++-        settings.source.registerDir,
++-      );
++-
++-      setOrDelete(this.store, 'redmine.endpoint', settings.redmine.endpoint);
++-      setOrDelete(this.store, 'redmine.apiKey', settings.redmine.apiKey);
++-
++-      setOrDelete(this.store, 'gitlab.endpoint', settings.gitlab.endpoint);
++-      setOrDelete(this.store, 'gitlab.apiKey', settings.gitlab.apiKey);
++-
++-      setOrDelete(
++-        this.store,
++-        'systemPrompt.content',
++-        settings.systemPrompt.content,
++-      );
++-
++-      if (settings.mcp.serverConfig) {
++-        this.store.set(
++-          'mcp.serverConfig',
++-          JSON.stringify(settings.mcp.serverConfig, null, 2),
++-        );
++-      } else {
++-        this.store.delete('mcp.serverConfig');
++-      }
++-    } catch (err) {
++-      throw repositoryError('設定情報の保存に失敗しました', err);
++-    }
++-  }
++-}
++diff --git a/src/adapter/db/drizzle/schema.ts b/src/adapter/db/drizzle/schema.ts
++index 39ffd9c64..20643f956 100644
++--- a/src/adapter/db/drizzle/schema.ts
+++++ b/src/adapter/db/drizzle/schema.ts
++@@ -59,9 +59,11 @@ export const reviewHistories = sqliteTable('review_histories', {
++     .primaryKey()
++     .$default(() => uuidv4()), // 汎用チャット機能のコードを活用できるように、MastraのThreadと同じく主キーは文字列とする
++   title: text('title').notNull(), // ソースのtitleを/区切りで結合
+++  targetDocumentName: text('target_document_name'), // レビュー対象の統合ドキュメント名
++   additionalInstructions: text('additional_instructions'), // レビューの追加指示
++   commentFormat: text('comment_format'), // レビューのコメントフォーマット
++   evaluationSettings: text('evaluation_settings'), // 評定項目設定（JSON形式）
+++  documentMode: text('document_mode'), // レビュー実行方法: small, large
++   processingStatus: text('processing_status').notNull().default('idle'), // 処理ステータス: idle, extracting, extracted, reviewing, completed
++   createdAt: text('created_at')
++     .notNull()
++@@ -79,6 +81,8 @@ export const reviewChecklists = sqliteTable('review_checklists', {
++     .notNull()
++     .references(() => reviewHistories.id, { onDelete: 'cascade' }),
++   content: text('content').notNull(), // チェックリスト項目
+++  evaluation: text('evaluation'), // A, B, C, - 評価
+++  comment: text('comment'), // レビューコメント
++   createdBy: text('created_by').notNull(), // 'user' or 'system'
++   createdAt: text('created_at')
++     .notNull()
++@@ -89,26 +93,49 @@ export const reviewChecklists = sqliteTable('review_checklists', {
++     .$onUpdate(() => sql`(current_timestamp)`),
++ });
++ 
++-// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
++-export const reviewChecklistResults = sqliteTable(
++-  'review_checklist_results',
+++// レビュードキュメントキャッシュを格納するテーブル
+++export const reviewDocumentCaches = sqliteTable('review_document_caches', {
+++  id: integer('id').primaryKey({ autoIncrement: true }),
+++  reviewHistoryId: text('review_history_id')
+++    .notNull()
+++    .references(() => reviewHistories.id, { onDelete: 'cascade' }),
+++  documentId: text('document_id').notNull(), // ワークフロー内のドキュメントID
+++  fileName: text('file_name').notNull(), // ワークフロー内での名前（分割時は "xxx (part 1)" など）
+++  processMode: text('process_mode').notNull(), // 'text' or 'image'
+++  cachePath: text('cache_path').notNull(), // ファイル/ディレクトリパス
+++  createdAt: text('created_at')
+++    .notNull()
+++    .default(sql`(current_timestamp)`),
+++  updatedAt: text('updated_at')
+++    .notNull()
+++    .default(sql`(current_timestamp)`)
+++    .$onUpdate(() => sql`(current_timestamp)`),
+++});
+++
+++// レビュー大量ドキュメント結果キャッシュを格納するテーブル（大量ドキュメントレビューの個別レビュー結果）
+++export const reviewLargedocumentResultCaches = sqliteTable(
+++  'review_largedocument_result_caches',
++   {
+++    reviewDocumentCacheId: integer('review_document_cache_id')
+++      .notNull()
+++      .references(() => reviewDocumentCaches.id, { onDelete: 'cascade' }),
++     reviewChecklistId: integer('review_checklist_id')
++       .notNull()
++       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
++-    fileId: text('file_id').notNull(), // アップロードファイルのID
++-    fileName: text('file_name').notNull(), // ファイル名
++-    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
++-    comment: text('comment'), // レビューコメント
++-    createdAt: text('created_at')
++-      .notNull()
++-      .default(sql`(current_timestamp)`),
++-    updatedAt: text('updated_at')
++-      .notNull()
++-      .default(sql`(current_timestamp)`)
++-      .$onUpdate(() => sql`(current_timestamp)`),
+++    comment: text('comment').notNull(), // 個別レビューコメント
+++    totalChunks: integer('total_chunks').notNull(), // ドキュメント分割総数
+++    chunkIndex: integer('chunk_index').notNull(), // 何番目のチャンクか（0から始まる）
+++    individualFileName: text('individual_file_name').notNull(), // 分割後の個別ドキュメント名（"xxx (part 1)" など）
++   },
++-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
+++  (table) => ({
+++    pk: primaryKey({
+++      columns: [
+++        table.reviewDocumentCacheId,
+++        table.reviewChecklistId,
+++        table.chunkIndex,
+++      ],
+++    }),
+++  }),
++ );
++ 
++ // 型定義
++@@ -120,6 +147,11 @@ export type ReviewHistoryEntity = typeof reviewHistories.$inferSelect;
++ export type InsertReviewHistoryEntity = typeof reviewHistories.$inferInsert;
++ export type ReviewChecklistEntity = typeof reviewChecklists.$inferSelect;
++ export type InsertReviewChecklistEntity = typeof reviewChecklists.$inferInsert;
++-export type ReviewChecklistResultEntity = typeof reviewChecklistResults.$inferSelect;
++-export type InsertReviewChecklistResultEntity =
++-  typeof reviewChecklistResults.$inferInsert;
+++export type ReviewDocumentCacheEntity =
+++  typeof reviewDocumentCaches.$inferSelect;
+++export type InsertReviewDocumentCacheEntity =
+++  typeof reviewDocumentCaches.$inferInsert;
+++export type ReviewLargedocumentResultCacheEntity =
+++  typeof reviewLargedocumentResultCaches.$inferSelect;
+++export type InsertReviewLargedocumentResultCacheEntity =
+++  typeof reviewLargedocumentResultCaches.$inferInsert;
++diff --git a/src/adapter/db/index.ts b/src/adapter/db/index.ts
++index 244d3fb47..d94b38fc0 100644
++--- a/src/adapter/db/index.ts
+++++ b/src/adapter/db/index.ts
++@@ -6,8 +6,8 @@ import {
++ import {
++   DrizzleReviewRepository,
++   DrizzleSourceRepository,
++-  ElectronStoreSettingsRepository,
++ } from './drizzle/repository';
+++import { ElectronStoreSettingsRepository } from './electron-store/repository/settingsRepository';
++ 
++ let sourceRepository: ISourceRepository | null = null;
++ 
++diff --git a/src/main/lib/csvParser.ts b/src/main/lib/csvParser.ts
++index 5a7817356..c2f82751c 100644
++--- a/src/main/lib/csvParser.ts
+++++ b/src/main/lib/csvParser.ts
++@@ -101,7 +101,7 @@ export class CsvParser {
++    * @returns 空行の場合true
++    */
++   private static isEmptyRow(row: string[]): boolean {
++-    return row.every(cell => cell.trim() === '');
+++    return row.every((cell) => cell.trim() === '');
++   }
++ 
++   /**
++@@ -109,7 +109,10 @@ export class CsvParser {
++    * @param csvText CSVテキスト
++    * @returns 検証結果
++    */
++-  public static validate(csvText: string): { isValid: boolean; error?: string } {
+++  public static validate(csvText: string): {
+++    isValid: boolean;
+++    error?: string;
+++  } {
++     try {
++       let inQuotes = false;
++       let quoteCount = 0;
++@@ -139,4 +142,4 @@ export class CsvParser {
++       return { isValid: false, error: `CSV解析エラー: ${error}` };
++     }
++   }
++-}
++\ No newline at end of file
+++}
++diff --git a/src/main/lib/fileExtractor.ts b/src/main/lib/fileExtractor.ts
++index f7f136069..d57d7f454 100644
++--- a/src/main/lib/fileExtractor.ts
+++++ b/src/main/lib/fileExtractor.ts
++@@ -166,7 +166,10 @@ export default class FileExtractor {
++ 
++       // ファイルが更新されている場合はキャッシュを無効とする
++       if (stats.mtimeMs !== cacheData.metadata.lastModified) {
++-        logger.debug({ filePath, cachePath }, 'ファイルが更新されているためキャッシュを無効化します');
+++        logger.debug(
+++          { filePath, cachePath },
+++          'ファイルが更新されているためキャッシュを無効化します',
+++        );
++         await this.deleteCache(filePath);
++         return null;
++       }
++@@ -200,7 +203,11 @@ export default class FileExtractor {
++           extractedAt: Date.now(),
++         },
++       };
++-      await fs.writeFile(cachePath, JSON.stringify(cacheData, null, 2), 'utf-8');
+++      await fs.writeFile(
+++        cachePath,
+++        JSON.stringify(cacheData, null, 2),
+++        'utf-8',
+++      );
++     } catch (error) {
++       // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
++       logger.error({ error, filePath }, 'キャッシュの保存に失敗しました');
++@@ -738,14 +745,18 @@ try {
++             if (stats.mtimeMs !== cacheData.metadata.lastModified) {
++               await fs.unlink(cacheFilePath);
++               deletedCount++;
++-              logger.debug(`ファイル更新日時が古いキャッシュを削除: ${fileName}`);
+++              logger.debug(
+++                `ファイル更新日時が古いキャッシュを削除: ${fileName}`,
+++              );
++             }
++           } catch (statError) {
++             // 元ファイルが存在しない場合は削除
++             if ((statError as NodeJS.ErrnoException).code === 'ENOENT') {
++               await fs.unlink(cacheFilePath);
++               deletedCount++;
++-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
+++              logger.debug(
+++                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
+++              );
++             }
++           }
++         } catch (processError) {
++@@ -755,14 +766,22 @@ try {
++             deletedCount++;
++             logger.debug(`不正なキャッシュファイルを削除: ${fileName}`);
++           } catch (unlinkError) {
++-            logger.error({ error: unlinkError, fileName }, 'キャッシュファイルの削除に失敗');
+++            logger.error(
+++              { error: unlinkError, fileName },
+++              'キャッシュファイルの削除に失敗',
+++            );
++           }
++         }
++       }
++ 
++-      logger.info(`キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`);
+++      logger.info(
+++        `キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`,
+++      );
++     } catch (error) {
++-      logger.error({ error }, 'キャッシュディレクトリのクリーニングに失敗しました');
+++      logger.error(
+++        { error },
+++        'キャッシュディレクトリのクリーニングに失敗しました',
+++      );
++     }
++   }
++ }
++diff --git a/src/main/lib/logger.ts b/src/main/lib/logger.ts
++index 0aa5282a2..b55e75012 100644
++--- a/src/main/lib/logger.ts
+++++ b/src/main/lib/logger.ts
++@@ -6,7 +6,8 @@ import path from 'path';
++ const logLevel = getLogLevel();
++ log.transports.file.level = logLevel;
++ log.transports.console.level = logLevel;
++-log.transports.file.resolvePathFn = () => path.join(getCustomAppDataDir(), 'main.log');
+++log.transports.file.resolvePathFn = () =>
+++  path.join(getCustomAppDataDir(), 'main.log');
++ 
++ // シングルトン変数
++ let _mainLogger: Logger.MainLogger | null = null;
++diff --git a/src/main/lib/officeConverter.ts b/src/main/lib/officeConverter.ts
++index 55663f57a..fc8d0147a 100644
++--- a/src/main/lib/officeConverter.ts
+++++ b/src/main/lib/officeConverter.ts
++@@ -199,9 +199,16 @@ async function saveCache(
++       cachePdfPath,
++       cachedAt: Date.now(),
++     };
++-    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf-8');
+++    await fs.writeFile(
+++      metadataPath,
+++      JSON.stringify(metadata, null, 2),
+++      'utf-8',
+++    );
++ 
++-    logger.debug({ originalFilePath, cachePdfPath }, 'PDFキャッシュを保存しました');
+++    logger.debug(
+++      { originalFilePath, cachePdfPath },
+++      'PDFキャッシュを保存しました',
+++    );
++   } catch (error) {
++     // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
++     logger.error({ error, originalFilePath }, 'キャッシュの保存に失敗しました');
++@@ -789,7 +796,9 @@ export async function cleanCacheDirectory(): Promise<void> {
++               // 対応するPDFファイルも削除
++               await fs.unlink(metadata.cachePdfPath).catch(() => void 0);
++               deletedCount++;
++-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
+++              logger.debug(
+++                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
+++              );
++             }
++           }
++         }
++diff --git a/src/main/lib/util.ts b/src/main/lib/util.ts
++index e3c43a641..9544e872f 100644
++--- a/src/main/lib/util.ts
+++++ b/src/main/lib/util.ts
++@@ -32,7 +32,9 @@ export function toAbsolutePath(dirOrPath: string, fileName?: string): string {
++       throw internalError({
++         expose: false,
++         messageCode: 'VALIDATION_ERROR',
++-        messageParams: { detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。` },
+++        messageParams: {
+++          detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。`,
+++        },
++       });
++     }
++     // ディレクトリ部を取り出して結合
++@@ -68,7 +70,9 @@ export function isPathExists(dirOrPath: string): boolean {
++     throw internalError({
++       expose: true,
++       messageCode: 'VALIDATION_ERROR',
++-      messageParams: { detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}` },
+++      messageParams: {
+++        detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
+++      },
++     });
++   }
++ }
++diff --git a/src/main/lib/utils/reviewCacheHelper.ts b/src/main/lib/utils/reviewCacheHelper.ts
++new file mode 100644
++index 000000000..fd2f7659b
++--- /dev/null
+++++ b/src/main/lib/utils/reviewCacheHelper.ts
++@@ -0,0 +1,127 @@
+++import * as fs from 'fs/promises';
+++import * as path from 'path';
+++import { app } from 'electron';
+++
+++/**
+++ * レビュー機能で使用するキャッシュファイルの管理ヘルパークラス
+++ */
+++export class ReviewCacheHelper {
+++  /**
+++   * キャッシュベースディレクトリ取得
+++   */
+++  private static getCacheBaseDir(reviewHistoryId: string): string {
+++    return path.join(
+++      app.getPath('userData'),
+++      'review_cache',
+++      reviewHistoryId,
+++      'file_cache',
+++    );
+++  }
+++
+++  /**
+++   * テキストキャッシュ保存
+++   * @param reviewHistoryId レビュー履歴ID
+++   * @param documentId ドキュメントID
+++   * @param content テキスト内容
+++   * @returns ファイルパス
+++   */
+++  static async saveTextCache(
+++    reviewHistoryId: string,
+++    documentId: string,
+++    content: string,
+++  ): Promise<string> {
+++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
+++    await fs.mkdir(baseDir, { recursive: true });
+++
+++    const cachePath = path.join(baseDir, `${documentId}.txt`);
+++    await fs.writeFile(cachePath, content, 'utf-8');
+++
+++    return cachePath;
+++  }
+++
+++  /**
+++   * 画像キャッシュ保存（複数ページ対応）
+++   * @param reviewHistoryId レビュー履歴ID
+++   * @param documentId ドキュメントID
+++   * @param imageData Base64画像データ配列
+++   * @returns ディレクトリパス
+++   */
+++  static async saveImageCache(
+++    reviewHistoryId: string,
+++    documentId: string,
+++    imageData: string[],
+++  ): Promise<string> {
+++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
+++    const imageCacheDir = path.join(baseDir, documentId);
+++    await fs.mkdir(imageCacheDir, { recursive: true });
+++
+++    for (let i = 0; i < imageData.length; i++) {
+++      const pagePath = path.join(imageCacheDir, `page_${i}.b64`);
+++      await fs.writeFile(pagePath, imageData[i], 'utf-8');
+++    }
+++
+++    return imageCacheDir;
+++  }
+++
+++  /**
+++   * テキストキャッシュ読み込み
+++   * @param cachePath ファイルパス
+++   * @returns テキスト内容
+++   * @throws ファイルが存在しない場合やアクセスできない場合にエラーをスロー
+++   */
+++  static async loadTextCache(cachePath: string): Promise<string> {
+++    try {
+++      return await fs.readFile(cachePath, 'utf-8');
+++    } catch (error) {
+++      // ファイルが存在しない、またはアクセスできない場合
+++      throw new Error(
+++        `Failed to load text cache from ${cachePath}: ${error instanceof Error ? error.message : String(error)}`,
+++      );
+++    }
+++  }
+++
+++  /**
+++   * 画像キャッシュ読み込み
+++   * @param cacheDir ディレクトリパス
+++   * @returns Base64画像データ配列
+++   * @throws ディレクトリが存在しない場合やアクセスできない場合にエラーをスロー
+++   */
+++  static async loadImageCache(cacheDir: string): Promise<string[]> {
+++    try {
+++      const files = await fs.readdir(cacheDir);
+++      const imageFiles = files
+++        .filter((f) => f.endsWith('.b64'))
+++        .sort((a, b) => {
+++          const aNum = parseInt(a.match(/page_(\d+)\.b64/)?.[1] || '0');
+++          const bNum = parseInt(b.match(/page_(\d+)\.b64/)?.[1] || '0');
+++          return aNum - bNum;
+++        });
+++
+++      const imageData: string[] = [];
+++      for (const file of imageFiles) {
+++        const content = await fs.readFile(path.join(cacheDir, file), 'utf-8');
+++        imageData.push(content);
+++      }
+++
+++      return imageData;
+++    } catch (error) {
+++      // ディレクトリが存在しない、またはアクセスできない場合
+++      throw new Error(
+++        `Failed to load image cache from ${cacheDir}: ${error instanceof Error ? error.message : String(error)}`,
+++      );
+++    }
+++  }
+++
+++  /**
+++   * キャッシュディレクトリ削除
+++   * @param reviewHistoryId レビュー履歴ID
+++   */
+++  static async deleteCacheDirectory(reviewHistoryId: string): Promise<void> {
+++    const cacheDir = path.join(
+++      app.getPath('userData'),
+++      'review_cache',
+++      reviewHistoryId,
+++    );
+++    await fs.rm(cacheDir, { recursive: true, force: true });
+++  }
+++}
++diff --git a/src/main/main.ts b/src/main/main.ts
++index 047392026..605d337f2 100644
++--- a/src/main/main.ts
+++++ b/src/main/main.ts
++@@ -272,12 +272,7 @@ const setupChatHandlers = () => {
++     IpcChannels.CHAT_SEND_MESSAGE,
++     async ({ roomId, messages }, { event }) => {
++       try {
++-        const dataStream = await chatService.generate(
++-          userId,
++-          roomId,
++-          messages,
++-          event,
++-        );
+++        const dataStream = await chatService.generate(userId, roomId, messages);
++ 
++         // テキストストリームを処理
++         // @ts-ignore
++@@ -542,6 +537,43 @@ const setupReviewHandlers = () => {
++     }
++     return undefined as never;
++   });
+++
+++  // レビューチャットメッセージ送信ハンドラ
+++  handleIpc(
+++    IpcChannels.REVIEW_CHAT_SEND_MESSAGE,
+++    async ({ reviewHistoryId, checklistIds, question }) => {
+++      try {
+++        const dataStream = await reviewService.chatWithReview(
+++          reviewHistoryId,
+++          checklistIds,
+++          question,
+++        );
+++
+++        // テキストストリームを処理
+++        // @ts-ignore
+++        for await (const chunk of dataStream) {
+++          // チャンクをフロントエンドに送信
+++          publishEvent(IpcChannels.REVIEW_CHAT_STREAM_RESPONSE, chunk);
+++        }
+++
+++        return undefined as never;
+++      } catch (error) {
+++        // エラー時もAbortControllerを削除
+++        reviewService.abortReviewChat(reviewHistoryId);
+++        const normalizedError = normalizeUnknownError(error);
+++        publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
+++          message: normalizedError.message,
+++        });
+++        throw normalizedError;
+++      }
+++    },
+++  );
+++
+++  // レビューチャット中断ハンドラ
+++  handleIpc(IpcChannels.REVIEW_CHAT_ABORT, async (reviewHistoryId) => {
+++    const result = reviewService.abortReviewChat(reviewHistoryId);
+++    return undefined as never;
+++  });
++ };
++ 
++ // ソース登録処理の実行
++diff --git a/src/main/preload.ts b/src/main/preload.ts
++index fa8d0f9c8..c32d7113f 100644
++--- a/src/main/preload.ts
+++++ b/src/main/preload.ts
++@@ -147,6 +147,13 @@ const electronHandler = {
++     /** レビュー実行キャンセル */
++     abortExecute: (reviewHistoryId: string) =>
++       invokeIpc(IpcChannels.REVIEW_EXECUTE_ABORT, reviewHistoryId),
+++    /** レビューチャットメッセージ送信 */
+++    sendChatMessage: (
+++      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE],
+++    ) => invokeIpc(IpcChannels.REVIEW_CHAT_SEND_MESSAGE, params),
+++    /** レビューチャット中断 */
+++    abortChat: (reviewHistoryId: string) =>
+++      invokeIpc(IpcChannels.REVIEW_CHAT_ABORT, reviewHistoryId),
++   },
++   pushApi: {
++     async subscribe<C extends EventChannel>(
++diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
++index 43df9c6a8..625443fe6 100644
++--- a/src/main/service/chatService.ts
+++++ b/src/main/service/chatService.ts
++@@ -120,7 +120,6 @@ export class ChatService implements IChatService {
++     userId: string,
++     threadId: string,
++     messages: ChatMessage[],
++-    event: Electron.IpcMainInvokeEvent,
++   ) {
++     // 新しいAbortControllerを作成
++     const controller = this.abortControllerManager.getOrCreateAbortController(
++diff --git a/src/main/service/port/repository/IReviewRepository.ts b/src/main/service/port/repository/IReviewRepository.ts
++index b558873e1..60b64222e 100644
++--- a/src/main/service/port/repository/IReviewRepository.ts
+++++ b/src/main/service/port/repository/IReviewRepository.ts
++@@ -1,10 +1,13 @@
++ import {
++   CustomEvaluationSettings,
+++  DocumentMode,
++   ProcessingStatus,
++   RevieHistory,
++   ReviewChecklist,
++   ReviewChecklistCreatedBy,
++   ReviewChecklistResult,
+++  ReviewDocumentCache,
+++  ReviewLargedocumentResultCache,
++   ReviewEvaluation,
++ } from '@/types';
++ 
++@@ -30,6 +33,10 @@ export interface IReviewRepository {
++     id: string,
++     processingStatus: ProcessingStatus,
++   ): Promise<void>;
+++  updateReviewHistoryTargetDocumentName(
+++    id: string,
+++    targetDocumentName: string,
+++  ): Promise<void>;
++   deleteReviewHistory(id: string): Promise<void>;
++ 
++   // チェックリスト
++@@ -49,16 +56,59 @@ export interface IReviewRepository {
++       reviewChecklistId: number;
++       evaluation: ReviewEvaluation;
++       comment: string;
++-      fileId: string;
++-      fileName: string;
++     }[],
++   ): Promise<void>;
++-  deleteReviewResults(
++-    reviewChecklistId: number,
++-    sourceId: number,
++-  ): Promise<void>;
++   getReviewChecklistResults(
++     reviewHistoryId: string,
++   ): Promise<ReviewChecklistResult[]>;
++   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
+++
+++  // documentModeの保存
+++  updateReviewHistoryDocumentMode(
+++    id: string,
+++    documentMode: DocumentMode,
+++  ): Promise<void>;
+++
+++  // ドキュメントキャッシュ管理
+++  createReviewDocumentCache(
+++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
+++  ): Promise<ReviewDocumentCache>;
+++  getReviewDocumentCaches(
+++    reviewHistoryId: string,
+++  ): Promise<ReviewDocumentCache[]>;
+++  getReviewDocumentCacheByDocumentId(
+++    reviewHistoryId: string,
+++    documentId: string,
+++  ): Promise<ReviewDocumentCache | null>;
+++  getReviewDocumentCacheByDocumentIds(
+++    reviewHistoryId: string,
+++    documentIds: string[],
+++  ): Promise<ReviewDocumentCache[]>;
+++
+++  // 大量ドキュメント結果キャッシュ管理
+++  createReviewLargedocumentResultCache(
+++    cache: ReviewLargedocumentResultCache,
+++  ): Promise<void>;
+++  getReviewLargedocumentResultCaches(
+++    reviewHistoryId: string,
+++  ): Promise<ReviewLargedocumentResultCache[]>;
+++  getMaxTotalChunksForDocument(
+++    reviewHistoryId: string,
+++    documentId: string,
+++  ): Promise<number>;
+++
+++  // レビューチャット用: チェックリスト結果と個別レビュー結果を取得
+++  getChecklistResultsWithIndividualResults(
+++    reviewHistoryId: string,
+++    checklistIds: number[],
+++  ): Promise<
+++    Array<{
+++      checklistResult: ReviewChecklistResult;
+++      individualResults?: Array<{
+++        documentId: number;
+++        comment: string;
+++        individualFileName: string;
+++      }>;
+++    }>
+++  >;
++ }
++diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
++index c65bd4539..8ced9789e 100644
++--- a/src/main/service/reviewService.ts
+++++ b/src/main/service/reviewService.ts
++@@ -1,3 +1,7 @@
+++import { createDataStream } from 'ai';
+++// @ts-ignore
+++import { RuntimeContext } from '@mastra/core/runtime-context';
+++import { v4 as uuid } from 'uuid';
++ import { getReviewRepository } from '@/adapter/db';
++ import {
++   ReviewChecklistEdit,
++@@ -20,11 +24,14 @@ import { getMainLogger } from '../lib/logger';
++ import { mastra } from '@/mastra';
++ import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
++ import { formatMessage } from '../lib/messages';
+++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
+++import { ReviewChatWorkflowRuntimeContext } from '@/mastra/workflows/reviewChat';
++ 
++ export interface IReviewService {
++   getReviewHistories(): Promise<RevieHistory[]>;
++   getReviewHistoryDetail(reviewHistoryId: string): Promise<{
++     checklistResults: ReviewChecklistResult[];
+++    targetDocumentName?: string | null;
++   }>;
++   getReviewInstruction(reviewHistoryId: string): Promise<{
++     additionalInstructions?: string;
++@@ -49,6 +56,15 @@ export interface IReviewService {
++     reviewHistoryId: string,
++     files: UploadFile[],
++   ): Promise<void>;
+++  chatWithReview(
+++    reviewHistoryId: string,
+++    checklistIds: number[],
+++    question: string,
+++  ): Promise<ReturnType<typeof createDataStream>>;
+++  abortReviewChat(reviewHistoryId: string): {
+++    success: boolean;
+++    error?: string;
+++  };
++ }
++ 
++ const logger = getMainLogger();
++@@ -82,8 +98,11 @@ export class ReviewService implements IReviewService {
++   public async getReviewHistoryDetail(reviewHistoryId: string) {
++     const checklistResults =
++       await this.reviewRepository.getReviewChecklistResults(reviewHistoryId);
+++    const reviewHistory =
+++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
++     return {
++       checklistResults: checklistResults,
+++      targetDocumentName: reviewHistory?.targetDocumentName,
++     };
++   }
++ 
++@@ -105,7 +124,18 @@ export class ReviewService implements IReviewService {
++    * レビュー履歴を削除
++    */
++   public async deleteReviewHistory(reviewHistoryId: string) {
++-    return this.reviewRepository.deleteReviewHistory(reviewHistoryId);
+++    await this.reviewRepository.deleteReviewHistory(reviewHistoryId);
+++
+++    // キャッシュディレクトリも削除
+++    try {
+++      await ReviewCacheHelper.deleteCacheDirectory(reviewHistoryId);
+++    } catch (err) {
+++      // キャッシュ削除失敗はログのみ（DB削除は成功しているため）
+++      logger.warn(
+++        err,
+++        `キャッシュディレクトリの削除に失敗しました: ${reviewHistoryId}`,
+++      );
+++    }
++   }
++ 
++   /**
++@@ -116,7 +146,8 @@ export class ReviewService implements IReviewService {
++     checklistEdits: ReviewChecklistEdit[],
++   ) {
++     // レビュー履歴が存在しない場合は新規作成
++-    let reviewHistory = await this.reviewRepository.getReviewHistory(reviewHistoryId);
+++    let reviewHistory =
+++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
++     if (reviewHistory === null) {
++       reviewHistory = await this.reviewRepository.createReviewHistory(
++         generateReviewTitle(),
++@@ -197,7 +228,9 @@ export class ReviewService implements IReviewService {
++       }
++ 
++       // システム作成のチェックリストを削除（手動作成分は保持）
++-      await this.reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
+++      await this.reviewRepository.deleteSystemCreatedChecklists(
+++        reviewHistoryId,
+++      );
++ 
++       const allChecklistItems: string[] = [];
++ 
++@@ -223,7 +256,11 @@ export class ReviewService implements IReviewService {
++ 
++       // チェックリスト項目をDBに保存
++       for (const item of uniqueChecklistItems) {
++-        await this.reviewRepository.createChecklist(reviewHistoryId, item, 'system');
+++        await this.reviewRepository.createChecklist(
+++          reviewHistoryId,
+++          item,
+++          'system',
+++        );
++       }
++       // AI処理と同様のイベント通知を発火
++       publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
++@@ -660,4 +697,147 @@ export class ReviewService implements IReviewService {
++       return { success: false, error: err.message };
++     }
++   }
+++
+++  /**
+++   * レビューチャット実行
+++   * @param reviewHistoryId レビュー履歴ID
+++   * @param checklistIds チェックリストID配列
+++   * @param question ユーザからの質問
+++   * @returns DataStream
+++   */
+++  public async chatWithReview(
+++    reviewHistoryId: string,
+++    checklistIds: number[],
+++    question: string,
+++  ): Promise<ReturnType<typeof createDataStream>> {
+++    // DataStreamを生成
+++    const dataStream = createDataStream({
+++      execute: async (writer) => {
+++        try {
+++          // Mastraワークフローを取得
+++          const workflow = mastra.getWorkflow('reviewChatWorkflow');
+++
+++          if (!workflow) {
+++            logger.error('レビュー実行ワークフローが見つかりません');
+++            throw internalError({
+++              expose: false,
+++            });
+++          }
+++
+++          // 質問テキストから本文のみを抽出
+++          // フォーマット: @チェックリスト行 + 空行 + 本文
+++          const lines = question.split('\n');
+++          const bodyLines: string[] = [];
+++          let foundEmptyLine = false;
+++
+++          for (const line of lines) {
+++            // @で始まる行は除外
+++            if (line.trim().startsWith('@')) {
+++              continue;
+++            }
+++
+++            // 最初の空行を見つけた後から本文開始
+++            if (!foundEmptyLine && line.trim() === '') {
+++              foundEmptyLine = true;
+++              continue;
+++            }
+++
+++            // 空行を見つけた後の行を本文として抽出
+++            if (foundEmptyLine) {
+++              bodyLines.push(line);
+++            }
+++          }
+++
+++          const bodyText = bodyLines.join('\n').trim();
+++
+++          // ランタイムコンテキストを作成
+++          const runtimeContext =
+++            new RuntimeContext<ReviewChatWorkflowRuntimeContext>();
+++          runtimeContext.set('dataStreamWriter', writer);
+++          runtimeContext.set('toolCallId', uuid());
+++
+++          const run = await workflow.createRunAsync();
+++
+++          // workflowをrunningWorkflowsに登録
+++          const workflowKey = `chat_${reviewHistoryId}`;
+++
+++          // 実行中のワークフローを管理
+++          this.runningWorkflows.set(workflowKey, {
+++            cancel: () => run.cancel(),
+++          });
+++
+++          // ストリーミングはworkflow内部で実行されるため、ここでは結果を待つだけ
+++          const result = await run.start({
+++            inputData: {
+++              reviewHistoryId,
+++              checklistIds,
+++              question: bodyText,
+++            },
+++            runtimeContext,
+++          });
+++
+++          const checkResult = checkWorkflowResult(result);
+++
+++          // 処理が完了したらworkflowを削除
+++          this.runningWorkflows.delete(workflowKey);
+++
+++          if (checkResult.status !== 'success') {
+++            throw internalError({
+++              expose: true,
+++              messageCode: 'PLAIN_MESSAGE',
+++              messageParams: {
+++                message: checkResult.errorMessage || '不明なエラー',
+++              },
+++            });
+++          }
+++        } catch (error) {
+++          logger.error(error, 'レビューチャット実行に失敗しました');
+++          // エラー時もworkflowを削除
+++          this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
+++          throw error;
+++        }
+++      },
+++      onError: (error) => {
+++        logger.error(error, 'レビューチャット中にエラーが発生');
+++        // エラー時もworkflowを削除
+++        this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
+++        const normalizedError = normalizeUnknownError(error);
+++        return normalizedError.message;
+++      },
+++    });
+++
+++    return dataStream;
+++  }
+++
+++  /**
+++   * レビューチャット中断
+++   * @param reviewHistoryId レビュー履歴ID
+++   */
+++  public abortReviewChat(reviewHistoryId: string): {
+++    success: boolean;
+++    error?: string;
+++  } {
+++    try {
+++      const workflowKey = `chat_${reviewHistoryId}`;
+++      const runningWorkflow = this.runningWorkflows.get(workflowKey);
+++      if (runningWorkflow) {
+++        runningWorkflow.cancel();
+++        this.runningWorkflows.delete(workflowKey);
+++        logger.info(`レビューチャットをキャンセルしました: ${reviewHistoryId}`);
+++        return { success: true };
+++      } else {
+++        logger.warn(
+++          `キャンセル対象のレビューチャットが見つかりません: ${reviewHistoryId}`,
+++        );
+++        return {
+++          success: false,
+++          error: 'キャンセル対象の処理が見つかりません',
+++        };
+++      }
+++    } catch (error) {
+++      logger.error(error, 'レビューチャットのキャンセルに失敗しました');
+++      const err = normalizeUnknownError(error);
+++      return { success: false, error: err.message };
+++    }
+++  }
++ }
++diff --git a/src/main/service/settingsService.ts b/src/main/service/settingsService.ts
++index 5882d1d96..682726a8a 100644
++--- a/src/main/service/settingsService.ts
+++++ b/src/main/service/settingsService.ts
++@@ -257,13 +257,17 @@ export class SettingsService implements ISettingsService {
++       publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: true });
++     } catch (error) {
++       // 設定更新完了イベントを発行（失敗）
++-      const errorMessage = error instanceof Error ? error.message : '不明なエラーが発生しました';
++-      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: false, error: errorMessage });
+++      const errorMessage =
+++        error instanceof Error ? error.message : '不明なエラーが発生しました';
+++      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, {
+++        success: false,
+++        error: errorMessage,
+++      });
++ 
++       // エラーを再throw
++       throw error;
++     }
++-  }
+++  };
++   /**
++    * 設定を取得する
++    */
++diff --git a/src/main/store.ts b/src/main/store.ts
++deleted file mode 100644
++index c0b84c2bc..000000000
++--- a/src/main/store.ts
+++++ /dev/null
++@@ -1,134 +0,0 @@
++-// @ts-ignore
++-import Store from 'electron-store';
++-import { getCustomAppDataDir } from './main';
++-// 設定の型定義
++-export interface StoreSchema {
++-  database: {
++-    dir: string;
++-  };
++-  source: {
++-    registerDir?: string;
++-  };
++-  api: {
++-    key: string;
++-    url: string;
++-    model: string;
++-  };
++-  redmine: {
++-    endpoint?: string;
++-    apiKey?: string;
++-  };
++-  gitlab: {
++-    endpoint?: string;
++-    apiKey?: string;
++-  };
++-  mcp: {
++-    serverConfig?: string;
++-  };
++-  systemPrompt: {
++-    content?: string;
++-  };
++-}
++-
++-// スキーマ定義
++-const schema = {
++-  database: {
++-    type: 'object',
++-    properties: {
++-      dir: { type: 'string' },
++-    },
++-    required: ['dir'],
++-  },
++-  source: {
++-    type: 'object',
++-    properties: {
++-      registerDir: { type: 'string' },
++-    },
++-  },
++-  api: {
++-    type: 'object',
++-    properties: {
++-      key: { type: 'string' },
++-      url: { type: 'string' },
++-      model: { type: 'string' },
++-    },
++-    required: ['key', 'url', 'model'],
++-  },
++-  redmine: {
++-    type: 'object',
++-    properties: {
++-      endpoint: { type: 'string' },
++-      apiKey: { type: 'string' },
++-    },
++-  },
++-  gitlab: {
++-    type: 'object',
++-    properties: {
++-      endpoint: { type: 'string' },
++-      apiKey: { type: 'string' },
++-    },
++-  },
++-  mcp: {
++-    type: 'object',
++-    properties: {
++-      serverConfigText: {
++-        type: 'string',
++-        default: '',
++-      },
++-    },
++-  },
++-  systemPrompt: {
++-    type: 'object',
++-    properties: {
++-      content: {
++-        type: 'string',
++-      },
++-    },
++-  },
++-} as const;
++-
++-// デフォルト値の設定
++-const defaults: StoreSchema = {
++-  database: {
++-    dir: getCustomAppDataDir(),
++-  },
++-  source: {
++-    registerDir: undefined,
++-  },
++-  api: {
++-    key: 'aaa',
++-    url: 'http://localhost',
++-    model: 'aaa',
++-  },
++-  redmine: {
++-    endpoint: 'http://localhost',
++-    apiKey: '',
++-  },
++-  gitlab: {
++-    endpoint: 'http://localhost',
++-    apiKey: '',
++-  },
++-  mcp: {
++-    serverConfig: undefined,
++-  },
++-  systemPrompt: {
++-    content: undefined,
++-  },
++-};
++-
++-// グローバルなストアインスタンス
++-const store = new Store<StoreSchema>({
++-  schema,
++-  defaults,
++-  // アプリのユーザーデータディレクトリ内のconfigフォルダに保存
++-  // cwd: path.join(app.getPath('userData'), 'config'),
++-  cwd: getCustomAppDataDir(),
++-});
++-
++-// ストアを取得する関数
++-export function getStore() {
++-  if (!store) {
++-    throw new Error('Store has not been initialized.');
++-  }
++-  return store;
++-}
++diff --git a/src/mastra/agents/model/openAICompatible.ts b/src/mastra/agents/model/openAICompatible.ts
++index c741004b1..158e92301 100644
++--- a/src/mastra/agents/model/openAICompatible.ts
+++++ b/src/mastra/agents/model/openAICompatible.ts
++@@ -14,7 +14,10 @@ export const getOpenAICompatibleModel = ({
++     throw internalError({
++       expose: true,
++       messageCode: 'VALIDATION_ERROR',
++-      messageParams: { detail: 'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。' },
+++      messageParams: {
+++        detail:
+++          'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。',
+++      },
++     });
++   }
++ 
++diff --git a/src/mastra/agents/orchestrator.ts b/src/mastra/agents/orchestrator.ts
++index 66730c8c7..6b85b70c4 100644
++--- a/src/mastra/agents/orchestrator.ts
+++++ b/src/mastra/agents/orchestrator.ts
++@@ -6,7 +6,7 @@ import { Memory } from '@mastra/memory';
++ import { TokenLimiter } from '@mastra/memory/processors';
++ // @ts-ignore
++ import { LibSQLStore } from '@mastra/libsql';
++-import { getStore } from '@/main/store';
+++import { getStore } from '@/adapter/db/electron-store/store';
++ import { getOrchestratorSystemPrompt } from './prompts';
++ import { getOpenAICompatibleModel } from './model/openAICompatible';
++ import { isPathExists, toAbsoluteFileURL } from '@/main/lib/util';
++diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
++index ed443613a..9f5ce1fa5 100644
++--- a/src/mastra/agents/prompts.ts
+++++ b/src/mastra/agents/prompts.ts
++@@ -8,11 +8,11 @@ import {
++   ReviewExecuteAgentRuntimeContext,
++   TopicExtractionAgentRuntimeContext,
++   TopicChecklistAgentRuntimeContext,
++-  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
++-  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
++-  ReviewAnswerQuestionAgentRuntimeContext,
++   IndividualDocumentReviewAgentRuntimeContext,
++   ConsolidateReviewAgentRuntimeContext,
+++  ReviewChatPlanningAgentRuntimeContext,
+++  ReviewChatResearchAgentRuntimeContext,
+++  ReviewChatAnswerAgentRuntimeContext,
++ } from './workflowAgents';
++ 
++ /**
++@@ -576,6 +576,237 @@ ${additionalInstructions}
++ Remember: Your thorough analysis of this document part is crucial for achieving an excellent final consolidated review. Include all relevant details that will contribute to the overall document assessment.`;
++ }
++ 
+++// レビューチャット：調査計画作成用のプロンプト
+++export function getReviewChatPlanningPrompt({
+++  runtimeContext,
+++}: {
+++  runtimeContext: RuntimeContext<ReviewChatPlanningAgentRuntimeContext>;
+++}): string {
+++  const availableDocuments = runtimeContext.get('availableDocuments');
+++  const checklistInfo = runtimeContext.get('checklistInfo');
+++
+++  const documentList = availableDocuments
+++    .map((doc) => `- ID: ${doc.id}, Name: ${doc.fileName}`)
+++    .join('\n');
+++
+++  return `You are a professional document analysis coordinator specializing in review result investigation.
+++
+++CONTEXT:
+++You are helping answer user questions about document review results. You have access to:
+++1. The original reviewed documents
+++2. Review results including evaluations and comments for specific checklist items
+++
+++AVAILABLE DOCUMENTS:
+++${documentList}
+++
+++CHECKLIST REVIEW INFORMATION:
+++${checklistInfo}
+++
+++YOUR TASK:
+++Create an efficient research plan to answer the user's question by identifying:
+++1. Which documents contain relevant information
+++2. What specific aspects to investigate in each document
+++3. How the investigation relates to the review results
+++
+++STRATEGIC PLANNING GUIDELINES:
+++
+++**Question Analysis:**
+++- Understand the user's intent: Are they asking about evaluation reasoning, improvement suggestions, specific document content, or discrepancies in the review?
+++- Identify keywords and concepts that connect to the checklist items and review comments
+++- Determine if the question relates to specific checklist items or general document content
+++
+++**Document Selection Strategy:**
+++- **Prioritize efficiency**: Select ONLY documents that are likely to contain relevant information
+++- Use the review results to guide your selection:
+++  * If asking about a specific evaluation or comment, focus on documents mentioned in those review results
+++  * If asking about document content, identify which documents are most likely to contain that information
+++  * Consider the review context: documents with lower ratings or specific comments may need investigation
+++
+++**Research Instructions Quality:**
+++- Be SPECIFIC and FOCUSED in your research instructions
+++- Clearly state what information to extract (e.g., "Find the section describing the testing methodology and extract the specific test types mentioned")
+++- Connect the research to the review context when relevant (e.g., "Verify the claim in the review comment that the security measures are incomplete")
+++- Prioritize targeted investigation over broad exploration
+++
+++**Efficiency Considerations:**
+++- Minimize the number of documents to investigate (only select what's necessary)
+++- Avoid redundant investigations across multiple documents unless truly needed
+++- Focus research instructions on finding specific information rather than general overviews
+++
+++OUTPUT REQUIREMENTS:
+++For each document that needs investigation, provide:
+++- **Document ID**: The exact ID from the available documents list above
+++- **Research Instructions**: Detailed, focused instructions explaining:
+++  * What specific information to look for
+++  * How it relates to the user's question
+++  * Connection to review results if applicable
+++- **Reasoning**: Brief explanation (1-2 sentences) of why this document is necessary for answering the question
+++
+++IMPORTANT:
+++- Create a focused, efficient plan - quality over quantity
+++- Your research plan will be executed in parallel across multiple documents
+++- Each investigation will be conducted independently, so make instructions self-contained and clear`;
+++}
+++
+++// レビューチャット：個別ドキュメント調査用のプロンプト
+++export function getReviewChatResearchPrompt({
+++  runtimeContext,
+++}: {
+++  runtimeContext: RuntimeContext<ReviewChatResearchAgentRuntimeContext>;
+++}): string {
+++  const totalChunks = runtimeContext.get('totalChunks');
+++  const chunkIndex = runtimeContext.get('chunkIndex');
+++  const fileName = runtimeContext.get('fileName');
+++  const checklistInfo = runtimeContext.get('checklistInfo');
+++  const userQuestion = runtimeContext.get('userQuestion');
+++
+++  // ドキュメントが分割されているかどうかで異なるプロンプトを生成
+++  const isChunked = totalChunks > 1;
+++
+++  const contextSection = isChunked
+++    ? `
+++IMPORTANT DOCUMENT CONTEXT:
+++- You are reviewing a PORTION (chunk ${chunkIndex + 1} of ${totalChunks}) of the document "${fileName}"
+++- This document has been split into ${totalChunks} parts due to length constraints
+++- You can ONLY see the content of this specific chunk (${chunkIndex + 1}/${totalChunks})
+++- Other parts of the document exist but are NOT visible to you in this analysis
+++- Information may be incomplete or cut off at chunk boundaries
+++
+++CRITICAL INSTRUCTIONS FOR CHUNKED DOCUMENTS:
+++- Report ONLY what you can find in THIS chunk
+++- If the requested information is not in this chunk, clearly state: "The information is not found in this portion (chunk ${chunkIndex + 1}/${totalChunks}) of the document"
+++- Do NOT speculate about what might be in other chunks
+++- If information appears to be cut off or incomplete at the beginning or end, note this explicitly
+++- Be aware that context from previous or subsequent chunks may be missing
+++`
+++    : `
+++DOCUMENT CONTEXT:
+++- You are reviewing the complete document "${fileName}"
+++- The full document content is available for your analysis
+++- You have access to all information needed to answer the research question
+++`;
+++
+++  return `You are a professional document researcher specializing in detailed document analysis.
+++
+++Your task is to conduct a specific investigation on the provided document based on the given research instructions.
+++
+++BACKGROUND CONTEXT:
+++This research is being conducted to help answer the following user question about a document review:
+++
+++User Question:
+++${userQuestion}
+++
+++The review was conducted based on the following checklist(s):
+++${checklistInfo}
+++
+++Understanding this context will help you focus your investigation on information that is truly relevant to answering the user's question about the review results.
+++${contextSection}
+++RESEARCH GUIDELINES:
+++1. Carefully read and analyze the provided document content with the user's question and checklist context in mind
+++2. Follow the specific research instructions precisely
+++3. Extract all relevant information related to the research topic
+++4. Consider how your findings relate to the checklist items and review results mentioned above
+++5. Cite specific sections, headings, page indicators, or other references where information is found
+++6. If information appears incomplete or ambiguous, note this clearly${isChunked ? ' (especially at chunk boundaries)' : ''}
+++7. Document your findings comprehensively - do not summarize or omit details
+++${isChunked ? '8. Remember: you can only report on what is visible in THIS chunk' : ''}
+++
+++OUTPUT REQUIREMENTS:
+++- Provide detailed research findings in Japanese
+++- Include specific citations and references from the document${isChunked ? ` (mention this is from chunk ${chunkIndex + 1}/${totalChunks} if relevant)` : ''}
+++- Note any limitations or gaps in the available information${isChunked ? ' within this chunk' : ''}
+++- Structure your findings clearly for easy integration into the final answer
+++${isChunked ? `- If the requested information is not in this chunk, explicitly state that it was not found in this portion` : ''}`;
+++}
+++
+++// レビューチャット：最終回答生成用のプロンプト
+++export function getReviewChatAnswerPrompt({
+++  runtimeContext,
+++}: {
+++  runtimeContext: RuntimeContext<ReviewChatAnswerAgentRuntimeContext>;
+++}): string {
+++  const userQuestion = runtimeContext.get('userQuestion');
+++  const checklistInfo = runtimeContext.get('checklistInfo');
+++
+++  return `You are a senior document review specialist responsible for synthesizing research findings into comprehensive answers.
+++
+++CONTEXT:
+++You are answering questions about document review results. You have access to:
+++1. The user's original question
+++2. Review results with evaluations and comments for specific checklist items
+++3. Research findings from individual document investigations
+++
+++USER QUESTION:
+++${userQuestion}
+++
+++CHECKLIST CONTEXT:
+++${checklistInfo}
+++
+++YOUR TASK:
+++Integrate all research findings and provide a clear, accurate, and comprehensive answer to the user's question.
+++
+++SYNTHESIS GUIDELINES:
+++
+++**Understanding the Research Results:**
+++- You will receive research findings from one or more documents
+++- Each finding may come from a complete document OR from a portion of a document (chunk)
+++- Some findings may indicate "information not found in this portion" - this is expected for chunked documents
+++- Consider ALL findings together to build a complete picture
+++
+++**Integration Strategy:**
+++1. **Identify Relevant Information:**
+++   - Extract key information from each research finding that addresses the user's question
+++   - Pay attention to specific citations, section references, and evidence provided
+++   - Distinguish between definitive findings and tentative/partial information
+++
+++2. **Handle Chunked Document Results:**
+++   - If research findings mention "chunk X/Y" or "this portion", the document was split for analysis
+++   - Combine findings from multiple chunks of the same document to form a complete view
+++   - If some chunks report "information not found", don't assume the information doesn't exist - it may be in other chunks
+++
+++3. **Resolve Contradictions:**
+++   - If findings from different sources contradict each other:
+++     * Present both perspectives
+++     * Explain the discrepancy clearly
+++     * Cite specific sources for each perspective
+++     * Offer reasoning if one source seems more authoritative
+++
+++4. **Synthesize into a Coherent Answer:**
+++   - Organize information logically to directly answer the question
+++   - Connect findings to the review context (evaluations, comments) when relevant
+++   - Build a narrative that flows naturally, not just a list of findings
+++
+++**Citation and Reference Guidelines:**
+++- **Document Names**: Use natural document names without mentioning chunk numbers (e.g., "設計書.pdf" not "設計書.pdf chunk 2/3")
+++- **Specific Citations**: Include section names, headings, page indicators, or other specific references from the research findings
+++- **Attribution**: Clearly attribute information to sources (e.g., "設計書.pdfの第3章によると...")
+++- **Avoid Internal Process Terms**: Do not mention "chunk", "research findings", "investigation" or similar internal process terminology
+++
+++**Handling Incomplete Information:**
+++- If critical information is missing or unclear, state this explicitly in Japanese
+++- Suggest what additional information would be needed
+++- Distinguish between:
+++  * Information that definitely doesn't exist in the documents
+++  * Information that wasn't found but might exist elsewhere
+++  * Information that is ambiguous or unclear
+++
+++OUTPUT REQUIREMENTS:
+++- **Language**: Answer in Japanese, matching the style and formality of the user's question
+++- **Structure**: Organize the answer clearly and logically:
+++  * Start with a direct answer to the main question if possible
+++  * Provide supporting details and evidence
+++  * Conclude with any caveats or additional context
+++- **Tone**: Professional, informative, and helpful
+++- **Completeness**: Address all aspects of the user's question
+++- **Natural Expression**: Write as if you reviewed the documents directly - avoid mentioning the research process
+++
+++CRITICAL REMINDERS:
+++- Your answer represents the final response to the user
+++- Quality and accuracy are paramount
+++- Provide value by synthesizing information, not just repeating findings
+++- Be honest about limitations while maximizing usefulness of available information`;
+++}
+++
++ // レビュー結果統合用のプロンプト
++ export function getConsolidateReviewPrompt({
++   runtimeContext,
++diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
++index ad0371265..f45e92522 100644
++--- a/src/mastra/agents/workflowAgents.ts
+++++ b/src/mastra/agents/workflowAgents.ts
++@@ -14,6 +14,9 @@ import {
++   getDocumentReviewExecutionPrompt,
++   getIndividualDocumentReviewPrompt,
++   getConsolidateReviewPrompt,
+++  getReviewChatPlanningPrompt,
+++  getReviewChatResearchPrompt,
+++  getReviewChatAnswerPrompt,
++ } from './prompts';
++ import { getOpenAICompatibleModel } from './model/openAICompatible';
++ import { BaseRuntimeContext } from './types';
++@@ -44,32 +47,37 @@ export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
++   checklistRequirements?: string;
++ };
++ 
++-export type ReviewCheckReviewReadinessFirstRunAgentRuntimeContext = BaseRuntimeContext & {
+++export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
++   checklistItems: { id: number; content: string }[];
++   additionalInstructions?: string;
+++  commentFormat?: string;
++ };
++ 
++-export type ReviewCheckReviewReadinessSubsequentAgentRuntimeContext = BaseRuntimeContext & {
+++export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
++   checklistItems: { id: number; content: string }[];
++   additionalInstructions?: string;
++-  priorQnA: { documentId: string; documentName: string; qna: { question: string; answer: string }[] }[];
+++  commentFormat?: string;
+++  evaluationSettings?: CustomEvaluationSettings;
++ };
++ 
++-export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
++-  checklistItems: { id: number; content: string }[];
+++// レビューチャット用エージェント
+++export type ReviewChatPlanningAgentRuntimeContext = BaseRuntimeContext & {
+++  availableDocuments: { id: string; fileName: string }[];
+++  checklistInfo: string; // チェックリスト情報のテキスト
++ };
++ 
++-export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
++-  checklistItems: { id: number; content: string }[];
++-  additionalInstructions?: string;
++-  commentFormat?: string;
+++export type ReviewChatResearchAgentRuntimeContext = BaseRuntimeContext & {
+++  researchContent: string; // 調査内容
+++  totalChunks: number; // ドキュメントの総チャンク数
+++  chunkIndex: number; // 現在のチャンクインデックス
+++  fileName: string; // ドキュメント名
+++  checklistInfo: string; // チェックリスト情報（内容とレビュー結果）
+++  userQuestion: string; // ユーザからの質問
++ };
++ 
++-export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
++-  checklistItems: { id: number; content: string }[];
++-  additionalInstructions?: string;
++-  commentFormat?: string;
++-  evaluationSettings?: CustomEvaluationSettings;
+++export type ReviewChatAnswerAgentRuntimeContext = BaseRuntimeContext & {
+++  userQuestion: string; // ユーザからの質問
+++  checklistInfo: string; // チェックリスト情報のテキスト
++ };
++ 
++ export const summarizeSourceAgent = new Agent({
++@@ -139,3 +147,21 @@ export const consolidateReviewAgent = new Agent({
++   instructions: getConsolidateReviewPrompt,
++   model: getOpenAICompatibleModel,
++ });
+++
+++export const reviewChatPlanningAgent = new Agent({
+++  name: 'reviewChatPlanningAgent',
+++  instructions: getReviewChatPlanningPrompt,
+++  model: getOpenAICompatibleModel,
+++});
+++
+++export const reviewChatResearchAgent = new Agent({
+++  name: 'reviewChatResearchAgent',
+++  instructions: getReviewChatResearchPrompt,
+++  model: getOpenAICompatibleModel,
+++});
+++
+++export const reviewChatAnswerAgent = new Agent({
+++  name: 'reviewChatAnswerAgent',
+++  instructions: getReviewChatAnswerPrompt,
+++  model: getOpenAICompatibleModel,
+++});
++diff --git a/src/mastra/index.ts b/src/mastra/index.ts
++index d2cd1e327..976120234 100644
++--- a/src/mastra/index.ts
+++++ b/src/mastra/index.ts
++@@ -19,10 +19,14 @@ import {
++   topicChecklistAgent,
++   individualDocumentReviewAgent,
++   consolidateReviewAgent,
+++  reviewChatPlanningAgent,
+++  reviewChatResearchAgent,
+++  reviewChatAnswerAgent,
++ } from './agents/workflowAgents';
++ import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
++ import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
++ import { executeReviewWorkflow } from './workflows/sourceReview/executeReview';
+++import { reviewChatWorkflow } from './workflows/reviewChat';
++ import fs from 'fs';
++ import path from 'path';
++ import { getLogLevel } from '@/main/lib/logger';
++@@ -51,7 +55,6 @@ try {
++   console.error('ログファイル初期化に失敗:', err);
++ }
++ 
++-
++ // ロガーの作成
++ export const logger = new PinoLogger({
++   name: 'AIKATA',
++@@ -73,11 +76,15 @@ export const mastra: Mastra = new Mastra({
++     topicChecklistAgent,
++     individualDocumentReviewAgent,
++     consolidateReviewAgent,
+++    reviewChatPlanningAgent,
+++    reviewChatResearchAgent,
+++    reviewChatAnswerAgent,
++   },
++   workflows: {
++     sourceRegistrationWorkflow,
++     checklistExtractionWorkflow,
++     executeReviewWorkflow,
+++    reviewChatWorkflow,
++   },
++   logger,
++ });
++diff --git a/src/mastra/lib/util.ts b/src/mastra/lib/util.ts
++index 57fe0b68c..3438aae8a 100644
++--- a/src/mastra/lib/util.ts
+++++ b/src/mastra/lib/util.ts
++@@ -8,7 +8,7 @@
++ export function makeChunksByCount<T extends { length: number }>(
++   data: T,
++   splitCount: number,
++-  overlap: number
+++  overlap: number,
++ ): Array<{ start: number; end: number }> {
++   const total = data.length;
++ 
++diff --git a/src/mastra/tools/redmine/redmineClient.ts b/src/mastra/tools/redmine/redmineClient.ts
++index d383049b7..1f88ac3cb 100644
++--- a/src/mastra/tools/redmine/redmineClient.ts
+++++ b/src/mastra/tools/redmine/redmineClient.ts
++@@ -92,7 +92,9 @@ export class RedmineClient {
++         throw internalError({
++           expose: true,
++           messageCode: 'REDMINE_API_ERROR',
++-          messageParams: { detail: `${response.status} ${response.statusText}` },
+++          messageParams: {
+++            detail: `${response.status} ${response.statusText}`,
+++          },
++         });
++       }
++       if (response.status === 204) {
++diff --git a/src/mastra/tools/toolDisplayConfig.ts b/src/mastra/tools/toolDisplayConfig.ts
++index 62ee97da4..9dca7f3da 100644
++--- a/src/mastra/tools/toolDisplayConfig.ts
+++++ b/src/mastra/tools/toolDisplayConfig.ts
++@@ -25,4 +25,8 @@ export const TOOL_NAME_DISPLAY_MAP: Record<string, string> = {
++   getMergeRequestDetail: 'マージリクエスト詳細取得',
++   addMergeRequestComment: 'マージリクエストコメント追加',
++   addMergeRequestDiffComment: 'マージリクエスト差分コメント追加',
+++
+++  // レビューチャット用
+++  researchDocumentStart: 'ドキュメント調査中...',
+++  researchDocumentComplete: 'ドキュメント調査完了',
++ };
++diff --git a/src/mastra/workflows/reviewChat/generateAnswerStep.ts b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
++new file mode 100644
++index 000000000..c6a039b9e
++--- /dev/null
+++++ b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
++@@ -0,0 +1,158 @@
+++// @ts-ignore
+++import { createStep } from '@mastra/core';
+++// @ts-ignore
+++import { RuntimeContext } from '@mastra/core/runtime-context';
+++import { z } from 'zod';
+++import { baseStepOutputSchema } from '../schema';
+++import { stepStatus } from '../types';
+++import { getReviewRepository } from '@/adapter/db';
+++import { getMainLogger } from '@/main/lib/logger';
+++import { normalizeUnknownError, internalError } from '@/main/lib/error';
+++import { ReviewChatAnswerAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+++import {
+++  createRuntimeContext,
+++  judgeFinishReason,
+++} from '@/mastra/lib/agentUtils';
+++import { IpcChannels } from '@/types';
+++import { publishEvent } from '@/main/lib/eventPayloadHelper';
+++import { ReviewChatWorkflowRuntimeContext } from '.';
+++
+++const logger = getMainLogger();
+++
+++export const generateAnswerStepInputSchema = z.object({
+++  reviewHistoryId: z.string(),
+++  checklistIds: z.array(z.number()),
+++  question: z.string(),
+++  researchResults: z.array(
+++    z.object({
+++      documentId: z.string(),
+++      researchResult: z.string(),
+++    }),
+++  ),
+++});
+++
+++export const generateAnswerStepOutputSchema = baseStepOutputSchema.extend({
+++  answer: z.string().optional(),
+++});
+++
+++export const generateAnswerStep = createStep({
+++  id: 'generateAnswerStep',
+++  description: '最終回答を生成するステップ（ストリーミング）',
+++  inputSchema: generateAnswerStepInputSchema,
+++  outputSchema: generateAnswerStepOutputSchema,
+++  execute: async ({
+++    inputData,
+++    bail,
+++    mastra,
+++    abortSignal,
+++    runtimeContext: workflowRuntimeContext,
+++  }) => {
+++    try {
+++      const { reviewHistoryId, checklistIds, question, researchResults } =
+++        inputData;
+++      const reviewRepository = getReviewRepository();
+++      const dataStreamWriter = (
+++        workflowRuntimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++      ).get('dataStreamWriter');
+++
+++      // チェックリスト結果を取得
+++      const checklistResults =
+++        await reviewRepository.getChecklistResultsWithIndividualResults(
+++          reviewHistoryId,
+++          checklistIds,
+++        );
+++
+++      // ドキュメントキャッシュ情報を取得
+++      const documentCaches =
+++        await reviewRepository.getReviewDocumentCacheByDocumentIds(
+++          reviewHistoryId,
+++          researchResults.map((r) => r.documentId),
+++        );
+++
+++      const checklistInfo = checklistResults
+++        .map((item) => {
+++          let info = `Checklist: ${item.checklistResult.content}\n`;
+++          if (item.checklistResult.sourceEvaluation) {
+++            info += `Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}, Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}`;
+++          }
+++          return info;
+++        })
+++        .join('\n');
+++
+++      // 調査結果を統合
+++      const researchSummary = researchResults
+++        .map(
+++          (result) =>
+++            `Document ID: ${result.documentId}\nDocument Name: ${documentCaches.find((dc) => dc.documentId === result.documentId)?.fileName || 'Unknown'}\nFindings: ${result.researchResult}`,
+++        )
+++        .join('\n---\n');
+++
+++      // RuntimeContext作成
+++      const runtimeContext =
+++        await createRuntimeContext<ReviewChatAnswerAgentRuntimeContext>();
+++      runtimeContext.set('userQuestion', question);
+++      runtimeContext.set('checklistInfo', checklistInfo);
+++
+++      const promptText = `User Question: ${question}\n\nResearch Findings:\n${researchSummary}`;
+++
+++      // Mastraエージェント経由でストリーミングAI呼び出し
+++      const answerAgent = mastra.getAgent('reviewChatAnswerAgent');
+++      const result = await answerAgent.generate(promptText, {
+++        runtimeContext,
+++        abortSignal,
+++        onStepFinish: (stepResult) => {
+++          // AI SDK Data Stream Protocol v1 形式でチャンクを送信
+++          // https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol
+++          if (stepResult.text) {
+++            dataStreamWriter.write(`0:${JSON.stringify(stepResult.text)}\n`);
+++          }
+++          stepResult.toolCalls.forEach((toolCall) => {
+++            dataStreamWriter.write(`9:${JSON.stringify(toolCall)}\n`);
+++          });
+++          stepResult.toolResults.forEach((toolResult) => {
+++            dataStreamWriter.write(`a:${JSON.stringify(toolResult)}\n`);
+++          });
+++          dataStreamWriter.write(
+++            `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
+++          );
+++        },
+++      });
+++
+++      const { success, reason } = judgeFinishReason(result.finishReason);
+++      if (!success) {
+++        throw internalError({
+++          expose: true,
+++          messageCode: 'AI_API_ERROR',
+++          messageParams: { detail: reason },
+++        });
+++      }
+++
+++      // 最終的なfinish reasonとusage情報を送信
+++      publishEvent(
+++        IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
+++        `d:${JSON.stringify({ finishReason: result.finishReason, ...result.usage })}\n`,
+++      );
+++
+++      // 完了イベント送信
+++      publishEvent(IpcChannels.REVIEW_CHAT_COMPLETE, undefined);
+++
+++      return {
+++        status: 'success' as stepStatus,
+++        answer: result.text,
+++      };
+++    } catch (error) {
+++      logger.error(error, '最終回答の生成に失敗しました');
+++      const normalizedError = normalizeUnknownError(error);
+++
+++      // エラーイベント送信
+++      publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
+++        message: normalizedError.message,
+++      });
+++
+++      return bail({
+++        status: 'failed' as stepStatus,
+++        errorMessage: normalizedError.message,
+++      });
+++    }
+++  },
+++});
++diff --git a/src/mastra/workflows/reviewChat/index.ts b/src/mastra/workflows/reviewChat/index.ts
++new file mode 100644
++index 000000000..840d52dde
++--- /dev/null
+++++ b/src/mastra/workflows/reviewChat/index.ts
++@@ -0,0 +1,133 @@
+++// @ts-ignore
+++import { createWorkflow } from '@mastra/core';
+++// @ts-ignore
+++import { RuntimeContext } from '@mastra/core/runtime-context';
+++import { DataStreamWriter } from 'ai';
+++import { z } from 'zod';
+++import { stepStatus } from '../types';
+++import { planResearchStep } from './planResearchStep';
+++import {
+++  generateAnswerStep,
+++  generateAnswerStepInputSchema,
+++  generateAnswerStepOutputSchema,
+++} from './generateAnswerStep';
+++import { researchDocumentWithRetryWorkflow } from './researchDocument';
+++import { getReviewRepository } from '@/adapter/db';
+++
+++// ワークフローのラインタイムコンテキスト
+++export type ReviewChatWorkflowRuntimeContext = {
+++  dataStreamWriter: DataStreamWriter;
+++  // 擬似的なtoolCallを表現するためのID
+++  toolCallId: string;
+++};
+++
+++// 入力スキーマ
+++export const reviewChatInputSchema = z.object({
+++  reviewHistoryId: z.string(),
+++  checklistIds: z.array(z.number()),
+++  question: z.string(),
+++});
+++
+++// メインワークフロー
+++export const reviewChatWorkflow = createWorkflow({
+++  id: 'reviewChatWorkflow',
+++  inputSchema: reviewChatInputSchema,
+++  outputSchema: generateAnswerStepOutputSchema,
+++})
+++  .then(planResearchStep)
+++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
+++    if (inputData.status === 'failed') {
+++      return bail(inputData);
+++    }
+++
+++    const initData = (await getInitData()) as z.infer<
+++      typeof reviewChatInputSchema
+++    >;
+++
+++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
+++    const toolCallId = (
+++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++    ).get('toolCallId');
+++    const writer = (
+++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++    ).get('dataStreamWriter');
+++    const reviewRepository = getReviewRepository();
+++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
+++      initData.reviewHistoryId,
+++    );
+++    writer.write(
+++      `9:${JSON.stringify({
+++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
+++        toolName: 'researchDocumentStart',
+++        args: inputData.researchTasks?.map((task) => {
+++          return {
+++            documentName:
+++              documentCaches.find((d) => d.documentId === task.documentId)
+++                ?.fileName || 'Unknown',
+++            researchContent: task.researchContent,
+++          };
+++        }),
+++      })}\n`,
+++    );
+++
+++    return (inputData.researchTasks || []).map((task) => ({
+++      reviewHistoryId: initData.reviewHistoryId,
+++      documentId: task.documentId,
+++      researchContent: task.researchContent,
+++      checklistIds: initData.checklistIds,
+++      question: initData.question,
+++    })) as z.infer<typeof researchDocumentWithRetryWorkflow.inputSchema>[];
+++  })
+++  .foreach(researchDocumentWithRetryWorkflow, { concurrency: 5 })
+++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
+++    // 失敗があればエラー
+++    if (inputData.some((item) => item.status === 'failed')) {
+++      const failed = inputData.find((item) => item.status === 'failed');
+++      return bail({
+++        status: 'failed' as stepStatus,
+++        errorMessage: failed?.errorMessage || '調査に失敗しました',
+++      });
+++    }
+++
+++    const initData = (await getInitData()) as z.infer<
+++      typeof reviewChatInputSchema
+++    >;
+++
+++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
+++    const toolCallId = (
+++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++    ).get('toolCallId');
+++    const writer = (
+++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+++    ).get('dataStreamWriter');
+++    const reviewRepository = getReviewRepository();
+++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
+++      initData.reviewHistoryId,
+++    );
+++    writer.write(
+++      `a:${JSON.stringify({
+++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
+++        toolName: 'researchDocumentComplete',
+++        result: inputData.map((item) => ({
+++          documentName:
+++            documentCaches.find((d) => d.documentId === item.documentId)
+++              ?.fileName || 'Unknown',
+++          researchResult: item.researchResult!,
+++        })),
+++      })}\n`,
+++    );
+++
+++    return {
+++      reviewHistoryId: initData.reviewHistoryId,
+++      checklistIds: initData.checklistIds,
+++      question: initData.question,
+++      researchResults: inputData
+++        .filter((item) => item.status === 'success')
+++        .map((item) => ({
+++          documentId: item.documentId!,
+++          researchResult: item.researchResult!,
+++        })),
+++    } as z.infer<typeof generateAnswerStepInputSchema>;
+++  })
+++  .then(generateAnswerStep)
+++  .commit();
++diff --git a/src/mastra/workflows/reviewChat/planResearchStep.ts b/src/mastra/workflows/reviewChat/planResearchStep.ts
++new file mode 100644
++index 000000000..fac9a8c13
++--- /dev/null
+++++ b/src/mastra/workflows/reviewChat/planResearchStep.ts
++@@ -0,0 +1,127 @@
+++// @ts-ignore
+++import { createStep } from '@mastra/core';
+++import { z } from 'zod';
+++import { baseStepOutputSchema } from '../schema';
+++import { stepStatus } from '../types';
+++import { getReviewRepository } from '@/adapter/db';
+++import { getMainLogger } from '@/main/lib/logger';
+++import { normalizeUnknownError, internalError } from '@/main/lib/error';
+++import { ReviewChatPlanningAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+++import {
+++  createRuntimeContext,
+++  judgeFinishReason,
+++} from '@/mastra/lib/agentUtils';
+++import { reviewChatInputSchema } from '.';
+++
+++const logger = getMainLogger();
+++
+++// Step 1: 調査計画作成
+++const planResearchStepOutputSchema = baseStepOutputSchema.extend({
+++  researchTasks: z
+++    .array(
+++      z.object({
+++        documentId: z.string(),
+++        researchContent: z.string(),
+++      }),
+++    )
+++    .optional(),
+++});
+++
+++export const planResearchStep = createStep({
+++  id: 'planResearchStep',
+++  description: '調査計画を作成するステップ',
+++  inputSchema: reviewChatInputSchema,
+++  outputSchema: planResearchStepOutputSchema,
+++  execute: async ({ inputData, bail, mastra }) => {
+++    try {
+++      const { reviewHistoryId, checklistIds, question } = inputData;
+++      const reviewRepository = getReviewRepository();
+++
+++      // チェックリスト結果と個別レビュー結果を取得
+++      const checklistResults =
+++        await reviewRepository.getChecklistResultsWithIndividualResults(
+++          reviewHistoryId,
+++          checklistIds,
+++        );
+++
+++      // ドキュメント一覧を取得
+++      const documentCaches =
+++        await reviewRepository.getReviewDocumentCaches(reviewHistoryId);
+++
+++      // RuntimeContext作成
+++      const availableDocuments = documentCaches.map((doc) => ({
+++        id: doc.documentId,
+++        fileName: doc.fileName,
+++      }));
+++
+++      // チェックリスト情報の文字列を生成
+++      const checklistInfo = checklistResults
+++        .map((item) => {
+++          let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
+++          if (item.checklistResult.sourceEvaluation) {
+++            info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
+++          }
+++          if (item.individualResults && item.individualResults.length > 0) {
+++            info += `Individual Review Results:\n`;
+++            item.individualResults.forEach((result) => {
+++              info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
+++            });
+++          }
+++          return info;
+++        })
+++        .join('\n---\n');
+++
+++      // RuntimeContext作成
+++      const runtimeContext =
+++        await createRuntimeContext<ReviewChatPlanningAgentRuntimeContext>();
+++      runtimeContext.set('availableDocuments', availableDocuments);
+++      runtimeContext.set('checklistInfo', checklistInfo);
+++
+++      // 構造化出力用のスキーマ
+++      const researchTasksSchema = z.object({
+++        tasks: z.array(
+++          z.object({
+++            reasoning: z
+++              .string()
+++              .describe('Reason for selecting this document for research'),
+++            documentId: z.string().describe('Document ID to investigate'),
+++            researchContent: z
+++              .string()
+++              .describe('Detailed research instructions for this document'),
+++          }),
+++        ),
+++      });
+++
+++      // Mastraエージェント経由でAI呼び出し（構造化出力）
+++      const planningAgent = mastra.getAgent('reviewChatPlanningAgent');
+++      const result = await planningAgent.generate(question, {
+++        runtimeContext,
+++        output: researchTasksSchema,
+++      });
+++
+++      const { success, reason } = judgeFinishReason(result.finishReason);
+++      if (!success) {
+++        throw internalError({
+++          expose: true,
+++          messageCode: 'AI_API_ERROR',
+++          messageParams: { detail: reason },
+++        });
+++      }
+++
+++      // 構造化出力から調査タスクを取得
+++      const researchTasks = result.object?.tasks || [];
+++
+++      return {
+++        status: 'success' as stepStatus,
+++        researchTasks,
+++      };
+++    } catch (error) {
+++      logger.error(error, '調査計画の作成に失敗しました');
+++      const normalizedError = normalizeUnknownError(error);
+++      return bail({
+++        status: 'failed' as stepStatus,
+++        errorMessage: normalizedError.message,
+++      });
+++    }
+++  },
+++});
++diff --git a/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
++new file mode 100644
++index 000000000..dd6e3f661
++--- /dev/null
+++++ b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
++@@ -0,0 +1,57 @@
+++// @ts-ignore
+++import { createStep } from '@mastra/core';
+++import { z } from 'zod';
+++import { baseStepOutputSchema } from '../../schema';
+++import { stepStatus } from '../../types';
+++import { getReviewRepository } from '@/adapter/db';
+++import { getMainLogger } from '@/main/lib/logger';
+++import { normalizeUnknownError } from '@/main/lib/error';
+++
+++const logger = getMainLogger();
+++
+++export const getTotalChunksStepInputSchema = z.object({
+++  reviewHistoryId: z.string(),
+++  documentId: z.string(),
+++  researchContent: z.string(),
+++});
+++
+++export const getTotalChunksStepOutputSchema = baseStepOutputSchema.extend({
+++  reviewHistoryId: z.string(),
+++  documentId: z.string(),
+++  researchContent: z.string(),
+++  totalChunks: z.number(),
+++});
+++
+++export const getTotalChunksStep = createStep({
+++  id: 'getTotalChunksStep',
+++  description: '最大チャンク数を取得するステップ',
+++  inputSchema: getTotalChunksStepInputSchema,
+++  outputSchema: getTotalChunksStepOutputSchema,
+++  execute: async ({ inputData, bail }) => {
+++    try {
+++      const { reviewHistoryId, documentId, researchContent } = inputData;
+++      const reviewRepository = getReviewRepository();
+++
+++      // 既存の最大チャンク数を取得
+++      const totalChunks = await reviewRepository.getMaxTotalChunksForDocument(
+++        reviewHistoryId,
+++        documentId,
+++      );
+++
+++      return {
+++        status: 'success' as stepStatus,
+++        reviewHistoryId,
+++        documentId,
+++        researchContent,
+++        totalChunks,
+++      };
+++    } catch (error) {
+++      logger.error(error, '最大チャンク数の取得に失敗しました');
+++      const normalizedError = normalizeUnknownError(error);
+++      return bail({
+++        status: 'failed' as stepStatus,
+++        errorMessage: normalizedError.message,
+++      });
+++    }
+++  },
+++});
++diff --git a/src/mastra/workflows/reviewChat/researchDocument/index.ts b/src/mastra/workflows/reviewChat/researchDocument/index.ts
++new file mode 100644
++index 000000000..d5367757e
++--- /dev/null
+++++ b/src/mastra/workflows/reviewChat/researchDocument/index.ts
++@@ -0,0 +1,202 @@
+++// @ts-ignore
+++import { createWorkflow } from '@mastra/core';
+++import { z } from 'zod';
+++import { baseStepOutputSchema } from '../../schema';
+++import { stepStatus } from '../../types';
+++import { getReviewRepository } from '@/adapter/db';
+++import { getMainLogger } from '@/main/lib/logger';
+++import { makeChunksByCount } from '@/mastra/lib/util';
+++import {
+++  getTotalChunksStep,
+++  getTotalChunksStepInputSchema,
+++  getTotalChunksStepOutputSchema,
+++} from './getTotalChunksStep';
+++import {
+++  researchChunkStep,
+++  researchChunkStepInputSchema,
+++} from './researchDocumentChunk';
+++import { input } from '@testing-library/user-event/dist/cjs/event/input.js';
+++
+++const logger = getMainLogger();
+++
+++const researchDocumentWithRetryInputSchema = z.object({
+++  reviewHistoryId: z.string(),
+++  documentId: z.string(),
+++  researchContent: z.string(),
+++  checklistIds: z.array(z.number()),
+++  question: z.string(),
+++});
+++
+++const researchDocumentWithRetryOutputSchema = baseStepOutputSchema.extend({
+++  documentId: z.string().optional(),
+++  researchResult: z.string().optional(),
+++});
+++
+++export const researchDocumentWithRetryWorkflow = createWorkflow({
+++  id: 'researchDocumentWithRetryWorkflow',
+++  inputSchema: researchDocumentWithRetryInputSchema,
+++  outputSchema: researchDocumentWithRetryOutputSchema,
+++})
+++  .map(async ({ inputData }) => {
+++    return inputData as z.infer<typeof getTotalChunksStepInputSchema>;
+++  })
+++  .then(getTotalChunksStep)
+++  .map(async ({ inputData, getInitData, bail }) => {
+++    if (inputData.status === 'failed') {
+++      return bail(inputData);
+++    }
+++    const initData = (await getInitData()) as z.infer<
+++      typeof researchDocumentWithRetryInputSchema
+++    >;
+++    return {
+++      ...inputData,
+++      checklistIds: initData.checklistIds,
+++      question: initData.question,
+++    } as z.infer<typeof getTotalChunksStepOutputSchema> & {
+++      checklistIds: number[];
+++      question: string;
+++    };
+++  })
+++  .dountil(
+++    createWorkflow({
+++      id: 'chunkResearchInnerWorkflow',
+++      inputSchema: getTotalChunksStepOutputSchema.extend({
+++        checklistIds: z.array(z.number()),
+++        question: z.string(),
+++      }),
+++      outputSchema: researchDocumentWithRetryOutputSchema,
+++    })
+++      .map(async ({ inputData }) => {
+++        const { reviewHistoryId, documentId, researchContent, totalChunks } =
+++          inputData;
+++        const reviewRepository = getReviewRepository();
+++
+++        // ドキュメントキャッシュを取得
+++        const documentCache =
+++          await reviewRepository.getReviewDocumentCacheByDocumentId(
+++            reviewHistoryId,
+++            documentId,
+++          );
+++
+++        if (!documentCache) {
+++          throw new Error(`Document not found: ${documentId}`);
+++        }
+++
+++        // ドキュメントをtotalChunks分に分割
+++        const chunks: Array<{ text?: string; images?: string[] }> = [];
+++
+++        if (documentCache.processMode === 'text' && documentCache.textContent) {
+++          // テキストをチャンク分割
+++          const chunkRanges = makeChunksByCount(
+++            documentCache.textContent,
+++            totalChunks,
+++            0,
+++          );
+++          chunkRanges.forEach((range) => {
+++            chunks.push({
+++              text: documentCache.textContent!.substring(
+++                range.start,
+++                range.end,
+++              ),
+++            });
+++          });
+++        } else if (
+++          documentCache.processMode === 'image' &&
+++          documentCache.imageData
+++        ) {
+++          // 画像配列をチャンク分割
+++          const chunkRanges = makeChunksByCount(
+++            documentCache.imageData,
+++            totalChunks,
+++            0,
+++          );
+++          chunkRanges.forEach((range) => {
+++            chunks.push({
+++              images: documentCache.imageData!.slice(range.start, range.end),
+++            });
+++          });
+++        }
+++
+++        // 各チャンクに対する調査タスクを作成
+++        return chunks.map((chunk, index) => ({
+++          reviewHistoryId,
+++          documentId,
+++          researchContent,
+++          chunkContent: chunk,
+++          chunkIndex: index,
+++          totalChunks,
+++          fileName: documentCache.fileName,
+++          checklistIds: inputData.checklistIds,
+++          question: inputData.question,
+++        })) as z.infer<typeof researchChunkStepInputSchema>[];
+++      })
+++      .foreach(researchChunkStep, { concurrency: 5 })
+++      .map(async ({ inputData, bail, getInitData }) => {
+++        const results = inputData;
+++
+++        // いずれかのチャンクでコンテキスト長エラーがあったかチェック
+++        const hasContentLengthError = results.some(
+++          (result) => result.finishReason === 'content_length',
+++        );
+++
+++        // 失敗があればエラー
+++        if (results.some((result) => result.status === 'failed')) {
+++          const failed = results.find((result) => result.status === 'failed');
+++          return bail({
+++            status: 'failed' as stepStatus,
+++            errorMessage: failed?.errorMessage || 'チャンク調査に失敗しました',
+++            finishReason: 'error' as const,
+++          });
+++        }
+++
+++        const initData = (await getInitData()) as z.infer<
+++          typeof getTotalChunksStepOutputSchema
+++        >;
+++
+++        if (hasContentLengthError) {
+++          // チャンク数を増やして再試行
+++          return {
+++            status: 'success' as stepStatus,
+++            reviewHistoryId: initData.reviewHistoryId,
+++            documentId: initData.documentId,
+++            researchContent: initData.researchContent,
+++            totalChunks: initData.totalChunks + 1,
+++            finishReason: 'content_length' as const,
+++          };
+++        }
+++
+++        // すべて成功したらチャンク結果を統合
+++        const combinedResult = results
+++          .filter((result) => result.chunkResult)
+++          .map((result, index) => `[Chunk ${index + 1}]\n${result.chunkResult}`)
+++          .join('\n\n');
+++
+++        return {
+++          status: 'success' as stepStatus,
+++          documentId: initData.documentId,
+++          researchResult: combinedResult,
+++          finishReason: 'success' as const,
+++        };
+++      })
+++      .commit(),
+++    async ({ inputData }) => {
+++      // 再試行上限または成功したら終了
+++      if ((inputData as any).totalChunks >= 10) {
+++        return true;
+++      }
+++      if ((inputData as any).finishReason !== 'content_length') {
+++        return true;
+++      }
+++      return false;
+++    },
+++  )
+++  .map(async ({ inputData }) => {
+++    // 最終結果を返す
+++    return {
+++      status: inputData.status,
+++      documentId: inputData.documentId,
+++      researchResult: inputData.researchResult,
+++      errorMessage: (inputData as any).errorMessage,
+++    };
+++  })
+++  .commit();
++diff --git a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
++new file mode 100644
++index 000000000..225e1901f
++--- /dev/null
+++++ b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
++@@ -0,0 +1,181 @@
+++// @ts-ignore
+++import { createStep } from '@mastra/core';
+++import { z } from 'zod';
+++import { baseStepOutputSchema } from '../../schema';
+++import { stepStatus } from '../../types';
+++import { getMainLogger } from '@/main/lib/logger';
+++import { normalizeUnknownError, internalError } from '@/main/lib/error';
+++import { ReviewChatResearchAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+++import {
+++  createRuntimeContext,
+++  judgeFinishReason,
+++  judgeErrorIsContentLengthError,
+++} from '@/mastra/lib/agentUtils';
+++import { getReviewRepository } from '@/adapter/db';
+++
+++const logger = getMainLogger();
+++
+++export const researchChunkStepInputSchema = z.object({
+++  reviewHistoryId: z.string(),
+++  documentId: z.string(),
+++  researchContent: z.string(),
+++  chunkContent: z.object({
+++    text: z.string().optional(),
+++    images: z.array(z.string()).optional(),
+++  }),
+++  chunkIndex: z.number(),
+++  totalChunks: z.number(),
+++  fileName: z.string(),
+++  checklistIds: z.array(z.number()),
+++  question: z.string(),
+++});
+++
+++const researchChunkStepOutputSchema = baseStepOutputSchema.extend({
+++  chunkResult: z.string().optional(),
+++  chunkIndex: z.number().optional(),
+++  finishReason: z.enum(['success', 'error', 'content_length']).optional(),
+++});
+++
+++export const researchChunkStep = createStep({
+++  id: 'researchChunkStep',
+++  description: 'チャンク単位でドキュメントを調査するステップ',
+++  inputSchema: researchChunkStepInputSchema,
+++  outputSchema: researchChunkStepOutputSchema,
+++  execute: async ({ inputData, bail, mastra, getInitData }) => {
+++    try {
+++      const {
+++        researchContent,
+++        chunkContent,
+++        chunkIndex,
+++        totalChunks,
+++        fileName,
+++        reviewHistoryId,
+++        checklistIds,
+++        question,
+++      } = inputData;
+++
+++      // チェックリスト情報を生成（planResearchStepと同じロジック）
+++      const reviewRepository = getReviewRepository();
+++      const checklistResults =
+++        await reviewRepository.getChecklistResultsWithIndividualResults(
+++          reviewHistoryId,
+++          checklistIds,
+++        );
+++
+++      const checklistInfo = checklistResults
+++        .map(
+++          (item: {
+++            checklistResult: {
+++              id: number;
+++              content: string;
+++              sourceEvaluation?: { evaluation?: string; comment?: string };
+++            };
+++            individualResults?: Array<{
+++              documentId: number;
+++              comment: string;
+++              individualFileName: string;
+++            }>;
+++          }) => {
+++            let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
+++            if (item.checklistResult.sourceEvaluation) {
+++              info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
+++            }
+++            if (item.individualResults && item.individualResults.length > 0) {
+++              info += `Individual Review Results:\n`;
+++              item.individualResults.forEach(
+++                (result: {
+++                  documentId: number;
+++                  comment: string;
+++                  individualFileName: string;
+++                }) => {
+++                  info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
+++                },
+++              );
+++            }
+++            return info;
+++          },
+++        )
+++        .join('\n---\n');
+++
+++      // RuntimeContext作成
+++      const runtimeContext =
+++        await createRuntimeContext<ReviewChatResearchAgentRuntimeContext>();
+++      runtimeContext.set('researchContent', researchContent);
+++      runtimeContext.set('totalChunks', totalChunks);
+++      runtimeContext.set('chunkIndex', chunkIndex);
+++      runtimeContext.set('fileName', fileName);
+++      runtimeContext.set('checklistInfo', checklistInfo);
+++      runtimeContext.set('userQuestion', question);
+++
+++      // メッセージを作成
+++      const messageContent = [];
+++
+++      if (chunkContent.text) {
+++        // テキストチャンクの場合
+++        messageContent.push({
+++          type: 'text' as const,
+++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nDocument Content:\n${chunkContent.text}`,
+++        });
+++      } else if (chunkContent.images && chunkContent.images.length > 0) {
+++        // 画像チャンクの場合
+++        messageContent.push({
+++          type: 'text' as const,
+++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nPlease analyze the following document images:`,
+++        });
+++
+++        chunkContent.images.forEach((imageBase64) => {
+++          messageContent.push({
+++            type: 'image' as const,
+++            image: imageBase64,
+++          });
+++        });
+++      }
+++
+++      // Mastraエージェント経由でAI呼び出し
+++      const researchAgent = mastra.getAgent('reviewChatResearchAgent');
+++      const result = await researchAgent.generate(
+++        {
+++          role: 'user',
+++          content: messageContent,
+++        },
+++        {
+++          runtimeContext,
+++        },
+++      );
+++
+++      const { success, reason } = judgeFinishReason(result.finishReason);
+++
+++      if (!success) {
+++        throw internalError({
+++          expose: true,
+++          messageCode: 'AI_API_ERROR',
+++          messageParams: { detail: reason },
+++        });
+++      }
+++
+++      return {
+++        status: 'success' as stepStatus,
+++        chunkIndex,
+++        chunkResult: result.text,
+++        finishReason: 'success' as const,
+++      };
+++    } catch (error) {
+++      // コンテキスト長エラーの場合は特別な処理
+++      if (judgeErrorIsContentLengthError(error)) {
+++        return {
+++          status: 'success' as stepStatus,
+++          chunkIndex: inputData.chunkIndex,
+++          finishReason: 'content_length' as const,
+++        };
+++      }
+++
+++      logger.error(error, 'チャンク調査に失敗しました');
+++      const normalizedError = normalizeUnknownError(error);
+++      return bail({
+++        status: 'failed' as stepStatus,
+++        errorMessage: normalizedError.message,
+++        finishReason: 'error' as const,
+++      });
+++    }
+++  },
+++});
++diff --git a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
++index 14ac3da86..e477a12a4 100644
++--- a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+++++ b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
++@@ -1,40 +1,46 @@
++-import { z } from "zod";
++-import { baseStepOutputSchema } from "../../schema";
+++import { z } from 'zod';
+++import { baseStepOutputSchema } from '../../schema';
++ // @ts-ignore
++-import { createStep } from "@mastra/core";
+++import { createStep } from '@mastra/core';
++ // @ts-ignore
++-import { MastraError } from "@mastra/core/error";
+++import { MastraError } from '@mastra/core/error';
++ import { NoObjectGeneratedError } from 'ai';
++-import { getReviewRepository } from "@/adapter/db";
++-import { extractAIAPISafeError, internalError, normalizeUnknownError } from "@/main/lib/error";
++-import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from ".";
++-import { stepStatus } from "../../types";
++-import { splitChecklistEquallyByMaxSize } from "../lib";
++-import { createRuntimeContext } from "@/mastra/lib/agentUtils";
++-import { ClassifyCategoryAgentRuntimeContext } from "@/mastra/agents/workflowAgents";
++-import { getMainLogger } from "@/main/lib/logger";
+++import { getReviewRepository } from '@/adapter/db';
+++import {
+++  extractAIAPISafeError,
+++  internalError,
+++  normalizeUnknownError,
+++} from '@/main/lib/error';
+++import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from '.';
+++import { stepStatus } from '../../types';
+++import { splitChecklistEquallyByMaxSize } from '../lib';
+++import { createRuntimeContext } from '@/mastra/lib/agentUtils';
+++import { ClassifyCategoryAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+++import { getMainLogger } from '@/main/lib/logger';
++ 
++ const logger = getMainLogger();
++ 
++ export const classifyChecklistsByCategoryInputSchema = z.object({
++-  reviewHistoryId: z.string().describe("レビュー履歴ID"),
+++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
++ });
++ 
++ // カテゴリ分類ステップの出力スキーマ
++-export const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
++-  categories: z
++-    .array(
++-      z.object({
++-        name: z.string(),
++-        checklists: z.array(
++-          z.object({
++-            id: z.number(),
++-            content: z.string().describe('チェックリストの内容'),
++-          }),
++-        ),
++-      }),
++-    ).optional(),
++-});
+++export const classifyChecklistsByCategoryOutputSchema =
+++  baseStepOutputSchema.extend({
+++    categories: z
+++      .array(
+++        z.object({
+++          name: z.string(),
+++          checklists: z.array(
+++            z.object({
+++              id: z.number(),
+++              content: z.string().describe('チェックリストの内容'),
+++            }),
+++          ),
+++        }),
+++      )
+++      .optional(),
+++  });
++ 
++ export const classifyChecklistsByCategoryStep = createStep({
++   id: 'classifyChecklistsByCategoryStep',
++diff --git a/src/mastra/workflows/sourceReview/executeReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/index.ts
++index 0972e2670..67e557283 100644
++--- a/src/mastra/workflows/sourceReview/executeReview/index.ts
+++++ b/src/mastra/workflows/sourceReview/executeReview/index.ts
++@@ -9,6 +9,7 @@ import { classifyChecklistsByCategoryStep } from './classifyChecklistStep';
++ import { smallDocumentReviewExecutionStep } from './smallDocumentReviewStep';
++ import { largeDocumentReviewWorkflow } from './largeDocumentReview';
++ import { extractedDocumentSchema, uploadedFileSchema } from './schema';
+++import { getReviewRepository } from '@/adapter/db';
++ 
++ const logger = getMainLogger();
++ 
++@@ -54,6 +55,7 @@ export const executeReviewWorkflowInputSchema = z.object({
++ export const executeReviewWorkflowOutputSchema = baseStepOutputSchema;
++ 
++ export const documentReviewExecutionInputSchema = z.object({
+++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
++   additionalInstructions: z
++     .string()
++     .optional()
++@@ -143,8 +145,46 @@ export const executeReviewWorkflow = createWorkflow({
++       typeof executeReviewWorkflowInputSchema
++     >;
++ 
+++    // 既存のレビュー結果を全て削除
+++    const reviewRepository = getReviewRepository();
+++    await reviewRepository.deleteAllReviewResults(initData.reviewHistoryId);
+++
+++    // documentModeを保存
+++    await reviewRepository.updateReviewHistoryDocumentMode(
+++      initData.reviewHistoryId,
+++      initData.documentMode,
+++    );
+++
+++    // ドキュメントキャッシュを保存
+++    for (const document of textExtractionResult.extractedDocuments || []) {
+++      if (!document) continue;
+++      const savedCache = await reviewRepository.createReviewDocumentCache({
+++        reviewHistoryId: initData.reviewHistoryId,
+++        documentId: document.id || '',
+++        fileName: document.name || '',
+++        processMode: document.processMode || 'text',
+++        textContent: document.textContent,
+++        imageData: document.imageData,
+++      });
+++      // キャッシュIDを付与
+++      document.cacheId = savedCache.id;
+++    }
+++
+++    // レビュー対象の統合ドキュメント名を保存
+++    const targetDocumentName = (textExtractionResult.extractedDocuments || [])
+++      .map((doc) => doc?.name || '')
+++      .filter((name) => name)
+++      .join('/');
+++    if (targetDocumentName) {
+++      await reviewRepository.updateReviewHistoryTargetDocumentName(
+++        initData.reviewHistoryId,
+++        targetDocumentName,
+++      );
+++    }
+++
++     return classifyChecklistsResult.categories!.map((category) => {
++       return {
+++        reviewHistoryId: initData.reviewHistoryId,
++         documents: textExtractionResult.extractedDocuments!,
++         checklists: category.checklists,
++         additionalInstructions: initData.additionalInstructions,
+ diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+-index 60120af8d..cafb8793c 100644
++index cafb8793c..e1187dce7 100644
+ --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+ +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+-@@ -198,9 +198,13 @@ Please provide a consolidated review that synthesizes all individual document re
+-           const idsHash = createHash('md5')
+-             .update(combinedFileIds)
+-             .digest('hex');
+--          const combinedFileNames = documentsWithReviewResults
+--            .map((f) => f.name)
+--            .join('/');
+-+          const combinedFileNames = [
+-+            ...new Set(
+-+              documentsWithReviewResults.map(
+-+                (f) => f.originalName || f.name,
+-+              ),
+-+            ),
+-+          ].join('/');
++@@ -87,7 +87,10 @@ export const consolidateReviewStep = createStep({
++       // 個別レビュー結果を整理
++       const consolidatedInput = documentsWithReviewResults.map((docResult) => {
++         return {
++-          originalName: docResult?.originalName || docResult?.name || `Document ${docResult.id}`,
+++          originalName:
+++            docResult?.originalName ||
+++            docResult?.name ||
+++            `Document ${docResult.id}`,
++           documentName: docResult?.name || `Document ${docResult.id}`,
++           reviewResults: docResult.reviewResults,
++         };
++@@ -102,7 +105,7 @@ export const consolidateReviewStep = createStep({
++             text: `Please consolidate the following individual document review results into a comprehensive final review.
++ 
++ ## Document Set Information:
++-Original Files: ${[...new Set(consolidatedInput.map(doc => doc.originalName))].join(', ')}
+++Original Files: ${[...new Set(consolidatedInput.map((doc) => doc.originalName))].join(', ')}
++ 
++ ## Individual Document Review Results:
++ ${consolidatedInput
++@@ -187,32 +190,16 @@ Please provide a consolidated review that synthesizes all individual document re
++           });
++         }
+  
++-        // 統合レビュー結果をDBに保存（複数ファイルの情報を統合）
+++        // 統合レビュー結果をDBに保存
++         if (
++           consolidatedResult.object &&
++           Array.isArray(consolidatedResult.object)
++         ) {
++-          const combinedFileIds = documentsWithReviewResults
++-            .map((f) => f.id)
++-            .join('/');
++-          const idsHash = createHash('md5')
++-            .update(combinedFileIds)
++-            .digest('hex');
++-          const combinedFileNames = [
++-            ...new Set(
++-              documentsWithReviewResults.map(
++-                (f) => f.originalName || f.name,
++-              ),
++-            ),
++-          ].join('/');
++-
+            await reviewRepository.upsertReviewResult(
+              consolidatedResult.object.map((result) => ({
++               reviewChecklistId: result.checklistId,
++               evaluation: result.evaluation as ReviewEvaluation,
++               comment: result.comment,
++-              fileId: idsHash,
++-              fileName: combinedFileNames,
++             })),
++           );
++         }
+ diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+-index 3e9bea206..c6f8371b8 100644
++index c6f8371b8..b72315a84 100644
+ --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+ +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+-@@ -108,7 +108,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+-           }
+-           return {
+-             originalDocument: initData.originalDocument,
+--            reviewInput: [],
+-+            reviewInput: initData.reviewInput,
+-             retryCount: nextRetryCount,
+-             status: isFailed
+-               ? ('failed' as stepStatus)
+-@@ -124,7 +124,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+-         if (initData.retryCount >= 5) {
+-           return {
+-             originalDocument: initData.originalDocument,
+--            reviewInput: [],
+-+            reviewInput: initData.reviewInput,
+-             retryCount: nextRetryCount,
+-             status: 'failed' as stepStatus,
+-             errorMessage:
+-@@ -155,6 +155,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
++@@ -155,8 +155,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
+                  ...initData.originalDocument,
+                  id: `${initData.originalDocument.id}_part${index + 1}`,
+                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
+-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+++                originalName:
+++                  initData.originalDocument.originalName ||
+++                  initData.originalDocument.name,
+                  textContent: chunk,
+++                totalChunks: splitCount,
+++                chunkIndex: index,
+                },
+              })),
+-@@ -181,6 +182,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
++             retryCount: nextRetryCount,
++@@ -182,8 +186,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
+                  ...initData.originalDocument,
+                  id: `${initData.originalDocument.id}_part${index + 1}`,
+                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
+-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+++                originalName:
+++                  initData.originalDocument.originalName ||
+++                  initData.originalDocument.name,
+                  imageData: chunk,
+++                totalChunks: splitCount,
+++                chunkIndex: index,
+                },
+              })),
+-@@ -227,6 +229,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
++             retryCount: nextRetryCount,
++@@ -251,9 +259,12 @@ export const largeDocumentReviewWorkflow = createWorkflow({
++     return inputData.documents.map(
++       (document) =>
++         ({
+++          reviewHistoryId: inputData.reviewHistoryId,
++           document: {
++             ...document,
++             originalName: document.name, // 分割された場合に元の名前を保持するため
+++            totalChunks: 1,
+++            chunkIndex: 0,
++           },
++           checklists: inputData.checklists,
++           additionalInstructions: inputData.additionalInstructions,
++diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
++index 4416735c4..f8602fc3d 100644
++--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+++++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
++@@ -15,13 +15,17 @@ import { getMainLogger } from '@/main/lib/logger';
++ import { createCombinedMessageFromExtractedDocument } from '../../lib';
++ import { getChecklistsErrorMessage } from '../lib';
++ import { extractedDocumentSchema } from '../schema';
+++import { getReviewRepository } from '@/adapter/db';
++ 
++ const logger = getMainLogger();
++ 
++ // 個別ドキュメントレビューステップの入力スキーマ
++ export const individualDocumentReviewStepInputSchema = z.object({
+++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
++   document: extractedDocumentSchema.extend({
++     originalName: z.string(),
+++    totalChunks: z.number().optional(), // ドキュメント分割総数
+++    chunkIndex: z.number().optional(), // 何番目のチャンクか（0から始まる）
++   }),
++   // チェックリスト
++   checklists: z.array(
++@@ -189,6 +193,20 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
++       }
++ 
++       // 全てのレビューが成功した場合
+++
+++      // 個別レビュー結果を保存
+++      const reviewRepository = getReviewRepository();
+++      for (const result of allReviewResults) {
+++        await reviewRepository.createReviewLargedocumentResultCache({
+++          reviewDocumentCacheId: document.cacheId!,
+++          reviewChecklistId: result.checklistId,
+++          comment: result.comment,
+++          totalChunks: document.totalChunks ?? 1,
+++          chunkIndex: document.chunkIndex ?? 0,
+++          individualFileName: document.name,
+++        });
+++      }
+++
++       return {
++         status: 'success' as stepStatus,
++         documentId: document.id,
++diff --git a/src/mastra/workflows/sourceReview/executeReview/lib.ts b/src/mastra/workflows/sourceReview/executeReview/lib.ts
++index b4bde036c..3f303042b 100644
++--- a/src/mastra/workflows/sourceReview/executeReview/lib.ts
+++++ b/src/mastra/workflows/sourceReview/executeReview/lib.ts
++@@ -1,7 +1,15 @@
++-export const getChecklistErrorMesssage = (checklist: { id: number; content: string }, errorMessage: string) => {
+++export const getChecklistErrorMesssage = (
+++  checklist: { id: number; content: string },
+++  errorMessage: string,
+++) => {
++   return `・${checklist.content}:${errorMessage}`;
++ };
++ 
++-export const getChecklistsErrorMessage = (checklists: { id: number; content: string }[], errorMessage: string) => {
++-  return checklists.map((checklist) => getChecklistErrorMesssage(checklist, errorMessage)).join('\n');
++-}
+++export const getChecklistsErrorMessage = (
+++  checklists: { id: number; content: string }[],
+++  errorMessage: string,
+++) => {
+++  return checklists
+++    .map((checklist) => getChecklistErrorMesssage(checklist, errorMessage))
+++    .join('\n');
+++};
++diff --git a/src/mastra/workflows/sourceReview/executeReview/schema.ts b/src/mastra/workflows/sourceReview/executeReview/schema.ts
++index 18b138b5d..e663cbe5a 100644
++--- a/src/mastra/workflows/sourceReview/executeReview/schema.ts
+++++ b/src/mastra/workflows/sourceReview/executeReview/schema.ts
++@@ -12,6 +12,7 @@ export const uploadedFileSchema = z.object({
++ 
++ export const extractedDocumentSchema = z.object({
++   id: z.string(),
+++  cacheId: z.number().optional(),
++   name: z.string(),
++   path: z.string(),
++   type: z.string(),
++diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
++index 33bc9e881..0b1e0746a 100644
++--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
++@@ -133,20 +133,13 @@ Please review the document against the above checklist items.`;
++             messageParams: { detail: reason },
++           });
++         }
++-        // レビュー結果をDBに保存（複数ファイルの情報を統合）
+++        // レビュー結果をDBに保存
++         if (reviewResult.object && Array.isArray(reviewResult.object)) {
++-          const combinedFileIds = documents.map((f) => f.id).join('/');
++-          const idsHash = createHash('md5')
++-            .update(combinedFileIds)
++-            .digest('hex');
++-          const combinedFileNames = documents.map((f) => f.name).join('/');
++           await reviewRepository.upsertReviewResult(
++             reviewResult.object.map((result) => ({
++               reviewChecklistId: result.checklistId,
++               evaluation: result.evaluation as ReviewEvaluation,
++               comment: result.comment,
++-              fileId: idsHash,
++-              fileName: combinedFileNames,
++             })),
++           );
++         }
++@@ -169,7 +162,10 @@ Please review the document against the above checklist items.`;
++         // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
++         return bail({
++           status: 'failed' as stepStatus,
++-          errorMessage: getChecklistsErrorMessage(targetChecklists, 'AIの出力にレビュー結果が含まれませんでした'),
+++          errorMessage: getChecklistsErrorMessage(
+++            targetChecklists,
+++            'AIの出力にレビュー結果が含まれませんでした',
+++          ),
++         });
++       }
++       // 全てのレビューが成功した場合
++diff --git a/src/mastra/workflows/sourceReview/lib.ts b/src/mastra/workflows/sourceReview/lib.ts
++index 4eed29a81..9518de038 100644
++--- a/src/mastra/workflows/sourceReview/lib.ts
+++++ b/src/mastra/workflows/sourceReview/lib.ts
++@@ -122,7 +122,9 @@ export async function createCombinedMessage(
++       }
++     } else {
++       // テキスト抽出処理
++-      const { content: fileContent } = await FileExtractor.extractText(file.path);
+++      const { content: fileContent } = await FileExtractor.extractText(
+++        file.path,
+++      );
++ 
++       // ファイルごとに個別のcontent要素として追加
++       content.push({
++@@ -181,7 +183,11 @@ export function createCombinedMessageFromExtractedDocument(
++     if (document.imageData && document.imageData.length > 0) {
++       // 各ページごとに個別の説明と画像を追加
++       const totalPages = document.imageData.length;
++-      for (let pageIndex = 0; pageIndex < document.imageData.length; pageIndex++) {
+++      for (
+++        let pageIndex = 0;
+++        pageIndex < document.imageData.length;
+++        pageIndex++
+++      ) {
++         const currentPage = pageIndex + 1;
++ 
++         // ページ番号を含むテキスト説明を追加
++diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
++index 9af029444..aec3ea97f 100644
++--- a/src/messages/ja/template.ts
+++++ b/src/messages/ja/template.ts
++@@ -33,4 +33,5 @@ export const template = {
++   REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR: `CSVファイルからのチェックリスト抽出中に予期せぬエラーが発生しました`,
++   AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
++   AI_MESSAGE_TOO_LARGE: `AIへの入力データが大きすぎます。入力データを減らしてください。`,
+++  REVIEW_DOCUMENT_CACHE_NOT_FOUND: `レビュー時にアップロードしたドキュメント情報が失われています。レビューを再実行してください`,
++ } as const;
++diff --git a/src/renderer/components/chat/MessageItem.tsx b/src/renderer/components/chat/MessageItem.tsx
++index 4a8877c44..5345514e0 100644
++--- a/src/renderer/components/chat/MessageItem.tsx
+++++ b/src/renderer/components/chat/MessageItem.tsx
++@@ -313,7 +313,8 @@ const renderPart = (
++         <Accordion sx={{ width: '100%' }} key={ti.toolCallId}>
++           <AccordionSummary expandIcon={<ExpandMoreIcon />}>
++             <Box sx={{ display: 'flex', alignItems: 'center' }}>
++-              {ti.toolName === 'documentQueryTool' ? (
+++              {ti.toolName === 'documentQueryTool' ||
+++              ti.toolCallId.startsWith('reviewChatResearchDocument-') ? (
++                 <SearchIcon sx={{ mr: 1 }} />
++               ) : (
++                 <SmartToyOutlinedIcon sx={{ mr: 1 }} />
++@@ -387,6 +388,7 @@ interface MessageProps {
++   onEditStart: (messageId: string) => void;
++   onEditContentChange: (content: string) => void;
++   onEditCancel: () => void;
+++  disableEdit?: boolean;
++ }
++ 
++ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++@@ -400,6 +402,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++       onEditStart,
++       onEditCancel,
++       onEditContentChange,
+++      disableEdit = false,
++     },
++     ref,
++   ) => {
++@@ -420,7 +423,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++               maxWidth: isUser && !isEditing ? '70%' : '100%',
++               width: isUser && !isEditing ? undefined : '100%',
++               textAlign: 'left',
++-              '&:hover .editBtn': { opacity: 1 },
+++              ...(!disableEdit && { '&:hover .editBtn': { opacity: 1 } }),
++             }}
++           >
++             <Paper
++@@ -432,28 +435,31 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
++                 position: 'relative',
++               }}
++             >
++-              {isUser && !message.experimental_attachments && !isEditing && (
++-                <IconButton
++-                  className="editBtn"
++-                  size="small"
++-                  onClick={() => {
++-                    onEditStart?.(message.id);
++-                    onEditContentChange(message.content ?? '');
++-                  }}
++-                  sx={{
++-                    position: 'absolute',
++-                    right: -36,
++-                    top: '50%',
++-                    transform: 'translateY(-50%)',
++-                    opacity: 0,
++-                    transition: 'opacity 0.2s',
++-                    bgcolor: 'background.paper',
++-                  }}
++-                  data-testid={`edit-message-button-${message.id}`}
++-                >
++-                  <EditIcon fontSize="small" />
++-                </IconButton>
++-              )}
+++              {isUser &&
+++                !message.experimental_attachments &&
+++                !isEditing &&
+++                !disableEdit && (
+++                  <IconButton
+++                    className="editBtn"
+++                    size="small"
+++                    onClick={() => {
+++                      onEditStart?.(message.id);
+++                      onEditContentChange(message.content ?? '');
+++                    }}
+++                    sx={{
+++                      position: 'absolute',
+++                      right: -36,
+++                      top: '50%',
+++                      transform: 'translateY(-50%)',
+++                      opacity: 0,
+++                      transition: 'opacity 0.2s',
+++                      bgcolor: 'background.paper',
+++                    }}
+++                    data-testid={`edit-message-button-${message.id}`}
+++                  >
+++                    <EditIcon fontSize="small" />
+++                  </IconButton>
+++                )}
++               {/* eslint-disable-next-line */}
++               {isEditing && !message.experimental_attachments && isUser ? (
++                 <Box sx={{ p: 1, width: '100%' }}>
++diff --git a/src/renderer/components/chat/MessageList.tsx b/src/renderer/components/chat/MessageList.tsx
++index e8325677a..321206563 100644
++--- a/src/renderer/components/chat/MessageList.tsx
+++++ b/src/renderer/components/chat/MessageList.tsx
++@@ -14,6 +14,8 @@ interface MessageListProps {
++   onEditSubmit: () => void;
++   onEditContentChange: (ontent: string) => void;
++   onEditCancel: () => void;
+++  loadingMessage?: string;
+++  disableEdit?: boolean;
++ }
++ 
++ const MessageList: React.FC<MessageListProps> = ({
++@@ -27,6 +29,8 @@ const MessageList: React.FC<MessageListProps> = ({
++   onEditSubmit,
++   onEditContentChange,
++   onEditCancel,
+++  loadingMessage = 'AIKATA作業中…',
+++  disableEdit = false,
++ }) => {
++   const bottomRef = useRef<HTMLDivElement>(null);
++ 
++@@ -64,12 +68,13 @@ const MessageList: React.FC<MessageListProps> = ({
++               onEditSubmit={onEditSubmit}
++               onEditContentChange={onEditContentChange}
++               onEditCancel={onEditCancel}
+++              disableEdit={disableEdit}
++             />
++           </Box>
+          );
+-         return {
+-           ...input.document,
+-+          originalName: input.document.originalName || input.document.name,
+-           reviewResults: reviewResult || [],
+-         };
+-       }),
++       })}
++ 
++-      {status === 'streaming' && (
+++      {(status === 'streaming' || status === 'submitted') && (
++         <Box
++           sx={{
++             display: 'flex',
++@@ -80,7 +85,7 @@ const MessageList: React.FC<MessageListProps> = ({
++         >
++           <CircularProgress size={24} />
++           <Box component="span" sx={{ ml: 1 }}>
++-            AIKATA作業中…
+++            {loadingMessage}
++           </Box>
++         </Box>
++       )}
++diff --git a/src/renderer/components/common/SettingsModal.tsx b/src/renderer/components/common/SettingsModal.tsx
++index c5b8d8a92..335ef9d7a 100644
++--- a/src/renderer/components/common/SettingsModal.tsx
+++++ b/src/renderer/components/common/SettingsModal.tsx
++@@ -10,7 +10,7 @@ import {
++ } from '@mui/material';
++ import Modal from './Modal';
++ import useSettingsStore from '../../hooks/useSettings';
++-import { StoreSchema as Settings } from '../../../main/store';
+++import { StoreSchema as Settings } from '../../../adapter/db/electron-store/store';
++ 
++ interface SettingsModalProps {
++   open: boolean;
++diff --git a/src/renderer/components/review/ChecklistMentionInput.tsx b/src/renderer/components/review/ChecklistMentionInput.tsx
++new file mode 100644
++index 000000000..978c8d7be
++--- /dev/null
+++++ b/src/renderer/components/review/ChecklistMentionInput.tsx
++@@ -0,0 +1,364 @@
+++import React, { useState, useCallback, useMemo, useRef } from 'react';
+++import {
+++  Box,
+++  IconButton,
+++  InputAdornment,
+++  Paper,
+++  TextField,
+++  Chip,
+++  Popover,
+++  List,
+++  ListItem,
+++  ListItemButton,
+++  ListItemText,
+++} from '@mui/material';
+++import {
+++  Send as SendIcon,
+++  StopCircleOutlined as StopIcon,
+++} from '@mui/icons-material';
+++import { useAlertStore } from '@/renderer/stores/alertStore';
+++
+++/* ---------- 型定義 ---------- */
+++
+++export interface ChecklistOption {
+++  id: number;
+++  content: string;
+++}
+++
+++interface ChecklistMentionInputProps {
+++  handleSubmit: (e: React.FormEvent) => void;
+++  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
+++  message: string;
+++  disabled?: boolean;
+++  placeholder?: string;
+++  isStreaming?: boolean;
+++  onStop?: () => void;
+++  checklists: ChecklistOption[];
+++  selectedChecklistIds: number[];
+++  onChecklistSelect: (ids: number[]) => void;
+++}
+++
+++const ChecklistMentionInput: React.FC<ChecklistMentionInputProps> = ({
+++  handleSubmit,
+++  handleInputChange,
+++  message,
+++  disabled = false,
+++  placeholder = 'メッセージを入力...',
+++  isStreaming = false,
+++  onStop,
+++  checklists,
+++  selectedChecklistIds,
+++  onChecklistSelect,
+++}) => {
+++  const [isComposing, setIsComposing] = useState(false);
+++  const [showMentionMenu, setShowMentionMenu] = useState(false);
+++  const [mentionSearchText, setMentionSearchText] = useState('');
+++  const inputRef = useRef<HTMLDivElement>(null);
+++  const addAlert = useAlertStore((state) => state.addAlert);
+++
+++  /* ---------- チェックリストオプション ---------- */
+++  const checklistOptions = useMemo(() => {
+++    return checklists.map((cl) => ({ id: cl.id, content: cl.content }));
+++  }, [checklists]);
+++
+++  /* ---------- フィルタリングされたチェックリストオプション ---------- */
+++  const filteredOptions = useMemo(() => {
+++    if (!mentionSearchText) return checklistOptions;
+++    const lowerSearch = mentionSearchText.toLowerCase();
+++    return checklistOptions.filter((option) =>
+++      option.content.toLowerCase().includes(lowerSearch),
+++    );
+++  }, [checklistOptions, mentionSearchText]);
+++
+++  /* ---------- @メンション検出 ---------- */
+++  const detectMention = useCallback((text: string) => {
+++    const atIndex = text.lastIndexOf('@');
+++    if (atIndex === -1) return null;
+++
+++    // @が行の先頭にあるかチェック
+++    if (atIndex > 0) {
+++      const beforeAt = text[atIndex - 1];
+++      // @の直前が改行でない場合はnullを返す
+++      if (beforeAt !== '\n') return null;
+++    }
+++
+++    // @以降の文字列を取得
+++    const afterAt = text.slice(atIndex + 1);
+++    // 空白や改行があれば@メンション終了とみなす
+++    if (/\s/.test(afterAt)) return null;
+++
+++    return { atIndex, searchText: afterAt };
+++  }, []);
+++
+++  /* ---------- 入力変更ハンドラ ---------- */
+++  const handleChange = useCallback(
+++    (e: React.ChangeEvent<HTMLInputElement>) => {
+++      const newValue = e.target.value;
+++      handleInputChange(e);
+++
+++      // @メンション検出
+++      const mention = detectMention(newValue);
+++      if (mention) {
+++        setShowMentionMenu(true);
+++        setMentionSearchText(mention.searchText);
+++      } else {
+++        setShowMentionMenu(false);
+++        setMentionSearchText('');
+++      }
+++    },
+++    [handleInputChange, detectMention],
+++  );
+++
+++  /* ---------- チェックリスト選択ハンドラ ---------- */
+++  const handleChecklistSelect = useCallback(
+++    (checklist: ChecklistOption | null) => {
+++      if (!checklist) return;
+++
+++      const mention = detectMention(message);
+++      if (!mention) return;
+++
+++      // @検索文字列を削除
+++      const beforeAt = message.slice(0, mention.atIndex);
+++      const afterMention = message.slice(
+++        mention.atIndex + 1 + mention.searchText.length,
+++      );
+++      const newMessage = beforeAt + afterMention;
+++
+++      // 入力値を更新
+++      const syntheticEvent = {
+++        target: { value: newMessage },
+++      } as React.ChangeEvent<HTMLInputElement>;
+++      handleInputChange(syntheticEvent);
+++
+++      // 選択リストに追加（重複チェック）
+++      if (!selectedChecklistIds.includes(checklist.id)) {
+++        onChecklistSelect([...selectedChecklistIds, checklist.id]);
+++      }
+++
+++      // メニューを閉じる
+++      setShowMentionMenu(false);
+++      setMentionSearchText('');
+++    },
+++    [
+++      message,
+++      detectMention,
+++      handleInputChange,
+++      selectedChecklistIds,
+++      onChecklistSelect,
+++    ],
+++  );
+++
+++  /* ---------- 送信ハンドラ（バリデーション付き） ---------- */
+++  const handleSubmitWithValidation = useCallback(
+++    (e: React.FormEvent) => {
+++      e.preventDefault();
+++
+++      // チェックリストが一つも選択されていない場合は警告
+++      if (selectedChecklistIds.length === 0) {
+++        addAlert({
+++          message: '@でチェックリストを一つ以上選択してください',
+++          severity: 'warning',
+++        });
+++        return;
+++      }
+++      handleSubmit(e);
+++    },
+++    [selectedChecklistIds, handleSubmit, addAlert],
+++  );
+++
+++  /* ---------- Enter キー送信（Shift+Enter で改行） ---------- */
+++  const handleKeyDown = (e: React.KeyboardEvent) => {
+++    if (e.key === 'Enter' && !isComposing) {
+++      // @メンションメニューが表示されている場合は完全一致をチェック
+++      if (showMentionMenu && mentionSearchText) {
+++        const exactMatch = filteredOptions.find(
+++          (option) =>
+++            option.content.toLowerCase() === mentionSearchText.toLowerCase(),
+++        );
+++        if (exactMatch) {
+++          // 完全一致した場合は自動選択
+++          e.preventDefault();
+++          handleChecklistSelect(exactMatch);
+++          return;
+++        }
+++      }
+++
+++      // Shift+Enterの場合は改行を許可（preventDefaultしない）
+++      if (!e.shiftKey) {
+++        e.preventDefault();
+++        handleSubmitWithValidation(e);
+++      }
+++    }
+++  };
+++
+++  /* ---------- IME 制御 ---------- */
+++  const handleCompositionStart = () => setIsComposing(true);
+++  const handleCompositionEnd = () => setIsComposing(false);
+++
+++  /* ============================================================= */
+++
+++  return (
+++    <Box sx={{ p: 2, width: '100%', mx: 'auto' }}>
+++      {/* 選択中のチェックリスト表示 */}
+++      {selectedChecklistIds.length > 0 && (
+++        <Box
+++          sx={{
+++            mb: 1,
+++            display: 'flex',
+++            flexDirection: 'column',
+++            alignItems: 'flex-start',
+++            gap: 0.5,
+++            overflow: 'auto',
+++            maxHeight: 100,
+++            pb: 0.5,
+++          }}
+++        >
+++          {selectedChecklistIds.map((id) => {
+++            const checklist = checklists.find((cl) => cl.id === id);
+++            if (!checklist) return null;
+++            return (
+++              <Chip
+++                key={id}
+++                label={checklist.content}
+++                size="small"
+++                color="primary"
+++                variant="outlined"
+++                onDelete={() => {
+++                  onChecklistSelect(
+++                    selectedChecklistIds.filter((cid) => cid !== id),
+++                  );
+++                }}
+++              />
+++            );
+++          })}
+++        </Box>
+++      )}
+++
+++      {/* 入力欄 ----------------------------------------------------------- */}
+++      <Paper
+++        component="form"
+++        onSubmit={handleSubmitWithValidation}
+++        elevation={3}
+++        sx={{
+++          p: '2px 4px',
+++          display: 'flex',
+++          alignItems: 'center',
+++          borderRadius: 2,
+++          position: 'relative',
+++        }}
+++      >
+++        {/* メインのテキストフィールド */}
+++        <TextField
+++          ref={inputRef}
+++          fullWidth
+++          multiline
+++          minRows={1}
+++          maxRows={6}
+++          placeholder={placeholder}
+++          variant="outlined"
+++          value={message}
+++          onChange={handleChange}
+++          onKeyDown={handleKeyDown}
+++          onCompositionStart={handleCompositionStart}
+++          onCompositionEnd={handleCompositionEnd}
+++          disabled={disabled}
+++          slotProps={{
+++            input: {
+++              sx: {
+++                p: 1,
+++                '& fieldset': { border: 'none' },
+++              },
+++              endAdornment: (
+++                <InputAdornment position="end">
+++                  {isStreaming ? (
+++                    <IconButton
+++                      color="primary"
+++                      onClick={onStop}
+++                      data-testid="review-chat-stop-button"
+++                    >
+++                      <StopIcon />
+++                    </IconButton>
+++                  ) : (
+++                    <IconButton
+++                      color="primary"
+++                      type="submit"
+++                      disabled={disabled || !message.trim()}
+++                      data-testid="review-chat-send-button"
+++                    >
+++                      <SendIcon />
+++                    </IconButton>
+++                  )}
+++                </InputAdornment>
+++              ),
+++            },
+++          }}
+++        />
+++
+++        {/* @メンション選択メニュー */}
+++        <Popover
+++          open={showMentionMenu}
+++          anchorEl={inputRef.current}
+++          onClose={() => {
+++            setShowMentionMenu(false);
+++            setMentionSearchText('');
+++          }}
+++          anchorOrigin={{
+++            vertical: 'top',
+++            horizontal: 'left',
+++          }}
+++          transformOrigin={{
+++            vertical: 'bottom',
+++            horizontal: 'left',
+++          }}
+++          disableAutoFocus
+++          disableEnforceFocus
+++          disableRestoreFocus
+++          slotProps={{
+++            paper: {
+++              sx: {
+++                maxHeight: 200,
+++                width: inputRef.current?.offsetWidth || 300,
+++                overflow: 'auto',
+++              },
+++            },
+++          }}
+++        >
+++          <List dense>
+++            {filteredOptions.length > 0 ? (
+++              filteredOptions.map((option) => (
+++                <ListItem key={option.id} disablePadding>
+++                  <ListItemButton
+++                    onClick={() => handleChecklistSelect(option)}
+++                    selected={selectedChecklistIds.includes(option.id)}
+++                  >
+++                    <ListItemText
+++                      primary={`@${option.content}`}
+++                      primaryTypographyProps={{
+++                        sx: {
+++                          fontWeight:
+++                            option.content.toLowerCase() ===
+++                            mentionSearchText.toLowerCase()
+++                              ? 'bold'
+++                              : 'normal',
+++                        },
+++                      }}
+++                    />
+++                  </ListItemButton>
+++                </ListItem>
+++              ))
+++            ) : (
+++              <ListItem>
+++                <ListItemText
+++                  primary="該当するチェックリストがありません"
+++                  sx={{ color: 'text.secondary', fontStyle: 'italic' }}
+++                />
+++              </ListItem>
+++            )}
+++          </List>
+++        </Popover>
+++      </Paper>
+++    </Box>
+++  );
+++};
+++
+++export default ChecklistMentionInput;
++diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
++index 2d2322987..d75832619 100644
++--- a/src/renderer/components/review/ReviewArea.tsx
+++++ b/src/renderer/components/review/ReviewArea.tsx
++@@ -6,11 +6,11 @@ import {
++   Stack,
++   Typography,
++   LinearProgress,
++-  Alert,
++ } from '@mui/material';
++ import CheckBoxIcon from '@mui/icons-material/CheckBox';
++ import RateReviewIcon from '@mui/icons-material/RateReview';
++ import StopIcon from '@mui/icons-material/Stop';
+++import ChatIcon from '@mui/icons-material/Chat';
++ import {
++   ReviewChecklistEdit,
++   ReviewChecklistResult,
++@@ -25,6 +25,7 @@ import {
++ import { ReviewAreaProps } from './types';
++ import ReviewChecklistSection from './ReviewChecklistSection';
++ import ReviewSourceModal from './ReviewSourceModal';
+++import ReviewChatPanel from './ReviewChatPanel';
++ import { ReviewApi } from '../../service/reviewApi';
++ import { useAlertStore } from '../../stores/alertStore';
++ import { getSafeErrorMessage } from '../../lib/error';
++@@ -47,6 +48,9 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++   const [checklistResults, setChecklistResults] = useState<
++     ReviewChecklistResult[]
++   >([]);
+++  const [targetDocumentName, setTargetDocumentName] = useState<string | null>(
+++    null,
+++  );
++   // チェックリスト更新処理中であるかどうか
++   const [isSaving, setIsSaving] = useState(false);
++   const [isExtracting, setIsExtracting] = useState(false);
++@@ -58,6 +62,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++   const [evaluationSettings, setEvaluationSettings] =
++     useState<CustomEvaluationSettings>(defaultEvaluationSettings);
++ 
+++  // チャット関連の状態管理
+++  const [chatPanelOpen, setChatPanelOpen] = useState(false);
+++  const [chatPanelWidth, setChatPanelWidth] = useState(500);
+++  const [isResizing, setIsResizing] = useState(false);
+++
++   const addAlert = useAlertStore((state) => state.addAlert);
++ 
++   // イベント購読の解除関数を管理
++@@ -73,6 +82,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++       { throwError: true, showAlert: true },
++     );
++     setChecklistResults(result?.checklistResults || []);
+++    setTargetDocumentName(result?.targetDocumentName || null);
++   }, [selectedReviewHistoryId]);
++ 
++   // チェックリスト抽出完了の共通処理ハンドラー
++@@ -526,6 +536,38 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++     setIsSaving(false);
++   };
++ 
+++  // リサイズハンドラ
+++  const handleMouseDown = (e: React.MouseEvent) => {
+++    setIsResizing(true);
+++    e.preventDefault();
+++  };
+++
+++  useEffect(() => {
+++    if (!isResizing) return;
+++
+++    const handleMouseMove = (e: MouseEvent) => {
+++      // 画面右端からのマウス位置を計算
+++      const newWidth = window.innerWidth - e.clientX;
+++      // 最小幅350px、最大幅は画面の65%まで
+++      const minWidth = 350;
+++      const maxWidth = window.innerWidth * 0.65;
+++      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
+++      setChatPanelWidth(clampedWidth);
+++    };
+++
+++    const handleMouseUp = () => {
+++      setIsResizing(false);
+++    };
+++
+++    document.addEventListener('mousemove', handleMouseMove);
+++    document.addEventListener('mouseup', handleMouseUp);
+++
+++    return () => {
+++      document.removeEventListener('mousemove', handleMouseMove);
+++      document.removeEventListener('mouseup', handleMouseUp);
+++    };
+++  }, [isResizing]);
+++
++   return (
++     <Box
++       sx={{
++@@ -548,15 +590,10 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++           {(isExtracting || isReviewing) && (
++             <Box sx={{ mb: 2 }}>
++               <LinearProgress />
++-              {/* <Alert severity="info" sx={{ mt: 1 }}>
++-                {isExtracting
++-                  ? 'チェックリスト抽出実行中...'
++-                  : 'レビュー実行中...'}
++-              </Alert> */}
++             </Box>
++           )}
++ 
++-          {/* ヘッダー部分 */}
+++          {/* ヘッダー部分 - 主要アクションボタン */}
++           <Stack
++             direction="row"
++             justifyContent="space-between"
++@@ -600,25 +637,85 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
++               >
++                 {isReviewing ? 'キャンセル' : 'レビュー実行'}
++               </Button>
+++              <Button
+++                variant="contained"
+++                color="primary"
+++                startIcon={<ChatIcon />}
+++                onClick={() => setChatPanelOpen(true)}
+++                disabled={
+++                  !selectedReviewHistoryId ||
+++                  isExtracting ||
+++                  isReviewing ||
+++                  checklistResults.filter((cl) => cl.sourceEvaluation?.comment)
+++                    .length === 0
+++                }
+++              >
+++                質問
+++              </Button>
++             </Stack>
++           </Stack>
++ 
++-          {/* メインコンテンツ */}
++-          <Paper
+++          {/* メインコンテンツ - Split View */}
+++          <Box
++             sx={{
++-              p: 2,
++-              flex: 1,
++               display: 'flex',
++-              flexDirection: 'column',
+++              flexDirection: 'row',
+++              flex: 1,
++               minHeight: 0,
+++              gap: 0,
++             }}
++           >
++-            <ReviewChecklistSection
++-              checklistResults={checklistResults}
++-              isLoading={isExtracting || isReviewing}
++-              onSave={handleSaveChecklist}
++-            />
++-          </Paper>
+++            {/* レビュー結果エリア */}
+++            <Paper
+++              sx={{
+++                p: 2,
+++                flex: 1,
+++                display: 'flex',
+++                flexDirection: 'column',
+++                minHeight: 0,
+++                minWidth: chatPanelOpen ? 400 : 0,
+++                overflow: 'hidden',
+++              }}
+++            >
+++              <ReviewChecklistSection
+++                checklistResults={checklistResults}
+++                isLoading={isExtracting || isReviewing}
+++                onSave={handleSaveChecklist}
+++                targetDocumentName={targetDocumentName}
+++              />
+++            </Paper>
+++
+++            {/* リサイズハンドル */}
+++            {chatPanelOpen && (
+++              <Box
+++                onMouseDown={handleMouseDown}
+++                sx={{
+++                  width: '6px',
+++                  cursor: 'col-resize',
+++                  bgcolor: 'divider',
+++                  transition: 'background-color 0.2s',
+++                  flexShrink: 0,
+++                  userSelect: 'none',
+++                }}
+++              />
+++            )}
+++
+++            {/* チャットパネル */}
+++            {selectedReviewHistoryId && (
+++              <ReviewChatPanel
+++                open={chatPanelOpen}
+++                onClose={() => setChatPanelOpen(false)}
+++                reviewHistoryId={selectedReviewHistoryId}
+++                checklists={checklistResults
+++                  .filter((cl) => cl.sourceEvaluation?.comment)
+++                  .map((cl) => ({
+++                    id: cl.id,
+++                    content: cl.content,
+++                  }))}
+++                width={chatPanelWidth}
+++              />
+++            )}
+++          </Box>
++ 
++           {/* モーダル */}
++           <ReviewSourceModal
++diff --git a/src/renderer/components/review/ReviewChatPanel.tsx b/src/renderer/components/review/ReviewChatPanel.tsx
++new file mode 100644
++index 000000000..525cfea7b
++--- /dev/null
+++++ b/src/renderer/components/review/ReviewChatPanel.tsx
++@@ -0,0 +1,265 @@
+++import React, { useState, useEffect, useCallback } from 'react';
+++import { useChat } from '@ai-sdk/react';
+++import { Box, Divider, IconButton } from '@mui/material';
+++import CloseIcon from '@mui/icons-material/Close';
+++import { v4 as uuid } from 'uuid';
+++import { ChatMessage } from '@/types';
+++import { IpcRequestPayload, IpcChannels } from '@/types/ipc';
+++import { useAlertStore } from '@/renderer/stores/alertStore';
+++import { getSafeErrorMessage } from '@/renderer/lib/error';
+++import MessageList from '../chat/MessageList';
+++import ChecklistMentionInput, {
+++  ChecklistOption,
+++} from './ChecklistMentionInput';
+++import { ReviewChatApi } from '../../service/reviewChatApi';
+++
+++interface ReviewChatPanelProps {
+++  open: boolean;
+++  onClose: () => void;
+++  reviewHistoryId: string;
+++  checklists: ChecklistOption[];
+++  width?: number;
+++}
+++
+++// customFetch関数 - ChatArea.tsxを参考に実装
+++const customFetch: typeof fetch = async (input, init) => {
+++  if (typeof input === 'string' && input === '/api/review-chat') {
+++    let unsubscribe: () => void;
+++    const encoder = new TextEncoder();
+++    const reviewChatApi = ReviewChatApi.getInstance();
+++
+++    const stream = new ReadableStream({
+++      start(controller) {
+++        unsubscribe = reviewChatApi.streamResponse({
+++          onMessage(raw) {
+++            controller.enqueue(encoder.encode(raw));
+++          },
+++          onDone() {
+++            controller.close();
+++          },
+++          onError(err) {
+++            controller.error(err);
+++          },
+++        });
+++
+++        const { reviewHistoryId, checklistIds, question } = JSON.parse(
+++          init!.body as string,
+++        ) as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
+++
+++        init?.signal?.addEventListener('abort', () => {
+++          reviewChatApi.abortChat(reviewHistoryId, {
+++            showAlert: false,
+++            throwError: true,
+++          });
+++          unsubscribe();
+++          controller.close();
+++        });
+++
+++        reviewChatApi.sendMessage(reviewHistoryId, checklistIds, question, {
+++          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
+++          showAlert: false,
+++          throwError: false,
+++        });
+++      },
+++      cancel() {
+++        unsubscribe();
+++      },
+++    });
+++
+++    return new Response(stream, {
+++      headers: {
+++        // SSE＋Data Stream Protocol ヘッダ
+++        'Content-Type': 'text/event-stream; charset=utf-8',
+++        'x-vercel-ai-data-stream': 'v1',
+++      },
+++    });
+++  }
+++
+++  return fetch(input, init);
+++};
+++
+++// プレースホルダーテキストを取得する関数
+++const getPlaceholderText = (status: string): string => {
+++  if (status === 'submitted') return 'メッセージ送信中…';
+++  return '@でチェックリストを選択して質問してください';
+++};
+++
+++const ReviewChatPanel: React.FC<ReviewChatPanelProps> = ({
+++  open,
+++  onClose,
+++  reviewHistoryId,
+++  checklists,
+++  width = 500,
+++}) => {
+++  const [input, setInput] = useState<string>('');
+++  const [selectedChecklistIds, setSelectedChecklistIds] = useState<number[]>(
+++    [],
+++  );
+++  const addAlert = useAlertStore((state) => state.addAlert);
+++
+++  const { messages, setMessages, reload, status, error, stop } = useChat({
+++    id: reviewHistoryId,
+++    api: '/api/review-chat',
+++    fetch: customFetch,
+++    experimental_throttle: 75,
+++    experimental_prepareRequestBody: (request) => {
+++      // Ensure messages array is not empty and get the last message
+++      const lastMessage =
+++        request.messages.length > 0
+++          ? request.messages[request.messages.length - 1]
+++          : null;
+++      if (!lastMessage) {
+++        throw new Error('送信メッセージの取得に失敗しました');
+++      }
+++
+++      // Return the structured body for API route
+++      return {
+++        reviewHistoryId,
+++        checklistIds: selectedChecklistIds,
+++        question: lastMessage.content,
+++      } as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
+++    },
+++    onError(err) {
+++      console.error('useChat error:', err);
+++    },
+++  });
+++
+++  // useChatのエラーをアラートとして表示
+++  useEffect(() => {
+++    if (error) {
+++      addAlert({
+++        message: getSafeErrorMessage(error),
+++        severity: 'error',
+++      });
+++    }
+++  }, [error, addAlert]);
+++
+++  // レビューID変更時にチャット内容を初期化
+++  useEffect(() => {
+++    setMessages([]);
+++    setInput('');
+++    setSelectedChecklistIds([]);
+++  }, [reviewHistoryId, setMessages]);
+++
+++  /* ---------- メッセージ送信処理 ---------- */
+++  const handleInputChange = useCallback(
+++    (e: React.ChangeEvent<HTMLInputElement>) => {
+++      setInput(e.target.value);
+++    },
+++    [],
+++  );
+++
+++  const handleSubmit = useCallback(
+++    async (e: React.FormEvent) => {
+++      e.preventDefault();
+++      if (!input.trim()) return;
+++
+++      // チェックリスト未選択の場合は警告
+++      if (selectedChecklistIds.length === 0) {
+++        addAlert({
+++          message: '@でチェックリストを選択してください',
+++          severity: 'warning',
+++        });
+++        return;
+++      }
+++
+++      // 選択されたチェックリストの内容を取得してフォーマット
+++      const selectedChecklistContents = selectedChecklistIds
+++        .map((id) => {
+++          const checklist = checklists.find((cl) => cl.id === id);
+++          return checklist ? `@${checklist.content}` : null;
+++        })
+++        .filter((content): content is string => content !== null);
+++
+++      // チェックリスト部分 + 空行 + 本文の形式でメッセージを構築
+++      const formattedContent =
+++        selectedChecklistContents.length > 0
+++          ? `${selectedChecklistContents.join('\n')}\n\n${input}`
+++          : input;
+++
+++      const newMessage: ChatMessage = {
+++        id: uuid(),
+++        role: 'user',
+++        content: formattedContent,
+++        parts: [
+++          {
+++            type: 'text',
+++            text: formattedContent,
+++          },
+++        ],
+++      };
+++
+++      setInput('');
+++      setMessages((prev) => [...prev, newMessage]);
+++      reload();
+++    },
+++    [input, selectedChecklistIds, checklists, addAlert, setMessages, reload],
+++  );
+++
+++  if (!open) return null;
+++
+++  return (
+++    <Box
+++      sx={{
+++        width,
+++        minWidth: 300,
+++        height: '100%',
+++        display: 'flex',
+++        flexDirection: 'column',
+++        borderLeft: 1,
+++        borderColor: 'divider',
+++        bgcolor: 'background.paper',
+++        position: 'relative',
+++      }}
+++    >
+++      {/* ヘッダー（閉じるボタン） */}
+++      <Box
+++        sx={{
+++          display: 'flex',
+++          justifyContent: 'flex-end',
+++          p: 1,
+++          borderBottom: 1,
+++          borderColor: 'divider',
+++        }}
+++      >
+++        <IconButton size="small" onClick={onClose}>
+++          <CloseIcon />
+++        </IconButton>
+++      </Box>
+++
+++      {/* メッセージリスト */}
+++      <MessageList
+++        messages={messages}
+++        loading={false}
+++        status={status}
+++        editContent=""
+++        disabled={status === 'submitted' || status === 'streaming'}
+++        editingMessageId=""
+++        onEditStart={() => {}}
+++        onEditContentChange={() => {}}
+++        onEditSubmit={async () => {}}
+++        onEditCancel={() => {}}
+++        loadingMessage="ドキュメントの調査中..."
+++        disableEdit
+++      />
+++
+++      <Divider />
+++
+++      {/* メッセージ入力 */}
+++      <ChecklistMentionInput
+++        handleSubmit={handleSubmit}
+++        handleInputChange={handleInputChange}
+++        message={input}
+++        disabled={status === 'submitted' || status === 'streaming'}
+++        placeholder={getPlaceholderText(status)}
+++        isStreaming={status === 'streaming'}
+++        onStop={stop}
+++        checklists={checklists}
+++        selectedChecklistIds={selectedChecklistIds}
+++        onChecklistSelect={setSelectedChecklistIds}
+++      />
+++    </Box>
+++  );
+++};
+++
+++export default ReviewChatPanel;
++diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
++index d37a5b5c9..7b00c802b 100644
++--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++++ b/src/renderer/components/review/ReviewChecklistSection.tsx
++@@ -58,6 +58,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++   checklistResults,
++   isLoading,
++   onSave,
+++  targetDocumentName,
++ }) => {
++   // --- ステート ---
++   const [editingId, setEditingId] = useState<number | null>(null);
++@@ -94,11 +95,11 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++     setIsAddingNew(false);
++     setNewContent('');
++   };
++-  const handleSort = (fileId: string) => {
++-    if (sortBy === fileId) {
+++  const handleSort = () => {
+++    if (sortBy === 'evaluation') {
++       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
++     } else {
++-      setSortBy(fileId);
+++      setSortBy('evaluation');
++       setSortDirection('desc');
++     }
++   };
++@@ -110,35 +111,15 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++     downloadCSV(csvContent, filename);
++   };
++ 
++-  // --- ユニークファイル抽出 ---
++-  const uniqueSources = useMemo(() => {
++-    const map = new Map<string, { id: string; fileName: string }>();
++-    checklistResults.forEach((cl) => {
++-      cl.sourceEvaluations?.forEach((ev) => {
++-        if (!map.has(ev.fileId)) {
++-          map.set(ev.fileId, {
++-            id: ev.fileId,
++-            fileName: ev.fileName,
++-          });
++-        }
++-      });
++-    });
++-    return Array.from(map.values());
++-  }, [checklistResults]);
++-
++   // --- ソート ---
++   // 動的評価項目対応のため、文字列順ソートを使用
++   const sortedResults = useMemo(() => {
++-    if (sortBy == null) return checklistResults;
+++    if (sortBy !== 'evaluation') return checklistResults;
++ 
++     return [...checklistResults].sort((a, b) => {
++-      // 対象ファイルの評価を取得。未評価は空文字扱い
++-      const aEv =
++-        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
++-        '';
++-      const bEv =
++-        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
++-        '';
+++      // 評価を取得。未評価は空文字扱い
+++      const aEv = a.sourceEvaluation?.evaluation ?? '';
+++      const bEv = b.sourceEvaluation?.evaluation ?? '';
++ 
++       // 文字列順で比較
++       if (sortDirection === 'desc') {
++@@ -169,41 +150,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++         >
++           チェックリスト
++         </TableCell>
++-        {uniqueSources.map((src) => (
++-          <TableCell
++-            key={src.id}
++-            align="center"
++-            sx={{
++-              minWidth: 200,
++-            }}
+++        <TableCell
+++          align="center"
+++          sx={{
+++            minWidth: 300,
+++          }}
+++        >
+++          <TableSortLabel
+++            active={sortBy === 'evaluation'}
+++            direction={sortBy === 'evaluation' ? sortDirection : 'desc'}
+++            onClick={() => handleSort()}
++           >
++-            <Box
++-              sx={{
++-                maxHeight: '4.5em',
++-                overflow: 'hidden',
++-                overflowY: 'auto',
++-                lineHeight: '1.5em',
++-                whiteSpace: 'normal',
++-                wordBreak: 'break-all',
++-                '&:hover': {
++-                  overflowY: 'auto',
++-                },
++-              }}
++-            >
++-              <Tooltip title={src.fileName} placement="top">
++-                <div>
++-                  <TableSortLabel
++-                    active={sortBy === src.id}
++-                    direction={sortBy === src.id ? sortDirection : 'desc'}
++-                    onClick={() => handleSort(src.id)}
++-                  >
++-                    {src.fileName}
++-                  </TableSortLabel>
++-                </div>
+++            {targetDocumentName ? (
+++              <Tooltip title={targetDocumentName} placement="top">
+++                <Box
+++                  component="span"
+++                  sx={{
+++                    maxHeight: '4.5em',
+++                    overflow: 'hidden',
+++                    textOverflow: 'ellipsis',
+++                    wordBreak: 'break-all',
+++                    whiteSpace: 'normal',
+++                  }}
+++                >
+++                  レビュー結果 ({targetDocumentName})
+++                </Box>
++               </Tooltip>
++-            </Box>
++-          </TableCell>
++-        ))}
+++            ) : (
+++              'レビュー結果'
+++            )}
+++          </TableSortLabel>
+++        </TableCell>
++         <TableCell align="center" sx={{ minWidth: 120 }}>
++           操作
++         </TableCell>
++@@ -231,44 +208,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++           )}
++         </Box>
++       </TableCell>
++-      {/* 評価列 */}
++-      {uniqueSources.map((src) => {
++-        const ev = checklist.sourceEvaluations?.find(
++-          (x) => x.fileId === src.id,
++-        );
++-        return (
++-          <TableCell
++-            key={src.id}
++-            align="center"
++-            sx={{ p: 1, verticalAlign: 'top' }}
++-          >
++-            <Box>
++-              {ev?.evaluation && (
++-                <Stack spacing={1} alignItems="center">
++-                  <Typography
++-                    variant="body2"
++-                    sx={{
++-                      color: getEvaluationColor(ev.evaluation),
++-                      fontWeight: 'bold',
++-                      textDecoration: 'underline',
++-                      textDecorationColor: getEvaluationColor(ev.evaluation),
++-                      textDecorationThickness: '2px',
++-                      textUnderlineOffset: '3px',
++-                    }}
++-                  >
++-                    {ev.evaluation}
++-                  </Typography>
++-                  {ev.comment && (
++-                    <Typography variant="body2" sx={commentBoxSx}>
++-                      {ev.comment}
++-                    </Typography>
++-                  )}
++-                </Stack>
+++      {/* レビュー結果列 */}
+++      <TableCell align="center" sx={{ p: 1, verticalAlign: 'top' }}>
+++        <Box>
+++          {checklist.sourceEvaluation?.evaluation && (
+++            <Stack spacing={1} alignItems="center">
+++              <Typography
+++                variant="body2"
+++                sx={{
+++                  color: getEvaluationColor(
+++                    checklist.sourceEvaluation.evaluation,
+++                  ),
+++                  fontWeight: 'bold',
+++                  textDecoration: 'underline',
+++                  textDecorationColor: getEvaluationColor(
+++                    checklist.sourceEvaluation.evaluation,
+++                  ),
+++                  textDecorationThickness: '2px',
+++                  textUnderlineOffset: '3px',
+++                }}
+++              >
+++                {checklist.sourceEvaluation.evaluation}
+++              </Typography>
+++              {checklist.sourceEvaluation.comment && (
+++                <Typography variant="body2" sx={commentBoxSx}>
+++                  {checklist.sourceEvaluation.comment}
+++                </Typography>
++               )}
++-            </Box>
++-          </TableCell>
++-        );
++-      })}
+++            </Stack>
+++          )}
+++        </Box>
+++      </TableCell>
++       {/* 操作 */}
++       <TableCell align="center" sx={{ p: 1 }}>
++         <Stack direction="row" spacing={1} justifyContent="center">
++@@ -321,10 +291,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
++           />
++         </Box>
++       </TableCell>
++-      {uniqueSources.map((_, i) => (
++-        // eslint-disable-next-line
++-        <TableCell key={i} />
++-      ))}
+++      <TableCell />
++       <TableCell align="center" sx={{ p: 1 }}>
++         <Stack direction="row" spacing={1} justifyContent="center">
++           <IconButton
++diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
++index 2599bdf7c..1f662086c 100644
++--- a/src/renderer/components/review/types.ts
+++++ b/src/renderer/components/review/types.ts
++@@ -18,6 +18,7 @@ export interface ReviewChecklistSectionProps {
++   checklistResults: ReviewChecklistResult[];
++   isLoading: boolean;
++   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
+++  targetDocumentName?: string | null;
++ }
++ 
++ // ReviewSourceModalのProps型
++diff --git a/src/renderer/lib/csvUtils.ts b/src/renderer/lib/csvUtils.ts
++index 7cfdefb6c..c5aac8405 100644
++--- a/src/renderer/lib/csvUtils.ts
+++++ b/src/renderer/lib/csvUtils.ts
++@@ -36,27 +36,8 @@ export const convertReviewResultsToCSV = (
++     return 'チェックリスト\n';
++   }
++ 
++-  // ユニークなソースファイルを抽出
++-  const uniqueSources = new Map<string, { id: string; fileName: string }>();
++-  checklistResults.forEach((checklist) => {
++-    checklist.sourceEvaluations?.forEach((ev) => {
++-      if (!uniqueSources.has(ev.fileId)) {
++-        uniqueSources.set(ev.fileId, {
++-          id: ev.fileId,
++-          fileName: ev.fileName,
++-        });
++-      }
++-    });
++-  });
++-
++-  const sources = Array.from(uniqueSources.values());
++-
++   // ヘッダー行を構築
++-  const headers = ['チェックリスト'];
++-  sources.forEach((source) => {
++-    headers.push(`${source.fileName}_評価`);
++-    headers.push(`${source.fileName}_コメント`);
++-  });
+++  const headers = ['チェックリスト', '評価', 'コメント'];
++ 
++   const csvRows: string[] = [];
++ 
++@@ -65,18 +46,11 @@ export const convertReviewResultsToCSV = (
++ 
++   // データ行を追加
++   checklistResults.forEach((checklist) => {
++-    const row: string[] = [checklist.content];
++-
++-    sources.forEach((source) => {
++-      const evaluation = checklist.sourceEvaluations?.find(
++-        (ev) => ev.fileId === source.id,
++-      );
++-
++-      // 評価値
++-      row.push(evaluation?.evaluation || '');
++-      // コメント
++-      row.push(evaluation?.comment || '');
++-    });
+++    const row: string[] = [
+++      checklist.content,
+++      checklist.sourceEvaluation?.evaluation || '',
+++      checklist.sourceEvaluation?.comment || '',
+++    ];
++ 
++     csvRows.push(row.map(escapeCSVField).join(','));
++   });
++diff --git a/src/renderer/service/chatApi.ts b/src/renderer/service/chatApi.ts
++index 7e99d3fcf..ae3995928 100644
++--- a/src/renderer/service/chatApi.ts
+++++ b/src/renderer/service/chatApi.ts
++@@ -129,9 +129,13 @@ export class ChatApi implements IChatApi {
++     roomId: string,
++     options?: ApiServiceDefaultOptions,
++   ): Promise<void> {
++-    await invokeApi(() => window.electron.chat.requestAbort({
++-      threadId: roomId,
++-    }), options);
+++    await invokeApi(
+++      () =>
+++        window.electron.chat.requestAbort({
+++          threadId: roomId,
+++        }),
+++      options,
+++    );
++   }
++ 
++   public async getChatMessages(
++@@ -146,7 +150,10 @@ export class ChatApi implements IChatApi {
++     title: string,
++     options?: ApiServiceDefaultOptions,
++   ): Promise<void> {
++-    await invokeApi(() => window.electron.chat.createThread({ roomId, title }), options);
+++    await invokeApi(
+++      () => window.electron.chat.createThread({ roomId, title }),
+++      options,
+++    );
++   }
++ 
++   public async sendMessage(
++@@ -154,7 +161,10 @@ export class ChatApi implements IChatApi {
++     messages: ChatMessage[],
++     options?: ApiServiceDefaultOptions,
++   ): Promise<void> {
++-    await invokeApi(() => window.electron.chat.sendMessage({ roomId, messages }), options);
+++    await invokeApi(
+++      () => window.electron.chat.sendMessage({ roomId, messages }),
+++      options,
+++    );
++     console.log('Message sent via IPC:', { roomId, messages });
++   }
++ 
++@@ -163,9 +173,13 @@ export class ChatApi implements IChatApi {
++     messageId: string,
++     options?: ApiServiceDefaultOptions,
++   ): Promise<void> {
++-    await invokeApi(() => window.electron.chat.deleteMessagesBeforeSpecificId({
++-      threadId: roomId,
++-      messageId,
++-    }), options);
+++    await invokeApi(
+++      () =>
+++        window.electron.chat.deleteMessagesBeforeSpecificId({
+++          threadId: roomId,
+++          messageId,
+++        }),
+++      options,
+++    );
++   }
++ }
++diff --git a/src/renderer/service/fsApi.ts b/src/renderer/service/fsApi.ts
++index bf8cc05a5..69f5b5f9b 100644
++--- a/src/renderer/service/fsApi.ts
+++++ b/src/renderer/service/fsApi.ts
++@@ -40,7 +40,10 @@ export class FsApi implements IFsApi {
++     options: OpenDialogOptions,
++     apiOptions?: ApiServiceDefaultOptions,
++   ): Promise<{ filePaths: string[]; canceled: boolean } | null> {
++-    return invokeApi(() => window.electron.fs.showOpenDialog(options), apiOptions);
+++    return invokeApi(
+++      () => window.electron.fs.showOpenDialog(options),
+++      apiOptions,
+++    );
++   }
++ 
++   public async readFile(
++diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
++index 02fc24edb..1ed208b6f 100644
++--- a/src/renderer/service/reviewApi.ts
+++++ b/src/renderer/service/reviewApi.ts
++@@ -27,6 +27,7 @@ export interface IReviewApi {
++     options?: ApiServiceDefaultOptions,
++   ): Promise<{
++     checklistResults?: ReviewChecklistResult[];
+++    targetDocumentName?: string | null;
++   } | null>;
++   getReviewInstruction(
++     historyId: string,
++@@ -118,6 +119,7 @@ export class ReviewApi implements IReviewApi {
++     options?: ApiServiceDefaultOptions,
++   ): Promise<{
++     checklistResults?: ReviewChecklistResult[];
+++    targetDocumentName?: string | null;
++   } | null> {
++     return invokeApi(
++       () => window.electron.review.getHistoryDetail(historyId),
++diff --git a/src/renderer/service/reviewChatApi.ts b/src/renderer/service/reviewChatApi.ts
++new file mode 100644
++index 000000000..f3da0c3d2
++--- /dev/null
+++++ b/src/renderer/service/reviewChatApi.ts
++@@ -0,0 +1,136 @@
+++import { IpcChannels, IpcEventPayload } from '@/types';
+++import { invokeApi } from '../lib/apiUtils';
+++import { ApiServiceDefaultOptions } from '../types';
+++import { ElectronPushClient } from '../lib/ElectronPushClient';
+++
+++export interface IReviewChatApi {
+++  streamResponse(callbacks: {
+++    onMessage: (
+++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
+++    ) => void;
+++    onDone: () => void;
+++    onError: (error: Error) => void;
+++  }): () => void;
+++  abortChat(
+++    reviewHistoryId: string,
+++    options?: ApiServiceDefaultOptions,
+++  ): Promise<void>;
+++  sendMessage(
+++    reviewHistoryId: string,
+++    checklistIds: number[],
+++    question: string,
+++    options?: ApiServiceDefaultOptions,
+++  ): Promise<void>;
+++}
+++
+++// IPC通信を使用してレビューチャット機能を提供するAPIサービス
+++export class ReviewChatApi implements IReviewChatApi {
+++  // シングルトン変数
+++  private static instance: ReviewChatApi;
+++
+++  // コンストラクタをprivateにして外部からのインスタンス化を防止
+++  private constructor() {}
+++
+++  // シングルトンインスタンスを取得するための静的メソッド
+++  public static getInstance(): ReviewChatApi {
+++    if (!ReviewChatApi.instance) {
+++      ReviewChatApi.instance = new ReviewChatApi();
+++    }
+++    return ReviewChatApi.instance;
+++  }
+++
+++  /**
+++   * ストリーミング応答の購読
+++   * @param callbacks ストリーミングイベントのコールバック
+++   * @returns 購読解除用の関数
+++   */
+++  public streamResponse(callbacks: {
+++    onMessage: (
+++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
+++    ) => void;
+++    onDone: () => void;
+++    onError: (error: Error) => void;
+++  }): () => void {
+++    const pushClient = new ElectronPushClient();
+++    const abortController = new AbortController();
+++
+++    // ストリーミングイベントの購読
+++    pushClient.subscribe(
+++      IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
+++      (event) => {
+++        callbacks.onMessage(event.payload);
+++      },
+++      { signal: abortController.signal },
+++    );
+++
+++    // 完了イベント（レビューチャット専用）
+++    pushClient.subscribe(
+++      IpcChannels.REVIEW_CHAT_COMPLETE,
+++      () => {
+++        // 購読を解除
+++        abortController.abort();
+++        // 完了コールバックを呼び出し
+++        callbacks.onDone();
+++      },
+++      { signal: abortController.signal },
+++    );
+++
+++    // エラーイベント（レビューチャット専用）
+++    pushClient.subscribe(
+++      IpcChannels.REVIEW_CHAT_ERROR,
+++      (event) => {
+++        // 購読を解除
+++        abortController.abort();
+++        // エラーコールバックを呼び出し
+++        callbacks.onError(
+++          new Error(event.payload.message || '予期せぬエラーが発生しました'),
+++        );
+++      },
+++      { signal: abortController.signal },
+++    );
+++
+++    // 購読解除のためのクリーンアップ
+++    return () => {
+++      abortController.abort();
+++    };
+++  }
+++
+++  /**
+++   * レビューチャットの中断
+++   * @param reviewHistoryId レビュー履歴ID
+++   * @param options APIサービスのオプション
+++   */
+++  public async abortChat(
+++    reviewHistoryId: string,
+++    options?: ApiServiceDefaultOptions,
+++  ): Promise<void> {
+++    await invokeApi(
+++      () => window.electron.review.abortChat(reviewHistoryId),
+++      options,
+++    );
+++  }
+++
+++  /**
+++   * レビューチャットメッセージ送信
+++   * @param reviewHistoryId レビュー履歴ID
+++   * @param checklistIds チェックリストID配列
+++   * @param question ユーザからの質問
+++   * @param options APIサービスのオプション
+++   */
+++  public async sendMessage(
+++    reviewHistoryId: string,
+++    checklistIds: number[],
+++    question: string,
+++    options?: ApiServiceDefaultOptions,
+++  ): Promise<void> {
+++    await invokeApi(
+++      () =>
+++        window.electron.review.sendChatMessage({
+++          reviewHistoryId,
+++          checklistIds,
+++          question,
+++        }),
+++      options,
+++    );
+++  }
+++}
++diff --git a/src/renderer/service/settingsApi.ts b/src/renderer/service/settingsApi.ts
++index 8ec061cbf..a2cdeecc5 100644
++--- a/src/renderer/service/settingsApi.ts
+++++ b/src/renderer/service/settingsApi.ts
++@@ -47,7 +47,10 @@ export class SettingsApi implements ISettingsApi {
++     messageId: string,
++     options?: ApiServiceDefaultOptions,
++   ): Promise<void> {
++-    await invokeApi(() => window.electron.settings.removeMessage(messageId), options);
+++    await invokeApi(
+++      () => window.electron.settings.removeMessage(messageId),
+++      options,
+++    );
++   }
++ 
++   public async reinitialize(options?: ApiServiceDefaultOptions): Promise<void> {
++@@ -64,7 +67,10 @@ export class SettingsApi implements ISettingsApi {
++     settings: Settings,
++     options?: ApiServiceDefaultOptions,
++   ): Promise<boolean | null> {
++-    return invokeApi(() => window.electron.settings.setSettings(settings), options);
+++    return invokeApi(
+++      () => window.electron.settings.setSettings(settings),
+++      options,
+++    );
++   }
++ 
++   public async subscribeSettingsUpdateFinished(
++diff --git a/src/renderer/service/sourceApi.ts b/src/renderer/service/sourceApi.ts
++index 76b2f9c6f..2500ff69b 100644
++--- a/src/renderer/service/sourceApi.ts
+++++ b/src/renderer/service/sourceApi.ts
++@@ -49,10 +49,14 @@ export class SourceApi implements ISourceApi {
++     enabled: boolean,
++     options?: ApiServiceDefaultOptions,
++   ): Promise<void> {
++-    await invokeApi(() => window.electron.source.updateSourceEnabled({
++-      sourceId: id,
++-      isEnabled: enabled,
++-    }), options);
+++    await invokeApi(
+++      () =>
+++        window.electron.source.updateSourceEnabled({
+++          sourceId: id,
+++          isEnabled: enabled,
+++        }),
+++      options,
+++    );
++   }
++ 
++   public async subscribeSourceReloadFinished(
++diff --git a/src/types/error.ts b/src/types/error.ts
++index a4fd32185..ad22f0b75 100644
++--- a/src/types/error.ts
+++++ b/src/types/error.ts
++@@ -14,10 +14,7 @@ export type ErrorCode =
++ /**
++  * フロントエンドで利用するエラーコード
++  */
++-export type FrontErrorCode =
++-  | 'APP_API'
++-  | 'APP_API_CALL'
++-  | 'INTERNAL';
+++export type FrontErrorCode = 'APP_API' | 'APP_API_CALL' | 'INTERNAL';
++ 
++ /**
++  * クライアントへ返す標準エラー形
++diff --git a/src/types/ipc.ts b/src/types/ipc.ts
++index 0fc449d82..69d3b10bd 100644
++--- a/src/types/ipc.ts
+++++ b/src/types/ipc.ts
++@@ -81,6 +81,11 @@ export const IpcChannels = {
++   REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
++   REVIEW_EXECUTE_ABORT: 'review-execute-abort', // レビュー実行処理をキャンセルする
++   REVIEW_HISTORY_UPDATED: 'review-history-updated', // レビュー履歴が更新された際の通知
+++  REVIEW_CHAT_SEND_MESSAGE: 'review-chat-send-message', // レビューチャットメッセージ送信
+++  REVIEW_CHAT_STREAM_RESPONSE: 'review-chat-stream-response', // レビューチャットストリーミング応答
+++  REVIEW_CHAT_COMPLETE: 'review-chat-complete', // レビューチャット完了
+++  REVIEW_CHAT_ERROR: 'review-chat-error', // レビューチャットエラー
+++  REVIEW_CHAT_ABORT: 'review-chat-abort', // レビューチャット中断
++ } as const;
++ 
++ export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
++@@ -150,6 +155,12 @@ export type IpcRequestPayloadMap = {
++     documentMode: DocumentMode;
++   };
++   [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
+++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: {
+++    reviewHistoryId: string;
+++    checklistIds: number[];
+++    question: string;
+++  };
+++  [IpcChannels.REVIEW_CHAT_ABORT]: string; // review history id
++ };
++ 
++ export type IpcResponsePayloadMap = {
++@@ -189,6 +200,7 @@ export type IpcResponsePayloadMap = {
++   [IpcChannels.REVIEW_GET_HISTORIES]: IpcResult<RevieHistory[]>;
++   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: IpcResult<{
++     checklistResults?: ReviewChecklistResult[];
+++    targetDocumentName?: string | null;
++   }>;
++   [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: IpcResult<{
++     additionalInstructions?: string;
++@@ -201,6 +213,8 @@ export type IpcResponsePayloadMap = {
++   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: IpcResult;
++   [IpcChannels.REVIEW_EXECUTE_CALL]: IpcResult;
++   [IpcChannels.REVIEW_EXECUTE_ABORT]: IpcResult;
+++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: IpcResult;
+++  [IpcChannels.REVIEW_CHAT_ABORT]: IpcResult;
++ };
++ 
++ export type IpcEventPayloadMap = {
++@@ -227,6 +241,9 @@ export type IpcEventPayloadMap = {
++     currentSheet?: number;
++     totalSheets?: number;
++   };
+++  [IpcChannels.REVIEW_CHAT_STREAM_RESPONSE]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
+++  [IpcChannels.REVIEW_CHAT_COMPLETE]: unknown;
+++  [IpcChannels.REVIEW_CHAT_ERROR]: { message: string };
++ };
++ 
++ /**
++@@ -287,4 +304,8 @@ export const IpcNameMap = {
++   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: 'チェックリストの更新',
++   [IpcChannels.REVIEW_EXECUTE_CALL]: 'ドキュメントレビューの実行',
++   [IpcChannels.REVIEW_EXECUTE_ABORT]: 'ドキュメントレビューの中断',
+++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: 'レビューチャットメッセージ送信',
+++  [IpcChannels.REVIEW_CHAT_COMPLETE]: 'レビューチャット完了',
+++  [IpcChannels.REVIEW_CHAT_ERROR]: 'レビューチャットエラー',
+++  [IpcChannels.REVIEW_CHAT_ABORT]: 'レビューチャット中断',
++ };
++diff --git a/src/types/message.ts b/src/types/message.ts
++index 979bb1cda..a4065ae2e 100644
++--- a/src/types/message.ts
+++++ b/src/types/message.ts
++@@ -11,6 +11,7 @@ export type MessageCode =
++   | 'GITLAB_API_CONNECTION_ERROR'
++   | 'REDMINE_API_CONNECTION_ERROR'
++   | 'REDMINE_API_ERROR'
+++  | 'FS_OPEN_DIALOG_ERROR'
++   | 'FILE_TEXT_EXTRACTION_ERROR'
++   | 'FS_CONVERT_OFFICE_TO_PDF_ERROR'
++   | 'SOURCE_REGISTRATION_DIR_READING_ERROR'
++@@ -18,8 +19,10 @@ export type MessageCode =
++   | 'REVIEW_CHECKLIST_EXTRACTION_ERROR'
++   | 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS'
++   | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
+++  | 'REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM'
++   | 'REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR'
++   | 'REVIEW_EXECUTION_ERROR'
++   | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
++   | 'AI_API_ERROR'
++-  | 'AI_MESSAGE_TOO_LARGE';
+++  | 'AI_MESSAGE_TOO_LARGE'
+++  | 'REVIEW_DOCUMENT_CACHE_NOT_FOUND';
++diff --git a/src/types/review.ts b/src/types/review.ts
++index 52578ffaa..85bce2524 100644
++--- a/src/types/review.ts
+++++ b/src/types/review.ts
++@@ -1,6 +1,7 @@
++ export interface RevieHistory {
++   id: string; // reviewHistoriesのid
++   title: string;
+++  targetDocumentName?: string | null; // レビュー対象の統合ドキュメント名
++   additionalInstructions: string | null;
++   commentFormat?: string | null;
++   evaluationSettings?: CustomEvaluationSettings | null; // カスタム評定項目設定
++@@ -13,6 +14,8 @@ export interface ReviewChecklist {
++   id: number;
++   reviewHistoryId: string;
++   content: string;
+++  evaluation?: ReviewEvaluation | null; // A, B, C, - 評価
+++  comment?: string | null; // レビューコメント
++   createdBy: ReviewChecklistCreatedBy;
++   createdAt: string;
++   updatedAt: string;
++@@ -39,12 +42,10 @@ export type ReviewChecklistCreatedBy = 'user' | 'system';
++ export type ReviewChecklistResult = {
++   id: number; // チェックリストのID
++   content: string;
++-  sourceEvaluations?: {
++-    fileId: string;
++-    fileName: string;
+++  sourceEvaluation?: {
++     evaluation?: ReviewEvaluation; // カスタム評定項目対応
++     comment?: string;
++-  }[];
+++  };
++ };
++ 
++ // チェックリストの編集内容を表す型
++@@ -92,8 +93,31 @@ export type ReviewExecutionResultStatus =
++ 
++ // 処理ステータスの型定義
++ export type ProcessingStatus =
++-  | 'idle'        // アイドル状態
++-  | 'extracting'  // チェックリスト抽出中
++-  | 'extracted'   // チェックリスト抽出完了
++-  | 'reviewing'   // レビュー実行中
++-  | 'completed';  // レビュー完了
+++  | 'idle' // アイドル状態
+++  | 'extracting' // チェックリスト抽出中
+++  | 'extracted' // チェックリスト抽出完了
+++  | 'reviewing' // レビュー実行中
+++  | 'completed'; // レビュー完了
+++
+++// レビュードキュメントキャッシュ（サービス層で使用）
+++export interface ReviewDocumentCache {
+++  id: number;
+++  reviewHistoryId: string;
+++  documentId: string; // ワークフロー内のドキュメントID
+++  fileName: string; // ワークフロー内での名前（分割時は "xxx (part 1)" など）
+++  processMode: ProcessMode;
+++  textContent?: string; // processMode='text'の場合
+++  imageData?: string[]; // processMode='image'の場合
+++  createdAt: string;
+++  updatedAt: string;
+++}
+++
+++// レビュー大量ドキュメント結果キャッシュ（大量ドキュメントレビューの個別レビュー結果）
+++export interface ReviewLargedocumentResultCache {
+++  reviewDocumentCacheId: number;
+++  reviewChecklistId: number;
+++  comment: string;
+++  totalChunks: number; // ドキュメント分割総数
+++  chunkIndex: number; // 何番目のチャンクか（0から始まる）
+++  individualFileName: string; // 分割後の個別ドキュメント名（"xxx (part 1)" など）
+++}
+diff --git a/drizzle.config.ts b/drizzle.config.ts
+index 36ebf09d3..f73e59241 100644
+--- a/drizzle.config.ts
++++ b/drizzle.config.ts
+@@ -12,7 +12,7 @@ console.log(
+ );
+ 
+ export default {
+-  schema: './src/db/schema.ts',
++  schema: './src/adapter/db/drizzle/schema.ts',
+   out: './drizzle/migrations',
+   dialect: 'sqlite',
+   dbCredentials: {
+diff --git a/drizzle/migrations/0008_pink_ezekiel.sql b/drizzle/migrations/0008_pink_ezekiel.sql
+new file mode 100644
+index 000000000..8169d2866
+--- /dev/null
++++ b/drizzle/migrations/0008_pink_ezekiel.sql
+@@ -0,0 +1,4 @@
++DROP TABLE `review_checklist_results`;--> statement-breakpoint
++ALTER TABLE `review_checklists` ADD `evaluation` text;--> statement-breakpoint
++ALTER TABLE `review_checklists` ADD `comment` text;--> statement-breakpoint
++ALTER TABLE `review_histories` ADD `target_document_name` text;
+\ No newline at end of file
+diff --git a/drizzle/migrations/0009_keen_radioactive_man.sql b/drizzle/migrations/0009_keen_radioactive_man.sql
+new file mode 100644
+index 000000000..999bdbbd9
+--- /dev/null
++++ b/drizzle/migrations/0009_keen_radioactive_man.sql
+@@ -0,0 +1,23 @@
++CREATE TABLE `review_checklist_result_caches` (
++	`review_document_cache_id` integer NOT NULL,
++	`review_checklist_id` integer NOT NULL,
++	`comment` text NOT NULL,
++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`),
++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
++);
++--> statement-breakpoint
++CREATE TABLE `review_document_caches` (
++	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
++	`review_history_id` text NOT NULL,
++	`document_id` text NOT NULL,
++	`original_file_name` text NOT NULL,
++	`file_name` text NOT NULL,
++	`process_mode` text NOT NULL,
++	`cache_path` text NOT NULL,
++	`created_at` text DEFAULT (current_timestamp) NOT NULL,
++	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
++	FOREIGN KEY (`review_history_id`) REFERENCES `review_histories`(`id`) ON UPDATE no action ON DELETE cascade
++);
++--> statement-breakpoint
++ALTER TABLE `review_histories` ADD `document_mode` text;
+\ No newline at end of file
+diff --git a/drizzle/migrations/0010_wet_shooting_star.sql b/drizzle/migrations/0010_wet_shooting_star.sql
+new file mode 100644
+index 000000000..49668f9f0
+--- /dev/null
++++ b/drizzle/migrations/0010_wet_shooting_star.sql
+@@ -0,0 +1,14 @@
++CREATE TABLE `review_largedocument_result_caches` (
++	`review_document_cache_id` integer NOT NULL,
++	`review_checklist_id` integer NOT NULL,
++	`comment` text NOT NULL,
++	`total_chunks` integer NOT NULL,
++	`chunk_index` integer NOT NULL,
++	`individual_file_name` text NOT NULL,
++	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`, `chunk_index`),
++	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
++);
++--> statement-breakpoint
++DROP TABLE `review_checklist_result_caches`;--> statement-breakpoint
++ALTER TABLE `review_document_caches` DROP COLUMN `original_file_name`;
+\ No newline at end of file
+diff --git a/drizzle/migrations/meta/0008_snapshot.json b/drizzle/migrations/meta/0008_snapshot.json
+new file mode 100644
+index 000000000..5148d151e
+--- /dev/null
++++ b/drizzle/migrations/meta/0008_snapshot.json
+@@ -0,0 +1,329 @@
++{
++  "version": "6",
++  "dialect": "sqlite",
++  "id": "e0ad999a-87f1-4f45-b070-a32c673d6352",
++  "prevId": "f10b9ed0-007d-4b08-941a-030265d534ff",
++  "tables": {
++    "review_checklists": {
++      "name": "review_checklists",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "review_history_id": {
++          "name": "review_history_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "content": {
++          "name": "content",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "evaluation": {
++          "name": "evaluation",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "comment": {
++          "name": "comment",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "created_by": {
++          "name": "created_by",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_checklists_review_history_id_review_histories_id_fk": {
++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++          "tableFrom": "review_checklists",
++          "tableTo": "review_histories",
++          "columnsFrom": [
++            "review_history_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_histories": {
++      "name": "review_histories",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "text",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "target_document_name": {
++          "name": "target_document_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "additional_instructions": {
++          "name": "additional_instructions",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "comment_format": {
++          "name": "comment_format",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "evaluation_settings": {
++          "name": "evaluation_settings",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "processing_status": {
++          "name": "processing_status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "sources": {
++      "name": "sources",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "path": {
++          "name": "path",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "status": {
++          "name": "status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "error": {
++          "name": "error",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "is_enabled": {
++          "name": "is_enabled",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": 1
++        }
++      },
++      "indexes": {
++        "sources_path_unique": {
++          "name": "sources_path_unique",
++          "columns": [
++            "path"
++          ],
++          "isUnique": true
++        }
++      },
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "topics": {
++      "name": "topics",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "source_id": {
++          "name": "source_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "name": {
++          "name": "name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "topics_source_id_sources_id_fk": {
++          "name": "topics_source_id_sources_id_fk",
++          "tableFrom": "topics",
++          "tableTo": "sources",
++          "columnsFrom": [
++            "source_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    }
++  },
++  "views": {},
++  "enums": {},
++  "_meta": {
++    "schemas": {},
++    "tables": {},
++    "columns": {}
++  },
++  "internal": {
++    "indexes": {}
++  }
++}
+\ No newline at end of file
+diff --git a/drizzle/migrations/meta/0009_snapshot.json b/drizzle/migrations/meta/0009_snapshot.json
+new file mode 100644
+index 000000000..0f58c9424
+--- /dev/null
++++ b/drizzle/migrations/meta/0009_snapshot.json
+@@ -0,0 +1,491 @@
++{
++  "version": "6",
++  "dialect": "sqlite",
++  "id": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
++  "prevId": "e0ad999a-87f1-4f45-b070-a32c673d6352",
++  "tables": {
++    "review_checklist_result_caches": {
++      "name": "review_checklist_result_caches",
++      "columns": {
++        "review_document_cache_id": {
++          "name": "review_document_cache_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "review_checklist_id": {
++          "name": "review_checklist_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "comment": {
++          "name": "comment",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk": {
++          "name": "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk",
++          "tableFrom": "review_checklist_result_caches",
++          "tableTo": "review_document_caches",
++          "columnsFrom": [
++            "review_document_cache_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        },
++        "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk": {
++          "name": "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk",
++          "tableFrom": "review_checklist_result_caches",
++          "tableTo": "review_checklists",
++          "columnsFrom": [
++            "review_checklist_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {
++        "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk": {
++          "columns": [
++            "review_document_cache_id",
++            "review_checklist_id"
++          ],
++          "name": "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk"
++        }
++      },
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_checklists": {
++      "name": "review_checklists",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "review_history_id": {
++          "name": "review_history_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "content": {
++          "name": "content",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "evaluation": {
++          "name": "evaluation",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "comment": {
++          "name": "comment",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "created_by": {
++          "name": "created_by",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_checklists_review_history_id_review_histories_id_fk": {
++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++          "tableFrom": "review_checklists",
++          "tableTo": "review_histories",
++          "columnsFrom": [
++            "review_history_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_document_caches": {
++      "name": "review_document_caches",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "review_history_id": {
++          "name": "review_history_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "document_id": {
++          "name": "document_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "original_file_name": {
++          "name": "original_file_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "file_name": {
++          "name": "file_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "process_mode": {
++          "name": "process_mode",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "cache_path": {
++          "name": "cache_path",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_document_caches_review_history_id_review_histories_id_fk": {
++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
++          "tableFrom": "review_document_caches",
++          "tableTo": "review_histories",
++          "columnsFrom": [
++            "review_history_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_histories": {
++      "name": "review_histories",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "text",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "target_document_name": {
++          "name": "target_document_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "additional_instructions": {
++          "name": "additional_instructions",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "comment_format": {
++          "name": "comment_format",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "evaluation_settings": {
++          "name": "evaluation_settings",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "document_mode": {
++          "name": "document_mode",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "processing_status": {
++          "name": "processing_status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "sources": {
++      "name": "sources",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "path": {
++          "name": "path",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "status": {
++          "name": "status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "error": {
++          "name": "error",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "is_enabled": {
++          "name": "is_enabled",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": 1
++        }
++      },
++      "indexes": {
++        "sources_path_unique": {
++          "name": "sources_path_unique",
++          "columns": [
++            "path"
++          ],
++          "isUnique": true
++        }
++      },
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "topics": {
++      "name": "topics",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "source_id": {
++          "name": "source_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "name": {
++          "name": "name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "topics_source_id_sources_id_fk": {
++          "name": "topics_source_id_sources_id_fk",
++          "tableFrom": "topics",
++          "tableTo": "sources",
++          "columnsFrom": [
++            "source_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    }
++  },
++  "views": {},
++  "enums": {},
++  "_meta": {
++    "schemas": {},
++    "tables": {},
++    "columns": {}
++  },
++  "internal": {
++    "indexes": {}
++  }
++}
+\ No newline at end of file
+diff --git a/drizzle/migrations/meta/0010_snapshot.json b/drizzle/migrations/meta/0010_snapshot.json
+new file mode 100644
+index 000000000..cf557a34d
+--- /dev/null
++++ b/drizzle/migrations/meta/0010_snapshot.json
+@@ -0,0 +1,506 @@
++{
++  "version": "6",
++  "dialect": "sqlite",
++  "id": "64a4c44b-83f4-4cca-b0a7-5e1962a1f61b",
++  "prevId": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
++  "tables": {
++    "review_checklists": {
++      "name": "review_checklists",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "review_history_id": {
++          "name": "review_history_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "content": {
++          "name": "content",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "evaluation": {
++          "name": "evaluation",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "comment": {
++          "name": "comment",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "created_by": {
++          "name": "created_by",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_checklists_review_history_id_review_histories_id_fk": {
++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++          "tableFrom": "review_checklists",
++          "tableTo": "review_histories",
++          "columnsFrom": [
++            "review_history_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_document_caches": {
++      "name": "review_document_caches",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "review_history_id": {
++          "name": "review_history_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "document_id": {
++          "name": "document_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "file_name": {
++          "name": "file_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "process_mode": {
++          "name": "process_mode",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "cache_path": {
++          "name": "cache_path",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_document_caches_review_history_id_review_histories_id_fk": {
++          "name": "review_document_caches_review_history_id_review_histories_id_fk",
++          "tableFrom": "review_document_caches",
++          "tableTo": "review_histories",
++          "columnsFrom": [
++            "review_history_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_histories": {
++      "name": "review_histories",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "text",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "target_document_name": {
++          "name": "target_document_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "additional_instructions": {
++          "name": "additional_instructions",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "comment_format": {
++          "name": "comment_format",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "evaluation_settings": {
++          "name": "evaluation_settings",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "document_mode": {
++          "name": "document_mode",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "processing_status": {
++          "name": "processing_status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_largedocument_result_caches": {
++      "name": "review_largedocument_result_caches",
++      "columns": {
++        "review_document_cache_id": {
++          "name": "review_document_cache_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "review_checklist_id": {
++          "name": "review_checklist_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "comment": {
++          "name": "comment",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "total_chunks": {
++          "name": "total_chunks",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "chunk_index": {
++          "name": "chunk_index",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "individual_file_name": {
++          "name": "individual_file_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk": {
++          "name": "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk",
++          "tableFrom": "review_largedocument_result_caches",
++          "tableTo": "review_document_caches",
++          "columnsFrom": [
++            "review_document_cache_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        },
++        "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk": {
++          "name": "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk",
++          "tableFrom": "review_largedocument_result_caches",
++          "tableTo": "review_checklists",
++          "columnsFrom": [
++            "review_checklist_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {
++        "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk": {
++          "columns": [
++            "review_document_cache_id",
++            "review_checklist_id",
++            "chunk_index"
++          ],
++          "name": "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk"
++        }
++      },
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "sources": {
++      "name": "sources",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "path": {
++          "name": "path",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "status": {
++          "name": "status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "error": {
++          "name": "error",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "is_enabled": {
++          "name": "is_enabled",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": 1
++        }
++      },
++      "indexes": {
++        "sources_path_unique": {
++          "name": "sources_path_unique",
++          "columns": [
++            "path"
++          ],
++          "isUnique": true
++        }
++      },
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "topics": {
++      "name": "topics",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "source_id": {
++          "name": "source_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "name": {
++          "name": "name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "topics_source_id_sources_id_fk": {
++          "name": "topics_source_id_sources_id_fk",
++          "tableFrom": "topics",
++          "tableTo": "sources",
++          "columnsFrom": [
++            "source_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    }
++  },
++  "views": {},
++  "enums": {},
++  "_meta": {
++    "schemas": {},
++    "tables": {},
++    "columns": {}
++  },
++  "internal": {
++    "indexes": {}
++  }
++}
+\ No newline at end of file
+diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
+index 18a6e2692..2c49cc99a 100644
+--- a/drizzle/migrations/meta/_journal.json
++++ b/drizzle/migrations/meta/_journal.json
+@@ -57,6 +57,27 @@
+       "when": 1758023792722,
+       "tag": "0007_awesome_caretaker",
+       "breakpoints": true
++    },
++    {
++      "idx": 8,
++      "version": "6",
++      "when": 1759653362189,
++      "tag": "0008_pink_ezekiel",
++      "breakpoints": true
++    },
++    {
++      "idx": 9,
++      "version": "6",
++      "when": 1759674897312,
++      "tag": "0009_keen_radioactive_man",
++      "breakpoints": true
++    },
++    {
++      "idx": 10,
++      "version": "6",
++      "when": 1760147587193,
++      "tag": "0010_wet_shooting_star",
++      "breakpoints": true
+     }
+   ]
+ }
+\ No newline at end of file
+diff --git a/src/__tests__/integration/Sidebar.test.tsx b/src/__tests__/integration/Sidebar.test.tsx
+index 00d96f758..a66dd0796 100644
+--- a/src/__tests__/integration/Sidebar.test.tsx
++++ b/src/__tests__/integration/Sidebar.test.tsx
+@@ -11,7 +11,7 @@ import { v4 as uuidv4 } from 'uuid';
+ import Sidebar from '@/renderer/components/sidebar/Sidebar';
+ import type { ChatRoom, ProcessStatus } from '@/types';
+ import type { Source } from '@/db/schema';
+-import { StoreSchema as Settings } from '@/main/store';
++import { StoreSchema as Settings } from '@/adapter/db/electron-store/store';
+ import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
+ import ChatRoomList from '@/renderer/components/chat/ChatRoomList';
+ import ReviewHistoryList from '@/renderer/components/review/ReviewHistoryList';
+diff --git a/src/adapter/db/drizzle/index.ts b/src/adapter/db/drizzle/index.ts
+index bf2e952ff..b581c2c5c 100644
+--- a/src/adapter/db/drizzle/index.ts
++++ b/src/adapter/db/drizzle/index.ts
+@@ -3,7 +3,7 @@ import { join } from 'path';
+ import { drizzle, type LibSQLDatabase } from 'drizzle-orm/libsql';
+ import { migrate } from 'drizzle-orm/libsql/migrator';
+ import * as schema from './schema';
+-import { getStore } from '@/main/store';
++import { getStore } from '@/adapter/db/electron-store/store';
+ import { toAbsoluteFileURL } from '@/main/lib/util';
+ 
+ // データベースの型定義
+diff --git a/src/adapter/db/drizzle/repository/index.ts b/src/adapter/db/drizzle/repository/index.ts
+index b908a5531..1d721b297 100644
+--- a/src/adapter/db/drizzle/repository/index.ts
++++ b/src/adapter/db/drizzle/repository/index.ts
+@@ -1,3 +1,2 @@
+ export * from './sourceRepository';
+ export * from './reviewRepository';
+-export * from './settingsRepository';
+diff --git a/src/adapter/db/drizzle/repository/reviewRepository.ts b/src/adapter/db/drizzle/repository/reviewRepository.ts
+index 572c1e214..cd8949e13 100644
+--- a/src/adapter/db/drizzle/repository/reviewRepository.ts
++++ b/src/adapter/db/drizzle/repository/reviewRepository.ts
+@@ -1,10 +1,13 @@
+-import { eq, and } from 'drizzle-orm';
++import { eq, and, inArray, max } from 'drizzle-orm';
+ import {
+   reviewHistories,
+   reviewChecklists,
+-  reviewChecklistResults,
++  reviewDocumentCaches,
++  reviewLargedocumentResultCaches,
+   ReviewChecklistEntity,
+   ReviewHistoryEntity,
++  ReviewDocumentCacheEntity,
++  ReviewLargedocumentResultCacheEntity,
+ } from '../schema';
+ import getDb from '..';
+ import type {
+@@ -15,10 +18,15 @@ import type {
+   ReviewChecklistCreatedBy,
+   CustomEvaluationSettings,
+   ProcessingStatus,
++  DocumentMode,
++  ReviewDocumentCache,
++  ReviewLargedocumentResultCache,
++  ProcessMode,
+ } from '@/types';
+-import { AppError } from '@/main/lib/error';
++import { AppError, internalError } from '@/main/lib/error';
+ import { repositoryError } from '@/main/lib/error';
+ import { IReviewRepository } from '@/main/service/port/repository';
++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
+ 
+ /**
+  * Drizzle ORM を使用したレビューリポジトリの実装
+@@ -31,6 +39,8 @@ export class DrizzleReviewRepository implements IReviewRepository {
+       id: reviewChecklistEntity.id,
+       reviewHistoryId: reviewChecklistEntity.reviewHistoryId,
+       content: reviewChecklistEntity.content,
++      evaluation: reviewChecklistEntity.evaluation as ReviewEvaluation | null,
++      comment: reviewChecklistEntity.comment,
+       createdBy: reviewChecklistEntity.createdBy as ReviewChecklistCreatedBy,
+       createdAt: reviewChecklistEntity.createdAt,
+       updatedAt: reviewChecklistEntity.updatedAt,
+@@ -43,6 +53,7 @@ export class DrizzleReviewRepository implements IReviewRepository {
+     const reviewHistory = {
+       id: reviewHistoryEntity.id,
+       title: reviewHistoryEntity.title,
++      targetDocumentName: reviewHistoryEntity.targetDocumentName,
+       additionalInstructions: reviewHistoryEntity.additionalInstructions,
+       commentFormat: reviewHistoryEntity.commentFormat,
+       evaluationSettings: null,
+@@ -189,6 +200,27 @@ export class DrizzleReviewRepository implements IReviewRepository {
+     }
+   }
+ 
++  /** レビュー対象ドキュメント名を更新 */
++  async updateReviewHistoryTargetDocumentName(
++    id: string,
++    targetDocumentName: string,
++  ): Promise<void> {
++    try {
++      const db = await getDb();
++      await db
++        .update(reviewHistories)
++        .set({
++          targetDocumentName,
++        })
++        .where(eq(reviewHistories.id, id));
++    } catch (err) {
++      throw repositoryError(
++        'レビュー対象ドキュメント名の更新に失敗しました',
++        err,
++      );
++    }
++  }
++
+   /** レビュー履歴を削除 */
+   async deleteReviewHistory(id: string): Promise<void> {
+     try {
+@@ -284,121 +316,426 @@ export class DrizzleReviewRepository implements IReviewRepository {
+       reviewChecklistId: number;
+       evaluation: ReviewEvaluation;
+       comment: string;
+-      fileId: string;
+-      fileName: string;
+     }[],
+   ): Promise<void> {
+     try {
+       const db = await getDb();
+       for (const result of results) {
+-        const [upserted] = await db
+-          .insert(reviewChecklistResults)
+-          .values(result)
+-          .onConflictDoUpdate({
+-            target: [
+-              reviewChecklistResults.reviewChecklistId,
+-              reviewChecklistResults.fileId,
+-            ],
+-            set: {
+-              evaluation: result.evaluation,
+-              comment: result.comment,
+-            },
++        await db
++          .update(reviewChecklists)
++          .set({
++            evaluation: result.evaluation,
++            comment: result.comment,
+           })
+-          .returning();
++          .where(eq(reviewChecklists.id, result.reviewChecklistId));
+       }
+     } catch (err) {
+       throw repositoryError('レビュー結果の保存に失敗しました', err);
+     }
+   }
+ 
+-  /** レビュー結果を削除 */
+-  async deleteReviewResults(
+-    reviewChecklistId: number,
+-    sourceId: number,
++  /** チェックリスト結果を取得してグルーピング */
++  async getReviewChecklistResults(
++    reviewHistoryId: string,
++  ): Promise<ReviewChecklistResult[]> {
++    try {
++      const db = await getDb();
++      const rows = await db
++        .select()
++        .from(reviewChecklists)
++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
++        .orderBy(reviewChecklists.createdAt);
++
++      return rows.map((row) => ({
++        id: row.id,
++        content: row.content,
++        sourceEvaluation: row.evaluation
++          ? {
++              evaluation: row.evaluation as ReviewEvaluation,
++              comment: row.comment ?? undefined,
++            }
++          : undefined,
++      }));
++    } catch (err) {
++      throw repositoryError('レビュー結果の取得に失敗しました', err);
++    }
++  }
++
++  /** すべてのレビュー結果を削除 */
++  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
++    try {
++      const db = await getDb();
++      await db
++        .update(reviewChecklists)
++        .set({
++          evaluation: null,
++          comment: null,
++        })
++        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
++    } catch (err) {
++      throw repositoryError('レビュー結果の削除に失敗しました', err);
++    }
++  }
++
++  /** documentModeを更新 */
++  async updateReviewHistoryDocumentMode(
++    id: string,
++    documentMode: DocumentMode,
+   ): Promise<void> {
+     try {
+       const db = await getDb();
+       await db
+-        .delete(reviewChecklistResults)
++        .update(reviewHistories)
++        .set({
++          documentMode,
++        })
++        .where(eq(reviewHistories.id, id));
++    } catch (err) {
++      throw repositoryError('ドキュメントモードの更新に失敗しました', err);
++    }
++  }
++
++  /**
++   * ReviewDocumentCacheEntity → ReviewDocumentCache の変換
++   * cachePathからファイルを読み込んでtextContent/imageDataに変換
++   */
++  private async convertDocumentCacheEntityToDomain(
++    entity: ReviewDocumentCacheEntity,
++  ): Promise<ReviewDocumentCache> {
++    const base = {
++      id: entity.id,
++      reviewHistoryId: entity.reviewHistoryId,
++      documentId: entity.documentId,
++      fileName: entity.fileName,
++      processMode: entity.processMode as ProcessMode,
++      createdAt: entity.createdAt,
++      updatedAt: entity.updatedAt,
++    };
++
++    try {
++      // cachePathからファイルを読み込む
++      if (entity.processMode === 'text') {
++        const textContent = await ReviewCacheHelper.loadTextCache(
++          entity.cachePath,
++        );
++        return { ...base, textContent };
++      } else if (entity.processMode === 'image') {
++        const imageData = await ReviewCacheHelper.loadImageCache(
++          entity.cachePath,
++        );
++        return { ...base, imageData };
++      }
++
++      throw repositoryError('無効なprocessModeです', null);
++    } catch (error) {
++      // キャッシュファイル読み込みエラーの場合は専用のエラーメッセージを返す
++      if (error instanceof Error && error.message.includes('Failed to load')) {
++        throw internalError({
++          expose: true,
++          messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
++          cause: error,
++        });
++      }
++      // その他のエラーはそのまま再スロー
++      throw error;
++    }
++  }
++
++  /** ドキュメントキャッシュを作成 */
++  async createReviewDocumentCache(
++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
++  ): Promise<ReviewDocumentCache> {
++    try {
++      // 1. ファイルシステムにキャッシュを保存
++      let cachePath: string;
++
++      if (cache.processMode === 'text' && cache.textContent) {
++        cachePath = await ReviewCacheHelper.saveTextCache(
++          cache.reviewHistoryId,
++          cache.documentId,
++          cache.textContent,
++        );
++      } else if (cache.processMode === 'image' && cache.imageData) {
++        cachePath = await ReviewCacheHelper.saveImageCache(
++          cache.reviewHistoryId,
++          cache.documentId,
++          cache.imageData,
++        );
++      } else {
++        throw repositoryError(
++          '無効なprocessModeまたはデータが不足しています',
++          null,
++        );
++      }
++
++      // 2. DBにメタデータを保存
++      const db = await getDb();
++      const [entity] = await db
++        .insert(reviewDocumentCaches)
++        .values({
++          reviewHistoryId: cache.reviewHistoryId,
++          documentId: cache.documentId,
++          fileName: cache.fileName,
++          processMode: cache.processMode,
++          cachePath,
++        })
++        .returning();
++
++      // 3. ファイルから読み込んでドメイン型に変換して返す
++      return this.convertDocumentCacheEntityToDomain(entity);
++    } catch (err) {
++      if (err instanceof AppError) throw err;
++      throw repositoryError('ドキュメントキャッシュの作成に失敗しました', err);
++    }
++  }
++
++  /** ドキュメントキャッシュ一覧を取得 */
++  async getReviewDocumentCaches(
++    reviewHistoryId: string,
++  ): Promise<ReviewDocumentCache[]> {
++    try {
++      const db = await getDb();
++      const entities = await db
++        .select()
++        .from(reviewDocumentCaches)
++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId))
++        .orderBy(reviewDocumentCaches.createdAt);
++
++      // 各EntityをDomain型に変換（ファイル読み込み含む）
++      return Promise.all(
++        entities.map((entity) =>
++          this.convertDocumentCacheEntityToDomain(entity),
++        ),
++      );
++    } catch (err) {
++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
++    }
++  }
++
++  /** documentIdでドキュメントキャッシュを取得 */
++  async getReviewDocumentCacheByDocumentId(
++    reviewHistoryId: string,
++    documentId: string,
++  ): Promise<ReviewDocumentCache | null> {
++    try {
++      const db = await getDb();
++      const [entity] = await db
++        .select()
++        .from(reviewDocumentCaches)
+         .where(
+           and(
+-            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
+-            eq(reviewChecklistResults.fileId, sourceId.toString()),
++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
++            eq(reviewDocumentCaches.documentId, documentId),
+           ),
+         );
++
++      if (!entity) return null;
++
++      return this.convertDocumentCacheEntityToDomain(entity);
+     } catch (err) {
+-      throw repositoryError('レビュー結果の削除に失敗しました', err);
++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+     }
+   }
+ 
+-  /** チェックリスト結果を取得してグルーピング */
+-  async getReviewChecklistResults(
++  /** ドキュメントキャッシュを取得（複数ID対応） */
++  async getReviewDocumentCacheByDocumentIds(
+     reviewHistoryId: string,
+-  ): Promise<ReviewChecklistResult[]> {
++    documentIds: string[],
++  ): Promise<ReviewDocumentCache[]> {
+     try {
+       const db = await getDb();
+-      const rows = await db
++      const entities = await db
++        .select()
++        .from(reviewDocumentCaches)
++        .where(
++          and(
++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
++            inArray(reviewDocumentCaches.documentId, documentIds),
++          ),
++        );
++
++      // 各EntityをDomain型に変換（ファイル読み込み含む）
++      return Promise.all(
++        entities.map((entity) =>
++          this.convertDocumentCacheEntityToDomain(entity),
++        ),
++      );
++    } catch (err) {
++      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
++    }
++  }
++
++  /** チェックリスト結果キャッシュを作成 */
++  async createReviewLargedocumentResultCache(
++    cache: ReviewLargedocumentResultCache,
++  ): Promise<void> {
++    try {
++      const db = await getDb();
++      await db.insert(reviewLargedocumentResultCaches).values({
++        reviewDocumentCacheId: cache.reviewDocumentCacheId,
++        reviewChecklistId: cache.reviewChecklistId,
++        comment: cache.comment,
++        totalChunks: cache.totalChunks,
++        chunkIndex: cache.chunkIndex,
++        individualFileName: cache.individualFileName,
++      });
++    } catch (err) {
++      throw repositoryError(
++        '大量ドキュメント結果キャッシュの作成に失敗しました',
++        err,
++      );
++    }
++  }
++
++  /** チェックリスト結果キャッシュ一覧を取得 */
++  async getReviewLargedocumentResultCaches(
++    reviewHistoryId: string,
++  ): Promise<ReviewLargedocumentResultCache[]> {
++    try {
++      const db = await getDb();
++      // reviewDocumentCachesとjoinしてreviewHistoryIdで絞り込む
++      const results = await db
+         .select({
+-          checklistId: reviewChecklists.id,
+-          content: reviewChecklists.content,
+-          fileId: reviewChecklistResults.fileId,
+-          fileName: reviewChecklistResults.fileName,
+-          evaluation: reviewChecklistResults.evaluation,
+-          comment: reviewChecklistResults.comment,
++          reviewDocumentCacheId:
++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
++          reviewChecklistId: reviewLargedocumentResultCaches.reviewChecklistId,
++          comment: reviewLargedocumentResultCaches.comment,
++          totalChunks: reviewLargedocumentResultCaches.totalChunks,
++          chunkIndex: reviewLargedocumentResultCaches.chunkIndex,
++          individualFileName:
++            reviewLargedocumentResultCaches.individualFileName,
+         })
+-        .from(reviewChecklists)
+-        .leftJoin(
+-          reviewChecklistResults,
+-          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
++        .from(reviewLargedocumentResultCaches)
++        .innerJoin(
++          reviewDocumentCaches,
++          eq(
++            reviewLargedocumentResultCaches.reviewDocumentCacheId,
++            reviewDocumentCaches.id,
++          ),
+         )
+-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+-        .orderBy(reviewChecklists.createdAt);
++        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
++
++      return results.map((row) => ({
++        reviewDocumentCacheId: row.reviewDocumentCacheId,
++        reviewChecklistId: row.reviewChecklistId,
++        comment: row.comment,
++        totalChunks: row.totalChunks,
++        chunkIndex: row.chunkIndex,
++        individualFileName: row.individualFileName,
++      }));
++    } catch (err) {
++      throw repositoryError(
++        '大量ドキュメント結果キャッシュの取得に失敗しました',
++        err,
++      );
++    }
++  }
++
++  /** 特定ドキュメントの最大totalChunks数を取得（レビューチャット用） */
++  async getMaxTotalChunksForDocument(
++    reviewHistoryId: string,
++    documentId: string,
++  ): Promise<number> {
++    try {
++      const db = await getDb();
+ 
+-      const map = new Map<number, ReviewChecklistResult>();
+-      for (const row of rows) {
+-        let group = map.get(row.checklistId);
+-        if (!group) {
+-          group = {
+-            id: row.checklistId,
+-            content: row.content,
+-            sourceEvaluations: [],
+-          };
+-          map.set(row.checklistId, group);
+-        }
+-        if (row.fileId !== null && row.fileName !== null) {
+-          group.sourceEvaluations!.push({
+-            fileId: row.fileId,
+-            fileName: row.fileName,
+-            evaluation: row.evaluation as ReviewEvaluation,
+-            comment: row.comment ?? undefined,
+-          });
+-        }
++      // まずdocumentIdからreviewDocumentCacheIdを取得
++      const [cache] = await db
++        .select({ id: reviewDocumentCaches.id })
++        .from(reviewDocumentCaches)
++        .where(
++          and(
++            eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId),
++            eq(reviewDocumentCaches.documentId, documentId),
++          ),
++        );
++
++      if (!cache) {
++        // ドキュメントキャッシュが存在しない場合は1を返す
++        return 1;
+       }
+-      return Array.from(map.values());
++
++      // 該当ドキュメントのtotalChunksの最大値を取得
++      const result = await db
++        .select({ maxChunks: max(reviewLargedocumentResultCaches.totalChunks) })
++        .from(reviewLargedocumentResultCaches)
++        .where(
++          eq(reviewLargedocumentResultCaches.reviewDocumentCacheId, cache.id),
++        );
++
++      const maxChunks = result[0]?.maxChunks;
++
++      // レコードが存在しない場合は1を返す（初回処理）
++      return maxChunks ?? 1;
+     } catch (err) {
+-      throw repositoryError('レビュー結果の取得に失敗しました', err);
++      throw repositoryError(
++        'ドキュメントの最大チャンク数取得に失敗しました',
++        err,
++      );
+     }
+   }
+ 
+-  /** すべてのレビュー結果を削除 */
+-  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
++  /** レビューチャット用: チェックリストと結果を取得 */
++  async getChecklistResultsWithIndividualResults(
++    reviewHistoryId: string,
++    checklistIds: number[],
++  ): Promise<
++    Array<{
++      checklistResult: ReviewChecklistResult;
++      individualResults?: Array<{
++        documentId: number;
++        comment: string;
++        individualFileName: string;
++      }>;
++    }>
++  > {
+     try {
+       const db = await getDb();
+-      const checklists = await db
+-        .select({ id: reviewChecklists.id })
++
++      // チェックリストを取得
++      const checklistEntities = await db
++        .select()
+         .from(reviewChecklists)
+-        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
++        .where(
++          and(
++            eq(reviewChecklists.reviewHistoryId, reviewHistoryId),
++            inArray(reviewChecklists.id, checklistIds),
++          ),
++        );
+ 
+-      // チェックリストが無ければ何もしない
+-      if (checklists.length === 0) return;
++      // 個別レビュー結果キャッシュを取得
++      const individualCaches =
++        await this.getReviewLargedocumentResultCaches(reviewHistoryId);
+ 
+-      for (const { id } of checklists) {
+-        await db
+-          .delete(reviewChecklistResults)
+-          .where(eq(reviewChecklistResults.reviewChecklistId, id));
+-      }
++      // 結果を組み立て
++      return checklistEntities.map((entity) => {
++        // 個別レビュー結果を抽出
++        const individualResults = individualCaches
++          .filter((cache) => cache.reviewChecklistId === entity.id)
++          .map((cache) => ({
++            documentId: cache.reviewDocumentCacheId,
++            comment: cache.comment,
++            individualFileName: cache.individualFileName,
++          }));
++
++        // ReviewChecklistResult型を構築
++        const checklistResult: ReviewChecklistResult = {
++          id: entity.id,
++          content: entity.content,
++          sourceEvaluation: {
++            evaluation: entity.evaluation ?? undefined,
++            comment: entity.comment ?? undefined,
++          },
++        };
++
++        return {
++          checklistResult,
++          individualResults:
++            individualResults.length > 0 ? individualResults : undefined,
++        };
++      });
+     } catch (err) {
+-      throw repositoryError('レビュー結果の削除に失敗しました', err);
++      throw repositoryError('チェックリストと結果の取得に失敗しました', err);
+     }
+   }
+ }
+diff --git a/src/adapter/db/drizzle/schema.ts b/src/adapter/db/drizzle/schema.ts
+index 39ffd9c64..20643f956 100644
+--- a/src/adapter/db/drizzle/schema.ts
++++ b/src/adapter/db/drizzle/schema.ts
+@@ -59,9 +59,11 @@ export const reviewHistories = sqliteTable('review_histories', {
+     .primaryKey()
+     .$default(() => uuidv4()), // 汎用チャット機能のコードを活用できるように、MastraのThreadと同じく主キーは文字列とする
+   title: text('title').notNull(), // ソースのtitleを/区切りで結合
++  targetDocumentName: text('target_document_name'), // レビュー対象の統合ドキュメント名
+   additionalInstructions: text('additional_instructions'), // レビューの追加指示
+   commentFormat: text('comment_format'), // レビューのコメントフォーマット
+   evaluationSettings: text('evaluation_settings'), // 評定項目設定（JSON形式）
++  documentMode: text('document_mode'), // レビュー実行方法: small, large
+   processingStatus: text('processing_status').notNull().default('idle'), // 処理ステータス: idle, extracting, extracted, reviewing, completed
+   createdAt: text('created_at')
+     .notNull()
+@@ -79,6 +81,8 @@ export const reviewChecklists = sqliteTable('review_checklists', {
+     .notNull()
+     .references(() => reviewHistories.id, { onDelete: 'cascade' }),
+   content: text('content').notNull(), // チェックリスト項目
++  evaluation: text('evaluation'), // A, B, C, - 評価
++  comment: text('comment'), // レビューコメント
+   createdBy: text('created_by').notNull(), // 'user' or 'system'
+   createdAt: text('created_at')
+     .notNull()
+@@ -89,26 +93,49 @@ export const reviewChecklists = sqliteTable('review_checklists', {
+     .$onUpdate(() => sql`(current_timestamp)`),
+ });
+ 
+-// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
+-export const reviewChecklistResults = sqliteTable(
+-  'review_checklist_results',
++// レビュードキュメントキャッシュを格納するテーブル
++export const reviewDocumentCaches = sqliteTable('review_document_caches', {
++  id: integer('id').primaryKey({ autoIncrement: true }),
++  reviewHistoryId: text('review_history_id')
++    .notNull()
++    .references(() => reviewHistories.id, { onDelete: 'cascade' }),
++  documentId: text('document_id').notNull(), // ワークフロー内のドキュメントID
++  fileName: text('file_name').notNull(), // ワークフロー内での名前（分割時は "xxx (part 1)" など）
++  processMode: text('process_mode').notNull(), // 'text' or 'image'
++  cachePath: text('cache_path').notNull(), // ファイル/ディレクトリパス
++  createdAt: text('created_at')
++    .notNull()
++    .default(sql`(current_timestamp)`),
++  updatedAt: text('updated_at')
++    .notNull()
++    .default(sql`(current_timestamp)`)
++    .$onUpdate(() => sql`(current_timestamp)`),
++});
++
++// レビュー大量ドキュメント結果キャッシュを格納するテーブル（大量ドキュメントレビューの個別レビュー結果）
++export const reviewLargedocumentResultCaches = sqliteTable(
++  'review_largedocument_result_caches',
+   {
++    reviewDocumentCacheId: integer('review_document_cache_id')
++      .notNull()
++      .references(() => reviewDocumentCaches.id, { onDelete: 'cascade' }),
+     reviewChecklistId: integer('review_checklist_id')
+       .notNull()
+       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
+-    fileId: text('file_id').notNull(), // アップロードファイルのID
+-    fileName: text('file_name').notNull(), // ファイル名
+-    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
+-    comment: text('comment'), // レビューコメント
+-    createdAt: text('created_at')
+-      .notNull()
+-      .default(sql`(current_timestamp)`),
+-    updatedAt: text('updated_at')
+-      .notNull()
+-      .default(sql`(current_timestamp)`)
+-      .$onUpdate(() => sql`(current_timestamp)`),
++    comment: text('comment').notNull(), // 個別レビューコメント
++    totalChunks: integer('total_chunks').notNull(), // ドキュメント分割総数
++    chunkIndex: integer('chunk_index').notNull(), // 何番目のチャンクか（0から始まる）
++    individualFileName: text('individual_file_name').notNull(), // 分割後の個別ドキュメント名（"xxx (part 1)" など）
+   },
+-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
++  (table) => ({
++    pk: primaryKey({
++      columns: [
++        table.reviewDocumentCacheId,
++        table.reviewChecklistId,
++        table.chunkIndex,
++      ],
++    }),
++  }),
+ );
+ 
+ // 型定義
+@@ -120,6 +147,11 @@ export type ReviewHistoryEntity = typeof reviewHistories.$inferSelect;
+ export type InsertReviewHistoryEntity = typeof reviewHistories.$inferInsert;
+ export type ReviewChecklistEntity = typeof reviewChecklists.$inferSelect;
+ export type InsertReviewChecklistEntity = typeof reviewChecklists.$inferInsert;
+-export type ReviewChecklistResultEntity = typeof reviewChecklistResults.$inferSelect;
+-export type InsertReviewChecklistResultEntity =
+-  typeof reviewChecklistResults.$inferInsert;
++export type ReviewDocumentCacheEntity =
++  typeof reviewDocumentCaches.$inferSelect;
++export type InsertReviewDocumentCacheEntity =
++  typeof reviewDocumentCaches.$inferInsert;
++export type ReviewLargedocumentResultCacheEntity =
++  typeof reviewLargedocumentResultCaches.$inferSelect;
++export type InsertReviewLargedocumentResultCacheEntity =
++  typeof reviewLargedocumentResultCaches.$inferInsert;
+diff --git a/src/adapter/db/drizzle/repository/settingsRepository.ts b/src/adapter/db/electron-store/repository/settingsRepository.ts
+similarity index 97%
+rename from src/adapter/db/drizzle/repository/settingsRepository.ts
+rename to src/adapter/db/electron-store/repository/settingsRepository.ts
+index c0ef0443c..050b2000b 100644
+--- a/src/adapter/db/drizzle/repository/settingsRepository.ts
++++ b/src/adapter/db/electron-store/repository/settingsRepository.ts
+@@ -1,6 +1,6 @@
+ import { z } from 'zod';
+ import { Settings, SettingsSchema } from '@/types';
+-import { getStore } from '@/main/store';
++import { getStore } from '@/adapter/db/electron-store/store';
+ import { repositoryError } from '@/main/lib/error';
+ import { ISettingsRepository } from '@/main/service/port/repository';
+ 
+diff --git a/src/main/store.ts b/src/adapter/db/electron-store/store.ts
+similarity index 97%
+rename from src/main/store.ts
+rename to src/adapter/db/electron-store/store.ts
+index c0b84c2bc..68036a088 100644
+--- a/src/main/store.ts
++++ b/src/adapter/db/electron-store/store.ts
+@@ -1,6 +1,6 @@
+ // @ts-ignore
+ import Store from 'electron-store';
+-import { getCustomAppDataDir } from './main';
++import { getCustomAppDataDir } from '../../../main/main';
+ // 設定の型定義
+ export interface StoreSchema {
+   database: {
+diff --git a/src/adapter/db/index.ts b/src/adapter/db/index.ts
+index 244d3fb47..d94b38fc0 100644
+--- a/src/adapter/db/index.ts
++++ b/src/adapter/db/index.ts
+@@ -6,8 +6,8 @@ import {
+ import {
+   DrizzleReviewRepository,
+   DrizzleSourceRepository,
+-  ElectronStoreSettingsRepository,
+ } from './drizzle/repository';
++import { ElectronStoreSettingsRepository } from './electron-store/repository/settingsRepository';
+ 
+ let sourceRepository: ISourceRepository | null = null;
+ 
+diff --git a/src/main/lib/csvParser.ts b/src/main/lib/csvParser.ts
+index 5a7817356..c2f82751c 100644
+--- a/src/main/lib/csvParser.ts
++++ b/src/main/lib/csvParser.ts
+@@ -101,7 +101,7 @@ export class CsvParser {
+    * @returns 空行の場合true
+    */
+   private static isEmptyRow(row: string[]): boolean {
+-    return row.every(cell => cell.trim() === '');
++    return row.every((cell) => cell.trim() === '');
+   }
+ 
+   /**
+@@ -109,7 +109,10 @@ export class CsvParser {
+    * @param csvText CSVテキスト
+    * @returns 検証結果
+    */
+-  public static validate(csvText: string): { isValid: boolean; error?: string } {
++  public static validate(csvText: string): {
++    isValid: boolean;
++    error?: string;
++  } {
+     try {
+       let inQuotes = false;
+       let quoteCount = 0;
+@@ -139,4 +142,4 @@ export class CsvParser {
+       return { isValid: false, error: `CSV解析エラー: ${error}` };
+     }
+   }
+-}
+\ No newline at end of file
++}
+diff --git a/src/main/lib/fileExtractor.ts b/src/main/lib/fileExtractor.ts
+index f7f136069..d57d7f454 100644
+--- a/src/main/lib/fileExtractor.ts
++++ b/src/main/lib/fileExtractor.ts
+@@ -166,7 +166,10 @@ export default class FileExtractor {
+ 
+       // ファイルが更新されている場合はキャッシュを無効とする
+       if (stats.mtimeMs !== cacheData.metadata.lastModified) {
+-        logger.debug({ filePath, cachePath }, 'ファイルが更新されているためキャッシュを無効化します');
++        logger.debug(
++          { filePath, cachePath },
++          'ファイルが更新されているためキャッシュを無効化します',
++        );
+         await this.deleteCache(filePath);
+         return null;
+       }
+@@ -200,7 +203,11 @@ export default class FileExtractor {
+           extractedAt: Date.now(),
+         },
+       };
+-      await fs.writeFile(cachePath, JSON.stringify(cacheData, null, 2), 'utf-8');
++      await fs.writeFile(
++        cachePath,
++        JSON.stringify(cacheData, null, 2),
++        'utf-8',
++      );
+     } catch (error) {
+       // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
+       logger.error({ error, filePath }, 'キャッシュの保存に失敗しました');
+@@ -738,14 +745,18 @@ try {
+             if (stats.mtimeMs !== cacheData.metadata.lastModified) {
+               await fs.unlink(cacheFilePath);
+               deletedCount++;
+-              logger.debug(`ファイル更新日時が古いキャッシュを削除: ${fileName}`);
++              logger.debug(
++                `ファイル更新日時が古いキャッシュを削除: ${fileName}`,
++              );
+             }
+           } catch (statError) {
+             // 元ファイルが存在しない場合は削除
+             if ((statError as NodeJS.ErrnoException).code === 'ENOENT') {
+               await fs.unlink(cacheFilePath);
+               deletedCount++;
+-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
++              logger.debug(
++                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
++              );
+             }
+           }
+         } catch (processError) {
+@@ -755,14 +766,22 @@ try {
+             deletedCount++;
+             logger.debug(`不正なキャッシュファイルを削除: ${fileName}`);
+           } catch (unlinkError) {
+-            logger.error({ error: unlinkError, fileName }, 'キャッシュファイルの削除に失敗');
++            logger.error(
++              { error: unlinkError, fileName },
++              'キャッシュファイルの削除に失敗',
++            );
+           }
+         }
+       }
+ 
+-      logger.info(`キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`);
++      logger.info(
++        `キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`,
++      );
+     } catch (error) {
+-      logger.error({ error }, 'キャッシュディレクトリのクリーニングに失敗しました');
++      logger.error(
++        { error },
++        'キャッシュディレクトリのクリーニングに失敗しました',
++      );
+     }
+   }
+ }
+diff --git a/src/main/lib/logger.ts b/src/main/lib/logger.ts
+index 0aa5282a2..b55e75012 100644
+--- a/src/main/lib/logger.ts
++++ b/src/main/lib/logger.ts
+@@ -6,7 +6,8 @@ import path from 'path';
+ const logLevel = getLogLevel();
+ log.transports.file.level = logLevel;
+ log.transports.console.level = logLevel;
+-log.transports.file.resolvePathFn = () => path.join(getCustomAppDataDir(), 'main.log');
++log.transports.file.resolvePathFn = () =>
++  path.join(getCustomAppDataDir(), 'main.log');
+ 
+ // シングルトン変数
+ let _mainLogger: Logger.MainLogger | null = null;
+diff --git a/src/main/lib/officeConverter.ts b/src/main/lib/officeConverter.ts
+index 55663f57a..fc8d0147a 100644
+--- a/src/main/lib/officeConverter.ts
++++ b/src/main/lib/officeConverter.ts
+@@ -199,9 +199,16 @@ async function saveCache(
+       cachePdfPath,
+       cachedAt: Date.now(),
+     };
+-    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf-8');
++    await fs.writeFile(
++      metadataPath,
++      JSON.stringify(metadata, null, 2),
++      'utf-8',
++    );
+ 
+-    logger.debug({ originalFilePath, cachePdfPath }, 'PDFキャッシュを保存しました');
++    logger.debug(
++      { originalFilePath, cachePdfPath },
++      'PDFキャッシュを保存しました',
++    );
+   } catch (error) {
+     // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
+     logger.error({ error, originalFilePath }, 'キャッシュの保存に失敗しました');
+@@ -789,7 +796,9 @@ export async function cleanCacheDirectory(): Promise<void> {
+               // 対応するPDFファイルも削除
+               await fs.unlink(metadata.cachePdfPath).catch(() => void 0);
+               deletedCount++;
+-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
++              logger.debug(
++                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
++              );
+             }
+           }
+         }
+diff --git a/src/main/lib/util.ts b/src/main/lib/util.ts
+index e3c43a641..9544e872f 100644
+--- a/src/main/lib/util.ts
++++ b/src/main/lib/util.ts
+@@ -32,7 +32,9 @@ export function toAbsolutePath(dirOrPath: string, fileName?: string): string {
+       throw internalError({
+         expose: false,
+         messageCode: 'VALIDATION_ERROR',
+-        messageParams: { detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。` },
++        messageParams: {
++          detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。`,
++        },
+       });
+     }
+     // ディレクトリ部を取り出して結合
+@@ -68,7 +70,9 @@ export function isPathExists(dirOrPath: string): boolean {
+     throw internalError({
+       expose: true,
+       messageCode: 'VALIDATION_ERROR',
+-      messageParams: { detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}` },
++      messageParams: {
++        detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
++      },
+     });
+   }
+ }
+diff --git a/src/main/lib/utils/reviewCacheHelper.ts b/src/main/lib/utils/reviewCacheHelper.ts
+new file mode 100644
+index 000000000..fd2f7659b
+--- /dev/null
++++ b/src/main/lib/utils/reviewCacheHelper.ts
+@@ -0,0 +1,127 @@
++import * as fs from 'fs/promises';
++import * as path from 'path';
++import { app } from 'electron';
++
++/**
++ * レビュー機能で使用するキャッシュファイルの管理ヘルパークラス
++ */
++export class ReviewCacheHelper {
++  /**
++   * キャッシュベースディレクトリ取得
++   */
++  private static getCacheBaseDir(reviewHistoryId: string): string {
++    return path.join(
++      app.getPath('userData'),
++      'review_cache',
++      reviewHistoryId,
++      'file_cache',
++    );
++  }
++
++  /**
++   * テキストキャッシュ保存
++   * @param reviewHistoryId レビュー履歴ID
++   * @param documentId ドキュメントID
++   * @param content テキスト内容
++   * @returns ファイルパス
++   */
++  static async saveTextCache(
++    reviewHistoryId: string,
++    documentId: string,
++    content: string,
++  ): Promise<string> {
++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
++    await fs.mkdir(baseDir, { recursive: true });
++
++    const cachePath = path.join(baseDir, `${documentId}.txt`);
++    await fs.writeFile(cachePath, content, 'utf-8');
++
++    return cachePath;
++  }
++
++  /**
++   * 画像キャッシュ保存（複数ページ対応）
++   * @param reviewHistoryId レビュー履歴ID
++   * @param documentId ドキュメントID
++   * @param imageData Base64画像データ配列
++   * @returns ディレクトリパス
++   */
++  static async saveImageCache(
++    reviewHistoryId: string,
++    documentId: string,
++    imageData: string[],
++  ): Promise<string> {
++    const baseDir = this.getCacheBaseDir(reviewHistoryId);
++    const imageCacheDir = path.join(baseDir, documentId);
++    await fs.mkdir(imageCacheDir, { recursive: true });
++
++    for (let i = 0; i < imageData.length; i++) {
++      const pagePath = path.join(imageCacheDir, `page_${i}.b64`);
++      await fs.writeFile(pagePath, imageData[i], 'utf-8');
++    }
++
++    return imageCacheDir;
++  }
++
++  /**
++   * テキストキャッシュ読み込み
++   * @param cachePath ファイルパス
++   * @returns テキスト内容
++   * @throws ファイルが存在しない場合やアクセスできない場合にエラーをスロー
++   */
++  static async loadTextCache(cachePath: string): Promise<string> {
++    try {
++      return await fs.readFile(cachePath, 'utf-8');
++    } catch (error) {
++      // ファイルが存在しない、またはアクセスできない場合
++      throw new Error(
++        `Failed to load text cache from ${cachePath}: ${error instanceof Error ? error.message : String(error)}`,
++      );
++    }
++  }
++
++  /**
++   * 画像キャッシュ読み込み
++   * @param cacheDir ディレクトリパス
++   * @returns Base64画像データ配列
++   * @throws ディレクトリが存在しない場合やアクセスできない場合にエラーをスロー
++   */
++  static async loadImageCache(cacheDir: string): Promise<string[]> {
++    try {
++      const files = await fs.readdir(cacheDir);
++      const imageFiles = files
++        .filter((f) => f.endsWith('.b64'))
++        .sort((a, b) => {
++          const aNum = parseInt(a.match(/page_(\d+)\.b64/)?.[1] || '0');
++          const bNum = parseInt(b.match(/page_(\d+)\.b64/)?.[1] || '0');
++          return aNum - bNum;
++        });
++
++      const imageData: string[] = [];
++      for (const file of imageFiles) {
++        const content = await fs.readFile(path.join(cacheDir, file), 'utf-8');
++        imageData.push(content);
++      }
++
++      return imageData;
++    } catch (error) {
++      // ディレクトリが存在しない、またはアクセスできない場合
++      throw new Error(
++        `Failed to load image cache from ${cacheDir}: ${error instanceof Error ? error.message : String(error)}`,
++      );
++    }
++  }
++
++  /**
++   * キャッシュディレクトリ削除
++   * @param reviewHistoryId レビュー履歴ID
++   */
++  static async deleteCacheDirectory(reviewHistoryId: string): Promise<void> {
++    const cacheDir = path.join(
++      app.getPath('userData'),
++      'review_cache',
++      reviewHistoryId,
++    );
++    await fs.rm(cacheDir, { recursive: true, force: true });
++  }
++}
+diff --git a/src/main/main.ts b/src/main/main.ts
+index 047392026..605d337f2 100644
+--- a/src/main/main.ts
++++ b/src/main/main.ts
+@@ -272,12 +272,7 @@ const setupChatHandlers = () => {
+     IpcChannels.CHAT_SEND_MESSAGE,
+     async ({ roomId, messages }, { event }) => {
+       try {
+-        const dataStream = await chatService.generate(
+-          userId,
+-          roomId,
+-          messages,
+-          event,
+-        );
++        const dataStream = await chatService.generate(userId, roomId, messages);
+ 
+         // テキストストリームを処理
+         // @ts-ignore
+@@ -542,6 +537,43 @@ const setupReviewHandlers = () => {
+     }
+     return undefined as never;
+   });
++
++  // レビューチャットメッセージ送信ハンドラ
++  handleIpc(
++    IpcChannels.REVIEW_CHAT_SEND_MESSAGE,
++    async ({ reviewHistoryId, checklistIds, question }) => {
++      try {
++        const dataStream = await reviewService.chatWithReview(
++          reviewHistoryId,
++          checklistIds,
++          question,
++        );
++
++        // テキストストリームを処理
++        // @ts-ignore
++        for await (const chunk of dataStream) {
++          // チャンクをフロントエンドに送信
++          publishEvent(IpcChannels.REVIEW_CHAT_STREAM_RESPONSE, chunk);
++        }
++
++        return undefined as never;
++      } catch (error) {
++        // エラー時もAbortControllerを削除
++        reviewService.abortReviewChat(reviewHistoryId);
++        const normalizedError = normalizeUnknownError(error);
++        publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
++          message: normalizedError.message,
++        });
++        throw normalizedError;
++      }
++    },
++  );
++
++  // レビューチャット中断ハンドラ
++  handleIpc(IpcChannels.REVIEW_CHAT_ABORT, async (reviewHistoryId) => {
++    const result = reviewService.abortReviewChat(reviewHistoryId);
++    return undefined as never;
++  });
+ };
+ 
+ // ソース登録処理の実行
+diff --git a/src/main/preload.ts b/src/main/preload.ts
+index fa8d0f9c8..c32d7113f 100644
+--- a/src/main/preload.ts
++++ b/src/main/preload.ts
+@@ -147,6 +147,13 @@ const electronHandler = {
+     /** レビュー実行キャンセル */
+     abortExecute: (reviewHistoryId: string) =>
+       invokeIpc(IpcChannels.REVIEW_EXECUTE_ABORT, reviewHistoryId),
++    /** レビューチャットメッセージ送信 */
++    sendChatMessage: (
++      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE],
++    ) => invokeIpc(IpcChannels.REVIEW_CHAT_SEND_MESSAGE, params),
++    /** レビューチャット中断 */
++    abortChat: (reviewHistoryId: string) =>
++      invokeIpc(IpcChannels.REVIEW_CHAT_ABORT, reviewHistoryId),
+   },
+   pushApi: {
+     async subscribe<C extends EventChannel>(
+diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
+index 43df9c6a8..625443fe6 100644
+--- a/src/main/service/chatService.ts
++++ b/src/main/service/chatService.ts
+@@ -120,7 +120,6 @@ export class ChatService implements IChatService {
+     userId: string,
+     threadId: string,
+     messages: ChatMessage[],
+-    event: Electron.IpcMainInvokeEvent,
+   ) {
+     // 新しいAbortControllerを作成
+     const controller = this.abortControllerManager.getOrCreateAbortController(
+diff --git a/src/main/service/port/repository/IReviewRepository.ts b/src/main/service/port/repository/IReviewRepository.ts
+index b558873e1..60b64222e 100644
+--- a/src/main/service/port/repository/IReviewRepository.ts
++++ b/src/main/service/port/repository/IReviewRepository.ts
+@@ -1,10 +1,13 @@
+ import {
+   CustomEvaluationSettings,
++  DocumentMode,
+   ProcessingStatus,
+   RevieHistory,
+   ReviewChecklist,
+   ReviewChecklistCreatedBy,
+   ReviewChecklistResult,
++  ReviewDocumentCache,
++  ReviewLargedocumentResultCache,
+   ReviewEvaluation,
+ } from '@/types';
+ 
+@@ -30,6 +33,10 @@ export interface IReviewRepository {
+     id: string,
+     processingStatus: ProcessingStatus,
+   ): Promise<void>;
++  updateReviewHistoryTargetDocumentName(
++    id: string,
++    targetDocumentName: string,
++  ): Promise<void>;
+   deleteReviewHistory(id: string): Promise<void>;
+ 
+   // チェックリスト
+@@ -49,16 +56,59 @@ export interface IReviewRepository {
+       reviewChecklistId: number;
+       evaluation: ReviewEvaluation;
+       comment: string;
+-      fileId: string;
+-      fileName: string;
+     }[],
+   ): Promise<void>;
+-  deleteReviewResults(
+-    reviewChecklistId: number,
+-    sourceId: number,
+-  ): Promise<void>;
+   getReviewChecklistResults(
+     reviewHistoryId: string,
+   ): Promise<ReviewChecklistResult[]>;
+   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
++
++  // documentModeの保存
++  updateReviewHistoryDocumentMode(
++    id: string,
++    documentMode: DocumentMode,
++  ): Promise<void>;
++
++  // ドキュメントキャッシュ管理
++  createReviewDocumentCache(
++    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
++  ): Promise<ReviewDocumentCache>;
++  getReviewDocumentCaches(
++    reviewHistoryId: string,
++  ): Promise<ReviewDocumentCache[]>;
++  getReviewDocumentCacheByDocumentId(
++    reviewHistoryId: string,
++    documentId: string,
++  ): Promise<ReviewDocumentCache | null>;
++  getReviewDocumentCacheByDocumentIds(
++    reviewHistoryId: string,
++    documentIds: string[],
++  ): Promise<ReviewDocumentCache[]>;
++
++  // 大量ドキュメント結果キャッシュ管理
++  createReviewLargedocumentResultCache(
++    cache: ReviewLargedocumentResultCache,
++  ): Promise<void>;
++  getReviewLargedocumentResultCaches(
++    reviewHistoryId: string,
++  ): Promise<ReviewLargedocumentResultCache[]>;
++  getMaxTotalChunksForDocument(
++    reviewHistoryId: string,
++    documentId: string,
++  ): Promise<number>;
++
++  // レビューチャット用: チェックリスト結果と個別レビュー結果を取得
++  getChecklistResultsWithIndividualResults(
++    reviewHistoryId: string,
++    checklistIds: number[],
++  ): Promise<
++    Array<{
++      checklistResult: ReviewChecklistResult;
++      individualResults?: Array<{
++        documentId: number;
++        comment: string;
++        individualFileName: string;
++      }>;
++    }>
++  >;
+ }
+diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
+index c65bd4539..8ced9789e 100644
+--- a/src/main/service/reviewService.ts
++++ b/src/main/service/reviewService.ts
+@@ -1,3 +1,7 @@
++import { createDataStream } from 'ai';
++// @ts-ignore
++import { RuntimeContext } from '@mastra/core/runtime-context';
++import { v4 as uuid } from 'uuid';
+ import { getReviewRepository } from '@/adapter/db';
+ import {
+   ReviewChecklistEdit,
+@@ -20,11 +24,14 @@ import { getMainLogger } from '../lib/logger';
+ import { mastra } from '@/mastra';
+ import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
+ import { formatMessage } from '../lib/messages';
++import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
++import { ReviewChatWorkflowRuntimeContext } from '@/mastra/workflows/reviewChat';
+ 
+ export interface IReviewService {
+   getReviewHistories(): Promise<RevieHistory[]>;
+   getReviewHistoryDetail(reviewHistoryId: string): Promise<{
+     checklistResults: ReviewChecklistResult[];
++    targetDocumentName?: string | null;
+   }>;
+   getReviewInstruction(reviewHistoryId: string): Promise<{
+     additionalInstructions?: string;
+@@ -49,6 +56,15 @@ export interface IReviewService {
+     reviewHistoryId: string,
+     files: UploadFile[],
+   ): Promise<void>;
++  chatWithReview(
++    reviewHistoryId: string,
++    checklistIds: number[],
++    question: string,
++  ): Promise<ReturnType<typeof createDataStream>>;
++  abortReviewChat(reviewHistoryId: string): {
++    success: boolean;
++    error?: string;
++  };
+ }
+ 
+ const logger = getMainLogger();
+@@ -82,8 +98,11 @@ export class ReviewService implements IReviewService {
+   public async getReviewHistoryDetail(reviewHistoryId: string) {
+     const checklistResults =
+       await this.reviewRepository.getReviewChecklistResults(reviewHistoryId);
++    const reviewHistory =
++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
+     return {
+       checklistResults: checklistResults,
++      targetDocumentName: reviewHistory?.targetDocumentName,
+     };
+   }
+ 
+@@ -105,7 +124,18 @@ export class ReviewService implements IReviewService {
+    * レビュー履歴を削除
+    */
+   public async deleteReviewHistory(reviewHistoryId: string) {
+-    return this.reviewRepository.deleteReviewHistory(reviewHistoryId);
++    await this.reviewRepository.deleteReviewHistory(reviewHistoryId);
++
++    // キャッシュディレクトリも削除
++    try {
++      await ReviewCacheHelper.deleteCacheDirectory(reviewHistoryId);
++    } catch (err) {
++      // キャッシュ削除失敗はログのみ（DB削除は成功しているため）
++      logger.warn(
++        err,
++        `キャッシュディレクトリの削除に失敗しました: ${reviewHistoryId}`,
++      );
++    }
+   }
+ 
+   /**
+@@ -116,7 +146,8 @@ export class ReviewService implements IReviewService {
+     checklistEdits: ReviewChecklistEdit[],
+   ) {
+     // レビュー履歴が存在しない場合は新規作成
+-    let reviewHistory = await this.reviewRepository.getReviewHistory(reviewHistoryId);
++    let reviewHistory =
++      await this.reviewRepository.getReviewHistory(reviewHistoryId);
+     if (reviewHistory === null) {
+       reviewHistory = await this.reviewRepository.createReviewHistory(
+         generateReviewTitle(),
+@@ -197,7 +228,9 @@ export class ReviewService implements IReviewService {
+       }
+ 
+       // システム作成のチェックリストを削除（手動作成分は保持）
+-      await this.reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
++      await this.reviewRepository.deleteSystemCreatedChecklists(
++        reviewHistoryId,
++      );
+ 
+       const allChecklistItems: string[] = [];
+ 
+@@ -223,7 +256,11 @@ export class ReviewService implements IReviewService {
+ 
+       // チェックリスト項目をDBに保存
+       for (const item of uniqueChecklistItems) {
+-        await this.reviewRepository.createChecklist(reviewHistoryId, item, 'system');
++        await this.reviewRepository.createChecklist(
++          reviewHistoryId,
++          item,
++          'system',
++        );
+       }
+       // AI処理と同様のイベント通知を発火
+       publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
+@@ -660,4 +697,147 @@ export class ReviewService implements IReviewService {
+       return { success: false, error: err.message };
+     }
+   }
++
++  /**
++   * レビューチャット実行
++   * @param reviewHistoryId レビュー履歴ID
++   * @param checklistIds チェックリストID配列
++   * @param question ユーザからの質問
++   * @returns DataStream
++   */
++  public async chatWithReview(
++    reviewHistoryId: string,
++    checklistIds: number[],
++    question: string,
++  ): Promise<ReturnType<typeof createDataStream>> {
++    // DataStreamを生成
++    const dataStream = createDataStream({
++      execute: async (writer) => {
++        try {
++          // Mastraワークフローを取得
++          const workflow = mastra.getWorkflow('reviewChatWorkflow');
++
++          if (!workflow) {
++            logger.error('レビュー実行ワークフローが見つかりません');
++            throw internalError({
++              expose: false,
++            });
++          }
++
++          // 質問テキストから本文のみを抽出
++          // フォーマット: @チェックリスト行 + 空行 + 本文
++          const lines = question.split('\n');
++          const bodyLines: string[] = [];
++          let foundEmptyLine = false;
++
++          for (const line of lines) {
++            // @で始まる行は除外
++            if (line.trim().startsWith('@')) {
++              continue;
++            }
++
++            // 最初の空行を見つけた後から本文開始
++            if (!foundEmptyLine && line.trim() === '') {
++              foundEmptyLine = true;
++              continue;
++            }
++
++            // 空行を見つけた後の行を本文として抽出
++            if (foundEmptyLine) {
++              bodyLines.push(line);
++            }
++          }
++
++          const bodyText = bodyLines.join('\n').trim();
++
++          // ランタイムコンテキストを作成
++          const runtimeContext =
++            new RuntimeContext<ReviewChatWorkflowRuntimeContext>();
++          runtimeContext.set('dataStreamWriter', writer);
++          runtimeContext.set('toolCallId', uuid());
++
++          const run = await workflow.createRunAsync();
++
++          // workflowをrunningWorkflowsに登録
++          const workflowKey = `chat_${reviewHistoryId}`;
++
++          // 実行中のワークフローを管理
++          this.runningWorkflows.set(workflowKey, {
++            cancel: () => run.cancel(),
++          });
++
++          // ストリーミングはworkflow内部で実行されるため、ここでは結果を待つだけ
++          const result = await run.start({
++            inputData: {
++              reviewHistoryId,
++              checklistIds,
++              question: bodyText,
++            },
++            runtimeContext,
++          });
++
++          const checkResult = checkWorkflowResult(result);
++
++          // 処理が完了したらworkflowを削除
++          this.runningWorkflows.delete(workflowKey);
++
++          if (checkResult.status !== 'success') {
++            throw internalError({
++              expose: true,
++              messageCode: 'PLAIN_MESSAGE',
++              messageParams: {
++                message: checkResult.errorMessage || '不明なエラー',
++              },
++            });
++          }
++        } catch (error) {
++          logger.error(error, 'レビューチャット実行に失敗しました');
++          // エラー時もworkflowを削除
++          this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
++          throw error;
++        }
++      },
++      onError: (error) => {
++        logger.error(error, 'レビューチャット中にエラーが発生');
++        // エラー時もworkflowを削除
++        this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
++        const normalizedError = normalizeUnknownError(error);
++        return normalizedError.message;
++      },
++    });
++
++    return dataStream;
++  }
++
++  /**
++   * レビューチャット中断
++   * @param reviewHistoryId レビュー履歴ID
++   */
++  public abortReviewChat(reviewHistoryId: string): {
++    success: boolean;
++    error?: string;
++  } {
++    try {
++      const workflowKey = `chat_${reviewHistoryId}`;
++      const runningWorkflow = this.runningWorkflows.get(workflowKey);
++      if (runningWorkflow) {
++        runningWorkflow.cancel();
++        this.runningWorkflows.delete(workflowKey);
++        logger.info(`レビューチャットをキャンセルしました: ${reviewHistoryId}`);
++        return { success: true };
++      } else {
++        logger.warn(
++          `キャンセル対象のレビューチャットが見つかりません: ${reviewHistoryId}`,
++        );
++        return {
++          success: false,
++          error: 'キャンセル対象の処理が見つかりません',
++        };
++      }
++    } catch (error) {
++      logger.error(error, 'レビューチャットのキャンセルに失敗しました');
++      const err = normalizeUnknownError(error);
++      return { success: false, error: err.message };
++    }
++  }
+ }
+diff --git a/src/main/service/settingsService.ts b/src/main/service/settingsService.ts
+index 5882d1d96..682726a8a 100644
+--- a/src/main/service/settingsService.ts
++++ b/src/main/service/settingsService.ts
+@@ -257,13 +257,17 @@ export class SettingsService implements ISettingsService {
+       publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: true });
+     } catch (error) {
+       // 設定更新完了イベントを発行（失敗）
+-      const errorMessage = error instanceof Error ? error.message : '不明なエラーが発生しました';
+-      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: false, error: errorMessage });
++      const errorMessage =
++        error instanceof Error ? error.message : '不明なエラーが発生しました';
++      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, {
++        success: false,
++        error: errorMessage,
++      });
+ 
+       // エラーを再throw
+       throw error;
+     }
+-  }
++  };
+   /**
+    * 設定を取得する
+    */
+diff --git a/src/mastra/agents/model/openAICompatible.ts b/src/mastra/agents/model/openAICompatible.ts
+index c741004b1..158e92301 100644
+--- a/src/mastra/agents/model/openAICompatible.ts
++++ b/src/mastra/agents/model/openAICompatible.ts
+@@ -14,7 +14,10 @@ export const getOpenAICompatibleModel = ({
+     throw internalError({
+       expose: true,
+       messageCode: 'VALIDATION_ERROR',
+-      messageParams: { detail: 'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。' },
++      messageParams: {
++        detail:
++          'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。',
++      },
+     });
+   }
+ 
+diff --git a/src/mastra/agents/orchestrator.ts b/src/mastra/agents/orchestrator.ts
+index 66730c8c7..6b85b70c4 100644
+--- a/src/mastra/agents/orchestrator.ts
++++ b/src/mastra/agents/orchestrator.ts
+@@ -6,7 +6,7 @@ import { Memory } from '@mastra/memory';
+ import { TokenLimiter } from '@mastra/memory/processors';
+ // @ts-ignore
+ import { LibSQLStore } from '@mastra/libsql';
+-import { getStore } from '@/main/store';
++import { getStore } from '@/adapter/db/electron-store/store';
+ import { getOrchestratorSystemPrompt } from './prompts';
+ import { getOpenAICompatibleModel } from './model/openAICompatible';
+ import { isPathExists, toAbsoluteFileURL } from '@/main/lib/util';
+diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
+index ed443613a..9f5ce1fa5 100644
+--- a/src/mastra/agents/prompts.ts
++++ b/src/mastra/agents/prompts.ts
+@@ -8,11 +8,11 @@ import {
+   ReviewExecuteAgentRuntimeContext,
+   TopicExtractionAgentRuntimeContext,
+   TopicChecklistAgentRuntimeContext,
+-  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
+-  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
+-  ReviewAnswerQuestionAgentRuntimeContext,
+   IndividualDocumentReviewAgentRuntimeContext,
+   ConsolidateReviewAgentRuntimeContext,
++  ReviewChatPlanningAgentRuntimeContext,
++  ReviewChatResearchAgentRuntimeContext,
++  ReviewChatAnswerAgentRuntimeContext,
+ } from './workflowAgents';
+ 
+ /**
+@@ -576,6 +576,237 @@ ${additionalInstructions}
+ Remember: Your thorough analysis of this document part is crucial for achieving an excellent final consolidated review. Include all relevant details that will contribute to the overall document assessment.`;
+ }
+ 
++// レビューチャット：調査計画作成用のプロンプト
++export function getReviewChatPlanningPrompt({
++  runtimeContext,
++}: {
++  runtimeContext: RuntimeContext<ReviewChatPlanningAgentRuntimeContext>;
++}): string {
++  const availableDocuments = runtimeContext.get('availableDocuments');
++  const checklistInfo = runtimeContext.get('checklistInfo');
++
++  const documentList = availableDocuments
++    .map((doc) => `- ID: ${doc.id}, Name: ${doc.fileName}`)
++    .join('\n');
++
++  return `You are a professional document analysis coordinator specializing in review result investigation.
++
++CONTEXT:
++You are helping answer user questions about document review results. You have access to:
++1. The original reviewed documents
++2. Review results including evaluations and comments for specific checklist items
++
++AVAILABLE DOCUMENTS:
++${documentList}
++
++CHECKLIST REVIEW INFORMATION:
++${checklistInfo}
++
++YOUR TASK:
++Create an efficient research plan to answer the user's question by identifying:
++1. Which documents contain relevant information
++2. What specific aspects to investigate in each document
++3. How the investigation relates to the review results
++
++STRATEGIC PLANNING GUIDELINES:
++
++**Question Analysis:**
++- Understand the user's intent: Are they asking about evaluation reasoning, improvement suggestions, specific document content, or discrepancies in the review?
++- Identify keywords and concepts that connect to the checklist items and review comments
++- Determine if the question relates to specific checklist items or general document content
++
++**Document Selection Strategy:**
++- **Prioritize efficiency**: Select ONLY documents that are likely to contain relevant information
++- Use the review results to guide your selection:
++  * If asking about a specific evaluation or comment, focus on documents mentioned in those review results
++  * If asking about document content, identify which documents are most likely to contain that information
++  * Consider the review context: documents with lower ratings or specific comments may need investigation
++
++**Research Instructions Quality:**
++- Be SPECIFIC and FOCUSED in your research instructions
++- Clearly state what information to extract (e.g., "Find the section describing the testing methodology and extract the specific test types mentioned")
++- Connect the research to the review context when relevant (e.g., "Verify the claim in the review comment that the security measures are incomplete")
++- Prioritize targeted investigation over broad exploration
++
++**Efficiency Considerations:**
++- Minimize the number of documents to investigate (only select what's necessary)
++- Avoid redundant investigations across multiple documents unless truly needed
++- Focus research instructions on finding specific information rather than general overviews
++
++OUTPUT REQUIREMENTS:
++For each document that needs investigation, provide:
++- **Document ID**: The exact ID from the available documents list above
++- **Research Instructions**: Detailed, focused instructions explaining:
++  * What specific information to look for
++  * How it relates to the user's question
++  * Connection to review results if applicable
++- **Reasoning**: Brief explanation (1-2 sentences) of why this document is necessary for answering the question
++
++IMPORTANT:
++- Create a focused, efficient plan - quality over quantity
++- Your research plan will be executed in parallel across multiple documents
++- Each investigation will be conducted independently, so make instructions self-contained and clear`;
++}
++
++// レビューチャット：個別ドキュメント調査用のプロンプト
++export function getReviewChatResearchPrompt({
++  runtimeContext,
++}: {
++  runtimeContext: RuntimeContext<ReviewChatResearchAgentRuntimeContext>;
++}): string {
++  const totalChunks = runtimeContext.get('totalChunks');
++  const chunkIndex = runtimeContext.get('chunkIndex');
++  const fileName = runtimeContext.get('fileName');
++  const checklistInfo = runtimeContext.get('checklistInfo');
++  const userQuestion = runtimeContext.get('userQuestion');
++
++  // ドキュメントが分割されているかどうかで異なるプロンプトを生成
++  const isChunked = totalChunks > 1;
++
++  const contextSection = isChunked
++    ? `
++IMPORTANT DOCUMENT CONTEXT:
++- You are reviewing a PORTION (chunk ${chunkIndex + 1} of ${totalChunks}) of the document "${fileName}"
++- This document has been split into ${totalChunks} parts due to length constraints
++- You can ONLY see the content of this specific chunk (${chunkIndex + 1}/${totalChunks})
++- Other parts of the document exist but are NOT visible to you in this analysis
++- Information may be incomplete or cut off at chunk boundaries
++
++CRITICAL INSTRUCTIONS FOR CHUNKED DOCUMENTS:
++- Report ONLY what you can find in THIS chunk
++- If the requested information is not in this chunk, clearly state: "The information is not found in this portion (chunk ${chunkIndex + 1}/${totalChunks}) of the document"
++- Do NOT speculate about what might be in other chunks
++- If information appears to be cut off or incomplete at the beginning or end, note this explicitly
++- Be aware that context from previous or subsequent chunks may be missing
++`
++    : `
++DOCUMENT CONTEXT:
++- You are reviewing the complete document "${fileName}"
++- The full document content is available for your analysis
++- You have access to all information needed to answer the research question
++`;
++
++  return `You are a professional document researcher specializing in detailed document analysis.
++
++Your task is to conduct a specific investigation on the provided document based on the given research instructions.
++
++BACKGROUND CONTEXT:
++This research is being conducted to help answer the following user question about a document review:
++
++User Question:
++${userQuestion}
++
++The review was conducted based on the following checklist(s):
++${checklistInfo}
++
++Understanding this context will help you focus your investigation on information that is truly relevant to answering the user's question about the review results.
++${contextSection}
++RESEARCH GUIDELINES:
++1. Carefully read and analyze the provided document content with the user's question and checklist context in mind
++2. Follow the specific research instructions precisely
++3. Extract all relevant information related to the research topic
++4. Consider how your findings relate to the checklist items and review results mentioned above
++5. Cite specific sections, headings, page indicators, or other references where information is found
++6. If information appears incomplete or ambiguous, note this clearly${isChunked ? ' (especially at chunk boundaries)' : ''}
++7. Document your findings comprehensively - do not summarize or omit details
++${isChunked ? '8. Remember: you can only report on what is visible in THIS chunk' : ''}
++
++OUTPUT REQUIREMENTS:
++- Provide detailed research findings in Japanese
++- Include specific citations and references from the document${isChunked ? ` (mention this is from chunk ${chunkIndex + 1}/${totalChunks} if relevant)` : ''}
++- Note any limitations or gaps in the available information${isChunked ? ' within this chunk' : ''}
++- Structure your findings clearly for easy integration into the final answer
++${isChunked ? `- If the requested information is not in this chunk, explicitly state that it was not found in this portion` : ''}`;
++}
++
++// レビューチャット：最終回答生成用のプロンプト
++export function getReviewChatAnswerPrompt({
++  runtimeContext,
++}: {
++  runtimeContext: RuntimeContext<ReviewChatAnswerAgentRuntimeContext>;
++}): string {
++  const userQuestion = runtimeContext.get('userQuestion');
++  const checklistInfo = runtimeContext.get('checklistInfo');
++
++  return `You are a senior document review specialist responsible for synthesizing research findings into comprehensive answers.
++
++CONTEXT:
++You are answering questions about document review results. You have access to:
++1. The user's original question
++2. Review results with evaluations and comments for specific checklist items
++3. Research findings from individual document investigations
++
++USER QUESTION:
++${userQuestion}
++
++CHECKLIST CONTEXT:
++${checklistInfo}
++
++YOUR TASK:
++Integrate all research findings and provide a clear, accurate, and comprehensive answer to the user's question.
++
++SYNTHESIS GUIDELINES:
++
++**Understanding the Research Results:**
++- You will receive research findings from one or more documents
++- Each finding may come from a complete document OR from a portion of a document (chunk)
++- Some findings may indicate "information not found in this portion" - this is expected for chunked documents
++- Consider ALL findings together to build a complete picture
++
++**Integration Strategy:**
++1. **Identify Relevant Information:**
++   - Extract key information from each research finding that addresses the user's question
++   - Pay attention to specific citations, section references, and evidence provided
++   - Distinguish between definitive findings and tentative/partial information
++
++2. **Handle Chunked Document Results:**
++   - If research findings mention "chunk X/Y" or "this portion", the document was split for analysis
++   - Combine findings from multiple chunks of the same document to form a complete view
++   - If some chunks report "information not found", don't assume the information doesn't exist - it may be in other chunks
++
++3. **Resolve Contradictions:**
++   - If findings from different sources contradict each other:
++     * Present both perspectives
++     * Explain the discrepancy clearly
++     * Cite specific sources for each perspective
++     * Offer reasoning if one source seems more authoritative
++
++4. **Synthesize into a Coherent Answer:**
++   - Organize information logically to directly answer the question
++   - Connect findings to the review context (evaluations, comments) when relevant
++   - Build a narrative that flows naturally, not just a list of findings
++
++**Citation and Reference Guidelines:**
++- **Document Names**: Use natural document names without mentioning chunk numbers (e.g., "設計書.pdf" not "設計書.pdf chunk 2/3")
++- **Specific Citations**: Include section names, headings, page indicators, or other specific references from the research findings
++- **Attribution**: Clearly attribute information to sources (e.g., "設計書.pdfの第3章によると...")
++- **Avoid Internal Process Terms**: Do not mention "chunk", "research findings", "investigation" or similar internal process terminology
++
++**Handling Incomplete Information:**
++- If critical information is missing or unclear, state this explicitly in Japanese
++- Suggest what additional information would be needed
++- Distinguish between:
++  * Information that definitely doesn't exist in the documents
++  * Information that wasn't found but might exist elsewhere
++  * Information that is ambiguous or unclear
++
++OUTPUT REQUIREMENTS:
++- **Language**: Answer in Japanese, matching the style and formality of the user's question
++- **Structure**: Organize the answer clearly and logically:
++  * Start with a direct answer to the main question if possible
++  * Provide supporting details and evidence
++  * Conclude with any caveats or additional context
++- **Tone**: Professional, informative, and helpful
++- **Completeness**: Address all aspects of the user's question
++- **Natural Expression**: Write as if you reviewed the documents directly - avoid mentioning the research process
++
++CRITICAL REMINDERS:
++- Your answer represents the final response to the user
++- Quality and accuracy are paramount
++- Provide value by synthesizing information, not just repeating findings
++- Be honest about limitations while maximizing usefulness of available information`;
++}
++
+ // レビュー結果統合用のプロンプト
+ export function getConsolidateReviewPrompt({
+   runtimeContext,
+diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
+index ad0371265..f45e92522 100644
+--- a/src/mastra/agents/workflowAgents.ts
++++ b/src/mastra/agents/workflowAgents.ts
+@@ -14,6 +14,9 @@ import {
+   getDocumentReviewExecutionPrompt,
+   getIndividualDocumentReviewPrompt,
+   getConsolidateReviewPrompt,
++  getReviewChatPlanningPrompt,
++  getReviewChatResearchPrompt,
++  getReviewChatAnswerPrompt,
+ } from './prompts';
+ import { getOpenAICompatibleModel } from './model/openAICompatible';
+ import { BaseRuntimeContext } from './types';
+@@ -44,32 +47,37 @@ export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
+   checklistRequirements?: string;
+ };
+ 
+-export type ReviewCheckReviewReadinessFirstRunAgentRuntimeContext = BaseRuntimeContext & {
++export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
+   checklistItems: { id: number; content: string }[];
+   additionalInstructions?: string;
++  commentFormat?: string;
+ };
+ 
+-export type ReviewCheckReviewReadinessSubsequentAgentRuntimeContext = BaseRuntimeContext & {
++export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
+   checklistItems: { id: number; content: string }[];
+   additionalInstructions?: string;
+-  priorQnA: { documentId: string; documentName: string; qna: { question: string; answer: string }[] }[];
++  commentFormat?: string;
++  evaluationSettings?: CustomEvaluationSettings;
+ };
+ 
+-export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
+-  checklistItems: { id: number; content: string }[];
++// レビューチャット用エージェント
++export type ReviewChatPlanningAgentRuntimeContext = BaseRuntimeContext & {
++  availableDocuments: { id: string; fileName: string }[];
++  checklistInfo: string; // チェックリスト情報のテキスト
+ };
+ 
+-export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
+-  checklistItems: { id: number; content: string }[];
+-  additionalInstructions?: string;
+-  commentFormat?: string;
++export type ReviewChatResearchAgentRuntimeContext = BaseRuntimeContext & {
++  researchContent: string; // 調査内容
++  totalChunks: number; // ドキュメントの総チャンク数
++  chunkIndex: number; // 現在のチャンクインデックス
++  fileName: string; // ドキュメント名
++  checklistInfo: string; // チェックリスト情報（内容とレビュー結果）
++  userQuestion: string; // ユーザからの質問
+ };
+ 
+-export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
+-  checklistItems: { id: number; content: string }[];
+-  additionalInstructions?: string;
+-  commentFormat?: string;
+-  evaluationSettings?: CustomEvaluationSettings;
++export type ReviewChatAnswerAgentRuntimeContext = BaseRuntimeContext & {
++  userQuestion: string; // ユーザからの質問
++  checklistInfo: string; // チェックリスト情報のテキスト
+ };
+ 
+ export const summarizeSourceAgent = new Agent({
+@@ -139,3 +147,21 @@ export const consolidateReviewAgent = new Agent({
+   instructions: getConsolidateReviewPrompt,
+   model: getOpenAICompatibleModel,
+ });
++
++export const reviewChatPlanningAgent = new Agent({
++  name: 'reviewChatPlanningAgent',
++  instructions: getReviewChatPlanningPrompt,
++  model: getOpenAICompatibleModel,
++});
++
++export const reviewChatResearchAgent = new Agent({
++  name: 'reviewChatResearchAgent',
++  instructions: getReviewChatResearchPrompt,
++  model: getOpenAICompatibleModel,
++});
++
++export const reviewChatAnswerAgent = new Agent({
++  name: 'reviewChatAnswerAgent',
++  instructions: getReviewChatAnswerPrompt,
++  model: getOpenAICompatibleModel,
++});
+diff --git a/src/mastra/index.ts b/src/mastra/index.ts
+index d2cd1e327..976120234 100644
+--- a/src/mastra/index.ts
++++ b/src/mastra/index.ts
+@@ -19,10 +19,14 @@ import {
+   topicChecklistAgent,
+   individualDocumentReviewAgent,
+   consolidateReviewAgent,
++  reviewChatPlanningAgent,
++  reviewChatResearchAgent,
++  reviewChatAnswerAgent,
+ } from './agents/workflowAgents';
+ import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
+ import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
+ import { executeReviewWorkflow } from './workflows/sourceReview/executeReview';
++import { reviewChatWorkflow } from './workflows/reviewChat';
+ import fs from 'fs';
+ import path from 'path';
+ import { getLogLevel } from '@/main/lib/logger';
+@@ -51,7 +55,6 @@ try {
+   console.error('ログファイル初期化に失敗:', err);
+ }
+ 
+-
+ // ロガーの作成
+ export const logger = new PinoLogger({
+   name: 'AIKATA',
+@@ -73,11 +76,15 @@ export const mastra: Mastra = new Mastra({
+     topicChecklistAgent,
+     individualDocumentReviewAgent,
+     consolidateReviewAgent,
++    reviewChatPlanningAgent,
++    reviewChatResearchAgent,
++    reviewChatAnswerAgent,
+   },
+   workflows: {
+     sourceRegistrationWorkflow,
+     checklistExtractionWorkflow,
+     executeReviewWorkflow,
++    reviewChatWorkflow,
+   },
+   logger,
+ });
+diff --git a/src/mastra/lib/util.ts b/src/mastra/lib/util.ts
+index 57fe0b68c..3438aae8a 100644
+--- a/src/mastra/lib/util.ts
++++ b/src/mastra/lib/util.ts
+@@ -8,7 +8,7 @@
+ export function makeChunksByCount<T extends { length: number }>(
+   data: T,
+   splitCount: number,
+-  overlap: number
++  overlap: number,
+ ): Array<{ start: number; end: number }> {
+   const total = data.length;
+ 
+diff --git a/src/mastra/tools/redmine/redmineClient.ts b/src/mastra/tools/redmine/redmineClient.ts
+index d383049b7..1f88ac3cb 100644
+--- a/src/mastra/tools/redmine/redmineClient.ts
++++ b/src/mastra/tools/redmine/redmineClient.ts
+@@ -92,7 +92,9 @@ export class RedmineClient {
+         throw internalError({
+           expose: true,
+           messageCode: 'REDMINE_API_ERROR',
+-          messageParams: { detail: `${response.status} ${response.statusText}` },
++          messageParams: {
++            detail: `${response.status} ${response.statusText}`,
++          },
+         });
+       }
+       if (response.status === 204) {
+diff --git a/src/mastra/tools/toolDisplayConfig.ts b/src/mastra/tools/toolDisplayConfig.ts
+index 62ee97da4..9dca7f3da 100644
+--- a/src/mastra/tools/toolDisplayConfig.ts
++++ b/src/mastra/tools/toolDisplayConfig.ts
+@@ -25,4 +25,8 @@ export const TOOL_NAME_DISPLAY_MAP: Record<string, string> = {
+   getMergeRequestDetail: 'マージリクエスト詳細取得',
+   addMergeRequestComment: 'マージリクエストコメント追加',
+   addMergeRequestDiffComment: 'マージリクエスト差分コメント追加',
++
++  // レビューチャット用
++  researchDocumentStart: 'ドキュメント調査中...',
++  researchDocumentComplete: 'ドキュメント調査完了',
+ };
+diff --git a/src/mastra/workflows/reviewChat/generateAnswerStep.ts b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
+new file mode 100644
+index 000000000..c6a039b9e
+--- /dev/null
++++ b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
+@@ -0,0 +1,158 @@
++// @ts-ignore
++import { createStep } from '@mastra/core';
++// @ts-ignore
++import { RuntimeContext } from '@mastra/core/runtime-context';
++import { z } from 'zod';
++import { baseStepOutputSchema } from '../schema';
++import { stepStatus } from '../types';
++import { getReviewRepository } from '@/adapter/db';
++import { getMainLogger } from '@/main/lib/logger';
++import { normalizeUnknownError, internalError } from '@/main/lib/error';
++import { ReviewChatAnswerAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++import {
++  createRuntimeContext,
++  judgeFinishReason,
++} from '@/mastra/lib/agentUtils';
++import { IpcChannels } from '@/types';
++import { publishEvent } from '@/main/lib/eventPayloadHelper';
++import { ReviewChatWorkflowRuntimeContext } from '.';
++
++const logger = getMainLogger();
++
++export const generateAnswerStepInputSchema = z.object({
++  reviewHistoryId: z.string(),
++  checklistIds: z.array(z.number()),
++  question: z.string(),
++  researchResults: z.array(
++    z.object({
++      documentId: z.string(),
++      researchResult: z.string(),
++    }),
++  ),
++});
++
++export const generateAnswerStepOutputSchema = baseStepOutputSchema.extend({
++  answer: z.string().optional(),
++});
++
++export const generateAnswerStep = createStep({
++  id: 'generateAnswerStep',
++  description: '最終回答を生成するステップ（ストリーミング）',
++  inputSchema: generateAnswerStepInputSchema,
++  outputSchema: generateAnswerStepOutputSchema,
++  execute: async ({
++    inputData,
++    bail,
++    mastra,
++    abortSignal,
++    runtimeContext: workflowRuntimeContext,
++  }) => {
++    try {
++      const { reviewHistoryId, checklistIds, question, researchResults } =
++        inputData;
++      const reviewRepository = getReviewRepository();
++      const dataStreamWriter = (
++        workflowRuntimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++      ).get('dataStreamWriter');
++
++      // チェックリスト結果を取得
++      const checklistResults =
++        await reviewRepository.getChecklistResultsWithIndividualResults(
++          reviewHistoryId,
++          checklistIds,
++        );
++
++      // ドキュメントキャッシュ情報を取得
++      const documentCaches =
++        await reviewRepository.getReviewDocumentCacheByDocumentIds(
++          reviewHistoryId,
++          researchResults.map((r) => r.documentId),
++        );
++
++      const checklistInfo = checklistResults
++        .map((item) => {
++          let info = `Checklist: ${item.checklistResult.content}\n`;
++          if (item.checklistResult.sourceEvaluation) {
++            info += `Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}, Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}`;
++          }
++          return info;
++        })
++        .join('\n');
++
++      // 調査結果を統合
++      const researchSummary = researchResults
++        .map(
++          (result) =>
++            `Document ID: ${result.documentId}\nDocument Name: ${documentCaches.find((dc) => dc.documentId === result.documentId)?.fileName || 'Unknown'}\nFindings: ${result.researchResult}`,
++        )
++        .join('\n---\n');
++
++      // RuntimeContext作成
++      const runtimeContext =
++        await createRuntimeContext<ReviewChatAnswerAgentRuntimeContext>();
++      runtimeContext.set('userQuestion', question);
++      runtimeContext.set('checklistInfo', checklistInfo);
++
++      const promptText = `User Question: ${question}\n\nResearch Findings:\n${researchSummary}`;
++
++      // Mastraエージェント経由でストリーミングAI呼び出し
++      const answerAgent = mastra.getAgent('reviewChatAnswerAgent');
++      const result = await answerAgent.generate(promptText, {
++        runtimeContext,
++        abortSignal,
++        onStepFinish: (stepResult) => {
++          // AI SDK Data Stream Protocol v1 形式でチャンクを送信
++          // https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol
++          if (stepResult.text) {
++            dataStreamWriter.write(`0:${JSON.stringify(stepResult.text)}\n`);
++          }
++          stepResult.toolCalls.forEach((toolCall) => {
++            dataStreamWriter.write(`9:${JSON.stringify(toolCall)}\n`);
++          });
++          stepResult.toolResults.forEach((toolResult) => {
++            dataStreamWriter.write(`a:${JSON.stringify(toolResult)}\n`);
++          });
++          dataStreamWriter.write(
++            `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
++          );
++        },
++      });
++
++      const { success, reason } = judgeFinishReason(result.finishReason);
++      if (!success) {
++        throw internalError({
++          expose: true,
++          messageCode: 'AI_API_ERROR',
++          messageParams: { detail: reason },
++        });
++      }
++
++      // 最終的なfinish reasonとusage情報を送信
++      publishEvent(
++        IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
++        `d:${JSON.stringify({ finishReason: result.finishReason, ...result.usage })}\n`,
++      );
++
++      // 完了イベント送信
++      publishEvent(IpcChannels.REVIEW_CHAT_COMPLETE, undefined);
++
++      return {
++        status: 'success' as stepStatus,
++        answer: result.text,
++      };
++    } catch (error) {
++      logger.error(error, '最終回答の生成に失敗しました');
++      const normalizedError = normalizeUnknownError(error);
++
++      // エラーイベント送信
++      publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
++        message: normalizedError.message,
++      });
++
++      return bail({
++        status: 'failed' as stepStatus,
++        errorMessage: normalizedError.message,
++      });
++    }
++  },
++});
+diff --git a/src/mastra/workflows/reviewChat/index.ts b/src/mastra/workflows/reviewChat/index.ts
+new file mode 100644
+index 000000000..840d52dde
+--- /dev/null
++++ b/src/mastra/workflows/reviewChat/index.ts
+@@ -0,0 +1,133 @@
++// @ts-ignore
++import { createWorkflow } from '@mastra/core';
++// @ts-ignore
++import { RuntimeContext } from '@mastra/core/runtime-context';
++import { DataStreamWriter } from 'ai';
++import { z } from 'zod';
++import { stepStatus } from '../types';
++import { planResearchStep } from './planResearchStep';
++import {
++  generateAnswerStep,
++  generateAnswerStepInputSchema,
++  generateAnswerStepOutputSchema,
++} from './generateAnswerStep';
++import { researchDocumentWithRetryWorkflow } from './researchDocument';
++import { getReviewRepository } from '@/adapter/db';
++
++// ワークフローのラインタイムコンテキスト
++export type ReviewChatWorkflowRuntimeContext = {
++  dataStreamWriter: DataStreamWriter;
++  // 擬似的なtoolCallを表現するためのID
++  toolCallId: string;
++};
++
++// 入力スキーマ
++export const reviewChatInputSchema = z.object({
++  reviewHistoryId: z.string(),
++  checklistIds: z.array(z.number()),
++  question: z.string(),
++});
++
++// メインワークフロー
++export const reviewChatWorkflow = createWorkflow({
++  id: 'reviewChatWorkflow',
++  inputSchema: reviewChatInputSchema,
++  outputSchema: generateAnswerStepOutputSchema,
++})
++  .then(planResearchStep)
++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
++    if (inputData.status === 'failed') {
++      return bail(inputData);
++    }
++
++    const initData = (await getInitData()) as z.infer<
++      typeof reviewChatInputSchema
++    >;
++
++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
++    const toolCallId = (
++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++    ).get('toolCallId');
++    const writer = (
++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++    ).get('dataStreamWriter');
++    const reviewRepository = getReviewRepository();
++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
++      initData.reviewHistoryId,
++    );
++    writer.write(
++      `9:${JSON.stringify({
++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
++        toolName: 'researchDocumentStart',
++        args: inputData.researchTasks?.map((task) => {
++          return {
++            documentName:
++              documentCaches.find((d) => d.documentId === task.documentId)
++                ?.fileName || 'Unknown',
++            researchContent: task.researchContent,
++          };
++        }),
++      })}\n`,
++    );
++
++    return (inputData.researchTasks || []).map((task) => ({
++      reviewHistoryId: initData.reviewHistoryId,
++      documentId: task.documentId,
++      researchContent: task.researchContent,
++      checklistIds: initData.checklistIds,
++      question: initData.question,
++    })) as z.infer<typeof researchDocumentWithRetryWorkflow.inputSchema>[];
++  })
++  .foreach(researchDocumentWithRetryWorkflow, { concurrency: 5 })
++  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
++    // 失敗があればエラー
++    if (inputData.some((item) => item.status === 'failed')) {
++      const failed = inputData.find((item) => item.status === 'failed');
++      return bail({
++        status: 'failed' as stepStatus,
++        errorMessage: failed?.errorMessage || '調査に失敗しました',
++      });
++    }
++
++    const initData = (await getInitData()) as z.infer<
++      typeof reviewChatInputSchema
++    >;
++
++    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
++    const toolCallId = (
++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++    ).get('toolCallId');
++    const writer = (
++      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
++    ).get('dataStreamWriter');
++    const reviewRepository = getReviewRepository();
++    const documentCaches = await reviewRepository.getReviewDocumentCaches(
++      initData.reviewHistoryId,
++    );
++    writer.write(
++      `a:${JSON.stringify({
++        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
++        toolName: 'researchDocumentComplete',
++        result: inputData.map((item) => ({
++          documentName:
++            documentCaches.find((d) => d.documentId === item.documentId)
++              ?.fileName || 'Unknown',
++          researchResult: item.researchResult!,
++        })),
++      })}\n`,
++    );
++
++    return {
++      reviewHistoryId: initData.reviewHistoryId,
++      checklistIds: initData.checklistIds,
++      question: initData.question,
++      researchResults: inputData
++        .filter((item) => item.status === 'success')
++        .map((item) => ({
++          documentId: item.documentId!,
++          researchResult: item.researchResult!,
++        })),
++    } as z.infer<typeof generateAnswerStepInputSchema>;
++  })
++  .then(generateAnswerStep)
++  .commit();
+diff --git a/src/mastra/workflows/reviewChat/planResearchStep.ts b/src/mastra/workflows/reviewChat/planResearchStep.ts
+new file mode 100644
+index 000000000..fac9a8c13
+--- /dev/null
++++ b/src/mastra/workflows/reviewChat/planResearchStep.ts
+@@ -0,0 +1,127 @@
++// @ts-ignore
++import { createStep } from '@mastra/core';
++import { z } from 'zod';
++import { baseStepOutputSchema } from '../schema';
++import { stepStatus } from '../types';
++import { getReviewRepository } from '@/adapter/db';
++import { getMainLogger } from '@/main/lib/logger';
++import { normalizeUnknownError, internalError } from '@/main/lib/error';
++import { ReviewChatPlanningAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++import {
++  createRuntimeContext,
++  judgeFinishReason,
++} from '@/mastra/lib/agentUtils';
++import { reviewChatInputSchema } from '.';
++
++const logger = getMainLogger();
++
++// Step 1: 調査計画作成
++const planResearchStepOutputSchema = baseStepOutputSchema.extend({
++  researchTasks: z
++    .array(
++      z.object({
++        documentId: z.string(),
++        researchContent: z.string(),
++      }),
++    )
++    .optional(),
++});
++
++export const planResearchStep = createStep({
++  id: 'planResearchStep',
++  description: '調査計画を作成するステップ',
++  inputSchema: reviewChatInputSchema,
++  outputSchema: planResearchStepOutputSchema,
++  execute: async ({ inputData, bail, mastra }) => {
++    try {
++      const { reviewHistoryId, checklistIds, question } = inputData;
++      const reviewRepository = getReviewRepository();
++
++      // チェックリスト結果と個別レビュー結果を取得
++      const checklistResults =
++        await reviewRepository.getChecklistResultsWithIndividualResults(
++          reviewHistoryId,
++          checklistIds,
++        );
++
++      // ドキュメント一覧を取得
++      const documentCaches =
++        await reviewRepository.getReviewDocumentCaches(reviewHistoryId);
++
++      // RuntimeContext作成
++      const availableDocuments = documentCaches.map((doc) => ({
++        id: doc.documentId,
++        fileName: doc.fileName,
++      }));
++
++      // チェックリスト情報の文字列を生成
++      const checklistInfo = checklistResults
++        .map((item) => {
++          let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
++          if (item.checklistResult.sourceEvaluation) {
++            info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
++          }
++          if (item.individualResults && item.individualResults.length > 0) {
++            info += `Individual Review Results:\n`;
++            item.individualResults.forEach((result) => {
++              info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
++            });
++          }
++          return info;
++        })
++        .join('\n---\n');
++
++      // RuntimeContext作成
++      const runtimeContext =
++        await createRuntimeContext<ReviewChatPlanningAgentRuntimeContext>();
++      runtimeContext.set('availableDocuments', availableDocuments);
++      runtimeContext.set('checklistInfo', checklistInfo);
++
++      // 構造化出力用のスキーマ
++      const researchTasksSchema = z.object({
++        tasks: z.array(
++          z.object({
++            reasoning: z
++              .string()
++              .describe('Reason for selecting this document for research'),
++            documentId: z.string().describe('Document ID to investigate'),
++            researchContent: z
++              .string()
++              .describe('Detailed research instructions for this document'),
++          }),
++        ),
++      });
++
++      // Mastraエージェント経由でAI呼び出し（構造化出力）
++      const planningAgent = mastra.getAgent('reviewChatPlanningAgent');
++      const result = await planningAgent.generate(question, {
++        runtimeContext,
++        output: researchTasksSchema,
++      });
++
++      const { success, reason } = judgeFinishReason(result.finishReason);
++      if (!success) {
++        throw internalError({
++          expose: true,
++          messageCode: 'AI_API_ERROR',
++          messageParams: { detail: reason },
++        });
++      }
++
++      // 構造化出力から調査タスクを取得
++      const researchTasks = result.object?.tasks || [];
++
++      return {
++        status: 'success' as stepStatus,
++        researchTasks,
++      };
++    } catch (error) {
++      logger.error(error, '調査計画の作成に失敗しました');
++      const normalizedError = normalizeUnknownError(error);
++      return bail({
++        status: 'failed' as stepStatus,
++        errorMessage: normalizedError.message,
++      });
++    }
++  },
++});
+diff --git a/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
+new file mode 100644
+index 000000000..dd6e3f661
+--- /dev/null
++++ b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
+@@ -0,0 +1,57 @@
++// @ts-ignore
++import { createStep } from '@mastra/core';
++import { z } from 'zod';
++import { baseStepOutputSchema } from '../../schema';
++import { stepStatus } from '../../types';
++import { getReviewRepository } from '@/adapter/db';
++import { getMainLogger } from '@/main/lib/logger';
++import { normalizeUnknownError } from '@/main/lib/error';
++
++const logger = getMainLogger();
++
++export const getTotalChunksStepInputSchema = z.object({
++  reviewHistoryId: z.string(),
++  documentId: z.string(),
++  researchContent: z.string(),
++});
++
++export const getTotalChunksStepOutputSchema = baseStepOutputSchema.extend({
++  reviewHistoryId: z.string(),
++  documentId: z.string(),
++  researchContent: z.string(),
++  totalChunks: z.number(),
++});
++
++export const getTotalChunksStep = createStep({
++  id: 'getTotalChunksStep',
++  description: '最大チャンク数を取得するステップ',
++  inputSchema: getTotalChunksStepInputSchema,
++  outputSchema: getTotalChunksStepOutputSchema,
++  execute: async ({ inputData, bail }) => {
++    try {
++      const { reviewHistoryId, documentId, researchContent } = inputData;
++      const reviewRepository = getReviewRepository();
++
++      // 既存の最大チャンク数を取得
++      const totalChunks = await reviewRepository.getMaxTotalChunksForDocument(
++        reviewHistoryId,
++        documentId,
++      );
++
++      return {
++        status: 'success' as stepStatus,
++        reviewHistoryId,
++        documentId,
++        researchContent,
++        totalChunks,
++      };
++    } catch (error) {
++      logger.error(error, '最大チャンク数の取得に失敗しました');
++      const normalizedError = normalizeUnknownError(error);
++      return bail({
++        status: 'failed' as stepStatus,
++        errorMessage: normalizedError.message,
++      });
++    }
++  },
++});
+diff --git a/src/mastra/workflows/reviewChat/researchDocument/index.ts b/src/mastra/workflows/reviewChat/researchDocument/index.ts
+new file mode 100644
+index 000000000..d5367757e
+--- /dev/null
++++ b/src/mastra/workflows/reviewChat/researchDocument/index.ts
+@@ -0,0 +1,202 @@
++// @ts-ignore
++import { createWorkflow } from '@mastra/core';
++import { z } from 'zod';
++import { baseStepOutputSchema } from '../../schema';
++import { stepStatus } from '../../types';
++import { getReviewRepository } from '@/adapter/db';
++import { getMainLogger } from '@/main/lib/logger';
++import { makeChunksByCount } from '@/mastra/lib/util';
++import {
++  getTotalChunksStep,
++  getTotalChunksStepInputSchema,
++  getTotalChunksStepOutputSchema,
++} from './getTotalChunksStep';
++import {
++  researchChunkStep,
++  researchChunkStepInputSchema,
++} from './researchDocumentChunk';
++import { input } from '@testing-library/user-event/dist/cjs/event/input.js';
++
++const logger = getMainLogger();
++
++const researchDocumentWithRetryInputSchema = z.object({
++  reviewHistoryId: z.string(),
++  documentId: z.string(),
++  researchContent: z.string(),
++  checklistIds: z.array(z.number()),
++  question: z.string(),
++});
++
++const researchDocumentWithRetryOutputSchema = baseStepOutputSchema.extend({
++  documentId: z.string().optional(),
++  researchResult: z.string().optional(),
++});
++
++export const researchDocumentWithRetryWorkflow = createWorkflow({
++  id: 'researchDocumentWithRetryWorkflow',
++  inputSchema: researchDocumentWithRetryInputSchema,
++  outputSchema: researchDocumentWithRetryOutputSchema,
++})
++  .map(async ({ inputData }) => {
++    return inputData as z.infer<typeof getTotalChunksStepInputSchema>;
++  })
++  .then(getTotalChunksStep)
++  .map(async ({ inputData, getInitData, bail }) => {
++    if (inputData.status === 'failed') {
++      return bail(inputData);
++    }
++    const initData = (await getInitData()) as z.infer<
++      typeof researchDocumentWithRetryInputSchema
++    >;
++    return {
++      ...inputData,
++      checklistIds: initData.checklistIds,
++      question: initData.question,
++    } as z.infer<typeof getTotalChunksStepOutputSchema> & {
++      checklistIds: number[];
++      question: string;
++    };
++  })
++  .dountil(
++    createWorkflow({
++      id: 'chunkResearchInnerWorkflow',
++      inputSchema: getTotalChunksStepOutputSchema.extend({
++        checklistIds: z.array(z.number()),
++        question: z.string(),
++      }),
++      outputSchema: researchDocumentWithRetryOutputSchema,
++    })
++      .map(async ({ inputData }) => {
++        const { reviewHistoryId, documentId, researchContent, totalChunks } =
++          inputData;
++        const reviewRepository = getReviewRepository();
++
++        // ドキュメントキャッシュを取得
++        const documentCache =
++          await reviewRepository.getReviewDocumentCacheByDocumentId(
++            reviewHistoryId,
++            documentId,
++          );
++
++        if (!documentCache) {
++          throw new Error(`Document not found: ${documentId}`);
++        }
++
++        // ドキュメントをtotalChunks分に分割
++        const chunks: Array<{ text?: string; images?: string[] }> = [];
++
++        if (documentCache.processMode === 'text' && documentCache.textContent) {
++          // テキストをチャンク分割
++          const chunkRanges = makeChunksByCount(
++            documentCache.textContent,
++            totalChunks,
++            0,
++          );
++          chunkRanges.forEach((range) => {
++            chunks.push({
++              text: documentCache.textContent!.substring(
++                range.start,
++                range.end,
++              ),
++            });
++          });
++        } else if (
++          documentCache.processMode === 'image' &&
++          documentCache.imageData
++        ) {
++          // 画像配列をチャンク分割
++          const chunkRanges = makeChunksByCount(
++            documentCache.imageData,
++            totalChunks,
++            0,
++          );
++          chunkRanges.forEach((range) => {
++            chunks.push({
++              images: documentCache.imageData!.slice(range.start, range.end),
++            });
++          });
++        }
++
++        // 各チャンクに対する調査タスクを作成
++        return chunks.map((chunk, index) => ({
++          reviewHistoryId,
++          documentId,
++          researchContent,
++          chunkContent: chunk,
++          chunkIndex: index,
++          totalChunks,
++          fileName: documentCache.fileName,
++          checklistIds: inputData.checklistIds,
++          question: inputData.question,
++        })) as z.infer<typeof researchChunkStepInputSchema>[];
++      })
++      .foreach(researchChunkStep, { concurrency: 5 })
++      .map(async ({ inputData, bail, getInitData }) => {
++        const results = inputData;
++
++        // いずれかのチャンクでコンテキスト長エラーがあったかチェック
++        const hasContentLengthError = results.some(
++          (result) => result.finishReason === 'content_length',
++        );
++
++        // 失敗があればエラー
++        if (results.some((result) => result.status === 'failed')) {
++          const failed = results.find((result) => result.status === 'failed');
++          return bail({
++            status: 'failed' as stepStatus,
++            errorMessage: failed?.errorMessage || 'チャンク調査に失敗しました',
++            finishReason: 'error' as const,
++          });
++        }
++
++        const initData = (await getInitData()) as z.infer<
++          typeof getTotalChunksStepOutputSchema
++        >;
++
++        if (hasContentLengthError) {
++          // チャンク数を増やして再試行
++          return {
++            status: 'success' as stepStatus,
++            reviewHistoryId: initData.reviewHistoryId,
++            documentId: initData.documentId,
++            researchContent: initData.researchContent,
++            totalChunks: initData.totalChunks + 1,
++            finishReason: 'content_length' as const,
++          };
++        }
++
++        // すべて成功したらチャンク結果を統合
++        const combinedResult = results
++          .filter((result) => result.chunkResult)
++          .map((result, index) => `[Chunk ${index + 1}]\n${result.chunkResult}`)
++          .join('\n\n');
++
++        return {
++          status: 'success' as stepStatus,
++          documentId: initData.documentId,
++          researchResult: combinedResult,
++          finishReason: 'success' as const,
++        };
++      })
++      .commit(),
++    async ({ inputData }) => {
++      // 再試行上限または成功したら終了
++      if ((inputData as any).totalChunks >= 10) {
++        return true;
++      }
++      if ((inputData as any).finishReason !== 'content_length') {
++        return true;
++      }
++      return false;
++    },
++  )
++  .map(async ({ inputData }) => {
++    // 最終結果を返す
++    return {
++      status: inputData.status,
++      documentId: inputData.documentId,
++      researchResult: inputData.researchResult,
++      errorMessage: (inputData as any).errorMessage,
++    };
++  })
++  .commit();
+diff --git a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
+new file mode 100644
+index 000000000..225e1901f
+--- /dev/null
++++ b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
+@@ -0,0 +1,181 @@
++// @ts-ignore
++import { createStep } from '@mastra/core';
++import { z } from 'zod';
++import { baseStepOutputSchema } from '../../schema';
++import { stepStatus } from '../../types';
++import { getMainLogger } from '@/main/lib/logger';
++import { normalizeUnknownError, internalError } from '@/main/lib/error';
++import { ReviewChatResearchAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++import {
++  createRuntimeContext,
++  judgeFinishReason,
++  judgeErrorIsContentLengthError,
++} from '@/mastra/lib/agentUtils';
++import { getReviewRepository } from '@/adapter/db';
++
++const logger = getMainLogger();
++
++export const researchChunkStepInputSchema = z.object({
++  reviewHistoryId: z.string(),
++  documentId: z.string(),
++  researchContent: z.string(),
++  chunkContent: z.object({
++    text: z.string().optional(),
++    images: z.array(z.string()).optional(),
++  }),
++  chunkIndex: z.number(),
++  totalChunks: z.number(),
++  fileName: z.string(),
++  checklistIds: z.array(z.number()),
++  question: z.string(),
++});
++
++const researchChunkStepOutputSchema = baseStepOutputSchema.extend({
++  chunkResult: z.string().optional(),
++  chunkIndex: z.number().optional(),
++  finishReason: z.enum(['success', 'error', 'content_length']).optional(),
++});
++
++export const researchChunkStep = createStep({
++  id: 'researchChunkStep',
++  description: 'チャンク単位でドキュメントを調査するステップ',
++  inputSchema: researchChunkStepInputSchema,
++  outputSchema: researchChunkStepOutputSchema,
++  execute: async ({ inputData, bail, mastra, getInitData }) => {
++    try {
++      const {
++        researchContent,
++        chunkContent,
++        chunkIndex,
++        totalChunks,
++        fileName,
++        reviewHistoryId,
++        checklistIds,
++        question,
++      } = inputData;
++
++      // チェックリスト情報を生成（planResearchStepと同じロジック）
++      const reviewRepository = getReviewRepository();
++      const checklistResults =
++        await reviewRepository.getChecklistResultsWithIndividualResults(
++          reviewHistoryId,
++          checklistIds,
++        );
++
++      const checklistInfo = checklistResults
++        .map(
++          (item: {
++            checklistResult: {
++              id: number;
++              content: string;
++              sourceEvaluation?: { evaluation?: string; comment?: string };
++            };
++            individualResults?: Array<{
++              documentId: number;
++              comment: string;
++              individualFileName: string;
++            }>;
++          }) => {
++            let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
++            if (item.checklistResult.sourceEvaluation) {
++              info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
++            }
++            if (item.individualResults && item.individualResults.length > 0) {
++              info += `Individual Review Results:\n`;
++              item.individualResults.forEach(
++                (result: {
++                  documentId: number;
++                  comment: string;
++                  individualFileName: string;
++                }) => {
++                  info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
++                },
++              );
++            }
++            return info;
++          },
++        )
++        .join('\n---\n');
++
++      // RuntimeContext作成
++      const runtimeContext =
++        await createRuntimeContext<ReviewChatResearchAgentRuntimeContext>();
++      runtimeContext.set('researchContent', researchContent);
++      runtimeContext.set('totalChunks', totalChunks);
++      runtimeContext.set('chunkIndex', chunkIndex);
++      runtimeContext.set('fileName', fileName);
++      runtimeContext.set('checklistInfo', checklistInfo);
++      runtimeContext.set('userQuestion', question);
++
++      // メッセージを作成
++      const messageContent = [];
++
++      if (chunkContent.text) {
++        // テキストチャンクの場合
++        messageContent.push({
++          type: 'text' as const,
++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nDocument Content:\n${chunkContent.text}`,
++        });
++      } else if (chunkContent.images && chunkContent.images.length > 0) {
++        // 画像チャンクの場合
++        messageContent.push({
++          type: 'text' as const,
++          text: `Document: ${fileName}\nChunk: ${chunkIndex + 1}/${totalChunks}\n\nResearch Instructions: ${researchContent}\n\nPlease analyze the following document images:`,
++        });
++
++        chunkContent.images.forEach((imageBase64) => {
++          messageContent.push({
++            type: 'image' as const,
++            image: imageBase64,
++          });
++        });
++      }
++
++      // Mastraエージェント経由でAI呼び出し
++      const researchAgent = mastra.getAgent('reviewChatResearchAgent');
++      const result = await researchAgent.generate(
++        {
++          role: 'user',
++          content: messageContent,
++        },
++        {
++          runtimeContext,
++        },
++      );
++
++      const { success, reason } = judgeFinishReason(result.finishReason);
++
++      if (!success) {
++        throw internalError({
++          expose: true,
++          messageCode: 'AI_API_ERROR',
++          messageParams: { detail: reason },
++        });
++      }
++
++      return {
++        status: 'success' as stepStatus,
++        chunkIndex,
++        chunkResult: result.text,
++        finishReason: 'success' as const,
++      };
++    } catch (error) {
++      // コンテキスト長エラーの場合は特別な処理
++      if (judgeErrorIsContentLengthError(error)) {
++        return {
++          status: 'success' as stepStatus,
++          chunkIndex: inputData.chunkIndex,
++          finishReason: 'content_length' as const,
++        };
++      }
++
++      logger.error(error, 'チャンク調査に失敗しました');
++      const normalizedError = normalizeUnknownError(error);
++      return bail({
++        status: 'failed' as stepStatus,
++        errorMessage: normalizedError.message,
++        finishReason: 'error' as const,
++      });
++    }
++  },
++});
+diff --git a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+index 14ac3da86..e477a12a4 100644
+--- a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
++++ b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+@@ -1,40 +1,46 @@
+-import { z } from "zod";
+-import { baseStepOutputSchema } from "../../schema";
++import { z } from 'zod';
++import { baseStepOutputSchema } from '../../schema';
+ // @ts-ignore
+-import { createStep } from "@mastra/core";
++import { createStep } from '@mastra/core';
+ // @ts-ignore
+-import { MastraError } from "@mastra/core/error";
++import { MastraError } from '@mastra/core/error';
+ import { NoObjectGeneratedError } from 'ai';
+-import { getReviewRepository } from "@/adapter/db";
+-import { extractAIAPISafeError, internalError, normalizeUnknownError } from "@/main/lib/error";
+-import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from ".";
+-import { stepStatus } from "../../types";
+-import { splitChecklistEquallyByMaxSize } from "../lib";
+-import { createRuntimeContext } from "@/mastra/lib/agentUtils";
+-import { ClassifyCategoryAgentRuntimeContext } from "@/mastra/agents/workflowAgents";
+-import { getMainLogger } from "@/main/lib/logger";
++import { getReviewRepository } from '@/adapter/db';
++import {
++  extractAIAPISafeError,
++  internalError,
++  normalizeUnknownError,
++} from '@/main/lib/error';
++import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from '.';
++import { stepStatus } from '../../types';
++import { splitChecklistEquallyByMaxSize } from '../lib';
++import { createRuntimeContext } from '@/mastra/lib/agentUtils';
++import { ClassifyCategoryAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
++import { getMainLogger } from '@/main/lib/logger';
+ 
+ const logger = getMainLogger();
+ 
+ export const classifyChecklistsByCategoryInputSchema = z.object({
+-  reviewHistoryId: z.string().describe("レビュー履歴ID"),
++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+ });
+ 
+ // カテゴリ分類ステップの出力スキーマ
+-export const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
+-  categories: z
+-    .array(
+-      z.object({
+-        name: z.string(),
+-        checklists: z.array(
+-          z.object({
+-            id: z.number(),
+-            content: z.string().describe('チェックリストの内容'),
+-          }),
+-        ),
+-      }),
+-    ).optional(),
+-});
++export const classifyChecklistsByCategoryOutputSchema =
++  baseStepOutputSchema.extend({
++    categories: z
++      .array(
++        z.object({
++          name: z.string(),
++          checklists: z.array(
++            z.object({
++              id: z.number(),
++              content: z.string().describe('チェックリストの内容'),
++            }),
++          ),
++        }),
++      )
++      .optional(),
++  });
+ 
+ export const classifyChecklistsByCategoryStep = createStep({
+   id: 'classifyChecklistsByCategoryStep',
+diff --git a/src/mastra/workflows/sourceReview/executeReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/index.ts
+index 0972e2670..67e557283 100644
+--- a/src/mastra/workflows/sourceReview/executeReview/index.ts
++++ b/src/mastra/workflows/sourceReview/executeReview/index.ts
+@@ -9,6 +9,7 @@ import { classifyChecklistsByCategoryStep } from './classifyChecklistStep';
+ import { smallDocumentReviewExecutionStep } from './smallDocumentReviewStep';
+ import { largeDocumentReviewWorkflow } from './largeDocumentReview';
+ import { extractedDocumentSchema, uploadedFileSchema } from './schema';
++import { getReviewRepository } from '@/adapter/db';
+ 
+ const logger = getMainLogger();
+ 
+@@ -54,6 +55,7 @@ export const executeReviewWorkflowInputSchema = z.object({
+ export const executeReviewWorkflowOutputSchema = baseStepOutputSchema;
+ 
+ export const documentReviewExecutionInputSchema = z.object({
++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+   additionalInstructions: z
+     .string()
+     .optional()
+@@ -143,8 +145,46 @@ export const executeReviewWorkflow = createWorkflow({
+       typeof executeReviewWorkflowInputSchema
+     >;
+ 
++    // 既存のレビュー結果を全て削除
++    const reviewRepository = getReviewRepository();
++    await reviewRepository.deleteAllReviewResults(initData.reviewHistoryId);
++
++    // documentModeを保存
++    await reviewRepository.updateReviewHistoryDocumentMode(
++      initData.reviewHistoryId,
++      initData.documentMode,
++    );
++
++    // ドキュメントキャッシュを保存
++    for (const document of textExtractionResult.extractedDocuments || []) {
++      if (!document) continue;
++      const savedCache = await reviewRepository.createReviewDocumentCache({
++        reviewHistoryId: initData.reviewHistoryId,
++        documentId: document.id || '',
++        fileName: document.name || '',
++        processMode: document.processMode || 'text',
++        textContent: document.textContent,
++        imageData: document.imageData,
++      });
++      // キャッシュIDを付与
++      document.cacheId = savedCache.id;
++    }
++
++    // レビュー対象の統合ドキュメント名を保存
++    const targetDocumentName = (textExtractionResult.extractedDocuments || [])
++      .map((doc) => doc?.name || '')
++      .filter((name) => name)
++      .join('/');
++    if (targetDocumentName) {
++      await reviewRepository.updateReviewHistoryTargetDocumentName(
++        initData.reviewHistoryId,
++        targetDocumentName,
++      );
++    }
++
+     return classifyChecklistsResult.categories!.map((category) => {
+       return {
++        reviewHistoryId: initData.reviewHistoryId,
+         documents: textExtractionResult.extractedDocuments!,
+         checklists: category.checklists,
+         additionalInstructions: initData.additionalInstructions,
 diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
-index 60120af8d..cafb8793c 100644
+index cafb8793c..e1187dce7 100644
 --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
 +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
-@@ -198,9 +198,13 @@ Please provide a consolidated review that synthesizes all individual document re
-           const idsHash = createHash('md5')
-             .update(combinedFileIds)
-             .digest('hex');
--          const combinedFileNames = documentsWithReviewResults
--            .map((f) => f.name)
--            .join('/');
-+          const combinedFileNames = [
-+            ...new Set(
-+              documentsWithReviewResults.map(
-+                (f) => f.originalName || f.name,
-+              ),
-+            ),
-+          ].join('/');
+@@ -87,7 +87,10 @@ export const consolidateReviewStep = createStep({
+       // 個別レビュー結果を整理
+       const consolidatedInput = documentsWithReviewResults.map((docResult) => {
+         return {
+-          originalName: docResult?.originalName || docResult?.name || `Document ${docResult.id}`,
++          originalName:
++            docResult?.originalName ||
++            docResult?.name ||
++            `Document ${docResult.id}`,
+           documentName: docResult?.name || `Document ${docResult.id}`,
+           reviewResults: docResult.reviewResults,
+         };
+@@ -102,7 +105,7 @@ export const consolidateReviewStep = createStep({
+             text: `Please consolidate the following individual document review results into a comprehensive final review.
+ 
+ ## Document Set Information:
+-Original Files: ${[...new Set(consolidatedInput.map(doc => doc.originalName))].join(', ')}
++Original Files: ${[...new Set(consolidatedInput.map((doc) => doc.originalName))].join(', ')}
  
+ ## Individual Document Review Results:
+ ${consolidatedInput
+@@ -187,32 +190,16 @@ Please provide a consolidated review that synthesizes all individual document re
+           });
+         }
+ 
+-        // 統合レビュー結果をDBに保存（複数ファイルの情報を統合）
++        // 統合レビュー結果をDBに保存
+         if (
+           consolidatedResult.object &&
+           Array.isArray(consolidatedResult.object)
+         ) {
+-          const combinedFileIds = documentsWithReviewResults
+-            .map((f) => f.id)
+-            .join('/');
+-          const idsHash = createHash('md5')
+-            .update(combinedFileIds)
+-            .digest('hex');
+-          const combinedFileNames = [
+-            ...new Set(
+-              documentsWithReviewResults.map(
+-                (f) => f.originalName || f.name,
+-              ),
+-            ),
+-          ].join('/');
+-
            await reviewRepository.upsertReviewResult(
              consolidatedResult.object.map((result) => ({
+               reviewChecklistId: result.checklistId,
+               evaluation: result.evaluation as ReviewEvaluation,
+               comment: result.comment,
+-              fileId: idsHash,
+-              fileName: combinedFileNames,
+             })),
+           );
+         }
 diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
-index 3e9bea206..c6f8371b8 100644
+index c6f8371b8..b72315a84 100644
 --- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
 +++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
-@@ -108,7 +108,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
-           }
-           return {
-             originalDocument: initData.originalDocument,
--            reviewInput: [],
-+            reviewInput: initData.reviewInput,
-             retryCount: nextRetryCount,
-             status: isFailed
-               ? ('failed' as stepStatus)
-@@ -124,7 +124,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
-         if (initData.retryCount >= 5) {
-           return {
-             originalDocument: initData.originalDocument,
--            reviewInput: [],
-+            reviewInput: initData.reviewInput,
-             retryCount: nextRetryCount,
-             status: 'failed' as stepStatus,
-             errorMessage:
-@@ -155,6 +155,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+@@ -155,8 +155,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
                  ...initData.originalDocument,
                  id: `${initData.originalDocument.id}_part${index + 1}`,
                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++                originalName:
++                  initData.originalDocument.originalName ||
++                  initData.originalDocument.name,
                  textContent: chunk,
++                totalChunks: splitCount,
++                chunkIndex: index,
                },
              })),
-@@ -181,6 +182,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+             retryCount: nextRetryCount,
+@@ -182,8 +186,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
                  ...initData.originalDocument,
                  id: `${initData.originalDocument.id}_part${index + 1}`,
                  name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
-+                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
++                originalName:
++                  initData.originalDocument.originalName ||
++                  initData.originalDocument.name,
                  imageData: chunk,
++                totalChunks: splitCount,
++                chunkIndex: index,
                },
              })),
-@@ -227,6 +229,7 @@ const individualDocumentReviewWorkflow = createWorkflow({
+             retryCount: nextRetryCount,
+@@ -251,9 +259,12 @@ export const largeDocumentReviewWorkflow = createWorkflow({
+     return inputData.documents.map(
+       (document) =>
+         ({
++          reviewHistoryId: inputData.reviewHistoryId,
+           document: {
+             ...document,
+             originalName: document.name, // 分割された場合に元の名前を保持するため
++            totalChunks: 1,
++            chunkIndex: 0,
+           },
+           checklists: inputData.checklists,
+           additionalInstructions: inputData.additionalInstructions,
+diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+index 4416735c4..f8602fc3d 100644
+--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
++++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+@@ -15,13 +15,17 @@ import { getMainLogger } from '@/main/lib/logger';
+ import { createCombinedMessageFromExtractedDocument } from '../../lib';
+ import { getChecklistsErrorMessage } from '../lib';
+ import { extractedDocumentSchema } from '../schema';
++import { getReviewRepository } from '@/adapter/db';
+ 
+ const logger = getMainLogger();
+ 
+ // 個別ドキュメントレビューステップの入力スキーマ
+ export const individualDocumentReviewStepInputSchema = z.object({
++  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+   document: extractedDocumentSchema.extend({
+     originalName: z.string(),
++    totalChunks: z.number().optional(), // ドキュメント分割総数
++    chunkIndex: z.number().optional(), // 何番目のチャンクか（0から始まる）
+   }),
+   // チェックリスト
+   checklists: z.array(
+@@ -189,6 +193,20 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
+       }
+ 
+       // 全てのレビューが成功した場合
++
++      // 個別レビュー結果を保存
++      const reviewRepository = getReviewRepository();
++      for (const result of allReviewResults) {
++        await reviewRepository.createReviewLargedocumentResultCache({
++          reviewDocumentCacheId: document.cacheId!,
++          reviewChecklistId: result.checklistId,
++          comment: result.comment,
++          totalChunks: document.totalChunks ?? 1,
++          chunkIndex: document.chunkIndex ?? 0,
++          individualFileName: document.name,
++        });
++      }
++
+       return {
+         status: 'success' as stepStatus,
+         documentId: document.id,
+diff --git a/src/mastra/workflows/sourceReview/executeReview/lib.ts b/src/mastra/workflows/sourceReview/executeReview/lib.ts
+index b4bde036c..3f303042b 100644
+--- a/src/mastra/workflows/sourceReview/executeReview/lib.ts
++++ b/src/mastra/workflows/sourceReview/executeReview/lib.ts
+@@ -1,7 +1,15 @@
+-export const getChecklistErrorMesssage = (checklist: { id: number; content: string }, errorMessage: string) => {
++export const getChecklistErrorMesssage = (
++  checklist: { id: number; content: string },
++  errorMessage: string,
++) => {
+   return `・${checklist.content}:${errorMessage}`;
+ };
+ 
+-export const getChecklistsErrorMessage = (checklists: { id: number; content: string }[], errorMessage: string) => {
+-  return checklists.map((checklist) => getChecklistErrorMesssage(checklist, errorMessage)).join('\n');
+-}
++export const getChecklistsErrorMessage = (
++  checklists: { id: number; content: string }[],
++  errorMessage: string,
++) => {
++  return checklists
++    .map((checklist) => getChecklistErrorMesssage(checklist, errorMessage))
++    .join('\n');
++};
+diff --git a/src/mastra/workflows/sourceReview/executeReview/schema.ts b/src/mastra/workflows/sourceReview/executeReview/schema.ts
+index 18b138b5d..e663cbe5a 100644
+--- a/src/mastra/workflows/sourceReview/executeReview/schema.ts
++++ b/src/mastra/workflows/sourceReview/executeReview/schema.ts
+@@ -12,6 +12,7 @@ export const uploadedFileSchema = z.object({
+ 
+ export const extractedDocumentSchema = z.object({
+   id: z.string(),
++  cacheId: z.number().optional(),
+   name: z.string(),
+   path: z.string(),
+   type: z.string(),
+diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+index 33bc9e881..0b1e0746a 100644
+--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
++++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+@@ -133,20 +133,13 @@ Please review the document against the above checklist items.`;
+             messageParams: { detail: reason },
+           });
+         }
+-        // レビュー結果をDBに保存（複数ファイルの情報を統合）
++        // レビュー結果をDBに保存
+         if (reviewResult.object && Array.isArray(reviewResult.object)) {
+-          const combinedFileIds = documents.map((f) => f.id).join('/');
+-          const idsHash = createHash('md5')
+-            .update(combinedFileIds)
+-            .digest('hex');
+-          const combinedFileNames = documents.map((f) => f.name).join('/');
+           await reviewRepository.upsertReviewResult(
+             reviewResult.object.map((result) => ({
+               reviewChecklistId: result.checklistId,
+               evaluation: result.evaluation as ReviewEvaluation,
+               comment: result.comment,
+-              fileId: idsHash,
+-              fileName: combinedFileNames,
+             })),
+           );
+         }
+@@ -169,7 +162,10 @@ Please review the document against the above checklist items.`;
+         // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
+         return bail({
+           status: 'failed' as stepStatus,
+-          errorMessage: getChecklistsErrorMessage(targetChecklists, 'AIの出力にレビュー結果が含まれませんでした'),
++          errorMessage: getChecklistsErrorMessage(
++            targetChecklists,
++            'AIの出力にレビュー結果が含まれませんでした',
++          ),
+         });
+       }
+       // 全てのレビューが成功した場合
+diff --git a/src/mastra/workflows/sourceReview/lib.ts b/src/mastra/workflows/sourceReview/lib.ts
+index 4eed29a81..9518de038 100644
+--- a/src/mastra/workflows/sourceReview/lib.ts
++++ b/src/mastra/workflows/sourceReview/lib.ts
+@@ -122,7 +122,9 @@ export async function createCombinedMessage(
+       }
+     } else {
+       // テキスト抽出処理
+-      const { content: fileContent } = await FileExtractor.extractText(file.path);
++      const { content: fileContent } = await FileExtractor.extractText(
++        file.path,
++      );
+ 
+       // ファイルごとに個別のcontent要素として追加
+       content.push({
+@@ -181,7 +183,11 @@ export function createCombinedMessageFromExtractedDocument(
+     if (document.imageData && document.imageData.length > 0) {
+       // 各ページごとに個別の説明と画像を追加
+       const totalPages = document.imageData.length;
+-      for (let pageIndex = 0; pageIndex < document.imageData.length; pageIndex++) {
++      for (
++        let pageIndex = 0;
++        pageIndex < document.imageData.length;
++        pageIndex++
++      ) {
+         const currentPage = pageIndex + 1;
+ 
+         // ページ番号を含むテキスト説明を追加
+diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
+index 9af029444..aec3ea97f 100644
+--- a/src/messages/ja/template.ts
++++ b/src/messages/ja/template.ts
+@@ -33,4 +33,5 @@ export const template = {
+   REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR: `CSVファイルからのチェックリスト抽出中に予期せぬエラーが発生しました`,
+   AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
+   AI_MESSAGE_TOO_LARGE: `AIへの入力データが大きすぎます。入力データを減らしてください。`,
++  REVIEW_DOCUMENT_CACHE_NOT_FOUND: `レビュー時にアップロードしたドキュメント情報が失われています。レビューを再実行してください`,
+ } as const;
+diff --git a/src/renderer/components/chat/MessageItem.tsx b/src/renderer/components/chat/MessageItem.tsx
+index 4a8877c44..5345514e0 100644
+--- a/src/renderer/components/chat/MessageItem.tsx
++++ b/src/renderer/components/chat/MessageItem.tsx
+@@ -313,7 +313,8 @@ const renderPart = (
+         <Accordion sx={{ width: '100%' }} key={ti.toolCallId}>
+           <AccordionSummary expandIcon={<ExpandMoreIcon />}>
+             <Box sx={{ display: 'flex', alignItems: 'center' }}>
+-              {ti.toolName === 'documentQueryTool' ? (
++              {ti.toolName === 'documentQueryTool' ||
++              ti.toolCallId.startsWith('reviewChatResearchDocument-') ? (
+                 <SearchIcon sx={{ mr: 1 }} />
+               ) : (
+                 <SmartToyOutlinedIcon sx={{ mr: 1 }} />
+@@ -387,6 +388,7 @@ interface MessageProps {
+   onEditStart: (messageId: string) => void;
+   onEditContentChange: (content: string) => void;
+   onEditCancel: () => void;
++  disableEdit?: boolean;
+ }
+ 
+ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+@@ -400,6 +402,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+       onEditStart,
+       onEditCancel,
+       onEditContentChange,
++      disableEdit = false,
+     },
+     ref,
+   ) => {
+@@ -420,7 +423,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+               maxWidth: isUser && !isEditing ? '70%' : '100%',
+               width: isUser && !isEditing ? undefined : '100%',
+               textAlign: 'left',
+-              '&:hover .editBtn': { opacity: 1 },
++              ...(!disableEdit && { '&:hover .editBtn': { opacity: 1 } }),
+             }}
+           >
+             <Paper
+@@ -432,28 +435,31 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
+                 position: 'relative',
+               }}
+             >
+-              {isUser && !message.experimental_attachments && !isEditing && (
+-                <IconButton
+-                  className="editBtn"
+-                  size="small"
+-                  onClick={() => {
+-                    onEditStart?.(message.id);
+-                    onEditContentChange(message.content ?? '');
+-                  }}
+-                  sx={{
+-                    position: 'absolute',
+-                    right: -36,
+-                    top: '50%',
+-                    transform: 'translateY(-50%)',
+-                    opacity: 0,
+-                    transition: 'opacity 0.2s',
+-                    bgcolor: 'background.paper',
+-                  }}
+-                  data-testid={`edit-message-button-${message.id}`}
+-                >
+-                  <EditIcon fontSize="small" />
+-                </IconButton>
+-              )}
++              {isUser &&
++                !message.experimental_attachments &&
++                !isEditing &&
++                !disableEdit && (
++                  <IconButton
++                    className="editBtn"
++                    size="small"
++                    onClick={() => {
++                      onEditStart?.(message.id);
++                      onEditContentChange(message.content ?? '');
++                    }}
++                    sx={{
++                      position: 'absolute',
++                      right: -36,
++                      top: '50%',
++                      transform: 'translateY(-50%)',
++                      opacity: 0,
++                      transition: 'opacity 0.2s',
++                      bgcolor: 'background.paper',
++                    }}
++                    data-testid={`edit-message-button-${message.id}`}
++                  >
++                    <EditIcon fontSize="small" />
++                  </IconButton>
++                )}
+               {/* eslint-disable-next-line */}
+               {isEditing && !message.experimental_attachments && isUser ? (
+                 <Box sx={{ p: 1, width: '100%' }}>
+diff --git a/src/renderer/components/chat/MessageList.tsx b/src/renderer/components/chat/MessageList.tsx
+index e8325677a..321206563 100644
+--- a/src/renderer/components/chat/MessageList.tsx
++++ b/src/renderer/components/chat/MessageList.tsx
+@@ -14,6 +14,8 @@ interface MessageListProps {
+   onEditSubmit: () => void;
+   onEditContentChange: (ontent: string) => void;
+   onEditCancel: () => void;
++  loadingMessage?: string;
++  disableEdit?: boolean;
+ }
+ 
+ const MessageList: React.FC<MessageListProps> = ({
+@@ -27,6 +29,8 @@ const MessageList: React.FC<MessageListProps> = ({
+   onEditSubmit,
+   onEditContentChange,
+   onEditCancel,
++  loadingMessage = 'AIKATA作業中…',
++  disableEdit = false,
+ }) => {
+   const bottomRef = useRef<HTMLDivElement>(null);
+ 
+@@ -64,12 +68,13 @@ const MessageList: React.FC<MessageListProps> = ({
+               onEditSubmit={onEditSubmit}
+               onEditContentChange={onEditContentChange}
+               onEditCancel={onEditCancel}
++              disableEdit={disableEdit}
+             />
+           </Box>
          );
-         return {
-           ...input.document,
-+          originalName: input.document.originalName || input.document.name,
-           reviewResults: reviewResult || [],
-         };
-       }),
+       })}
+ 
+-      {status === 'streaming' && (
++      {(status === 'streaming' || status === 'submitted') && (
+         <Box
+           sx={{
+             display: 'flex',
+@@ -80,7 +85,7 @@ const MessageList: React.FC<MessageListProps> = ({
+         >
+           <CircularProgress size={24} />
+           <Box component="span" sx={{ ml: 1 }}>
+-            AIKATA作業中…
++            {loadingMessage}
+           </Box>
+         </Box>
+       )}
+diff --git a/src/renderer/components/common/SettingsModal.tsx b/src/renderer/components/common/SettingsModal.tsx
+index c5b8d8a92..335ef9d7a 100644
+--- a/src/renderer/components/common/SettingsModal.tsx
++++ b/src/renderer/components/common/SettingsModal.tsx
+@@ -10,7 +10,7 @@ import {
+ } from '@mui/material';
+ import Modal from './Modal';
+ import useSettingsStore from '../../hooks/useSettings';
+-import { StoreSchema as Settings } from '../../../main/store';
++import { StoreSchema as Settings } from '../../../adapter/db/electron-store/store';
+ 
+ interface SettingsModalProps {
+   open: boolean;
+diff --git a/src/renderer/components/review/ChecklistMentionInput.tsx b/src/renderer/components/review/ChecklistMentionInput.tsx
+new file mode 100644
+index 000000000..978c8d7be
+--- /dev/null
++++ b/src/renderer/components/review/ChecklistMentionInput.tsx
+@@ -0,0 +1,364 @@
++import React, { useState, useCallback, useMemo, useRef } from 'react';
++import {
++  Box,
++  IconButton,
++  InputAdornment,
++  Paper,
++  TextField,
++  Chip,
++  Popover,
++  List,
++  ListItem,
++  ListItemButton,
++  ListItemText,
++} from '@mui/material';
++import {
++  Send as SendIcon,
++  StopCircleOutlined as StopIcon,
++} from '@mui/icons-material';
++import { useAlertStore } from '@/renderer/stores/alertStore';
++
++/* ---------- 型定義 ---------- */
++
++export interface ChecklistOption {
++  id: number;
++  content: string;
++}
++
++interface ChecklistMentionInputProps {
++  handleSubmit: (e: React.FormEvent) => void;
++  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
++  message: string;
++  disabled?: boolean;
++  placeholder?: string;
++  isStreaming?: boolean;
++  onStop?: () => void;
++  checklists: ChecklistOption[];
++  selectedChecklistIds: number[];
++  onChecklistSelect: (ids: number[]) => void;
++}
++
++const ChecklistMentionInput: React.FC<ChecklistMentionInputProps> = ({
++  handleSubmit,
++  handleInputChange,
++  message,
++  disabled = false,
++  placeholder = 'メッセージを入力...',
++  isStreaming = false,
++  onStop,
++  checklists,
++  selectedChecklistIds,
++  onChecklistSelect,
++}) => {
++  const [isComposing, setIsComposing] = useState(false);
++  const [showMentionMenu, setShowMentionMenu] = useState(false);
++  const [mentionSearchText, setMentionSearchText] = useState('');
++  const inputRef = useRef<HTMLDivElement>(null);
++  const addAlert = useAlertStore((state) => state.addAlert);
++
++  /* ---------- チェックリストオプション ---------- */
++  const checklistOptions = useMemo(() => {
++    return checklists.map((cl) => ({ id: cl.id, content: cl.content }));
++  }, [checklists]);
++
++  /* ---------- フィルタリングされたチェックリストオプション ---------- */
++  const filteredOptions = useMemo(() => {
++    if (!mentionSearchText) return checklistOptions;
++    const lowerSearch = mentionSearchText.toLowerCase();
++    return checklistOptions.filter((option) =>
++      option.content.toLowerCase().includes(lowerSearch),
++    );
++  }, [checklistOptions, mentionSearchText]);
++
++  /* ---------- @メンション検出 ---------- */
++  const detectMention = useCallback((text: string) => {
++    const atIndex = text.lastIndexOf('@');
++    if (atIndex === -1) return null;
++
++    // @が行の先頭にあるかチェック
++    if (atIndex > 0) {
++      const beforeAt = text[atIndex - 1];
++      // @の直前が改行でない場合はnullを返す
++      if (beforeAt !== '\n') return null;
++    }
++
++    // @以降の文字列を取得
++    const afterAt = text.slice(atIndex + 1);
++    // 空白や改行があれば@メンション終了とみなす
++    if (/\s/.test(afterAt)) return null;
++
++    return { atIndex, searchText: afterAt };
++  }, []);
++
++  /* ---------- 入力変更ハンドラ ---------- */
++  const handleChange = useCallback(
++    (e: React.ChangeEvent<HTMLInputElement>) => {
++      const newValue = e.target.value;
++      handleInputChange(e);
++
++      // @メンション検出
++      const mention = detectMention(newValue);
++      if (mention) {
++        setShowMentionMenu(true);
++        setMentionSearchText(mention.searchText);
++      } else {
++        setShowMentionMenu(false);
++        setMentionSearchText('');
++      }
++    },
++    [handleInputChange, detectMention],
++  );
++
++  /* ---------- チェックリスト選択ハンドラ ---------- */
++  const handleChecklistSelect = useCallback(
++    (checklist: ChecklistOption | null) => {
++      if (!checklist) return;
++
++      const mention = detectMention(message);
++      if (!mention) return;
++
++      // @検索文字列を削除
++      const beforeAt = message.slice(0, mention.atIndex);
++      const afterMention = message.slice(
++        mention.atIndex + 1 + mention.searchText.length,
++      );
++      const newMessage = beforeAt + afterMention;
++
++      // 入力値を更新
++      const syntheticEvent = {
++        target: { value: newMessage },
++      } as React.ChangeEvent<HTMLInputElement>;
++      handleInputChange(syntheticEvent);
++
++      // 選択リストに追加（重複チェック）
++      if (!selectedChecklistIds.includes(checklist.id)) {
++        onChecklistSelect([...selectedChecklistIds, checklist.id]);
++      }
++
++      // メニューを閉じる
++      setShowMentionMenu(false);
++      setMentionSearchText('');
++    },
++    [
++      message,
++      detectMention,
++      handleInputChange,
++      selectedChecklistIds,
++      onChecklistSelect,
++    ],
++  );
++
++  /* ---------- 送信ハンドラ（バリデーション付き） ---------- */
++  const handleSubmitWithValidation = useCallback(
++    (e: React.FormEvent) => {
++      e.preventDefault();
++
++      // チェックリストが一つも選択されていない場合は警告
++      if (selectedChecklistIds.length === 0) {
++        addAlert({
++          message: '@でチェックリストを一つ以上選択してください',
++          severity: 'warning',
++        });
++        return;
++      }
++      handleSubmit(e);
++    },
++    [selectedChecklistIds, handleSubmit, addAlert],
++  );
++
++  /* ---------- Enter キー送信（Shift+Enter で改行） ---------- */
++  const handleKeyDown = (e: React.KeyboardEvent) => {
++    if (e.key === 'Enter' && !isComposing) {
++      // @メンションメニューが表示されている場合は完全一致をチェック
++      if (showMentionMenu && mentionSearchText) {
++        const exactMatch = filteredOptions.find(
++          (option) =>
++            option.content.toLowerCase() === mentionSearchText.toLowerCase(),
++        );
++        if (exactMatch) {
++          // 完全一致した場合は自動選択
++          e.preventDefault();
++          handleChecklistSelect(exactMatch);
++          return;
++        }
++      }
++
++      // Shift+Enterの場合は改行を許可（preventDefaultしない）
++      if (!e.shiftKey) {
++        e.preventDefault();
++        handleSubmitWithValidation(e);
++      }
++    }
++  };
++
++  /* ---------- IME 制御 ---------- */
++  const handleCompositionStart = () => setIsComposing(true);
++  const handleCompositionEnd = () => setIsComposing(false);
++
++  /* ============================================================= */
++
++  return (
++    <Box sx={{ p: 2, width: '100%', mx: 'auto' }}>
++      {/* 選択中のチェックリスト表示 */}
++      {selectedChecklistIds.length > 0 && (
++        <Box
++          sx={{
++            mb: 1,
++            display: 'flex',
++            flexDirection: 'column',
++            alignItems: 'flex-start',
++            gap: 0.5,
++            overflow: 'auto',
++            maxHeight: 100,
++            pb: 0.5,
++          }}
++        >
++          {selectedChecklistIds.map((id) => {
++            const checklist = checklists.find((cl) => cl.id === id);
++            if (!checklist) return null;
++            return (
++              <Chip
++                key={id}
++                label={checklist.content}
++                size="small"
++                color="primary"
++                variant="outlined"
++                onDelete={() => {
++                  onChecklistSelect(
++                    selectedChecklistIds.filter((cid) => cid !== id),
++                  );
++                }}
++              />
++            );
++          })}
++        </Box>
++      )}
++
++      {/* 入力欄 ----------------------------------------------------------- */}
++      <Paper
++        component="form"
++        onSubmit={handleSubmitWithValidation}
++        elevation={3}
++        sx={{
++          p: '2px 4px',
++          display: 'flex',
++          alignItems: 'center',
++          borderRadius: 2,
++          position: 'relative',
++        }}
++      >
++        {/* メインのテキストフィールド */}
++        <TextField
++          ref={inputRef}
++          fullWidth
++          multiline
++          minRows={1}
++          maxRows={6}
++          placeholder={placeholder}
++          variant="outlined"
++          value={message}
++          onChange={handleChange}
++          onKeyDown={handleKeyDown}
++          onCompositionStart={handleCompositionStart}
++          onCompositionEnd={handleCompositionEnd}
++          disabled={disabled}
++          slotProps={{
++            input: {
++              sx: {
++                p: 1,
++                '& fieldset': { border: 'none' },
++              },
++              endAdornment: (
++                <InputAdornment position="end">
++                  {isStreaming ? (
++                    <IconButton
++                      color="primary"
++                      onClick={onStop}
++                      data-testid="review-chat-stop-button"
++                    >
++                      <StopIcon />
++                    </IconButton>
++                  ) : (
++                    <IconButton
++                      color="primary"
++                      type="submit"
++                      disabled={disabled || !message.trim()}
++                      data-testid="review-chat-send-button"
++                    >
++                      <SendIcon />
++                    </IconButton>
++                  )}
++                </InputAdornment>
++              ),
++            },
++          }}
++        />
++
++        {/* @メンション選択メニュー */}
++        <Popover
++          open={showMentionMenu}
++          anchorEl={inputRef.current}
++          onClose={() => {
++            setShowMentionMenu(false);
++            setMentionSearchText('');
++          }}
++          anchorOrigin={{
++            vertical: 'top',
++            horizontal: 'left',
++          }}
++          transformOrigin={{
++            vertical: 'bottom',
++            horizontal: 'left',
++          }}
++          disableAutoFocus
++          disableEnforceFocus
++          disableRestoreFocus
++          slotProps={{
++            paper: {
++              sx: {
++                maxHeight: 200,
++                width: inputRef.current?.offsetWidth || 300,
++                overflow: 'auto',
++              },
++            },
++          }}
++        >
++          <List dense>
++            {filteredOptions.length > 0 ? (
++              filteredOptions.map((option) => (
++                <ListItem key={option.id} disablePadding>
++                  <ListItemButton
++                    onClick={() => handleChecklistSelect(option)}
++                    selected={selectedChecklistIds.includes(option.id)}
++                  >
++                    <ListItemText
++                      primary={`@${option.content}`}
++                      primaryTypographyProps={{
++                        sx: {
++                          fontWeight:
++                            option.content.toLowerCase() ===
++                            mentionSearchText.toLowerCase()
++                              ? 'bold'
++                              : 'normal',
++                        },
++                      }}
++                    />
++                  </ListItemButton>
++                </ListItem>
++              ))
++            ) : (
++              <ListItem>
++                <ListItemText
++                  primary="該当するチェックリストがありません"
++                  sx={{ color: 'text.secondary', fontStyle: 'italic' }}
++                />
++              </ListItem>
++            )}
++          </List>
++        </Popover>
++      </Paper>
++    </Box>
++  );
++};
++
++export default ChecklistMentionInput;
+diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
+index 2d2322987..d75832619 100644
+--- a/src/renderer/components/review/ReviewArea.tsx
++++ b/src/renderer/components/review/ReviewArea.tsx
+@@ -6,11 +6,11 @@ import {
+   Stack,
+   Typography,
+   LinearProgress,
+-  Alert,
+ } from '@mui/material';
+ import CheckBoxIcon from '@mui/icons-material/CheckBox';
+ import RateReviewIcon from '@mui/icons-material/RateReview';
+ import StopIcon from '@mui/icons-material/Stop';
++import ChatIcon from '@mui/icons-material/Chat';
+ import {
+   ReviewChecklistEdit,
+   ReviewChecklistResult,
+@@ -25,6 +25,7 @@ import {
+ import { ReviewAreaProps } from './types';
+ import ReviewChecklistSection from './ReviewChecklistSection';
+ import ReviewSourceModal from './ReviewSourceModal';
++import ReviewChatPanel from './ReviewChatPanel';
+ import { ReviewApi } from '../../service/reviewApi';
+ import { useAlertStore } from '../../stores/alertStore';
+ import { getSafeErrorMessage } from '../../lib/error';
+@@ -47,6 +48,9 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+   const [checklistResults, setChecklistResults] = useState<
+     ReviewChecklistResult[]
+   >([]);
++  const [targetDocumentName, setTargetDocumentName] = useState<string | null>(
++    null,
++  );
+   // チェックリスト更新処理中であるかどうか
+   const [isSaving, setIsSaving] = useState(false);
+   const [isExtracting, setIsExtracting] = useState(false);
+@@ -58,6 +62,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+   const [evaluationSettings, setEvaluationSettings] =
+     useState<CustomEvaluationSettings>(defaultEvaluationSettings);
+ 
++  // チャット関連の状態管理
++  const [chatPanelOpen, setChatPanelOpen] = useState(false);
++  const [chatPanelWidth, setChatPanelWidth] = useState(500);
++  const [isResizing, setIsResizing] = useState(false);
++
+   const addAlert = useAlertStore((state) => state.addAlert);
+ 
+   // イベント購読の解除関数を管理
+@@ -73,6 +82,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+       { throwError: true, showAlert: true },
+     );
+     setChecklistResults(result?.checklistResults || []);
++    setTargetDocumentName(result?.targetDocumentName || null);
+   }, [selectedReviewHistoryId]);
+ 
+   // チェックリスト抽出完了の共通処理ハンドラー
+@@ -526,6 +536,38 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+     setIsSaving(false);
+   };
+ 
++  // リサイズハンドラ
++  const handleMouseDown = (e: React.MouseEvent) => {
++    setIsResizing(true);
++    e.preventDefault();
++  };
++
++  useEffect(() => {
++    if (!isResizing) return;
++
++    const handleMouseMove = (e: MouseEvent) => {
++      // 画面右端からのマウス位置を計算
++      const newWidth = window.innerWidth - e.clientX;
++      // 最小幅350px、最大幅は画面の65%まで
++      const minWidth = 350;
++      const maxWidth = window.innerWidth * 0.65;
++      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
++      setChatPanelWidth(clampedWidth);
++    };
++
++    const handleMouseUp = () => {
++      setIsResizing(false);
++    };
++
++    document.addEventListener('mousemove', handleMouseMove);
++    document.addEventListener('mouseup', handleMouseUp);
++
++    return () => {
++      document.removeEventListener('mousemove', handleMouseMove);
++      document.removeEventListener('mouseup', handleMouseUp);
++    };
++  }, [isResizing]);
++
+   return (
+     <Box
+       sx={{
+@@ -548,15 +590,10 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+           {(isExtracting || isReviewing) && (
+             <Box sx={{ mb: 2 }}>
+               <LinearProgress />
+-              {/* <Alert severity="info" sx={{ mt: 1 }}>
+-                {isExtracting
+-                  ? 'チェックリスト抽出実行中...'
+-                  : 'レビュー実行中...'}
+-              </Alert> */}
+             </Box>
+           )}
+ 
+-          {/* ヘッダー部分 */}
++          {/* ヘッダー部分 - 主要アクションボタン */}
+           <Stack
+             direction="row"
+             justifyContent="space-between"
+@@ -600,25 +637,85 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+               >
+                 {isReviewing ? 'キャンセル' : 'レビュー実行'}
+               </Button>
++              <Button
++                variant="contained"
++                color="primary"
++                startIcon={<ChatIcon />}
++                onClick={() => setChatPanelOpen(true)}
++                disabled={
++                  !selectedReviewHistoryId ||
++                  isExtracting ||
++                  isReviewing ||
++                  checklistResults.filter((cl) => cl.sourceEvaluation?.comment)
++                    .length === 0
++                }
++              >
++                質問
++              </Button>
+             </Stack>
+           </Stack>
+ 
+-          {/* メインコンテンツ */}
+-          <Paper
++          {/* メインコンテンツ - Split View */}
++          <Box
+             sx={{
+-              p: 2,
+-              flex: 1,
+               display: 'flex',
+-              flexDirection: 'column',
++              flexDirection: 'row',
++              flex: 1,
+               minHeight: 0,
++              gap: 0,
+             }}
+           >
+-            <ReviewChecklistSection
+-              checklistResults={checklistResults}
+-              isLoading={isExtracting || isReviewing}
+-              onSave={handleSaveChecklist}
+-            />
+-          </Paper>
++            {/* レビュー結果エリア */}
++            <Paper
++              sx={{
++                p: 2,
++                flex: 1,
++                display: 'flex',
++                flexDirection: 'column',
++                minHeight: 0,
++                minWidth: chatPanelOpen ? 400 : 0,
++                overflow: 'hidden',
++              }}
++            >
++              <ReviewChecklistSection
++                checklistResults={checklistResults}
++                isLoading={isExtracting || isReviewing}
++                onSave={handleSaveChecklist}
++                targetDocumentName={targetDocumentName}
++              />
++            </Paper>
++
++            {/* リサイズハンドル */}
++            {chatPanelOpen && (
++              <Box
++                onMouseDown={handleMouseDown}
++                sx={{
++                  width: '6px',
++                  cursor: 'col-resize',
++                  bgcolor: 'divider',
++                  transition: 'background-color 0.2s',
++                  flexShrink: 0,
++                  userSelect: 'none',
++                }}
++              />
++            )}
++
++            {/* チャットパネル */}
++            {selectedReviewHistoryId && (
++              <ReviewChatPanel
++                open={chatPanelOpen}
++                onClose={() => setChatPanelOpen(false)}
++                reviewHistoryId={selectedReviewHistoryId}
++                checklists={checklistResults
++                  .filter((cl) => cl.sourceEvaluation?.comment)
++                  .map((cl) => ({
++                    id: cl.id,
++                    content: cl.content,
++                  }))}
++                width={chatPanelWidth}
++              />
++            )}
++          </Box>
+ 
+           {/* モーダル */}
+           <ReviewSourceModal
+diff --git a/src/renderer/components/review/ReviewChatPanel.tsx b/src/renderer/components/review/ReviewChatPanel.tsx
+new file mode 100644
+index 000000000..525cfea7b
+--- /dev/null
++++ b/src/renderer/components/review/ReviewChatPanel.tsx
+@@ -0,0 +1,265 @@
++import React, { useState, useEffect, useCallback } from 'react';
++import { useChat } from '@ai-sdk/react';
++import { Box, Divider, IconButton } from '@mui/material';
++import CloseIcon from '@mui/icons-material/Close';
++import { v4 as uuid } from 'uuid';
++import { ChatMessage } from '@/types';
++import { IpcRequestPayload, IpcChannels } from '@/types/ipc';
++import { useAlertStore } from '@/renderer/stores/alertStore';
++import { getSafeErrorMessage } from '@/renderer/lib/error';
++import MessageList from '../chat/MessageList';
++import ChecklistMentionInput, {
++  ChecklistOption,
++} from './ChecklistMentionInput';
++import { ReviewChatApi } from '../../service/reviewChatApi';
++
++interface ReviewChatPanelProps {
++  open: boolean;
++  onClose: () => void;
++  reviewHistoryId: string;
++  checklists: ChecklistOption[];
++  width?: number;
++}
++
++// customFetch関数 - ChatArea.tsxを参考に実装
++const customFetch: typeof fetch = async (input, init) => {
++  if (typeof input === 'string' && input === '/api/review-chat') {
++    let unsubscribe: () => void;
++    const encoder = new TextEncoder();
++    const reviewChatApi = ReviewChatApi.getInstance();
++
++    const stream = new ReadableStream({
++      start(controller) {
++        unsubscribe = reviewChatApi.streamResponse({
++          onMessage(raw) {
++            controller.enqueue(encoder.encode(raw));
++          },
++          onDone() {
++            controller.close();
++          },
++          onError(err) {
++            controller.error(err);
++          },
++        });
++
++        const { reviewHistoryId, checklistIds, question } = JSON.parse(
++          init!.body as string,
++        ) as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
++
++        init?.signal?.addEventListener('abort', () => {
++          reviewChatApi.abortChat(reviewHistoryId, {
++            showAlert: false,
++            throwError: true,
++          });
++          unsubscribe();
++          controller.close();
++        });
++
++        reviewChatApi.sendMessage(reviewHistoryId, checklistIds, question, {
++          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
++          showAlert: false,
++          throwError: false,
++        });
++      },
++      cancel() {
++        unsubscribe();
++      },
++    });
++
++    return new Response(stream, {
++      headers: {
++        // SSE＋Data Stream Protocol ヘッダ
++        'Content-Type': 'text/event-stream; charset=utf-8',
++        'x-vercel-ai-data-stream': 'v1',
++      },
++    });
++  }
++
++  return fetch(input, init);
++};
++
++// プレースホルダーテキストを取得する関数
++const getPlaceholderText = (status: string): string => {
++  if (status === 'submitted') return 'メッセージ送信中…';
++  return '@でチェックリストを選択して質問してください';
++};
++
++const ReviewChatPanel: React.FC<ReviewChatPanelProps> = ({
++  open,
++  onClose,
++  reviewHistoryId,
++  checklists,
++  width = 500,
++}) => {
++  const [input, setInput] = useState<string>('');
++  const [selectedChecklistIds, setSelectedChecklistIds] = useState<number[]>(
++    [],
++  );
++  const addAlert = useAlertStore((state) => state.addAlert);
++
++  const { messages, setMessages, reload, status, error, stop } = useChat({
++    id: reviewHistoryId,
++    api: '/api/review-chat',
++    fetch: customFetch,
++    experimental_throttle: 75,
++    experimental_prepareRequestBody: (request) => {
++      // Ensure messages array is not empty and get the last message
++      const lastMessage =
++        request.messages.length > 0
++          ? request.messages[request.messages.length - 1]
++          : null;
++      if (!lastMessage) {
++        throw new Error('送信メッセージの取得に失敗しました');
++      }
++
++      // Return the structured body for API route
++      return {
++        reviewHistoryId,
++        checklistIds: selectedChecklistIds,
++        question: lastMessage.content,
++      } as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
++    },
++    onError(err) {
++      console.error('useChat error:', err);
++    },
++  });
++
++  // useChatのエラーをアラートとして表示
++  useEffect(() => {
++    if (error) {
++      addAlert({
++        message: getSafeErrorMessage(error),
++        severity: 'error',
++      });
++    }
++  }, [error, addAlert]);
++
++  // レビューID変更時にチャット内容を初期化
++  useEffect(() => {
++    setMessages([]);
++    setInput('');
++    setSelectedChecklistIds([]);
++  }, [reviewHistoryId, setMessages]);
++
++  /* ---------- メッセージ送信処理 ---------- */
++  const handleInputChange = useCallback(
++    (e: React.ChangeEvent<HTMLInputElement>) => {
++      setInput(e.target.value);
++    },
++    [],
++  );
++
++  const handleSubmit = useCallback(
++    async (e: React.FormEvent) => {
++      e.preventDefault();
++      if (!input.trim()) return;
++
++      // チェックリスト未選択の場合は警告
++      if (selectedChecklistIds.length === 0) {
++        addAlert({
++          message: '@でチェックリストを選択してください',
++          severity: 'warning',
++        });
++        return;
++      }
++
++      // 選択されたチェックリストの内容を取得してフォーマット
++      const selectedChecklistContents = selectedChecklistIds
++        .map((id) => {
++          const checklist = checklists.find((cl) => cl.id === id);
++          return checklist ? `@${checklist.content}` : null;
++        })
++        .filter((content): content is string => content !== null);
++
++      // チェックリスト部分 + 空行 + 本文の形式でメッセージを構築
++      const formattedContent =
++        selectedChecklistContents.length > 0
++          ? `${selectedChecklistContents.join('\n')}\n\n${input}`
++          : input;
++
++      const newMessage: ChatMessage = {
++        id: uuid(),
++        role: 'user',
++        content: formattedContent,
++        parts: [
++          {
++            type: 'text',
++            text: formattedContent,
++          },
++        ],
++      };
++
++      setInput('');
++      setMessages((prev) => [...prev, newMessage]);
++      reload();
++    },
++    [input, selectedChecklistIds, checklists, addAlert, setMessages, reload],
++  );
++
++  if (!open) return null;
++
++  return (
++    <Box
++      sx={{
++        width,
++        minWidth: 300,
++        height: '100%',
++        display: 'flex',
++        flexDirection: 'column',
++        borderLeft: 1,
++        borderColor: 'divider',
++        bgcolor: 'background.paper',
++        position: 'relative',
++      }}
++    >
++      {/* ヘッダー（閉じるボタン） */}
++      <Box
++        sx={{
++          display: 'flex',
++          justifyContent: 'flex-end',
++          p: 1,
++          borderBottom: 1,
++          borderColor: 'divider',
++        }}
++      >
++        <IconButton size="small" onClick={onClose}>
++          <CloseIcon />
++        </IconButton>
++      </Box>
++
++      {/* メッセージリスト */}
++      <MessageList
++        messages={messages}
++        loading={false}
++        status={status}
++        editContent=""
++        disabled={status === 'submitted' || status === 'streaming'}
++        editingMessageId=""
++        onEditStart={() => {}}
++        onEditContentChange={() => {}}
++        onEditSubmit={async () => {}}
++        onEditCancel={() => {}}
++        loadingMessage="ドキュメントの調査中..."
++        disableEdit
++      />
++
++      <Divider />
++
++      {/* メッセージ入力 */}
++      <ChecklistMentionInput
++        handleSubmit={handleSubmit}
++        handleInputChange={handleInputChange}
++        message={input}
++        disabled={status === 'submitted' || status === 'streaming'}
++        placeholder={getPlaceholderText(status)}
++        isStreaming={status === 'streaming'}
++        onStop={stop}
++        checklists={checklists}
++        selectedChecklistIds={selectedChecklistIds}
++        onChecklistSelect={setSelectedChecklistIds}
++      />
++    </Box>
++  );
++};
++
++export default ReviewChatPanel;
+diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
+index d37a5b5c9..7b00c802b 100644
+--- a/src/renderer/components/review/ReviewChecklistSection.tsx
++++ b/src/renderer/components/review/ReviewChecklistSection.tsx
+@@ -58,6 +58,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+   checklistResults,
+   isLoading,
+   onSave,
++  targetDocumentName,
+ }) => {
+   // --- ステート ---
+   const [editingId, setEditingId] = useState<number | null>(null);
+@@ -94,11 +95,11 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+     setIsAddingNew(false);
+     setNewContent('');
+   };
+-  const handleSort = (fileId: string) => {
+-    if (sortBy === fileId) {
++  const handleSort = () => {
++    if (sortBy === 'evaluation') {
+       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
+     } else {
+-      setSortBy(fileId);
++      setSortBy('evaluation');
+       setSortDirection('desc');
+     }
+   };
+@@ -110,35 +111,15 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+     downloadCSV(csvContent, filename);
+   };
+ 
+-  // --- ユニークファイル抽出 ---
+-  const uniqueSources = useMemo(() => {
+-    const map = new Map<string, { id: string; fileName: string }>();
+-    checklistResults.forEach((cl) => {
+-      cl.sourceEvaluations?.forEach((ev) => {
+-        if (!map.has(ev.fileId)) {
+-          map.set(ev.fileId, {
+-            id: ev.fileId,
+-            fileName: ev.fileName,
+-          });
+-        }
+-      });
+-    });
+-    return Array.from(map.values());
+-  }, [checklistResults]);
+-
+   // --- ソート ---
+   // 動的評価項目対応のため、文字列順ソートを使用
+   const sortedResults = useMemo(() => {
+-    if (sortBy == null) return checklistResults;
++    if (sortBy !== 'evaluation') return checklistResults;
+ 
+     return [...checklistResults].sort((a, b) => {
+-      // 対象ファイルの評価を取得。未評価は空文字扱い
+-      const aEv =
+-        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
+-        '';
+-      const bEv =
+-        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
+-        '';
++      // 評価を取得。未評価は空文字扱い
++      const aEv = a.sourceEvaluation?.evaluation ?? '';
++      const bEv = b.sourceEvaluation?.evaluation ?? '';
+ 
+       // 文字列順で比較
+       if (sortDirection === 'desc') {
+@@ -169,41 +150,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+         >
+           チェックリスト
+         </TableCell>
+-        {uniqueSources.map((src) => (
+-          <TableCell
+-            key={src.id}
+-            align="center"
+-            sx={{
+-              minWidth: 200,
+-            }}
++        <TableCell
++          align="center"
++          sx={{
++            minWidth: 300,
++          }}
++        >
++          <TableSortLabel
++            active={sortBy === 'evaluation'}
++            direction={sortBy === 'evaluation' ? sortDirection : 'desc'}
++            onClick={() => handleSort()}
+           >
+-            <Box
+-              sx={{
+-                maxHeight: '4.5em',
+-                overflow: 'hidden',
+-                overflowY: 'auto',
+-                lineHeight: '1.5em',
+-                whiteSpace: 'normal',
+-                wordBreak: 'break-all',
+-                '&:hover': {
+-                  overflowY: 'auto',
+-                },
+-              }}
+-            >
+-              <Tooltip title={src.fileName} placement="top">
+-                <div>
+-                  <TableSortLabel
+-                    active={sortBy === src.id}
+-                    direction={sortBy === src.id ? sortDirection : 'desc'}
+-                    onClick={() => handleSort(src.id)}
+-                  >
+-                    {src.fileName}
+-                  </TableSortLabel>
+-                </div>
++            {targetDocumentName ? (
++              <Tooltip title={targetDocumentName} placement="top">
++                <Box
++                  component="span"
++                  sx={{
++                    maxHeight: '4.5em',
++                    overflow: 'hidden',
++                    textOverflow: 'ellipsis',
++                    wordBreak: 'break-all',
++                    whiteSpace: 'normal',
++                  }}
++                >
++                  レビュー結果 ({targetDocumentName})
++                </Box>
+               </Tooltip>
+-            </Box>
+-          </TableCell>
+-        ))}
++            ) : (
++              'レビュー結果'
++            )}
++          </TableSortLabel>
++        </TableCell>
+         <TableCell align="center" sx={{ minWidth: 120 }}>
+           操作
+         </TableCell>
+@@ -231,44 +208,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+           )}
+         </Box>
+       </TableCell>
+-      {/* 評価列 */}
+-      {uniqueSources.map((src) => {
+-        const ev = checklist.sourceEvaluations?.find(
+-          (x) => x.fileId === src.id,
+-        );
+-        return (
+-          <TableCell
+-            key={src.id}
+-            align="center"
+-            sx={{ p: 1, verticalAlign: 'top' }}
+-          >
+-            <Box>
+-              {ev?.evaluation && (
+-                <Stack spacing={1} alignItems="center">
+-                  <Typography
+-                    variant="body2"
+-                    sx={{
+-                      color: getEvaluationColor(ev.evaluation),
+-                      fontWeight: 'bold',
+-                      textDecoration: 'underline',
+-                      textDecorationColor: getEvaluationColor(ev.evaluation),
+-                      textDecorationThickness: '2px',
+-                      textUnderlineOffset: '3px',
+-                    }}
+-                  >
+-                    {ev.evaluation}
+-                  </Typography>
+-                  {ev.comment && (
+-                    <Typography variant="body2" sx={commentBoxSx}>
+-                      {ev.comment}
+-                    </Typography>
+-                  )}
+-                </Stack>
++      {/* レビュー結果列 */}
++      <TableCell align="center" sx={{ p: 1, verticalAlign: 'top' }}>
++        <Box>
++          {checklist.sourceEvaluation?.evaluation && (
++            <Stack spacing={1} alignItems="center">
++              <Typography
++                variant="body2"
++                sx={{
++                  color: getEvaluationColor(
++                    checklist.sourceEvaluation.evaluation,
++                  ),
++                  fontWeight: 'bold',
++                  textDecoration: 'underline',
++                  textDecorationColor: getEvaluationColor(
++                    checklist.sourceEvaluation.evaluation,
++                  ),
++                  textDecorationThickness: '2px',
++                  textUnderlineOffset: '3px',
++                }}
++              >
++                {checklist.sourceEvaluation.evaluation}
++              </Typography>
++              {checklist.sourceEvaluation.comment && (
++                <Typography variant="body2" sx={commentBoxSx}>
++                  {checklist.sourceEvaluation.comment}
++                </Typography>
+               )}
+-            </Box>
+-          </TableCell>
+-        );
+-      })}
++            </Stack>
++          )}
++        </Box>
++      </TableCell>
+       {/* 操作 */}
+       <TableCell align="center" sx={{ p: 1 }}>
+         <Stack direction="row" spacing={1} justifyContent="center">
+@@ -321,10 +291,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+           />
+         </Box>
+       </TableCell>
+-      {uniqueSources.map((_, i) => (
+-        // eslint-disable-next-line
+-        <TableCell key={i} />
+-      ))}
++      <TableCell />
+       <TableCell align="center" sx={{ p: 1 }}>
+         <Stack direction="row" spacing={1} justifyContent="center">
+           <IconButton
+diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
+index 2599bdf7c..1f662086c 100644
+--- a/src/renderer/components/review/types.ts
++++ b/src/renderer/components/review/types.ts
+@@ -18,6 +18,7 @@ export interface ReviewChecklistSectionProps {
+   checklistResults: ReviewChecklistResult[];
+   isLoading: boolean;
+   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
++  targetDocumentName?: string | null;
+ }
+ 
+ // ReviewSourceModalのProps型
+diff --git a/src/renderer/lib/csvUtils.ts b/src/renderer/lib/csvUtils.ts
+index 7cfdefb6c..c5aac8405 100644
+--- a/src/renderer/lib/csvUtils.ts
++++ b/src/renderer/lib/csvUtils.ts
+@@ -36,27 +36,8 @@ export const convertReviewResultsToCSV = (
+     return 'チェックリスト\n';
+   }
+ 
+-  // ユニークなソースファイルを抽出
+-  const uniqueSources = new Map<string, { id: string; fileName: string }>();
+-  checklistResults.forEach((checklist) => {
+-    checklist.sourceEvaluations?.forEach((ev) => {
+-      if (!uniqueSources.has(ev.fileId)) {
+-        uniqueSources.set(ev.fileId, {
+-          id: ev.fileId,
+-          fileName: ev.fileName,
+-        });
+-      }
+-    });
+-  });
+-
+-  const sources = Array.from(uniqueSources.values());
+-
+   // ヘッダー行を構築
+-  const headers = ['チェックリスト'];
+-  sources.forEach((source) => {
+-    headers.push(`${source.fileName}_評価`);
+-    headers.push(`${source.fileName}_コメント`);
+-  });
++  const headers = ['チェックリスト', '評価', 'コメント'];
+ 
+   const csvRows: string[] = [];
+ 
+@@ -65,18 +46,11 @@ export const convertReviewResultsToCSV = (
+ 
+   // データ行を追加
+   checklistResults.forEach((checklist) => {
+-    const row: string[] = [checklist.content];
+-
+-    sources.forEach((source) => {
+-      const evaluation = checklist.sourceEvaluations?.find(
+-        (ev) => ev.fileId === source.id,
+-      );
+-
+-      // 評価値
+-      row.push(evaluation?.evaluation || '');
+-      // コメント
+-      row.push(evaluation?.comment || '');
+-    });
++    const row: string[] = [
++      checklist.content,
++      checklist.sourceEvaluation?.evaluation || '',
++      checklist.sourceEvaluation?.comment || '',
++    ];
+ 
+     csvRows.push(row.map(escapeCSVField).join(','));
+   });
+diff --git a/src/renderer/service/chatApi.ts b/src/renderer/service/chatApi.ts
+index 7e99d3fcf..ae3995928 100644
+--- a/src/renderer/service/chatApi.ts
++++ b/src/renderer/service/chatApi.ts
+@@ -129,9 +129,13 @@ export class ChatApi implements IChatApi {
+     roomId: string,
+     options?: ApiServiceDefaultOptions,
+   ): Promise<void> {
+-    await invokeApi(() => window.electron.chat.requestAbort({
+-      threadId: roomId,
+-    }), options);
++    await invokeApi(
++      () =>
++        window.electron.chat.requestAbort({
++          threadId: roomId,
++        }),
++      options,
++    );
+   }
+ 
+   public async getChatMessages(
+@@ -146,7 +150,10 @@ export class ChatApi implements IChatApi {
+     title: string,
+     options?: ApiServiceDefaultOptions,
+   ): Promise<void> {
+-    await invokeApi(() => window.electron.chat.createThread({ roomId, title }), options);
++    await invokeApi(
++      () => window.electron.chat.createThread({ roomId, title }),
++      options,
++    );
+   }
+ 
+   public async sendMessage(
+@@ -154,7 +161,10 @@ export class ChatApi implements IChatApi {
+     messages: ChatMessage[],
+     options?: ApiServiceDefaultOptions,
+   ): Promise<void> {
+-    await invokeApi(() => window.electron.chat.sendMessage({ roomId, messages }), options);
++    await invokeApi(
++      () => window.electron.chat.sendMessage({ roomId, messages }),
++      options,
++    );
+     console.log('Message sent via IPC:', { roomId, messages });
+   }
+ 
+@@ -163,9 +173,13 @@ export class ChatApi implements IChatApi {
+     messageId: string,
+     options?: ApiServiceDefaultOptions,
+   ): Promise<void> {
+-    await invokeApi(() => window.electron.chat.deleteMessagesBeforeSpecificId({
+-      threadId: roomId,
+-      messageId,
+-    }), options);
++    await invokeApi(
++      () =>
++        window.electron.chat.deleteMessagesBeforeSpecificId({
++          threadId: roomId,
++          messageId,
++        }),
++      options,
++    );
+   }
+ }
+diff --git a/src/renderer/service/fsApi.ts b/src/renderer/service/fsApi.ts
+index bf8cc05a5..69f5b5f9b 100644
+--- a/src/renderer/service/fsApi.ts
++++ b/src/renderer/service/fsApi.ts
+@@ -40,7 +40,10 @@ export class FsApi implements IFsApi {
+     options: OpenDialogOptions,
+     apiOptions?: ApiServiceDefaultOptions,
+   ): Promise<{ filePaths: string[]; canceled: boolean } | null> {
+-    return invokeApi(() => window.electron.fs.showOpenDialog(options), apiOptions);
++    return invokeApi(
++      () => window.electron.fs.showOpenDialog(options),
++      apiOptions,
++    );
+   }
+ 
+   public async readFile(
+diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
+index 02fc24edb..1ed208b6f 100644
+--- a/src/renderer/service/reviewApi.ts
++++ b/src/renderer/service/reviewApi.ts
+@@ -27,6 +27,7 @@ export interface IReviewApi {
+     options?: ApiServiceDefaultOptions,
+   ): Promise<{
+     checklistResults?: ReviewChecklistResult[];
++    targetDocumentName?: string | null;
+   } | null>;
+   getReviewInstruction(
+     historyId: string,
+@@ -118,6 +119,7 @@ export class ReviewApi implements IReviewApi {
+     options?: ApiServiceDefaultOptions,
+   ): Promise<{
+     checklistResults?: ReviewChecklistResult[];
++    targetDocumentName?: string | null;
+   } | null> {
+     return invokeApi(
+       () => window.electron.review.getHistoryDetail(historyId),
+diff --git a/src/renderer/service/reviewChatApi.ts b/src/renderer/service/reviewChatApi.ts
+new file mode 100644
+index 000000000..f3da0c3d2
+--- /dev/null
++++ b/src/renderer/service/reviewChatApi.ts
+@@ -0,0 +1,136 @@
++import { IpcChannels, IpcEventPayload } from '@/types';
++import { invokeApi } from '../lib/apiUtils';
++import { ApiServiceDefaultOptions } from '../types';
++import { ElectronPushClient } from '../lib/ElectronPushClient';
++
++export interface IReviewChatApi {
++  streamResponse(callbacks: {
++    onMessage: (
++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
++    ) => void;
++    onDone: () => void;
++    onError: (error: Error) => void;
++  }): () => void;
++  abortChat(
++    reviewHistoryId: string,
++    options?: ApiServiceDefaultOptions,
++  ): Promise<void>;
++  sendMessage(
++    reviewHistoryId: string,
++    checklistIds: number[],
++    question: string,
++    options?: ApiServiceDefaultOptions,
++  ): Promise<void>;
++}
++
++// IPC通信を使用してレビューチャット機能を提供するAPIサービス
++export class ReviewChatApi implements IReviewChatApi {
++  // シングルトン変数
++  private static instance: ReviewChatApi;
++
++  // コンストラクタをprivateにして外部からのインスタンス化を防止
++  private constructor() {}
++
++  // シングルトンインスタンスを取得するための静的メソッド
++  public static getInstance(): ReviewChatApi {
++    if (!ReviewChatApi.instance) {
++      ReviewChatApi.instance = new ReviewChatApi();
++    }
++    return ReviewChatApi.instance;
++  }
++
++  /**
++   * ストリーミング応答の購読
++   * @param callbacks ストリーミングイベントのコールバック
++   * @returns 購読解除用の関数
++   */
++  public streamResponse(callbacks: {
++    onMessage: (
++      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
++    ) => void;
++    onDone: () => void;
++    onError: (error: Error) => void;
++  }): () => void {
++    const pushClient = new ElectronPushClient();
++    const abortController = new AbortController();
++
++    // ストリーミングイベントの購読
++    pushClient.subscribe(
++      IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
++      (event) => {
++        callbacks.onMessage(event.payload);
++      },
++      { signal: abortController.signal },
++    );
++
++    // 完了イベント（レビューチャット専用）
++    pushClient.subscribe(
++      IpcChannels.REVIEW_CHAT_COMPLETE,
++      () => {
++        // 購読を解除
++        abortController.abort();
++        // 完了コールバックを呼び出し
++        callbacks.onDone();
++      },
++      { signal: abortController.signal },
++    );
++
++    // エラーイベント（レビューチャット専用）
++    pushClient.subscribe(
++      IpcChannels.REVIEW_CHAT_ERROR,
++      (event) => {
++        // 購読を解除
++        abortController.abort();
++        // エラーコールバックを呼び出し
++        callbacks.onError(
++          new Error(event.payload.message || '予期せぬエラーが発生しました'),
++        );
++      },
++      { signal: abortController.signal },
++    );
++
++    // 購読解除のためのクリーンアップ
++    return () => {
++      abortController.abort();
++    };
++  }
++
++  /**
++   * レビューチャットの中断
++   * @param reviewHistoryId レビュー履歴ID
++   * @param options APIサービスのオプション
++   */
++  public async abortChat(
++    reviewHistoryId: string,
++    options?: ApiServiceDefaultOptions,
++  ): Promise<void> {
++    await invokeApi(
++      () => window.electron.review.abortChat(reviewHistoryId),
++      options,
++    );
++  }
++
++  /**
++   * レビューチャットメッセージ送信
++   * @param reviewHistoryId レビュー履歴ID
++   * @param checklistIds チェックリストID配列
++   * @param question ユーザからの質問
++   * @param options APIサービスのオプション
++   */
++  public async sendMessage(
++    reviewHistoryId: string,
++    checklistIds: number[],
++    question: string,
++    options?: ApiServiceDefaultOptions,
++  ): Promise<void> {
++    await invokeApi(
++      () =>
++        window.electron.review.sendChatMessage({
++          reviewHistoryId,
++          checklistIds,
++          question,
++        }),
++      options,
++    );
++  }
++}
+diff --git a/src/renderer/service/settingsApi.ts b/src/renderer/service/settingsApi.ts
+index 8ec061cbf..a2cdeecc5 100644
+--- a/src/renderer/service/settingsApi.ts
++++ b/src/renderer/service/settingsApi.ts
+@@ -47,7 +47,10 @@ export class SettingsApi implements ISettingsApi {
+     messageId: string,
+     options?: ApiServiceDefaultOptions,
+   ): Promise<void> {
+-    await invokeApi(() => window.electron.settings.removeMessage(messageId), options);
++    await invokeApi(
++      () => window.electron.settings.removeMessage(messageId),
++      options,
++    );
+   }
+ 
+   public async reinitialize(options?: ApiServiceDefaultOptions): Promise<void> {
+@@ -64,7 +67,10 @@ export class SettingsApi implements ISettingsApi {
+     settings: Settings,
+     options?: ApiServiceDefaultOptions,
+   ): Promise<boolean | null> {
+-    return invokeApi(() => window.electron.settings.setSettings(settings), options);
++    return invokeApi(
++      () => window.electron.settings.setSettings(settings),
++      options,
++    );
+   }
+ 
+   public async subscribeSettingsUpdateFinished(
+diff --git a/src/renderer/service/sourceApi.ts b/src/renderer/service/sourceApi.ts
+index 76b2f9c6f..2500ff69b 100644
+--- a/src/renderer/service/sourceApi.ts
++++ b/src/renderer/service/sourceApi.ts
+@@ -49,10 +49,14 @@ export class SourceApi implements ISourceApi {
+     enabled: boolean,
+     options?: ApiServiceDefaultOptions,
+   ): Promise<void> {
+-    await invokeApi(() => window.electron.source.updateSourceEnabled({
+-      sourceId: id,
+-      isEnabled: enabled,
+-    }), options);
++    await invokeApi(
++      () =>
++        window.electron.source.updateSourceEnabled({
++          sourceId: id,
++          isEnabled: enabled,
++        }),
++      options,
++    );
+   }
+ 
+   public async subscribeSourceReloadFinished(
+diff --git a/src/types/error.ts b/src/types/error.ts
+index a4fd32185..ad22f0b75 100644
+--- a/src/types/error.ts
++++ b/src/types/error.ts
+@@ -14,10 +14,7 @@ export type ErrorCode =
+ /**
+  * フロントエンドで利用するエラーコード
+  */
+-export type FrontErrorCode =
+-  | 'APP_API'
+-  | 'APP_API_CALL'
+-  | 'INTERNAL';
++export type FrontErrorCode = 'APP_API' | 'APP_API_CALL' | 'INTERNAL';
+ 
+ /**
+  * クライアントへ返す標準エラー形
+diff --git a/src/types/ipc.ts b/src/types/ipc.ts
+index 0fc449d82..69d3b10bd 100644
+--- a/src/types/ipc.ts
++++ b/src/types/ipc.ts
+@@ -81,6 +81,11 @@ export const IpcChannels = {
+   REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
+   REVIEW_EXECUTE_ABORT: 'review-execute-abort', // レビュー実行処理をキャンセルする
+   REVIEW_HISTORY_UPDATED: 'review-history-updated', // レビュー履歴が更新された際の通知
++  REVIEW_CHAT_SEND_MESSAGE: 'review-chat-send-message', // レビューチャットメッセージ送信
++  REVIEW_CHAT_STREAM_RESPONSE: 'review-chat-stream-response', // レビューチャットストリーミング応答
++  REVIEW_CHAT_COMPLETE: 'review-chat-complete', // レビューチャット完了
++  REVIEW_CHAT_ERROR: 'review-chat-error', // レビューチャットエラー
++  REVIEW_CHAT_ABORT: 'review-chat-abort', // レビューチャット中断
+ } as const;
+ 
+ export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
+@@ -150,6 +155,12 @@ export type IpcRequestPayloadMap = {
+     documentMode: DocumentMode;
+   };
+   [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: {
++    reviewHistoryId: string;
++    checklistIds: number[];
++    question: string;
++  };
++  [IpcChannels.REVIEW_CHAT_ABORT]: string; // review history id
+ };
+ 
+ export type IpcResponsePayloadMap = {
+@@ -189,6 +200,7 @@ export type IpcResponsePayloadMap = {
+   [IpcChannels.REVIEW_GET_HISTORIES]: IpcResult<RevieHistory[]>;
+   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: IpcResult<{
+     checklistResults?: ReviewChecklistResult[];
++    targetDocumentName?: string | null;
+   }>;
+   [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: IpcResult<{
+     additionalInstructions?: string;
+@@ -201,6 +213,8 @@ export type IpcResponsePayloadMap = {
+   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: IpcResult;
+   [IpcChannels.REVIEW_EXECUTE_CALL]: IpcResult;
+   [IpcChannels.REVIEW_EXECUTE_ABORT]: IpcResult;
++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: IpcResult;
++  [IpcChannels.REVIEW_CHAT_ABORT]: IpcResult;
+ };
+ 
+ export type IpcEventPayloadMap = {
+@@ -227,6 +241,9 @@ export type IpcEventPayloadMap = {
+     currentSheet?: number;
+     totalSheets?: number;
+   };
++  [IpcChannels.REVIEW_CHAT_STREAM_RESPONSE]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
++  [IpcChannels.REVIEW_CHAT_COMPLETE]: unknown;
++  [IpcChannels.REVIEW_CHAT_ERROR]: { message: string };
+ };
+ 
+ /**
+@@ -287,4 +304,8 @@ export const IpcNameMap = {
+   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: 'チェックリストの更新',
+   [IpcChannels.REVIEW_EXECUTE_CALL]: 'ドキュメントレビューの実行',
+   [IpcChannels.REVIEW_EXECUTE_ABORT]: 'ドキュメントレビューの中断',
++  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: 'レビューチャットメッセージ送信',
++  [IpcChannels.REVIEW_CHAT_COMPLETE]: 'レビューチャット完了',
++  [IpcChannels.REVIEW_CHAT_ERROR]: 'レビューチャットエラー',
++  [IpcChannels.REVIEW_CHAT_ABORT]: 'レビューチャット中断',
+ };
+diff --git a/src/types/message.ts b/src/types/message.ts
+index 979bb1cda..a4065ae2e 100644
+--- a/src/types/message.ts
++++ b/src/types/message.ts
+@@ -11,6 +11,7 @@ export type MessageCode =
+   | 'GITLAB_API_CONNECTION_ERROR'
+   | 'REDMINE_API_CONNECTION_ERROR'
+   | 'REDMINE_API_ERROR'
++  | 'FS_OPEN_DIALOG_ERROR'
+   | 'FILE_TEXT_EXTRACTION_ERROR'
+   | 'FS_CONVERT_OFFICE_TO_PDF_ERROR'
+   | 'SOURCE_REGISTRATION_DIR_READING_ERROR'
+@@ -18,8 +19,10 @@ export type MessageCode =
+   | 'REVIEW_CHECKLIST_EXTRACTION_ERROR'
+   | 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS'
+   | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
++  | 'REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM'
+   | 'REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR'
+   | 'REVIEW_EXECUTION_ERROR'
+   | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
+   | 'AI_API_ERROR'
+-  | 'AI_MESSAGE_TOO_LARGE';
++  | 'AI_MESSAGE_TOO_LARGE'
++  | 'REVIEW_DOCUMENT_CACHE_NOT_FOUND';
+diff --git a/src/types/review.ts b/src/types/review.ts
+index 52578ffaa..85bce2524 100644
+--- a/src/types/review.ts
++++ b/src/types/review.ts
+@@ -1,6 +1,7 @@
+ export interface RevieHistory {
+   id: string; // reviewHistoriesのid
+   title: string;
++  targetDocumentName?: string | null; // レビュー対象の統合ドキュメント名
+   additionalInstructions: string | null;
+   commentFormat?: string | null;
+   evaluationSettings?: CustomEvaluationSettings | null; // カスタム評定項目設定
+@@ -13,6 +14,8 @@ export interface ReviewChecklist {
+   id: number;
+   reviewHistoryId: string;
+   content: string;
++  evaluation?: ReviewEvaluation | null; // A, B, C, - 評価
++  comment?: string | null; // レビューコメント
+   createdBy: ReviewChecklistCreatedBy;
+   createdAt: string;
+   updatedAt: string;
+@@ -39,12 +42,10 @@ export type ReviewChecklistCreatedBy = 'user' | 'system';
+ export type ReviewChecklistResult = {
+   id: number; // チェックリストのID
+   content: string;
+-  sourceEvaluations?: {
+-    fileId: string;
+-    fileName: string;
++  sourceEvaluation?: {
+     evaluation?: ReviewEvaluation; // カスタム評定項目対応
+     comment?: string;
+-  }[];
++  };
+ };
+ 
+ // チェックリストの編集内容を表す型
+@@ -92,8 +93,31 @@ export type ReviewExecutionResultStatus =
+ 
+ // 処理ステータスの型定義
+ export type ProcessingStatus =
+-  | 'idle'        // アイドル状態
+-  | 'extracting'  // チェックリスト抽出中
+-  | 'extracted'   // チェックリスト抽出完了
+-  | 'reviewing'   // レビュー実行中
+-  | 'completed';  // レビュー完了
++  | 'idle' // アイドル状態
++  | 'extracting' // チェックリスト抽出中
++  | 'extracted' // チェックリスト抽出完了
++  | 'reviewing' // レビュー実行中
++  | 'completed'; // レビュー完了
++
++// レビュードキュメントキャッシュ（サービス層で使用）
++export interface ReviewDocumentCache {
++  id: number;
++  reviewHistoryId: string;
++  documentId: string; // ワークフロー内のドキュメントID
++  fileName: string; // ワークフロー内での名前（分割時は "xxx (part 1)" など）
++  processMode: ProcessMode;
++  textContent?: string; // processMode='text'の場合
++  imageData?: string[]; // processMode='image'の場合
++  createdAt: string;
++  updatedAt: string;
++}
++
++// レビュー大量ドキュメント結果キャッシュ（大量ドキュメントレビューの個別レビュー結果）
++export interface ReviewLargedocumentResultCache {
++  reviewDocumentCacheId: number;
++  reviewChecklistId: number;
++  comment: string;
++  totalChunks: number; // ドキュメント分割総数
++  chunkIndex: number; // 何番目のチャンクか（0から始まる）
++  individualFileName: string; // 分割後の個別ドキュメント名（"xxx (part 1)" など）
++}
diff --git a/drizzle.config.ts b/drizzle.config.ts
index 36ebf09d3..f73e59241 100644
--- a/drizzle.config.ts
+++ b/drizzle.config.ts
@@ -12,7 +12,7 @@ console.log(
 );
 
 export default {
-  schema: './src/db/schema.ts',
+  schema: './src/adapter/db/drizzle/schema.ts',
   out: './drizzle/migrations',
   dialect: 'sqlite',
   dbCredentials: {
diff --git a/drizzle/migrations/0008_pink_ezekiel.sql b/drizzle/migrations/0008_pink_ezekiel.sql
new file mode 100644
index 000000000..8169d2866
--- /dev/null
+++ b/drizzle/migrations/0008_pink_ezekiel.sql
@@ -0,0 +1,4 @@
+DROP TABLE `review_checklist_results`;--> statement-breakpoint
+ALTER TABLE `review_checklists` ADD `evaluation` text;--> statement-breakpoint
+ALTER TABLE `review_checklists` ADD `comment` text;--> statement-breakpoint
+ALTER TABLE `review_histories` ADD `target_document_name` text;
\ No newline at end of file
diff --git a/drizzle/migrations/0009_keen_radioactive_man.sql b/drizzle/migrations/0009_keen_radioactive_man.sql
new file mode 100644
index 000000000..999bdbbd9
--- /dev/null
+++ b/drizzle/migrations/0009_keen_radioactive_man.sql
@@ -0,0 +1,23 @@
+CREATE TABLE `review_checklist_result_caches` (
+	`review_document_cache_id` integer NOT NULL,
+	`review_checklist_id` integer NOT NULL,
+	`comment` text NOT NULL,
+	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`),
+	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
+	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+);
+--> statement-breakpoint
+CREATE TABLE `review_document_caches` (
+	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
+	`review_history_id` text NOT NULL,
+	`document_id` text NOT NULL,
+	`original_file_name` text NOT NULL,
+	`file_name` text NOT NULL,
+	`process_mode` text NOT NULL,
+	`cache_path` text NOT NULL,
+	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
+	FOREIGN KEY (`review_history_id`) REFERENCES `review_histories`(`id`) ON UPDATE no action ON DELETE cascade
+);
+--> statement-breakpoint
+ALTER TABLE `review_histories` ADD `document_mode` text;
\ No newline at end of file
diff --git a/drizzle/migrations/0010_wet_shooting_star.sql b/drizzle/migrations/0010_wet_shooting_star.sql
new file mode 100644
index 000000000..49668f9f0
--- /dev/null
+++ b/drizzle/migrations/0010_wet_shooting_star.sql
@@ -0,0 +1,14 @@
+CREATE TABLE `review_largedocument_result_caches` (
+	`review_document_cache_id` integer NOT NULL,
+	`review_checklist_id` integer NOT NULL,
+	`comment` text NOT NULL,
+	`total_chunks` integer NOT NULL,
+	`chunk_index` integer NOT NULL,
+	`individual_file_name` text NOT NULL,
+	PRIMARY KEY(`review_document_cache_id`, `review_checklist_id`, `chunk_index`),
+	FOREIGN KEY (`review_document_cache_id`) REFERENCES `review_document_caches`(`id`) ON UPDATE no action ON DELETE cascade,
+	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+);
+--> statement-breakpoint
+DROP TABLE `review_checklist_result_caches`;--> statement-breakpoint
+ALTER TABLE `review_document_caches` DROP COLUMN `original_file_name`;
\ No newline at end of file
diff --git a/drizzle/migrations/0011_talented_chimera.sql b/drizzle/migrations/0011_talented_chimera.sql
new file mode 100644
index 000000000..ef02555ae
--- /dev/null
+++ b/drizzle/migrations/0011_talented_chimera.sql
@@ -0,0 +1 @@
+ALTER TABLE `review_document_caches` DROP COLUMN `document_id`;
\ No newline at end of file
diff --git a/drizzle/migrations/meta/0008_snapshot.json b/drizzle/migrations/meta/0008_snapshot.json
new file mode 100644
index 000000000..5148d151e
--- /dev/null
+++ b/drizzle/migrations/meta/0008_snapshot.json
@@ -0,0 +1,329 @@
+{
+  "version": "6",
+  "dialect": "sqlite",
+  "id": "e0ad999a-87f1-4f45-b070-a32c673d6352",
+  "prevId": "f10b9ed0-007d-4b08-941a-030265d534ff",
+  "tables": {
+    "review_checklists": {
+      "name": "review_checklists",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "content": {
+          "name": "content",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "evaluation": {
+          "name": "evaluation",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "created_by": {
+          "name": "created_by",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklists_review_history_id_review_histories_id_fk": {
+          "name": "review_checklists_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_checklists",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_histories": {
+      "name": "review_histories",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "text",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "target_document_name": {
+          "name": "target_document_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "additional_instructions": {
+          "name": "additional_instructions",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment_format": {
+          "name": "comment_format",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "evaluation_settings": {
+          "name": "evaluation_settings",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "processing_status": {
+          "name": "processing_status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "sources": {
+      "name": "sources",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "path": {
+          "name": "path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "status": {
+          "name": "status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "error": {
+          "name": "error",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "is_enabled": {
+          "name": "is_enabled",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": 1
+        }
+      },
+      "indexes": {
+        "sources_path_unique": {
+          "name": "sources_path_unique",
+          "columns": [
+            "path"
+          ],
+          "isUnique": true
+        }
+      },
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "topics": {
+      "name": "topics",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "name": {
+          "name": "name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "topics_source_id_sources_id_fk": {
+          "name": "topics_source_id_sources_id_fk",
+          "tableFrom": "topics",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    }
+  },
+  "views": {},
+  "enums": {},
+  "_meta": {
+    "schemas": {},
+    "tables": {},
+    "columns": {}
+  },
+  "internal": {
+    "indexes": {}
+  }
+}
\ No newline at end of file
diff --git a/drizzle/migrations/meta/0009_snapshot.json b/drizzle/migrations/meta/0009_snapshot.json
new file mode 100644
index 000000000..0f58c9424
--- /dev/null
+++ b/drizzle/migrations/meta/0009_snapshot.json
@@ -0,0 +1,491 @@
+{
+  "version": "6",
+  "dialect": "sqlite",
+  "id": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
+  "prevId": "e0ad999a-87f1-4f45-b070-a32c673d6352",
+  "tables": {
+    "review_checklist_result_caches": {
+      "name": "review_checklist_result_caches",
+      "columns": {
+        "review_document_cache_id": {
+          "name": "review_document_cache_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "review_checklist_id": {
+          "name": "review_checklist_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+          "name": "review_checklist_result_caches_review_document_cache_id_review_document_caches_id_fk",
+          "tableFrom": "review_checklist_result_caches",
+          "tableTo": "review_document_caches",
+          "columnsFrom": [
+            "review_document_cache_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        },
+        "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk": {
+          "name": "review_checklist_result_caches_review_checklist_id_review_checklists_id_fk",
+          "tableFrom": "review_checklist_result_caches",
+          "tableTo": "review_checklists",
+          "columnsFrom": [
+            "review_checklist_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {
+        "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk": {
+          "columns": [
+            "review_document_cache_id",
+            "review_checklist_id"
+          ],
+          "name": "review_checklist_result_caches_review_document_cache_id_review_checklist_id_pk"
+        }
+      },
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_checklists": {
+      "name": "review_checklists",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "content": {
+          "name": "content",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "evaluation": {
+          "name": "evaluation",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "created_by": {
+          "name": "created_by",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklists_review_history_id_review_histories_id_fk": {
+          "name": "review_checklists_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_checklists",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_document_caches": {
+      "name": "review_document_caches",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "document_id": {
+          "name": "document_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "original_file_name": {
+          "name": "original_file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "file_name": {
+          "name": "file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "process_mode": {
+          "name": "process_mode",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "cache_path": {
+          "name": "cache_path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_document_caches_review_history_id_review_histories_id_fk": {
+          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_document_caches",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_histories": {
+      "name": "review_histories",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "text",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "target_document_name": {
+          "name": "target_document_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "additional_instructions": {
+          "name": "additional_instructions",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment_format": {
+          "name": "comment_format",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "evaluation_settings": {
+          "name": "evaluation_settings",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "document_mode": {
+          "name": "document_mode",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "processing_status": {
+          "name": "processing_status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "sources": {
+      "name": "sources",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "path": {
+          "name": "path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "status": {
+          "name": "status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "error": {
+          "name": "error",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "is_enabled": {
+          "name": "is_enabled",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": 1
+        }
+      },
+      "indexes": {
+        "sources_path_unique": {
+          "name": "sources_path_unique",
+          "columns": [
+            "path"
+          ],
+          "isUnique": true
+        }
+      },
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "topics": {
+      "name": "topics",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "name": {
+          "name": "name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "topics_source_id_sources_id_fk": {
+          "name": "topics_source_id_sources_id_fk",
+          "tableFrom": "topics",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    }
+  },
+  "views": {},
+  "enums": {},
+  "_meta": {
+    "schemas": {},
+    "tables": {},
+    "columns": {}
+  },
+  "internal": {
+    "indexes": {}
+  }
+}
\ No newline at end of file
diff --git a/drizzle/migrations/meta/0010_snapshot.json b/drizzle/migrations/meta/0010_snapshot.json
new file mode 100644
index 000000000..cf557a34d
--- /dev/null
+++ b/drizzle/migrations/meta/0010_snapshot.json
@@ -0,0 +1,506 @@
+{
+  "version": "6",
+  "dialect": "sqlite",
+  "id": "64a4c44b-83f4-4cca-b0a7-5e1962a1f61b",
+  "prevId": "c24436bf-543e-4cc5-9e34-9b3c0e65e810",
+  "tables": {
+    "review_checklists": {
+      "name": "review_checklists",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "content": {
+          "name": "content",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "evaluation": {
+          "name": "evaluation",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "created_by": {
+          "name": "created_by",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklists_review_history_id_review_histories_id_fk": {
+          "name": "review_checklists_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_checklists",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_document_caches": {
+      "name": "review_document_caches",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "document_id": {
+          "name": "document_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "file_name": {
+          "name": "file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "process_mode": {
+          "name": "process_mode",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "cache_path": {
+          "name": "cache_path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_document_caches_review_history_id_review_histories_id_fk": {
+          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_document_caches",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_histories": {
+      "name": "review_histories",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "text",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "target_document_name": {
+          "name": "target_document_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "additional_instructions": {
+          "name": "additional_instructions",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment_format": {
+          "name": "comment_format",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "evaluation_settings": {
+          "name": "evaluation_settings",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "document_mode": {
+          "name": "document_mode",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "processing_status": {
+          "name": "processing_status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_largedocument_result_caches": {
+      "name": "review_largedocument_result_caches",
+      "columns": {
+        "review_document_cache_id": {
+          "name": "review_document_cache_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "review_checklist_id": {
+          "name": "review_checklist_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "total_chunks": {
+          "name": "total_chunks",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "chunk_index": {
+          "name": "chunk_index",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "individual_file_name": {
+          "name": "individual_file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+          "name": "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk",
+          "tableFrom": "review_largedocument_result_caches",
+          "tableTo": "review_document_caches",
+          "columnsFrom": [
+            "review_document_cache_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        },
+        "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk": {
+          "name": "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk",
+          "tableFrom": "review_largedocument_result_caches",
+          "tableTo": "review_checklists",
+          "columnsFrom": [
+            "review_checklist_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {
+        "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk": {
+          "columns": [
+            "review_document_cache_id",
+            "review_checklist_id",
+            "chunk_index"
+          ],
+          "name": "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk"
+        }
+      },
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "sources": {
+      "name": "sources",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "path": {
+          "name": "path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "status": {
+          "name": "status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "error": {
+          "name": "error",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "is_enabled": {
+          "name": "is_enabled",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": 1
+        }
+      },
+      "indexes": {
+        "sources_path_unique": {
+          "name": "sources_path_unique",
+          "columns": [
+            "path"
+          ],
+          "isUnique": true
+        }
+      },
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "topics": {
+      "name": "topics",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "name": {
+          "name": "name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "topics_source_id_sources_id_fk": {
+          "name": "topics_source_id_sources_id_fk",
+          "tableFrom": "topics",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    }
+  },
+  "views": {},
+  "enums": {},
+  "_meta": {
+    "schemas": {},
+    "tables": {},
+    "columns": {}
+  },
+  "internal": {
+    "indexes": {}
+  }
+}
\ No newline at end of file
diff --git a/drizzle/migrations/meta/0011_snapshot.json b/drizzle/migrations/meta/0011_snapshot.json
new file mode 100644
index 000000000..85ef897d1
--- /dev/null
+++ b/drizzle/migrations/meta/0011_snapshot.json
@@ -0,0 +1,499 @@
+{
+  "version": "6",
+  "dialect": "sqlite",
+  "id": "d0ea5a0b-0305-4775-97b0-31963e3d505b",
+  "prevId": "64a4c44b-83f4-4cca-b0a7-5e1962a1f61b",
+  "tables": {
+    "review_checklists": {
+      "name": "review_checklists",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "content": {
+          "name": "content",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "evaluation": {
+          "name": "evaluation",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "created_by": {
+          "name": "created_by",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklists_review_history_id_review_histories_id_fk": {
+          "name": "review_checklists_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_checklists",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_document_caches": {
+      "name": "review_document_caches",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "file_name": {
+          "name": "file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "process_mode": {
+          "name": "process_mode",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "cache_path": {
+          "name": "cache_path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_document_caches_review_history_id_review_histories_id_fk": {
+          "name": "review_document_caches_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_document_caches",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_histories": {
+      "name": "review_histories",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "text",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "target_document_name": {
+          "name": "target_document_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "additional_instructions": {
+          "name": "additional_instructions",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment_format": {
+          "name": "comment_format",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "evaluation_settings": {
+          "name": "evaluation_settings",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "document_mode": {
+          "name": "document_mode",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "processing_status": {
+          "name": "processing_status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_largedocument_result_caches": {
+      "name": "review_largedocument_result_caches",
+      "columns": {
+        "review_document_cache_id": {
+          "name": "review_document_cache_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "review_checklist_id": {
+          "name": "review_checklist_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "total_chunks": {
+          "name": "total_chunks",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "chunk_index": {
+          "name": "chunk_index",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "individual_file_name": {
+          "name": "individual_file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk": {
+          "name": "review_largedocument_result_caches_review_document_cache_id_review_document_caches_id_fk",
+          "tableFrom": "review_largedocument_result_caches",
+          "tableTo": "review_document_caches",
+          "columnsFrom": [
+            "review_document_cache_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        },
+        "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk": {
+          "name": "review_largedocument_result_caches_review_checklist_id_review_checklists_id_fk",
+          "tableFrom": "review_largedocument_result_caches",
+          "tableTo": "review_checklists",
+          "columnsFrom": [
+            "review_checklist_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {
+        "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk": {
+          "columns": [
+            "review_document_cache_id",
+            "review_checklist_id",
+            "chunk_index"
+          ],
+          "name": "review_largedocument_result_caches_review_document_cache_id_review_checklist_id_chunk_index_pk"
+        }
+      },
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "sources": {
+      "name": "sources",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "path": {
+          "name": "path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "status": {
+          "name": "status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "error": {
+          "name": "error",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "is_enabled": {
+          "name": "is_enabled",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": 1
+        }
+      },
+      "indexes": {
+        "sources_path_unique": {
+          "name": "sources_path_unique",
+          "columns": [
+            "path"
+          ],
+          "isUnique": true
+        }
+      },
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "topics": {
+      "name": "topics",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "name": {
+          "name": "name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "topics_source_id_sources_id_fk": {
+          "name": "topics_source_id_sources_id_fk",
+          "tableFrom": "topics",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    }
+  },
+  "views": {},
+  "enums": {},
+  "_meta": {
+    "schemas": {},
+    "tables": {},
+    "columns": {}
+  },
+  "internal": {
+    "indexes": {}
+  }
+}
\ No newline at end of file
diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
index 18a6e2692..963df9ad9 100644
--- a/drizzle/migrations/meta/_journal.json
+++ b/drizzle/migrations/meta/_journal.json
@@ -57,6 +57,34 @@
       "when": 1758023792722,
       "tag": "0007_awesome_caretaker",
       "breakpoints": true
+    },
+    {
+      "idx": 8,
+      "version": "6",
+      "when": 1759653362189,
+      "tag": "0008_pink_ezekiel",
+      "breakpoints": true
+    },
+    {
+      "idx": 9,
+      "version": "6",
+      "when": 1759674897312,
+      "tag": "0009_keen_radioactive_man",
+      "breakpoints": true
+    },
+    {
+      "idx": 10,
+      "version": "6",
+      "when": 1760147587193,
+      "tag": "0010_wet_shooting_star",
+      "breakpoints": true
+    },
+    {
+      "idx": 11,
+      "version": "6",
+      "when": 1760580310921,
+      "tag": "0011_talented_chimera",
+      "breakpoints": true
     }
   ]
 }
\ No newline at end of file
diff --git a/src/__tests__/integration/Sidebar.test.tsx b/src/__tests__/integration/Sidebar.test.tsx
index 00d96f758..a66dd0796 100644
--- a/src/__tests__/integration/Sidebar.test.tsx
+++ b/src/__tests__/integration/Sidebar.test.tsx
@@ -11,7 +11,7 @@ import { v4 as uuidv4 } from 'uuid';
 import Sidebar from '@/renderer/components/sidebar/Sidebar';
 import type { ChatRoom, ProcessStatus } from '@/types';
 import type { Source } from '@/db/schema';
-import { StoreSchema as Settings } from '@/main/store';
+import { StoreSchema as Settings } from '@/adapter/db/electron-store/store';
 import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
 import ChatRoomList from '@/renderer/components/chat/ChatRoomList';
 import ReviewHistoryList from '@/renderer/components/review/ReviewHistoryList';
diff --git a/src/adapter/db/drizzle/index.ts b/src/adapter/db/drizzle/index.ts
index bf2e952ff..b581c2c5c 100644
--- a/src/adapter/db/drizzle/index.ts
+++ b/src/adapter/db/drizzle/index.ts
@@ -3,7 +3,7 @@ import { join } from 'path';
 import { drizzle, type LibSQLDatabase } from 'drizzle-orm/libsql';
 import { migrate } from 'drizzle-orm/libsql/migrator';
 import * as schema from './schema';
-import { getStore } from '@/main/store';
+import { getStore } from '@/adapter/db/electron-store/store';
 import { toAbsoluteFileURL } from '@/main/lib/util';
 
 // データベースの型定義
diff --git a/src/adapter/db/drizzle/repository/index.ts b/src/adapter/db/drizzle/repository/index.ts
index b908a5531..1d721b297 100644
--- a/src/adapter/db/drizzle/repository/index.ts
+++ b/src/adapter/db/drizzle/repository/index.ts
@@ -1,3 +1,2 @@
 export * from './sourceRepository';
 export * from './reviewRepository';
-export * from './settingsRepository';
diff --git a/src/adapter/db/drizzle/repository/reviewRepository.ts b/src/adapter/db/drizzle/repository/reviewRepository.ts
index 572c1e214..2117a79d5 100644
--- a/src/adapter/db/drizzle/repository/reviewRepository.ts
+++ b/src/adapter/db/drizzle/repository/reviewRepository.ts
@@ -1,10 +1,13 @@
-import { eq, and } from 'drizzle-orm';
+import { eq, and, inArray, max } from 'drizzle-orm';
 import {
   reviewHistories,
   reviewChecklists,
-  reviewChecklistResults,
+  reviewDocumentCaches,
+  reviewLargedocumentResultCaches,
   ReviewChecklistEntity,
   ReviewHistoryEntity,
+  ReviewDocumentCacheEntity,
+  ReviewLargedocumentResultCacheEntity,
 } from '../schema';
 import getDb from '..';
 import type {
@@ -15,10 +18,15 @@ import type {
   ReviewChecklistCreatedBy,
   CustomEvaluationSettings,
   ProcessingStatus,
+  DocumentMode,
+  ReviewDocumentCache,
+  ReviewLargedocumentResultCache,
+  ProcessMode,
 } from '@/types';
-import { AppError } from '@/main/lib/error';
+import { AppError, internalError } from '@/main/lib/error';
 import { repositoryError } from '@/main/lib/error';
 import { IReviewRepository } from '@/main/service/port/repository';
+import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
 
 /**
  * Drizzle ORM を使用したレビューリポジトリの実装
@@ -31,6 +39,8 @@ export class DrizzleReviewRepository implements IReviewRepository {
       id: reviewChecklistEntity.id,
       reviewHistoryId: reviewChecklistEntity.reviewHistoryId,
       content: reviewChecklistEntity.content,
+      evaluation: reviewChecklistEntity.evaluation as ReviewEvaluation | null,
+      comment: reviewChecklistEntity.comment,
       createdBy: reviewChecklistEntity.createdBy as ReviewChecklistCreatedBy,
       createdAt: reviewChecklistEntity.createdAt,
       updatedAt: reviewChecklistEntity.updatedAt,
@@ -43,6 +53,7 @@ export class DrizzleReviewRepository implements IReviewRepository {
     const reviewHistory = {
       id: reviewHistoryEntity.id,
       title: reviewHistoryEntity.title,
+      targetDocumentName: reviewHistoryEntity.targetDocumentName,
       additionalInstructions: reviewHistoryEntity.additionalInstructions,
       commentFormat: reviewHistoryEntity.commentFormat,
       evaluationSettings: null,
@@ -189,6 +200,27 @@ export class DrizzleReviewRepository implements IReviewRepository {
     }
   }
 
+  /** レビュー対象ドキュメント名を更新 */
+  async updateReviewHistoryTargetDocumentName(
+    id: string,
+    targetDocumentName: string,
+  ): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .update(reviewHistories)
+        .set({
+          targetDocumentName,
+        })
+        .where(eq(reviewHistories.id, id));
+    } catch (err) {
+      throw repositoryError(
+        'レビュー対象ドキュメント名の更新に失敗しました',
+        err,
+      );
+    }
+  }
+
   /** レビュー履歴を削除 */
   async deleteReviewHistory(id: string): Promise<void> {
     try {
@@ -284,53 +316,24 @@ export class DrizzleReviewRepository implements IReviewRepository {
       reviewChecklistId: number;
       evaluation: ReviewEvaluation;
       comment: string;
-      fileId: string;
-      fileName: string;
     }[],
   ): Promise<void> {
     try {
       const db = await getDb();
       for (const result of results) {
-        const [upserted] = await db
-          .insert(reviewChecklistResults)
-          .values(result)
-          .onConflictDoUpdate({
-            target: [
-              reviewChecklistResults.reviewChecklistId,
-              reviewChecklistResults.fileId,
-            ],
-            set: {
-              evaluation: result.evaluation,
-              comment: result.comment,
-            },
+        await db
+          .update(reviewChecklists)
+          .set({
+            evaluation: result.evaluation,
+            comment: result.comment,
           })
-          .returning();
+          .where(eq(reviewChecklists.id, result.reviewChecklistId));
       }
     } catch (err) {
       throw repositoryError('レビュー結果の保存に失敗しました', err);
     }
   }
 
-  /** レビュー結果を削除 */
-  async deleteReviewResults(
-    reviewChecklistId: number,
-    sourceId: number,
-  ): Promise<void> {
-    try {
-      const db = await getDb();
-      await db
-        .delete(reviewChecklistResults)
-        .where(
-          and(
-            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
-            eq(reviewChecklistResults.fileId, sourceId.toString()),
-          ),
-        );
-    } catch (err) {
-      throw repositoryError('レビュー結果の削除に失敗しました', err);
-    }
-  }
-
   /** チェックリスト結果を取得してグルーピング */
   async getReviewChecklistResults(
     reviewHistoryId: string,
@@ -338,43 +341,21 @@ export class DrizzleReviewRepository implements IReviewRepository {
     try {
       const db = await getDb();
       const rows = await db
-        .select({
-          checklistId: reviewChecklists.id,
-          content: reviewChecklists.content,
-          fileId: reviewChecklistResults.fileId,
-          fileName: reviewChecklistResults.fileName,
-          evaluation: reviewChecklistResults.evaluation,
-          comment: reviewChecklistResults.comment,
-        })
+        .select()
         .from(reviewChecklists)
-        .leftJoin(
-          reviewChecklistResults,
-          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
-        )
         .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
         .orderBy(reviewChecklists.createdAt);
 
-      const map = new Map<number, ReviewChecklistResult>();
-      for (const row of rows) {
-        let group = map.get(row.checklistId);
-        if (!group) {
-          group = {
-            id: row.checklistId,
-            content: row.content,
-            sourceEvaluations: [],
-          };
-          map.set(row.checklistId, group);
-        }
-        if (row.fileId !== null && row.fileName !== null) {
-          group.sourceEvaluations!.push({
-            fileId: row.fileId,
-            fileName: row.fileName,
-            evaluation: row.evaluation as ReviewEvaluation,
-            comment: row.comment ?? undefined,
-          });
-        }
-      }
-      return Array.from(map.values());
+      return rows.map((row) => ({
+        id: row.id,
+        content: row.content,
+        sourceEvaluation: row.evaluation
+          ? {
+              evaluation: row.evaluation as ReviewEvaluation,
+              comment: row.comment ?? undefined,
+            }
+          : undefined,
+      }));
     } catch (err) {
       throw repositoryError('レビュー結果の取得に失敗しました', err);
     }
@@ -384,21 +365,406 @@ export class DrizzleReviewRepository implements IReviewRepository {
   async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
     try {
       const db = await getDb();
-      const checklists = await db
-        .select({ id: reviewChecklists.id })
-        .from(reviewChecklists)
+      await db
+        .update(reviewChecklists)
+        .set({
+          evaluation: null,
+          comment: null,
+        })
         .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
+    } catch (err) {
+      throw repositoryError('レビュー結果の削除に失敗しました', err);
+    }
+  }
 
-      // チェックリストが無ければ何もしない
-      if (checklists.length === 0) return;
+  /** ドキュメントキャッシュを削除（DBとファイルシステム） */
+  async deleteReviewDocumentCaches(reviewHistoryId: string): Promise<void> {
+    try {
+      const db = await getDb();
+      
+      // まずDBレコードを削除
+      await db
+        .delete(reviewDocumentCaches)
+        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
+      
+      // ファイルシステムのキャッシュディレクトリも削除
+      await ReviewCacheHelper.deleteCacheDirectory(reviewHistoryId);
+    } catch (err) {
+      throw repositoryError('ドキュメントキャッシュの削除に失敗しました', err);
+    }
+  }
 
-      for (const { id } of checklists) {
+  /** 大量ドキュメント結果キャッシュを削除 */
+  async deleteReviewLargedocumentResultCaches(
+    reviewHistoryId: string,
+  ): Promise<void> {
+    try {
+      const db = await getDb();
+      
+      // reviewDocumentCachesとjoinしてreviewHistoryIdで絞り込んで削除
+      const caches = await db
+        .select({ id: reviewDocumentCaches.id })
+        .from(reviewDocumentCaches)
+        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
+      
+      const cacheIds = caches.map((c) => c.id);
+      
+      if (cacheIds.length > 0) {
         await db
-          .delete(reviewChecklistResults)
-          .where(eq(reviewChecklistResults.reviewChecklistId, id));
+          .delete(reviewLargedocumentResultCaches)
+          .where(
+            inArray(
+              reviewLargedocumentResultCaches.reviewDocumentCacheId,
+              cacheIds,
+            ),
+          );
       }
     } catch (err) {
-      throw repositoryError('レビュー結果の削除に失敗しました', err);
+      throw repositoryError(
+        '大量ドキュメント結果キャッシュの削除に失敗しました',
+        err,
+      );
+    }
+  }
+
+  /** documentModeを更新 */
+  async updateReviewHistoryDocumentMode(
+    id: string,
+    documentMode: DocumentMode,
+  ): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .update(reviewHistories)
+        .set({
+          documentMode,
+        })
+        .where(eq(reviewHistories.id, id));
+    } catch (err) {
+      throw repositoryError('ドキュメントモードの更新に失敗しました', err);
+    }
+  }
+
+  /**
+   * ReviewDocumentCacheEntity → ReviewDocumentCache の変換
+   * cachePathからファイルを読み込んでtextContent/imageDataに変換
+   */
+  private async convertDocumentCacheEntityToDomain(
+    entity: ReviewDocumentCacheEntity,
+  ): Promise<ReviewDocumentCache> {
+    const base = {
+      id: entity.id,
+      reviewHistoryId: entity.reviewHistoryId,
+      fileName: entity.fileName,
+      processMode: entity.processMode as ProcessMode,
+      createdAt: entity.createdAt,
+      updatedAt: entity.updatedAt,
+    };
+
+    try {
+      // cachePathからファイルを読み込む
+      if (entity.processMode === 'text') {
+        const textContent = await ReviewCacheHelper.loadTextCache(
+          entity.cachePath,
+        );
+        return { ...base, textContent };
+      } else if (entity.processMode === 'image') {
+        const imageData = await ReviewCacheHelper.loadImageCache(
+          entity.cachePath,
+        );
+        return { ...base, imageData };
+      }
+
+      throw repositoryError('無効なprocessModeです', null);
+    } catch (error) {
+      // キャッシュファイル読み込みエラーの場合は専用のエラーメッセージを返す
+      if (error instanceof Error && error.message.includes('Failed to load')) {
+        throw internalError({
+          expose: true,
+          messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
+          cause: error,
+        });
+      }
+      // その他のエラーはそのまま再スロー
+      throw error;
+    }
+  }
+
+  /** ドキュメントキャッシュを作成 */
+  async createReviewDocumentCache(
+    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
+  ): Promise<ReviewDocumentCache> {
+    try {
+      // 1. 一時的なcachePathでDBにメタデータを保存（IDを取得するため）
+      const db = await getDb();
+      const [entity] = await db
+        .insert(reviewDocumentCaches)
+        .values({
+          reviewHistoryId: cache.reviewHistoryId,
+          fileName: cache.fileName,
+          processMode: cache.processMode,
+          cachePath: '', // 一時的に空文字列を設定
+        })
+        .returning();
+
+      // 2. 取得したIDを使用してファイルシステムにキャッシュを保存
+      let cachePath: string;
+
+      if (cache.processMode === 'text' && cache.textContent) {
+        cachePath = await ReviewCacheHelper.saveTextCache(
+          cache.reviewHistoryId,
+          entity.id,
+          cache.textContent,
+        );
+      } else if (cache.processMode === 'image' && cache.imageData) {
+        cachePath = await ReviewCacheHelper.saveImageCache(
+          cache.reviewHistoryId,
+          entity.id,
+          cache.imageData,
+        );
+      } else {
+        throw repositoryError(
+          '無効なprocessModeまたはデータが不足しています',
+          null,
+        );
+      }
+
+      // 3. cachePathを更新
+      await db
+        .update(reviewDocumentCaches)
+        .set({ cachePath })
+        .where(eq(reviewDocumentCaches.id, entity.id));
+
+      // 4. 更新されたエンティティを取得してドメイン型に変換して返す
+      const updatedEntity = { ...entity, cachePath };
+      return this.convertDocumentCacheEntityToDomain(updatedEntity);
+    } catch (err) {
+      if (err instanceof AppError) throw err;
+      throw repositoryError('ドキュメントキャッシュの作成に失敗しました', err);
+    }
+  }
+
+  /** ドキュメントキャッシュ一覧を取得 */
+  async getReviewDocumentCaches(
+    reviewHistoryId: string,
+  ): Promise<ReviewDocumentCache[]> {
+    try {
+      const db = await getDb();
+      const entities = await db
+        .select()
+        .from(reviewDocumentCaches)
+        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId))
+        .orderBy(reviewDocumentCaches.createdAt);
+
+      // 各EntityをDomain型に変換（ファイル読み込み含む）
+      return Promise.all(
+        entities.map((entity) =>
+          this.convertDocumentCacheEntityToDomain(entity),
+        ),
+      );
+    } catch (err) {
+      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+    }
+  }
+
+  /** IDでドキュメントキャッシュを取得 */
+  async getReviewDocumentCacheById(
+    id: number,
+  ): Promise<ReviewDocumentCache | null> {
+    try {
+      const db = await getDb();
+      const [entity] = await db
+        .select()
+        .from(reviewDocumentCaches)
+        .where(eq(reviewDocumentCaches.id, id));
+
+      if (!entity) return null;
+
+      return this.convertDocumentCacheEntityToDomain(entity);
+    } catch (err) {
+      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+    }
+  }
+
+  /** ドキュメントキャッシュを取得（複数ID対応） */
+  async getReviewDocumentCacheByIds(
+    ids: number[],
+  ): Promise<ReviewDocumentCache[]> {
+    try {
+      const db = await getDb();
+      const entities = await db
+        .select()
+        .from(reviewDocumentCaches)
+        .where(inArray(reviewDocumentCaches.id, ids));
+
+      // 各EntityをDomain型に変換（ファイル読み込み含む）
+      return Promise.all(
+        entities.map((entity) =>
+          this.convertDocumentCacheEntityToDomain(entity),
+        ),
+      );
+    } catch (err) {
+      throw repositoryError('ドキュメントキャッシュの取得に失敗しました', err);
+    }
+  }
+
+  /** チェックリスト結果キャッシュを作成 */
+  async createReviewLargedocumentResultCache(
+    cache: ReviewLargedocumentResultCache,
+  ): Promise<void> {
+    try {
+      const db = await getDb();
+      await db.insert(reviewLargedocumentResultCaches).values({
+        reviewDocumentCacheId: cache.reviewDocumentCacheId,
+        reviewChecklistId: cache.reviewChecklistId,
+        comment: cache.comment,
+        totalChunks: cache.totalChunks,
+        chunkIndex: cache.chunkIndex,
+        individualFileName: cache.individualFileName,
+      });
+    } catch (err) {
+      throw repositoryError(
+        '大量ドキュメント結果キャッシュの作成に失敗しました',
+        err,
+      );
+    }
+  }
+
+  /** チェックリスト結果キャッシュ一覧を取得 */
+  async getReviewLargedocumentResultCaches(
+    reviewHistoryId: string,
+  ): Promise<ReviewLargedocumentResultCache[]> {
+    try {
+      const db = await getDb();
+      // reviewDocumentCachesとjoinしてreviewHistoryIdで絞り込む
+      const results = await db
+        .select({
+          reviewDocumentCacheId:
+            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+          reviewChecklistId: reviewLargedocumentResultCaches.reviewChecklistId,
+          comment: reviewLargedocumentResultCaches.comment,
+          totalChunks: reviewLargedocumentResultCaches.totalChunks,
+          chunkIndex: reviewLargedocumentResultCaches.chunkIndex,
+          individualFileName:
+            reviewLargedocumentResultCaches.individualFileName,
+        })
+        .from(reviewLargedocumentResultCaches)
+        .innerJoin(
+          reviewDocumentCaches,
+          eq(
+            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+            reviewDocumentCaches.id,
+          ),
+        )
+        .where(eq(reviewDocumentCaches.reviewHistoryId, reviewHistoryId));
+
+      return results.map((row) => ({
+        reviewDocumentCacheId: row.reviewDocumentCacheId,
+        reviewChecklistId: row.reviewChecklistId,
+        comment: row.comment,
+        totalChunks: row.totalChunks,
+        chunkIndex: row.chunkIndex,
+        individualFileName: row.individualFileName,
+      }));
+    } catch (err) {
+      throw repositoryError(
+        '大量ドキュメント結果キャッシュの取得に失敗しました',
+        err,
+      );
+    }
+  }
+
+  /** 特定ドキュメントの最大totalChunks数を取得（レビューチャット用） */
+  async getMaxTotalChunksForDocument(
+    reviewDocumentCacheId: number,
+  ): Promise<number> {
+    try {
+      const db = await getDb();
+
+      // 該当ドキュメントのtotalChunksの最大値を取得
+      const result = await db
+        .select({ maxChunks: max(reviewLargedocumentResultCaches.totalChunks) })
+        .from(reviewLargedocumentResultCaches)
+        .where(
+          eq(
+            reviewLargedocumentResultCaches.reviewDocumentCacheId,
+            reviewDocumentCacheId,
+          ),
+        );
+
+      const maxChunks = result[0]?.maxChunks;
+
+      // レコードが存在しない場合は1を返す（初回処理）
+      return maxChunks ?? 1;
+    } catch (err) {
+      throw repositoryError(
+        'ドキュメントの最大チャンク数取得に失敗しました',
+        err,
+      );
+    }
+  }
+
+  /** レビューチャット用: チェックリストと結果を取得 */
+  async getChecklistResultsWithIndividualResults(
+    reviewHistoryId: string,
+    checklistIds: number[],
+  ): Promise<
+    Array<{
+      checklistResult: ReviewChecklistResult;
+      individualResults?: Array<{
+        documentId: number;
+        comment: string;
+        individualFileName: string;
+      }>;
+    }>
+  > {
+    try {
+      const db = await getDb();
+
+      // チェックリストを取得
+      const checklistEntities = await db
+        .select()
+        .from(reviewChecklists)
+        .where(
+          and(
+            eq(reviewChecklists.reviewHistoryId, reviewHistoryId),
+            inArray(reviewChecklists.id, checklistIds),
+          ),
+        );
+
+      // 個別レビュー結果キャッシュを取得
+      const individualCaches =
+        await this.getReviewLargedocumentResultCaches(reviewHistoryId);
+
+      // 結果を組み立て
+      return checklistEntities.map((entity) => {
+        // 個別レビュー結果を抽出
+        const individualResults = individualCaches
+          .filter((cache) => cache.reviewChecklistId === entity.id)
+          .map((cache) => ({
+            documentId: cache.reviewDocumentCacheId,
+            comment: cache.comment,
+            individualFileName: cache.individualFileName,
+          }));
+
+        // ReviewChecklistResult型を構築
+        const checklistResult: ReviewChecklistResult = {
+          id: entity.id,
+          content: entity.content,
+          sourceEvaluation: {
+            evaluation: entity.evaluation ?? undefined,
+            comment: entity.comment ?? undefined,
+          },
+        };
+
+        return {
+          checklistResult,
+          individualResults:
+            individualResults.length > 0 ? individualResults : undefined,
+        };
+      });
+    } catch (err) {
+      throw repositoryError('チェックリストと結果の取得に失敗しました', err);
     }
   }
 }
diff --git a/src/adapter/db/drizzle/schema.ts b/src/adapter/db/drizzle/schema.ts
index 39ffd9c64..71b86e455 100644
--- a/src/adapter/db/drizzle/schema.ts
+++ b/src/adapter/db/drizzle/schema.ts
@@ -59,9 +59,11 @@ export const reviewHistories = sqliteTable('review_histories', {
     .primaryKey()
     .$default(() => uuidv4()), // 汎用チャット機能のコードを活用できるように、MastraのThreadと同じく主キーは文字列とする
   title: text('title').notNull(), // ソースのtitleを/区切りで結合
+  targetDocumentName: text('target_document_name'), // レビュー対象の統合ドキュメント名
   additionalInstructions: text('additional_instructions'), // レビューの追加指示
   commentFormat: text('comment_format'), // レビューのコメントフォーマット
   evaluationSettings: text('evaluation_settings'), // 評定項目設定（JSON形式）
+  documentMode: text('document_mode'), // レビュー実行方法: small, large
   processingStatus: text('processing_status').notNull().default('idle'), // 処理ステータス: idle, extracting, extracted, reviewing, completed
   createdAt: text('created_at')
     .notNull()
@@ -79,6 +81,8 @@ export const reviewChecklists = sqliteTable('review_checklists', {
     .notNull()
     .references(() => reviewHistories.id, { onDelete: 'cascade' }),
   content: text('content').notNull(), // チェックリスト項目
+  evaluation: text('evaluation'), // A, B, C, - 評価
+  comment: text('comment'), // レビューコメント
   createdBy: text('created_by').notNull(), // 'user' or 'system'
   createdAt: text('created_at')
     .notNull()
@@ -89,26 +93,48 @@ export const reviewChecklists = sqliteTable('review_checklists', {
     .$onUpdate(() => sql`(current_timestamp)`),
 });
 
-// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
-export const reviewChecklistResults = sqliteTable(
-  'review_checklist_results',
+// レビュードキュメントキャッシュを格納するテーブル
+export const reviewDocumentCaches = sqliteTable('review_document_caches', {
+  id: integer('id').primaryKey({ autoIncrement: true }),
+  reviewHistoryId: text('review_history_id')
+    .notNull()
+    .references(() => reviewHistories.id, { onDelete: 'cascade' }),
+  fileName: text('file_name').notNull(), // ワークフロー内での名前（分割時は "xxx (part 1)" など）
+  processMode: text('process_mode').notNull(), // 'text' or 'image'
+  cachePath: text('cache_path').notNull(), // ファイル/ディレクトリパス
+  createdAt: text('created_at')
+    .notNull()
+    .default(sql`(current_timestamp)`),
+  updatedAt: text('updated_at')
+    .notNull()
+    .default(sql`(current_timestamp)`)
+    .$onUpdate(() => sql`(current_timestamp)`),
+});
+
+// レビュー大量ドキュメント結果キャッシュを格納するテーブル（大量ドキュメントレビューの個別レビュー結果）
+export const reviewLargedocumentResultCaches = sqliteTable(
+  'review_largedocument_result_caches',
   {
+    reviewDocumentCacheId: integer('review_document_cache_id')
+      .notNull()
+      .references(() => reviewDocumentCaches.id, { onDelete: 'cascade' }),
     reviewChecklistId: integer('review_checklist_id')
       .notNull()
       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
-    fileId: text('file_id').notNull(), // アップロードファイルのID
-    fileName: text('file_name').notNull(), // ファイル名
-    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
-    comment: text('comment'), // レビューコメント
-    createdAt: text('created_at')
-      .notNull()
-      .default(sql`(current_timestamp)`),
-    updatedAt: text('updated_at')
-      .notNull()
-      .default(sql`(current_timestamp)`)
-      .$onUpdate(() => sql`(current_timestamp)`),
+    comment: text('comment').notNull(), // 個別レビューコメント
+    totalChunks: integer('total_chunks').notNull(), // ドキュメント分割総数
+    chunkIndex: integer('chunk_index').notNull(), // 何番目のチャンクか（0から始まる）
+    individualFileName: text('individual_file_name').notNull(), // 分割後の個別ドキュメント名（"xxx (part 1)" など）
   },
-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
+  (table) => ({
+    pk: primaryKey({
+      columns: [
+        table.reviewDocumentCacheId,
+        table.reviewChecklistId,
+        table.chunkIndex,
+      ],
+    }),
+  }),
 );
 
 // 型定義
@@ -120,6 +146,11 @@ export type ReviewHistoryEntity = typeof reviewHistories.$inferSelect;
 export type InsertReviewHistoryEntity = typeof reviewHistories.$inferInsert;
 export type ReviewChecklistEntity = typeof reviewChecklists.$inferSelect;
 export type InsertReviewChecklistEntity = typeof reviewChecklists.$inferInsert;
-export type ReviewChecklistResultEntity = typeof reviewChecklistResults.$inferSelect;
-export type InsertReviewChecklistResultEntity =
-  typeof reviewChecklistResults.$inferInsert;
+export type ReviewDocumentCacheEntity =
+  typeof reviewDocumentCaches.$inferSelect;
+export type InsertReviewDocumentCacheEntity =
+  typeof reviewDocumentCaches.$inferInsert;
+export type ReviewLargedocumentResultCacheEntity =
+  typeof reviewLargedocumentResultCaches.$inferSelect;
+export type InsertReviewLargedocumentResultCacheEntity =
+  typeof reviewLargedocumentResultCaches.$inferInsert;
diff --git a/src/adapter/db/drizzle/repository/settingsRepository.ts b/src/adapter/db/electron-store/repository/settingsRepository.ts
similarity index 97%
rename from src/adapter/db/drizzle/repository/settingsRepository.ts
rename to src/adapter/db/electron-store/repository/settingsRepository.ts
index c0ef0443c..050b2000b 100644
--- a/src/adapter/db/drizzle/repository/settingsRepository.ts
+++ b/src/adapter/db/electron-store/repository/settingsRepository.ts
@@ -1,6 +1,6 @@
 import { z } from 'zod';
 import { Settings, SettingsSchema } from '@/types';
-import { getStore } from '@/main/store';
+import { getStore } from '@/adapter/db/electron-store/store';
 import { repositoryError } from '@/main/lib/error';
 import { ISettingsRepository } from '@/main/service/port/repository';
 
diff --git a/src/main/store.ts b/src/adapter/db/electron-store/store.ts
similarity index 97%
rename from src/main/store.ts
rename to src/adapter/db/electron-store/store.ts
index c0b84c2bc..68036a088 100644
--- a/src/main/store.ts
+++ b/src/adapter/db/electron-store/store.ts
@@ -1,6 +1,6 @@
 // @ts-ignore
 import Store from 'electron-store';
-import { getCustomAppDataDir } from './main';
+import { getCustomAppDataDir } from '../../../main/main';
 // 設定の型定義
 export interface StoreSchema {
   database: {
diff --git a/src/adapter/db/index.ts b/src/adapter/db/index.ts
index 244d3fb47..d94b38fc0 100644
--- a/src/adapter/db/index.ts
+++ b/src/adapter/db/index.ts
@@ -6,8 +6,8 @@ import {
 import {
   DrizzleReviewRepository,
   DrizzleSourceRepository,
-  ElectronStoreSettingsRepository,
 } from './drizzle/repository';
+import { ElectronStoreSettingsRepository } from './electron-store/repository/settingsRepository';
 
 let sourceRepository: ISourceRepository | null = null;
 
diff --git a/src/main/lib/csvParser.ts b/src/main/lib/csvParser.ts
index 5a7817356..c2f82751c 100644
--- a/src/main/lib/csvParser.ts
+++ b/src/main/lib/csvParser.ts
@@ -101,7 +101,7 @@ export class CsvParser {
    * @returns 空行の場合true
    */
   private static isEmptyRow(row: string[]): boolean {
-    return row.every(cell => cell.trim() === '');
+    return row.every((cell) => cell.trim() === '');
   }
 
   /**
@@ -109,7 +109,10 @@ export class CsvParser {
    * @param csvText CSVテキスト
    * @returns 検証結果
    */
-  public static validate(csvText: string): { isValid: boolean; error?: string } {
+  public static validate(csvText: string): {
+    isValid: boolean;
+    error?: string;
+  } {
     try {
       let inQuotes = false;
       let quoteCount = 0;
@@ -139,4 +142,4 @@ export class CsvParser {
       return { isValid: false, error: `CSV解析エラー: ${error}` };
     }
   }
-}
\ No newline at end of file
+}
diff --git a/src/main/lib/fileExtractor.ts b/src/main/lib/fileExtractor.ts
index f7f136069..d57d7f454 100644
--- a/src/main/lib/fileExtractor.ts
+++ b/src/main/lib/fileExtractor.ts
@@ -166,7 +166,10 @@ export default class FileExtractor {
 
       // ファイルが更新されている場合はキャッシュを無効とする
       if (stats.mtimeMs !== cacheData.metadata.lastModified) {
-        logger.debug({ filePath, cachePath }, 'ファイルが更新されているためキャッシュを無効化します');
+        logger.debug(
+          { filePath, cachePath },
+          'ファイルが更新されているためキャッシュを無効化します',
+        );
         await this.deleteCache(filePath);
         return null;
       }
@@ -200,7 +203,11 @@ export default class FileExtractor {
           extractedAt: Date.now(),
         },
       };
-      await fs.writeFile(cachePath, JSON.stringify(cacheData, null, 2), 'utf-8');
+      await fs.writeFile(
+        cachePath,
+        JSON.stringify(cacheData, null, 2),
+        'utf-8',
+      );
     } catch (error) {
       // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
       logger.error({ error, filePath }, 'キャッシュの保存に失敗しました');
@@ -738,14 +745,18 @@ try {
             if (stats.mtimeMs !== cacheData.metadata.lastModified) {
               await fs.unlink(cacheFilePath);
               deletedCount++;
-              logger.debug(`ファイル更新日時が古いキャッシュを削除: ${fileName}`);
+              logger.debug(
+                `ファイル更新日時が古いキャッシュを削除: ${fileName}`,
+              );
             }
           } catch (statError) {
             // 元ファイルが存在しない場合は削除
             if ((statError as NodeJS.ErrnoException).code === 'ENOENT') {
               await fs.unlink(cacheFilePath);
               deletedCount++;
-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
+              logger.debug(
+                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
+              );
             }
           }
         } catch (processError) {
@@ -755,14 +766,22 @@ try {
             deletedCount++;
             logger.debug(`不正なキャッシュファイルを削除: ${fileName}`);
           } catch (unlinkError) {
-            logger.error({ error: unlinkError, fileName }, 'キャッシュファイルの削除に失敗');
+            logger.error(
+              { error: unlinkError, fileName },
+              'キャッシュファイルの削除に失敗',
+            );
           }
         }
       }
 
-      logger.info(`キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`);
+      logger.info(
+        `キャッシュクリーニング完了: ${deletedCount}個のファイルを削除`,
+      );
     } catch (error) {
-      logger.error({ error }, 'キャッシュディレクトリのクリーニングに失敗しました');
+      logger.error(
+        { error },
+        'キャッシュディレクトリのクリーニングに失敗しました',
+      );
     }
   }
 }
diff --git a/src/main/lib/logger.ts b/src/main/lib/logger.ts
index 0aa5282a2..b55e75012 100644
--- a/src/main/lib/logger.ts
+++ b/src/main/lib/logger.ts
@@ -6,7 +6,8 @@ import path from 'path';
 const logLevel = getLogLevel();
 log.transports.file.level = logLevel;
 log.transports.console.level = logLevel;
-log.transports.file.resolvePathFn = () => path.join(getCustomAppDataDir(), 'main.log');
+log.transports.file.resolvePathFn = () =>
+  path.join(getCustomAppDataDir(), 'main.log');
 
 // シングルトン変数
 let _mainLogger: Logger.MainLogger | null = null;
diff --git a/src/main/lib/officeConverter.ts b/src/main/lib/officeConverter.ts
index 55663f57a..fc8d0147a 100644
--- a/src/main/lib/officeConverter.ts
+++ b/src/main/lib/officeConverter.ts
@@ -199,9 +199,16 @@ async function saveCache(
       cachePdfPath,
       cachedAt: Date.now(),
     };
-    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf-8');
+    await fs.writeFile(
+      metadataPath,
+      JSON.stringify(metadata, null, 2),
+      'utf-8',
+    );
 
-    logger.debug({ originalFilePath, cachePdfPath }, 'PDFキャッシュを保存しました');
+    logger.debug(
+      { originalFilePath, cachePdfPath },
+      'PDFキャッシュを保存しました',
+    );
   } catch (error) {
     // キャッシュが保存できない場合は大きな問題にならないのでエラーは握りつぶす
     logger.error({ error, originalFilePath }, 'キャッシュの保存に失敗しました');
@@ -789,7 +796,9 @@ export async function cleanCacheDirectory(): Promise<void> {
               // 対応するPDFファイルも削除
               await fs.unlink(metadata.cachePdfPath).catch(() => void 0);
               deletedCount++;
-              logger.debug(`元ファイルが存在しないキャッシュを削除: ${fileName}`);
+              logger.debug(
+                `元ファイルが存在しないキャッシュを削除: ${fileName}`,
+              );
             }
           }
         }
diff --git a/src/main/lib/util.ts b/src/main/lib/util.ts
index e3c43a641..9544e872f 100644
--- a/src/main/lib/util.ts
+++ b/src/main/lib/util.ts
@@ -32,7 +32,9 @@ export function toAbsolutePath(dirOrPath: string, fileName?: string): string {
       throw internalError({
         expose: false,
         messageCode: 'VALIDATION_ERROR',
-        messageParams: { detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。` },
+        messageParams: {
+          detail: `第一引数にファイル名が含まれています: "${dirOrPath}". fileName と重複指定はできません。`,
+        },
       });
     }
     // ディレクトリ部を取り出して結合
@@ -68,7 +70,9 @@ export function isPathExists(dirOrPath: string): boolean {
     throw internalError({
       expose: true,
       messageCode: 'VALIDATION_ERROR',
-      messageParams: { detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}` },
+      messageParams: {
+        detail: `パスの存在確認中にエラーが発生しました: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
+      },
     });
   }
 }
diff --git a/src/main/lib/utils/reviewCacheHelper.ts b/src/main/lib/utils/reviewCacheHelper.ts
new file mode 100644
index 000000000..b1bd808ad
--- /dev/null
+++ b/src/main/lib/utils/reviewCacheHelper.ts
@@ -0,0 +1,127 @@
+import * as fs from 'fs/promises';
+import * as path from 'path';
+import { app } from 'electron';
+
+/**
+ * レビュー機能で使用するキャッシュファイルの管理ヘルパークラス
+ */
+export class ReviewCacheHelper {
+  /**
+   * キャッシュベースディレクトリ取得
+   */
+  private static getCacheBaseDir(reviewHistoryId: string): string {
+    return path.join(
+      app.getPath('userData'),
+      'review_cache',
+      reviewHistoryId,
+      'file_cache',
+    );
+  }
+
+  /**
+   * テキストキャッシュ保存
+   * @param reviewHistoryId レビュー履歴ID
+   * @param id ドキュメントキャッシュID
+   * @param content テキスト内容
+   * @returns ファイルパス
+   */
+  static async saveTextCache(
+    reviewHistoryId: string,
+    id: number,
+    content: string,
+  ): Promise<string> {
+    const baseDir = this.getCacheBaseDir(reviewHistoryId);
+    await fs.mkdir(baseDir, { recursive: true });
+
+    const cachePath = path.join(baseDir, `${id}.txt`);
+    await fs.writeFile(cachePath, content, 'utf-8');
+
+    return cachePath;
+  }
+
+  /**
+   * 画像キャッシュ保存（複数ページ対応）
+   * @param reviewHistoryId レビュー履歴ID
+   * @param id ドキュメントキャッシュID
+   * @param imageData Base64画像データ配列
+   * @returns ディレクトリパス
+   */
+  static async saveImageCache(
+    reviewHistoryId: string,
+    id: number,
+    imageData: string[],
+  ): Promise<string> {
+    const baseDir = this.getCacheBaseDir(reviewHistoryId);
+    const imageCacheDir = path.join(baseDir, `${id}`);
+    await fs.mkdir(imageCacheDir, { recursive: true });
+
+    for (let i = 0; i < imageData.length; i++) {
+      const pagePath = path.join(imageCacheDir, `page_${i}.b64`);
+      await fs.writeFile(pagePath, imageData[i], 'utf-8');
+    }
+
+    return imageCacheDir;
+  }
+
+  /**
+   * テキストキャッシュ読み込み
+   * @param cachePath ファイルパス
+   * @returns テキスト内容
+   * @throws ファイルが存在しない場合やアクセスできない場合にエラーをスロー
+   */
+  static async loadTextCache(cachePath: string): Promise<string> {
+    try {
+      return await fs.readFile(cachePath, 'utf-8');
+    } catch (error) {
+      // ファイルが存在しない、またはアクセスできない場合
+      throw new Error(
+        `Failed to load text cache from ${cachePath}: ${error instanceof Error ? error.message : String(error)}`,
+      );
+    }
+  }
+
+  /**
+   * 画像キャッシュ読み込み
+   * @param cacheDir ディレクトリパス
+   * @returns Base64画像データ配列
+   * @throws ディレクトリが存在しない場合やアクセスできない場合にエラーをスロー
+   */
+  static async loadImageCache(cacheDir: string): Promise<string[]> {
+    try {
+      const files = await fs.readdir(cacheDir);
+      const imageFiles = files
+        .filter((f) => f.endsWith('.b64'))
+        .sort((a, b) => {
+          const aNum = parseInt(a.match(/page_(\d+)\.b64/)?.[1] || '0');
+          const bNum = parseInt(b.match(/page_(\d+)\.b64/)?.[1] || '0');
+          return aNum - bNum;
+        });
+
+      const imageData: string[] = [];
+      for (const file of imageFiles) {
+        const content = await fs.readFile(path.join(cacheDir, file), 'utf-8');
+        imageData.push(content);
+      }
+
+      return imageData;
+    } catch (error) {
+      // ディレクトリが存在しない、またはアクセスできない場合
+      throw new Error(
+        `Failed to load image cache from ${cacheDir}: ${error instanceof Error ? error.message : String(error)}`,
+      );
+    }
+  }
+
+  /**
+   * キャッシュディレクトリ削除
+   * @param reviewHistoryId レビュー履歴ID
+   */
+  static async deleteCacheDirectory(reviewHistoryId: string): Promise<void> {
+    const cacheDir = path.join(
+      app.getPath('userData'),
+      'review_cache',
+      reviewHistoryId,
+    );
+    await fs.rm(cacheDir, { recursive: true, force: true });
+  }
+}
diff --git a/src/main/main.ts b/src/main/main.ts
index 047392026..605d337f2 100644
--- a/src/main/main.ts
+++ b/src/main/main.ts
@@ -272,12 +272,7 @@ const setupChatHandlers = () => {
     IpcChannels.CHAT_SEND_MESSAGE,
     async ({ roomId, messages }, { event }) => {
       try {
-        const dataStream = await chatService.generate(
-          userId,
-          roomId,
-          messages,
-          event,
-        );
+        const dataStream = await chatService.generate(userId, roomId, messages);
 
         // テキストストリームを処理
         // @ts-ignore
@@ -542,6 +537,43 @@ const setupReviewHandlers = () => {
     }
     return undefined as never;
   });
+
+  // レビューチャットメッセージ送信ハンドラ
+  handleIpc(
+    IpcChannels.REVIEW_CHAT_SEND_MESSAGE,
+    async ({ reviewHistoryId, checklistIds, question }) => {
+      try {
+        const dataStream = await reviewService.chatWithReview(
+          reviewHistoryId,
+          checklistIds,
+          question,
+        );
+
+        // テキストストリームを処理
+        // @ts-ignore
+        for await (const chunk of dataStream) {
+          // チャンクをフロントエンドに送信
+          publishEvent(IpcChannels.REVIEW_CHAT_STREAM_RESPONSE, chunk);
+        }
+
+        return undefined as never;
+      } catch (error) {
+        // エラー時もAbortControllerを削除
+        reviewService.abortReviewChat(reviewHistoryId);
+        const normalizedError = normalizeUnknownError(error);
+        publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
+          message: normalizedError.message,
+        });
+        throw normalizedError;
+      }
+    },
+  );
+
+  // レビューチャット中断ハンドラ
+  handleIpc(IpcChannels.REVIEW_CHAT_ABORT, async (reviewHistoryId) => {
+    const result = reviewService.abortReviewChat(reviewHistoryId);
+    return undefined as never;
+  });
 };
 
 // ソース登録処理の実行
diff --git a/src/main/preload.ts b/src/main/preload.ts
index fa8d0f9c8..c32d7113f 100644
--- a/src/main/preload.ts
+++ b/src/main/preload.ts
@@ -147,6 +147,13 @@ const electronHandler = {
     /** レビュー実行キャンセル */
     abortExecute: (reviewHistoryId: string) =>
       invokeIpc(IpcChannels.REVIEW_EXECUTE_ABORT, reviewHistoryId),
+    /** レビューチャットメッセージ送信 */
+    sendChatMessage: (
+      params: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE],
+    ) => invokeIpc(IpcChannels.REVIEW_CHAT_SEND_MESSAGE, params),
+    /** レビューチャット中断 */
+    abortChat: (reviewHistoryId: string) =>
+      invokeIpc(IpcChannels.REVIEW_CHAT_ABORT, reviewHistoryId),
   },
   pushApi: {
     async subscribe<C extends EventChannel>(
diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
index 43df9c6a8..625443fe6 100644
--- a/src/main/service/chatService.ts
+++ b/src/main/service/chatService.ts
@@ -120,7 +120,6 @@ export class ChatService implements IChatService {
     userId: string,
     threadId: string,
     messages: ChatMessage[],
-    event: Electron.IpcMainInvokeEvent,
   ) {
     // 新しいAbortControllerを作成
     const controller = this.abortControllerManager.getOrCreateAbortController(
diff --git a/src/main/service/port/repository/IReviewRepository.ts b/src/main/service/port/repository/IReviewRepository.ts
index b558873e1..9fac263b7 100644
--- a/src/main/service/port/repository/IReviewRepository.ts
+++ b/src/main/service/port/repository/IReviewRepository.ts
@@ -1,10 +1,13 @@
 import {
   CustomEvaluationSettings,
+  DocumentMode,
   ProcessingStatus,
   RevieHistory,
   ReviewChecklist,
   ReviewChecklistCreatedBy,
   ReviewChecklistResult,
+  ReviewDocumentCache,
+  ReviewLargedocumentResultCache,
   ReviewEvaluation,
 } from '@/types';
 
@@ -30,6 +33,10 @@ export interface IReviewRepository {
     id: string,
     processingStatus: ProcessingStatus,
   ): Promise<void>;
+  updateReviewHistoryTargetDocumentName(
+    id: string,
+    targetDocumentName: string,
+  ): Promise<void>;
   deleteReviewHistory(id: string): Promise<void>;
 
   // チェックリスト
@@ -49,16 +56,57 @@ export interface IReviewRepository {
       reviewChecklistId: number;
       evaluation: ReviewEvaluation;
       comment: string;
-      fileId: string;
-      fileName: string;
     }[],
   ): Promise<void>;
-  deleteReviewResults(
-    reviewChecklistId: number,
-    sourceId: number,
-  ): Promise<void>;
   getReviewChecklistResults(
     reviewHistoryId: string,
   ): Promise<ReviewChecklistResult[]>;
   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
+
+  // ドキュメントキャッシュ削除
+  deleteReviewDocumentCaches(reviewHistoryId: string): Promise<void>;
+  // 大量ドキュメント結果キャッシュ削除
+  deleteReviewLargedocumentResultCaches(reviewHistoryId: string): Promise<void>;
+
+  // documentModeの保存
+  updateReviewHistoryDocumentMode(
+    id: string,
+    documentMode: DocumentMode,
+  ): Promise<void>;
+
+  // ドキュメントキャッシュ管理
+  createReviewDocumentCache(
+    cache: Omit<ReviewDocumentCache, 'id' | 'createdAt' | 'updatedAt'>,
+  ): Promise<ReviewDocumentCache>;
+  getReviewDocumentCaches(
+    reviewHistoryId: string,
+  ): Promise<ReviewDocumentCache[]>;
+  getReviewDocumentCacheById(id: number): Promise<ReviewDocumentCache | null>;
+  getReviewDocumentCacheByIds(ids: number[]): Promise<ReviewDocumentCache[]>;
+
+  // 大量ドキュメント結果キャッシュ管理
+  createReviewLargedocumentResultCache(
+    cache: ReviewLargedocumentResultCache,
+  ): Promise<void>;
+  getReviewLargedocumentResultCaches(
+    reviewHistoryId: string,
+  ): Promise<ReviewLargedocumentResultCache[]>;
+  getMaxTotalChunksForDocument(
+    reviewDocumentCacheId: number,
+  ): Promise<number>;
+
+  // レビューチャット用: チェックリスト結果と個別レビュー結果を取得
+  getChecklistResultsWithIndividualResults(
+    reviewHistoryId: string,
+    checklistIds: number[],
+  ): Promise<
+    Array<{
+      checklistResult: ReviewChecklistResult;
+      individualResults?: Array<{
+        documentId: number;
+        comment: string;
+        individualFileName: string;
+      }>;
+    }>
+  >;
 }
diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
index c65bd4539..8ced9789e 100644
--- a/src/main/service/reviewService.ts
+++ b/src/main/service/reviewService.ts
@@ -1,3 +1,7 @@
+import { createDataStream } from 'ai';
+// @ts-ignore
+import { RuntimeContext } from '@mastra/core/runtime-context';
+import { v4 as uuid } from 'uuid';
 import { getReviewRepository } from '@/adapter/db';
 import {
   ReviewChecklistEdit,
@@ -20,11 +24,14 @@ import { getMainLogger } from '../lib/logger';
 import { mastra } from '@/mastra';
 import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
 import { formatMessage } from '../lib/messages';
+import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
+import { ReviewChatWorkflowRuntimeContext } from '@/mastra/workflows/reviewChat';
 
 export interface IReviewService {
   getReviewHistories(): Promise<RevieHistory[]>;
   getReviewHistoryDetail(reviewHistoryId: string): Promise<{
     checklistResults: ReviewChecklistResult[];
+    targetDocumentName?: string | null;
   }>;
   getReviewInstruction(reviewHistoryId: string): Promise<{
     additionalInstructions?: string;
@@ -49,6 +56,15 @@ export interface IReviewService {
     reviewHistoryId: string,
     files: UploadFile[],
   ): Promise<void>;
+  chatWithReview(
+    reviewHistoryId: string,
+    checklistIds: number[],
+    question: string,
+  ): Promise<ReturnType<typeof createDataStream>>;
+  abortReviewChat(reviewHistoryId: string): {
+    success: boolean;
+    error?: string;
+  };
 }
 
 const logger = getMainLogger();
@@ -82,8 +98,11 @@ export class ReviewService implements IReviewService {
   public async getReviewHistoryDetail(reviewHistoryId: string) {
     const checklistResults =
       await this.reviewRepository.getReviewChecklistResults(reviewHistoryId);
+    const reviewHistory =
+      await this.reviewRepository.getReviewHistory(reviewHistoryId);
     return {
       checklistResults: checklistResults,
+      targetDocumentName: reviewHistory?.targetDocumentName,
     };
   }
 
@@ -105,7 +124,18 @@ export class ReviewService implements IReviewService {
    * レビュー履歴を削除
    */
   public async deleteReviewHistory(reviewHistoryId: string) {
-    return this.reviewRepository.deleteReviewHistory(reviewHistoryId);
+    await this.reviewRepository.deleteReviewHistory(reviewHistoryId);
+
+    // キャッシュディレクトリも削除
+    try {
+      await ReviewCacheHelper.deleteCacheDirectory(reviewHistoryId);
+    } catch (err) {
+      // キャッシュ削除失敗はログのみ（DB削除は成功しているため）
+      logger.warn(
+        err,
+        `キャッシュディレクトリの削除に失敗しました: ${reviewHistoryId}`,
+      );
+    }
   }
 
   /**
@@ -116,7 +146,8 @@ export class ReviewService implements IReviewService {
     checklistEdits: ReviewChecklistEdit[],
   ) {
     // レビュー履歴が存在しない場合は新規作成
-    let reviewHistory = await this.reviewRepository.getReviewHistory(reviewHistoryId);
+    let reviewHistory =
+      await this.reviewRepository.getReviewHistory(reviewHistoryId);
     if (reviewHistory === null) {
       reviewHistory = await this.reviewRepository.createReviewHistory(
         generateReviewTitle(),
@@ -197,7 +228,9 @@ export class ReviewService implements IReviewService {
       }
 
       // システム作成のチェックリストを削除（手動作成分は保持）
-      await this.reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
+      await this.reviewRepository.deleteSystemCreatedChecklists(
+        reviewHistoryId,
+      );
 
       const allChecklistItems: string[] = [];
 
@@ -223,7 +256,11 @@ export class ReviewService implements IReviewService {
 
       // チェックリスト項目をDBに保存
       for (const item of uniqueChecklistItems) {
-        await this.reviewRepository.createChecklist(reviewHistoryId, item, 'system');
+        await this.reviewRepository.createChecklist(
+          reviewHistoryId,
+          item,
+          'system',
+        );
       }
       // AI処理と同様のイベント通知を発火
       publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
@@ -660,4 +697,147 @@ export class ReviewService implements IReviewService {
       return { success: false, error: err.message };
     }
   }
+
+  /**
+   * レビューチャット実行
+   * @param reviewHistoryId レビュー履歴ID
+   * @param checklistIds チェックリストID配列
+   * @param question ユーザからの質問
+   * @returns DataStream
+   */
+  public async chatWithReview(
+    reviewHistoryId: string,
+    checklistIds: number[],
+    question: string,
+  ): Promise<ReturnType<typeof createDataStream>> {
+    // DataStreamを生成
+    const dataStream = createDataStream({
+      execute: async (writer) => {
+        try {
+          // Mastraワークフローを取得
+          const workflow = mastra.getWorkflow('reviewChatWorkflow');
+
+          if (!workflow) {
+            logger.error('レビュー実行ワークフローが見つかりません');
+            throw internalError({
+              expose: false,
+            });
+          }
+
+          // 質問テキストから本文のみを抽出
+          // フォーマット: @チェックリスト行 + 空行 + 本文
+          const lines = question.split('\n');
+          const bodyLines: string[] = [];
+          let foundEmptyLine = false;
+
+          for (const line of lines) {
+            // @で始まる行は除外
+            if (line.trim().startsWith('@')) {
+              continue;
+            }
+
+            // 最初の空行を見つけた後から本文開始
+            if (!foundEmptyLine && line.trim() === '') {
+              foundEmptyLine = true;
+              continue;
+            }
+
+            // 空行を見つけた後の行を本文として抽出
+            if (foundEmptyLine) {
+              bodyLines.push(line);
+            }
+          }
+
+          const bodyText = bodyLines.join('\n').trim();
+
+          // ランタイムコンテキストを作成
+          const runtimeContext =
+            new RuntimeContext<ReviewChatWorkflowRuntimeContext>();
+          runtimeContext.set('dataStreamWriter', writer);
+          runtimeContext.set('toolCallId', uuid());
+
+          const run = await workflow.createRunAsync();
+
+          // workflowをrunningWorkflowsに登録
+          const workflowKey = `chat_${reviewHistoryId}`;
+
+          // 実行中のワークフローを管理
+          this.runningWorkflows.set(workflowKey, {
+            cancel: () => run.cancel(),
+          });
+
+          // ストリーミングはworkflow内部で実行されるため、ここでは結果を待つだけ
+          const result = await run.start({
+            inputData: {
+              reviewHistoryId,
+              checklistIds,
+              question: bodyText,
+            },
+            runtimeContext,
+          });
+
+          const checkResult = checkWorkflowResult(result);
+
+          // 処理が完了したらworkflowを削除
+          this.runningWorkflows.delete(workflowKey);
+
+          if (checkResult.status !== 'success') {
+            throw internalError({
+              expose: true,
+              messageCode: 'PLAIN_MESSAGE',
+              messageParams: {
+                message: checkResult.errorMessage || '不明なエラー',
+              },
+            });
+          }
+        } catch (error) {
+          logger.error(error, 'レビューチャット実行に失敗しました');
+          // エラー時もworkflowを削除
+          this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
+          throw error;
+        }
+      },
+      onError: (error) => {
+        logger.error(error, 'レビューチャット中にエラーが発生');
+        // エラー時もworkflowを削除
+        this.runningWorkflows.delete(`chat_${reviewHistoryId}`);
+        const normalizedError = normalizeUnknownError(error);
+        return normalizedError.message;
+      },
+    });
+
+    return dataStream;
+  }
+
+  /**
+   * レビューチャット中断
+   * @param reviewHistoryId レビュー履歴ID
+   */
+  public abortReviewChat(reviewHistoryId: string): {
+    success: boolean;
+    error?: string;
+  } {
+    try {
+      const workflowKey = `chat_${reviewHistoryId}`;
+      const runningWorkflow = this.runningWorkflows.get(workflowKey);
+      if (runningWorkflow) {
+        runningWorkflow.cancel();
+        this.runningWorkflows.delete(workflowKey);
+        logger.info(`レビューチャットをキャンセルしました: ${reviewHistoryId}`);
+        return { success: true };
+      } else {
+        logger.warn(
+          `キャンセル対象のレビューチャットが見つかりません: ${reviewHistoryId}`,
+        );
+        return {
+          success: false,
+          error: 'キャンセル対象の処理が見つかりません',
+        };
+      }
+    } catch (error) {
+      logger.error(error, 'レビューチャットのキャンセルに失敗しました');
+      const err = normalizeUnknownError(error);
+      return { success: false, error: err.message };
+    }
+  }
 }
diff --git a/src/main/service/settingsService.ts b/src/main/service/settingsService.ts
index 5882d1d96..682726a8a 100644
--- a/src/main/service/settingsService.ts
+++ b/src/main/service/settingsService.ts
@@ -257,13 +257,17 @@ export class SettingsService implements ISettingsService {
       publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: true });
     } catch (error) {
       // 設定更新完了イベントを発行（失敗）
-      const errorMessage = error instanceof Error ? error.message : '不明なエラーが発生しました';
-      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, { success: false, error: errorMessage });
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラーが発生しました';
+      publishEvent(IpcChannels.SETTINGS_UPDATE_FINISHED, {
+        success: false,
+        error: errorMessage,
+      });
 
       // エラーを再throw
       throw error;
     }
-  }
+  };
   /**
    * 設定を取得する
    */
diff --git a/src/mastra/agents/model/openAICompatible.ts b/src/mastra/agents/model/openAICompatible.ts
index c741004b1..158e92301 100644
--- a/src/mastra/agents/model/openAICompatible.ts
+++ b/src/mastra/agents/model/openAICompatible.ts
@@ -14,7 +14,10 @@ export const getOpenAICompatibleModel = ({
     throw internalError({
       expose: true,
       messageCode: 'VALIDATION_ERROR',
-      messageParams: { detail: 'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。' },
+      messageParams: {
+        detail:
+          'AI APIの設定が正しくありません。APIキー、URL、BPR IDを確認してください。',
+      },
     });
   }
 
diff --git a/src/mastra/agents/orchestrator.ts b/src/mastra/agents/orchestrator.ts
index 66730c8c7..6b85b70c4 100644
--- a/src/mastra/agents/orchestrator.ts
+++ b/src/mastra/agents/orchestrator.ts
@@ -6,7 +6,7 @@ import { Memory } from '@mastra/memory';
 import { TokenLimiter } from '@mastra/memory/processors';
 // @ts-ignore
 import { LibSQLStore } from '@mastra/libsql';
-import { getStore } from '@/main/store';
+import { getStore } from '@/adapter/db/electron-store/store';
 import { getOrchestratorSystemPrompt } from './prompts';
 import { getOpenAICompatibleModel } from './model/openAICompatible';
 import { isPathExists, toAbsoluteFileURL } from '@/main/lib/util';
diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
index ed443613a..1ba3b3377 100644
--- a/src/mastra/agents/prompts.ts
+++ b/src/mastra/agents/prompts.ts
@@ -8,11 +8,11 @@ import {
   ReviewExecuteAgentRuntimeContext,
   TopicExtractionAgentRuntimeContext,
   TopicChecklistAgentRuntimeContext,
-  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
-  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
-  ReviewAnswerQuestionAgentRuntimeContext,
   IndividualDocumentReviewAgentRuntimeContext,
   ConsolidateReviewAgentRuntimeContext,
+  ReviewChatPlanningAgentRuntimeContext,
+  ReviewChatResearchAgentRuntimeContext,
+  ReviewChatAnswerAgentRuntimeContext,
 } from './workflowAgents';
 
 /**
@@ -576,6 +576,294 @@ ${additionalInstructions}
 Remember: Your thorough analysis of this document part is crucial for achieving an excellent final consolidated review. Include all relevant details that will contribute to the overall document assessment.`;
 }
 
+// レビューチャット：調査計画作成用のプロンプト
+export function getReviewChatPlanningPrompt({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewChatPlanningAgentRuntimeContext>;
+}): string {
+  const availableDocuments = runtimeContext.get('availableDocuments');
+  const checklistInfo = runtimeContext.get('checklistInfo');
+  const reviewMode = runtimeContext.get('reviewMode');
+
+  const documentList = availableDocuments
+    .map((doc) => `- ID: ${doc.id}, Name: ${doc.fileName}`)
+    .join('\n');
+
+  return `You are a professional document analysis coordinator specializing in review result investigation.
+
+CONTEXT:
+You are helping answer user questions about document review results. You have access to:
+1. The original reviewed documents
+2. Review results including evaluations and comments for specific checklist items${reviewMode === 'large' ? '\n3. Individual review results from analyzing specific document sections' : ''}
+
+AVAILABLE DOCUMENTS:
+${documentList}
+
+CHECKLIST REVIEW INFORMATION:
+${checklistInfo}
+
+${reviewMode === 'large' ? `IMPORTANT: Individual Review Results Available
+The checklist information above includes detailed individual review results from analyzing specific document sections. These individual results provide:
+- Granular findings from each document part
+- Specific issues or strengths identified in different sections
+- Detailed evidence and citations
+
+When planning your research:
+- Consider these individual results as valuable context and clues for understanding where specific information exists
+- Use them to identify which documents or sections need deeper investigation
+- Focus your research on areas where the user's question relates to findings in these individual results
+- The individual results can help you avoid unnecessary investigation of irrelevant documents
+
+` : ''}DOCUMENT PROCESSING NOTE:
+Documents will be analyzed automatically and split into sections if needed for processing. Focus on WHAT information to extract, not HOW to process the documents. Your research instructions should be clear about the specific information needed to answer the user's question.
+
+YOUR TASK:
+Create an efficient research plan to answer the user's question by identifying:
+1. Which documents contain relevant information
+2. What specific aspects to investigate in each document
+3. How the investigation relates to the review results
+
+STRATEGIC PLANNING GUIDELINES:
+
+**Question Analysis:**
+- Understand the user's intent: Are they asking about evaluation reasoning, improvement suggestions, specific document content, or discrepancies in the review?
+- Identify keywords and concepts that connect to the checklist items and review comments
+- Determine if the question relates to specific checklist items or general document content
+
+**Document Selection Strategy:**
+- **Prioritize efficiency**: Select ONLY documents that are likely to contain relevant information
+- Use the review results to guide your selection:
+  * If asking about a specific evaluation or comment, focus on documents mentioned in those review results
+  * If asking about document content, identify which documents are most likely to contain that information
+  * Consider the review context: documents with lower ratings or specific comments may need investigation
+
+**Research Instructions Quality:**
+- Be SPECIFIC and FOCUSED in your research instructions
+- Clearly state what information to extract (e.g., "Find the section describing the testing methodology and extract the specific test types mentioned")
+- Prioritize targeted investigation over broad exploration
+
+**Efficiency Considerations:**
+- Minimize the number of documents to investigate (only select what's necessary)
+- Avoid redundant investigations across multiple documents unless truly needed
+- Focus research instructions on finding specific information rather than general overviews
+
+OUTPUT REQUIREMENTS:
+For each document that needs investigation, provide:
+- **Document ID**: The exact ID from the available documents list above
+- **Research Instructions**: Detailed, focused instructions explaining:
+  * What specific information to look for
+  * How it relates to the user's question
+  * Connection to review results if applicable
+- **Reasoning**: Brief explanation (1-2 sentences) of why this document is necessary for answering the question
+
+IMPORTANT:
+- Create a focused, efficient plan - quality over quantity
+- Your research plan will be executed in parallel across multiple documents
+- Each investigation will be conducted independently, so make instructions self-contained and clear`;
+}
+
+// レビューチャット：個別ドキュメント調査用のプロンプト
+export function getReviewChatResearchPrompt({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewChatResearchAgentRuntimeContext>;
+}): string {
+  const totalChunks = runtimeContext.get('totalChunks');
+  const chunkIndex = runtimeContext.get('chunkIndex');
+  const fileName = runtimeContext.get('fileName');
+  const checklistInfo = runtimeContext.get('checklistInfo');
+  const userQuestion = runtimeContext.get('userQuestion');
+  const reviewMode = runtimeContext.get('reviewMode');
+
+  // ドキュメントが分割されているかどうかで異なるプロンプトを生成
+  const isChunked = totalChunks > 1;
+
+  const contextSection = isChunked
+    ? `
+DOCUMENT ANALYSIS SCOPE:
+- You are analyzing a specific section of the document "${fileName}"
+- Due to the document's length, it has been divided into ${totalChunks} sequential sections for thorough analysis
+- You are currently analyzing section ${chunkIndex + 1} of ${totalChunks}
+- You can ONLY see the content of this section
+- Other sections exist but are being analyzed separately
+- Content may be incomplete at section boundaries
+
+CRITICAL INSTRUCTIONS FOR SECTION-BASED ANALYSIS:
+- Report ONLY what you can find in the content provided to you
+- If the requested information is not present in this section, state clearly: "情報はこのセクションでは見つかりませんでした"
+- Do NOT speculate about content in other sections
+- If content appears to begin or end mid-topic, acknowledge this limitation
+- Focus on thoroughly documenting what IS present rather than what is missing
+- Your findings will be combined with analyses from other sections to form a complete picture
+`
+    : `
+DOCUMENT ANALYSIS SCOPE:
+- You are analyzing the complete document "${fileName}"
+- The full document content is available for your review
+- You have access to all information needed for comprehensive analysis
+`;
+
+  return `You are a professional document researcher specializing in detailed document analysis.
+
+Your task is to conduct a focused investigation on the provided document content based on specific research instructions.
+
+BACKGROUND CONTEXT:
+This research is being conducted to answer the following user question about a document review:
+
+User Question:
+${userQuestion}
+
+The review was conducted using the following checklist(s):
+${checklistInfo}
+
+${reviewMode === 'large' ? `NOTE: This was a comprehensive review of large documents. The checklist information above includes both:
+- Overall consolidated review results (final evaluation and comments)
+- Individual review results from analyzing specific document sections
+When investigating, you may reference both levels of review detail to provide thorough answers.` : `NOTE: This was a standard review where all documents fit within a single analysis. The checklist information above shows the direct review results.`}
+
+Understanding this context will help you focus your investigation on information that is truly relevant to answering the user's question about the review results.
+${contextSection}
+RESEARCH GUIDELINES:
+1. Carefully read and analyze the provided document content with the user's question and checklist context in mind
+2. Follow the specific research instructions precisely
+3. Extract all relevant information related to the research topic
+4. Consider how your findings relate to the checklist items and review results mentioned above
+5. Cite specific sections, chapter numbers, headings, page numbers, or other document-native references where information is found
+   - Example: "第3章「システム設計」の3.2節に記載されています"
+   - Example: "15ページの図表5に示されています"
+6. If information appears incomplete or ambiguous, note this clearly${isChunked ? ' (particularly at section boundaries)' : ''}
+7. Document your findings comprehensively - do not omit relevant details
+${isChunked ? '8. Remember: report only on what is present in the content provided to you' : ''}
+
+IMPORTANT: NATURAL DOCUMENT REFERENCES ONLY
+- When citing locations in the document, use ONLY natural document elements (chapter numbers, section titles, page numbers, headings, etc.)
+- Do NOT mention "chunk", "section ${chunkIndex + 1}/${totalChunks}", "part", or any other processing-related divisions
+
+OUTPUT REQUIREMENTS:
+- Provide detailed research findings in Japanese
+- Include specific, natural citations using document-native references (chapters, sections, pages, headings)
+- Note any limitations or gaps in the available information${isChunked ? ' within this chunk' : ''} using natural language
+- Structure your findings clearly for easy integration into a comprehensive answer${isChunked ? `
+- If requested information is not present, state naturally like "この点については確認できませんでした"` : ''}
+- Focus on WHAT you found and WHERE in the document (using natural references), not on HOW the analysis was conducted`;
+}
+
+// レビューチャット：最終回答生成用のプロンプト
+export function getReviewChatAnswerPrompt({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewChatAnswerAgentRuntimeContext>;
+}): string {
+  const userQuestion = runtimeContext.get('userQuestion');
+  const checklistInfo = runtimeContext.get('checklistInfo');
+  const reviewMode = runtimeContext.get('reviewMode');
+
+  return `You are a senior document review specialist responsible for synthesizing research findings into comprehensive answers.
+
+CONTEXT:
+You are answering questions about document review results. You have access to:
+1. The user's original question
+2. Review results with evaluations and comments for specific checklist items${reviewMode === 'large' ? `
+3. Individual review results from analyzing specific document sections
+4. ` : `
+3. `}Research findings from document investigations
+
+USER QUESTION:
+${userQuestion}
+
+CHECKLIST CONTEXT:
+${checklistInfo}
+
+YOUR TASK:
+Integrate all research findings and provide a clear, accurate, and comprehensive answer to the user's question.
+
+CRITICAL: HIDE ALL INTERNAL PROCESSING
+The research findings you receive may contain internal processing information (such as document chunking, splitting, or analysis workflow details). Your final answer to the user MUST COMPLETELY HIDE these internal processes. The user should never know about:
+- How documents were split or chunked for processing
+- Internal workflow steps or intermediate analysis stages
+- Technical details about how the research was conducted
+
+Instead, write your answer as if you directly reviewed the complete, original documents.
+
+SYNTHESIS GUIDELINES:
+
+**Understanding the Research Results:**
+- You will receive research findings from documents
+- These findings have been gathered through an internal analysis process
+- The internal process details are NOT relevant to the user and must be hidden
+- Your task is to synthesize the findings into a natural, coherent answer
+- Consider ALL findings together to build a complete picture
+
+**Integration Strategy:**
+1. **Identify Relevant Information:**
+   - Extract key information from each research finding that addresses the user's question
+   - Pay attention to specific citations, section references, and evidence provided
+   - Distinguish between definitive findings and tentative/partial information
+   - Ignore any internal processing markers or workflow indicators
+
+2. **Synthesize Information Naturally:**
+   - Combine all findings into a unified answer
+   - If the same document is referenced multiple times, consolidate the information smoothly
+   - Present information as if it came from a single, thorough review of each complete document
+   - Remove any indication that documents were processed in parts or stages
+
+3. **Resolve Contradictions:**
+   - If findings from different sources contradict each other:
+     * Present both perspectives
+     * Explain the discrepancy clearly
+     * Cite specific sources for each perspective
+     * Offer reasoning if one source seems more authoritative
+
+4. **Create a Coherent Narrative:**
+   - Organize information logically to directly answer the question
+   - Connect findings to the review context (evaluations, comments) when relevant
+   - Build a narrative that flows naturally, not just a list of findings
+   - Ensure the answer reads as if written by someone who reviewed the complete documents directly
+
+**Citation and Reference Guidelines:**
+- **Document Names**: Use ONLY the original document names (e.g., "設計書.pdf")
+- **Never mention**: "chunk", "part", "section" (when referring to processing divisions), "portion analyzed", or any similar internal processing terminology
+- **Specific Citations**: Include actual section names, chapter headings, page numbers, or other document-native references (e.g., "設計書.pdfの第3章によると...")
+- **Attribution**: Clearly attribute information to the original document sources
+- **Natural Language**: Write as if you physically read through each complete document
+
+**Handling Incomplete Information:**
+- If critical information is missing or unclear, state this explicitly in Japanese
+- Suggest what additional information would be needed
+- Distinguish between:
+  * Information that definitely doesn't exist in the documents
+  * Information that wasn't found but might exist elsewhere
+  * Information that is ambiguous or unclear
+- Frame this naturally without revealing internal processing details
+
+OUTPUT REQUIREMENTS:
+- **Language**: Answer in Japanese, matching the style and formality of the user's question
+- **Structure**: Organize the answer clearly and logically:
+  * Start with a direct answer to the main question if possible
+  * Provide supporting details and evidence from the documents
+  * Conclude with any caveats or additional context
+- **Tone**: Professional, informative, and helpful
+- **Completeness**: Address all aspects of the user's question
+- **Natural Expression**: Write EXACTLY as if you personally reviewed the complete, original documents from start to finish
+- **Transparency**: Be completely transparent when information is insufficient, but frame it naturally (e.g., "この点については設計書.pdfに明確な記載が見つかりませんでした" rather than revealing processing limitations)
+
+FINAL QUALITY CHECK:
+Before finalizing your answer, verify:
+1. No internal processing terminology is present
+2. All document references use original document names only
+3. The answer reads as if written by someone who reviewed complete documents
+4. The narrative flows naturally without gaps or awkward transitions
+5. No hint of chunking, splitting, or staged processing is visible
+
+CRITICAL REMINDERS:
+- Your answer represents the final response to the user
+- The user must NEVER know about internal processing details
+- Quality and accuracy are paramount
+- Provide value by synthesizing information naturally and comprehensively
+- Write as if you are a human expert who thoroughly reviewed all complete documents`;
+}
+
 // レビュー結果統合用のプロンプト
 export function getConsolidateReviewPrompt({
   runtimeContext,
diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
index ad0371265..f2d5644b4 100644
--- a/src/mastra/agents/workflowAgents.ts
+++ b/src/mastra/agents/workflowAgents.ts
@@ -14,6 +14,9 @@ import {
   getDocumentReviewExecutionPrompt,
   getIndividualDocumentReviewPrompt,
   getConsolidateReviewPrompt,
+  getReviewChatPlanningPrompt,
+  getReviewChatResearchPrompt,
+  getReviewChatAnswerPrompt,
 } from './prompts';
 import { getOpenAICompatibleModel } from './model/openAICompatible';
 import { BaseRuntimeContext } from './types';
@@ -44,32 +47,41 @@ export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
   checklistRequirements?: string;
 };
 
-export type ReviewCheckReviewReadinessFirstRunAgentRuntimeContext = BaseRuntimeContext & {
+export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
   checklistItems: { id: number; content: string }[];
   additionalInstructions?: string;
+  commentFormat?: string;
 };
 
-export type ReviewCheckReviewReadinessSubsequentAgentRuntimeContext = BaseRuntimeContext & {
+export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
   checklistItems: { id: number; content: string }[];
   additionalInstructions?: string;
-  priorQnA: { documentId: string; documentName: string; qna: { question: string; answer: string }[] }[];
+  commentFormat?: string;
+  evaluationSettings?: CustomEvaluationSettings;
 };
 
-export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
-  checklistItems: { id: number; content: string }[];
+// レビューチャット用エージェント
+export type ReviewChatPlanningAgentRuntimeContext = BaseRuntimeContext & {
+  availableDocuments: { id: number; fileName: string }[];
+  checklistInfo: string; // チェックリスト情報のテキスト
+  reviewMode: 'large' | 'small'; // レビュー方式（大量レビュー/少量レビュー）
 };
 
-export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
-  checklistItems: { id: number; content: string }[];
-  additionalInstructions?: string;
-  commentFormat?: string;
+export type ReviewChatResearchAgentRuntimeContext = BaseRuntimeContext & {
+  researchContent: string; // 調査内容
+  totalChunks: number; // ドキュメントの総チャンク数
+  chunkIndex: number; // 現在のチャンクインデックス
+  fileName: string; // ドキュメント名
+  checklistInfo: string; // チェックリスト情報（内容とレビュー結果）
+  userQuestion: string; // ユーザからの質問
+  reasoning?: string; // 調査計画の理由
+  reviewMode: 'large' | 'small'; // レビュー方式（大量レビュー/少量レビュー）
 };
 
-export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
-  checklistItems: { id: number; content: string }[];
-  additionalInstructions?: string;
-  commentFormat?: string;
-  evaluationSettings?: CustomEvaluationSettings;
+export type ReviewChatAnswerAgentRuntimeContext = BaseRuntimeContext & {
+  userQuestion: string; // ユーザからの質問
+  checklistInfo: string; // チェックリスト情報のテキスト
+  reviewMode: 'large' | 'small'; // レビュー方式（大量レビュー/少量レビュー）
 };
 
 export const summarizeSourceAgent = new Agent({
@@ -139,3 +151,21 @@ export const consolidateReviewAgent = new Agent({
   instructions: getConsolidateReviewPrompt,
   model: getOpenAICompatibleModel,
 });
+
+export const reviewChatPlanningAgent = new Agent({
+  name: 'reviewChatPlanningAgent',
+  instructions: getReviewChatPlanningPrompt,
+  model: getOpenAICompatibleModel,
+});
+
+export const reviewChatResearchAgent = new Agent({
+  name: 'reviewChatResearchAgent',
+  instructions: getReviewChatResearchPrompt,
+  model: getOpenAICompatibleModel,
+});
+
+export const reviewChatAnswerAgent = new Agent({
+  name: 'reviewChatAnswerAgent',
+  instructions: getReviewChatAnswerPrompt,
+  model: getOpenAICompatibleModel,
+});
diff --git a/src/mastra/index.ts b/src/mastra/index.ts
index d2cd1e327..976120234 100644
--- a/src/mastra/index.ts
+++ b/src/mastra/index.ts
@@ -19,10 +19,14 @@ import {
   topicChecklistAgent,
   individualDocumentReviewAgent,
   consolidateReviewAgent,
+  reviewChatPlanningAgent,
+  reviewChatResearchAgent,
+  reviewChatAnswerAgent,
 } from './agents/workflowAgents';
 import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
 import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
 import { executeReviewWorkflow } from './workflows/sourceReview/executeReview';
+import { reviewChatWorkflow } from './workflows/reviewChat';
 import fs from 'fs';
 import path from 'path';
 import { getLogLevel } from '@/main/lib/logger';
@@ -51,7 +55,6 @@ try {
   console.error('ログファイル初期化に失敗:', err);
 }
 
-
 // ロガーの作成
 export const logger = new PinoLogger({
   name: 'AIKATA',
@@ -73,11 +76,15 @@ export const mastra: Mastra = new Mastra({
     topicChecklistAgent,
     individualDocumentReviewAgent,
     consolidateReviewAgent,
+    reviewChatPlanningAgent,
+    reviewChatResearchAgent,
+    reviewChatAnswerAgent,
   },
   workflows: {
     sourceRegistrationWorkflow,
     checklistExtractionWorkflow,
     executeReviewWorkflow,
+    reviewChatWorkflow,
   },
   logger,
 });
diff --git a/src/mastra/lib/util.ts b/src/mastra/lib/util.ts
index 57fe0b68c..3438aae8a 100644
--- a/src/mastra/lib/util.ts
+++ b/src/mastra/lib/util.ts
@@ -8,7 +8,7 @@
 export function makeChunksByCount<T extends { length: number }>(
   data: T,
   splitCount: number,
-  overlap: number
+  overlap: number,
 ): Array<{ start: number; end: number }> {
   const total = data.length;
 
diff --git a/src/mastra/tools/redmine/redmineClient.ts b/src/mastra/tools/redmine/redmineClient.ts
index d383049b7..1f88ac3cb 100644
--- a/src/mastra/tools/redmine/redmineClient.ts
+++ b/src/mastra/tools/redmine/redmineClient.ts
@@ -92,7 +92,9 @@ export class RedmineClient {
         throw internalError({
           expose: true,
           messageCode: 'REDMINE_API_ERROR',
-          messageParams: { detail: `${response.status} ${response.statusText}` },
+          messageParams: {
+            detail: `${response.status} ${response.statusText}`,
+          },
         });
       }
       if (response.status === 204) {
diff --git a/src/mastra/tools/toolDisplayConfig.ts b/src/mastra/tools/toolDisplayConfig.ts
index 62ee97da4..9dca7f3da 100644
--- a/src/mastra/tools/toolDisplayConfig.ts
+++ b/src/mastra/tools/toolDisplayConfig.ts
@@ -25,4 +25,8 @@ export const TOOL_NAME_DISPLAY_MAP: Record<string, string> = {
   getMergeRequestDetail: 'マージリクエスト詳細取得',
   addMergeRequestComment: 'マージリクエストコメント追加',
   addMergeRequestDiffComment: 'マージリクエスト差分コメント追加',
+
+  // レビューチャット用
+  researchDocumentStart: 'ドキュメント調査中...',
+  researchDocumentComplete: 'ドキュメント調査完了',
 };
diff --git a/src/mastra/workflows/reviewChat/generateAnswerStep.ts b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
new file mode 100644
index 000000000..abe60e6d7
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
@@ -0,0 +1,160 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+// @ts-ignore
+import { RuntimeContext } from '@mastra/core/runtime-context';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../schema';
+import { stepStatus } from '../types';
+import { getReviewRepository } from '@/adapter/db';
+import { getMainLogger } from '@/main/lib/logger';
+import { normalizeUnknownError, internalError } from '@/main/lib/error';
+import { ReviewChatAnswerAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import { IpcChannels } from '@/types';
+import { publishEvent } from '@/main/lib/eventPayloadHelper';
+import { ReviewChatWorkflowRuntimeContext } from '.';
+import {
+  judgeReviewMode,
+  buildAnswerChecklistInfo,
+} from './lib';
+
+const logger = getMainLogger();
+
+export const generateAnswerStepInputSchema = z.object({
+  reviewHistoryId: z.string(),
+  checklistIds: z.array(z.number()),
+  question: z.string(),
+  researchResults: z.array(
+    z.object({
+      documentCacheId: z.number(),
+      researchResult: z.string(),
+    }),
+  ),
+});
+
+export const generateAnswerStepOutputSchema = baseStepOutputSchema.extend({
+  answer: z.string().optional(),
+});
+
+export const generateAnswerStep = createStep({
+  id: 'generateAnswerStep',
+  description: '最終回答を生成するステップ（ストリーミング）',
+  inputSchema: generateAnswerStepInputSchema,
+  outputSchema: generateAnswerStepOutputSchema,
+  execute: async ({
+    inputData,
+    bail,
+    mastra,
+    abortSignal,
+    runtimeContext: workflowRuntimeContext,
+  }) => {
+    try {
+      const { reviewHistoryId, checklistIds, question, researchResults } =
+        inputData;
+      const reviewRepository = getReviewRepository();
+      const dataStreamWriter = (
+        workflowRuntimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+      ).get('dataStreamWriter');
+
+      // チェックリスト結果を取得
+      const checklistResults =
+        await reviewRepository.getChecklistResultsWithIndividualResults(
+          reviewHistoryId,
+          checklistIds,
+        );
+
+      // レビュー方式を判定（ヘルパー関数を利用）
+      const reviewMode = judgeReviewMode(checklistResults);
+
+      // ドキュメントキャッシュ情報を取得
+      const documentCaches =
+        await reviewRepository.getReviewDocumentCacheByIds(
+          researchResults.map((r) => r.documentCacheId),
+        );
+
+      // チェックリスト情報の文字列を生成（ヘルパー関数を利用）
+      const checklistInfo = buildAnswerChecklistInfo(checklistResults);
+
+      // 調査結果を統合
+      const researchSummary = researchResults
+        .map((result) => {
+          const doc = documentCaches.find((dc) => dc.id === result.documentCacheId);
+          return `Document: ${doc?.fileName || 'Unknown'}
+Research Findings:
+${result.researchResult}`;
+        })
+        .join('\n\n---\n\n');
+
+      // RuntimeContext作成
+      const runtimeContext =
+        await createRuntimeContext<ReviewChatAnswerAgentRuntimeContext>();
+      runtimeContext.set('userQuestion', question);
+      runtimeContext.set('checklistInfo', checklistInfo);
+      runtimeContext.set('reviewMode', reviewMode);
+
+      const promptText = `User Question: ${question}\n\nResearch Findings:\n${researchSummary}`;
+
+      // Mastraエージェント経由でストリーミングAI呼び出し
+      const answerAgent = mastra.getAgent('reviewChatAnswerAgent');
+      const result = await answerAgent.generate(promptText, {
+        runtimeContext,
+        abortSignal,
+        onStepFinish: (stepResult) => {
+          // AI SDK Data Stream Protocol v1 形式でチャンクを送信
+          // https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol
+          if (stepResult.text) {
+            dataStreamWriter.write(`0:${JSON.stringify(stepResult.text)}\n`);
+          }
+          stepResult.toolCalls.forEach((toolCall) => {
+            dataStreamWriter.write(`9:${JSON.stringify(toolCall)}\n`);
+          });
+          stepResult.toolResults.forEach((toolResult) => {
+            dataStreamWriter.write(`a:${JSON.stringify(toolResult)}\n`);
+          });
+          dataStreamWriter.write(
+            `e:${JSON.stringify({ finishReason: stepResult.finishReason, ...stepResult.usage })}\n`,
+          );
+        },
+      });
+
+      const { success, reason } = judgeFinishReason(result.finishReason);
+      if (!success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'AI_API_ERROR',
+          messageParams: { detail: reason },
+        });
+      }
+
+      // 最終的なfinish reasonとusage情報を送信
+      publishEvent(
+        IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
+        `d:${JSON.stringify({ finishReason: result.finishReason, ...result.usage })}\n`,
+      );
+
+      // 完了イベント送信
+      publishEvent(IpcChannels.REVIEW_CHAT_COMPLETE, undefined);
+
+      return {
+        status: 'success' as stepStatus,
+        answer: result.text,
+      };
+    } catch (error) {
+      logger.error(error, '最終回答の生成に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+
+      // エラーイベント送信
+      publishEvent(IpcChannels.REVIEW_CHAT_ERROR, {
+        message: normalizedError.message,
+      });
+
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: normalizedError.message,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/reviewChat/index.ts b/src/mastra/workflows/reviewChat/index.ts
new file mode 100644
index 000000000..fb46abf77
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/index.ts
@@ -0,0 +1,134 @@
+// @ts-ignore
+import { createWorkflow } from '@mastra/core';
+// @ts-ignore
+import { RuntimeContext } from '@mastra/core/runtime-context';
+import { DataStreamWriter } from 'ai';
+import { z } from 'zod';
+import { stepStatus } from '../types';
+import { planResearchStep } from './planResearchStep';
+import {
+  generateAnswerStep,
+  generateAnswerStepInputSchema,
+  generateAnswerStepOutputSchema,
+} from './generateAnswerStep';
+import { researchDocumentWithRetryWorkflow } from './researchDocument';
+import { getReviewRepository } from '@/adapter/db';
+
+// ワークフローのラインタイムコンテキスト
+export type ReviewChatWorkflowRuntimeContext = {
+  dataStreamWriter: DataStreamWriter;
+  // 擬似的なtoolCallを表現するためのID
+  toolCallId: string;
+};
+
+// 入力スキーマ
+export const reviewChatInputSchema = z.object({
+  reviewHistoryId: z.string(),
+  checklistIds: z.array(z.number()),
+  question: z.string(),
+});
+
+// メインワークフロー
+export const reviewChatWorkflow = createWorkflow({
+  id: 'reviewChatWorkflow',
+  inputSchema: reviewChatInputSchema,
+  outputSchema: generateAnswerStepOutputSchema,
+})
+  .then(planResearchStep)
+  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
+    if (inputData.status === 'failed') {
+      return bail(inputData);
+    }
+
+    const initData = (await getInitData()) as z.infer<
+      typeof reviewChatInputSchema
+    >;
+
+    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
+    const toolCallId = (
+      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+    ).get('toolCallId');
+    const writer = (
+      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+    ).get('dataStreamWriter');
+    const reviewRepository = getReviewRepository();
+    const documentCaches = await reviewRepository.getReviewDocumentCaches(
+      initData.reviewHistoryId,
+    );
+    writer.write(
+      `9:${JSON.stringify({
+        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
+        toolName: 'researchDocumentStart',
+        args: inputData.researchTasks?.map((task) => {
+          return {
+            documentName:
+              documentCaches.find((d) => d.id === task.documentCacheId)
+                ?.fileName || 'Unknown',
+            researchContent: task.researchContent,
+          };
+        }),
+      })}\n`,
+    );
+
+    return (inputData.researchTasks || []).map((task) => ({
+      reviewHistoryId: initData.reviewHistoryId,
+      documentCacheId: task.documentCacheId,
+      researchContent: task.researchContent,
+      reasoning: task.reasoning,
+      checklistIds: initData.checklistIds,
+      question: initData.question,
+    })) as z.infer<typeof researchDocumentWithRetryWorkflow.inputSchema>[];
+  })
+  .foreach(researchDocumentWithRetryWorkflow, { concurrency: 5 })
+  .map(async ({ inputData, bail, getInitData, runtimeContext }) => {
+    // 失敗があればエラー
+    if (inputData.some((item) => item.status === 'failed')) {
+      const failed = inputData.find((item) => item.status === 'failed');
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: failed?.errorMessage || '調査に失敗しました',
+      });
+    }
+
+    const initData = (await getInitData()) as z.infer<
+      typeof reviewChatInputSchema
+    >;
+
+    // ユーザ体験向上のため、調査タスクを擬似的なtoolCallとして表現する
+    const toolCallId = (
+      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+    ).get('toolCallId');
+    const writer = (
+      runtimeContext as RuntimeContext<ReviewChatWorkflowRuntimeContext>
+    ).get('dataStreamWriter');
+    const reviewRepository = getReviewRepository();
+    const documentCaches = await reviewRepository.getReviewDocumentCaches(
+      initData.reviewHistoryId,
+    );
+    writer.write(
+      `a:${JSON.stringify({
+        toolCallId: `reviewChatResearchDocument-${toolCallId}`,
+        toolName: 'researchDocumentComplete',
+        result: inputData.map((item) => ({
+          documentName:
+            documentCaches.find((d) => d.id === item.documentCacheId)
+              ?.fileName || 'Unknown',
+          researchResult: item.researchResult!,
+        })),
+      })}\n`,
+    );
+
+    return {
+      reviewHistoryId: initData.reviewHistoryId,
+      checklistIds: initData.checklistIds,
+      question: initData.question,
+      researchResults: inputData
+        .filter((item) => item.status === 'success')
+        .map((item) => ({
+          documentCacheId: item.documentCacheId!,
+          researchResult: item.researchResult!,
+        })),
+    } as z.infer<typeof generateAnswerStepInputSchema>;
+  })
+  .then(generateAnswerStep)
+  .commit();
diff --git a/src/mastra/workflows/reviewChat/lib.ts b/src/mastra/workflows/reviewChat/lib.ts
new file mode 100644
index 000000000..46f863584
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/lib.ts
@@ -0,0 +1,100 @@
+/**
+ * レビューチャットworkflowで利用するヘルパー関数
+ */
+
+import type { ReviewChecklistResult } from '@/types';
+
+/**
+ * チェックリスト結果と個別レビュー結果のデータ型
+ */
+export type ChecklistResultWithIndividualResults = {
+  checklistResult: ReviewChecklistResult;
+  individualResults?: Array<{
+    documentId: number;
+    comment: string;
+    individualFileName: string;
+  }>;
+};
+
+/**
+ * レビューモードを判定する
+ * @param checklistResults チェックリスト結果と個別レビュー結果の配列
+ * @returns 'large' | 'small'
+ */
+export function judgeReviewMode(
+  checklistResults: ChecklistResultWithIndividualResults[],
+): 'large' | 'small' {
+  const hasIndividualResults = checklistResults.some(
+    (item) => item.individualResults && item.individualResults.length > 0,
+  );
+  return hasIndividualResults ? 'large' : 'small';
+}
+
+/**
+ * レビュー計画用のチェックリスト情報を構築する
+ * @param checklistResults チェックリスト結果と個別レビュー結果の配列
+ * @returns チェックリスト情報のテキスト
+ */
+export function buildPlanningChecklistInfo(
+  checklistResults: ChecklistResultWithIndividualResults[],
+): string {
+  return checklistResults
+    .map((item) => {
+      let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
+      if (item.checklistResult.sourceEvaluation) {
+        info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
+      }
+      if (item.individualResults && item.individualResults.length > 0) {
+        info += `Individual Review Results:\n`;
+        item.individualResults.forEach((result) => {
+          info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
+        });
+      }
+      return info;
+    })
+    .join('\n---\n');
+}
+
+/**
+ * レビュー調査用のチェックリスト情報を構築する
+ * @param checklistResults チェックリスト結果と個別レビュー結果の配列
+ * @returns チェックリスト情報のテキスト
+ */
+export function buildResearchChecklistInfo(
+  checklistResults: ChecklistResultWithIndividualResults[],
+): string {
+  return checklistResults
+    .map((item) => {
+      let info = `Checklist ID: ${item.checklistResult.id}\nContent: ${item.checklistResult.content}\n`;
+      if (item.checklistResult.sourceEvaluation) {
+        info += `Review Result:\n  Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}\n  Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}\n`;
+      }
+      if (item.individualResults && item.individualResults.length > 0) {
+        info += `Individual Review Results:\n`;
+        item.individualResults.forEach((result) => {
+          info += `  - Document ID: ${result.documentId}\n    Document Name: ${result.individualFileName}\n    Comment: ${result.comment}\n`;
+        });
+      }
+      return info;
+    })
+    .join('\n---\n');
+}
+
+/**
+ * レビュー回答用のチェックリスト情報を構築する
+ * @param checklistResults チェックリスト結果と個別レビュー結果の配列
+ * @returns チェックリスト情報のテキスト
+ */
+export function buildAnswerChecklistInfo(
+  checklistResults: ChecklistResultWithIndividualResults[],
+): string {
+  return checklistResults
+    .map((item) => {
+      let info = `Checklist: ${item.checklistResult.content}\n`;
+      if (item.checklistResult.sourceEvaluation) {
+        info += `Evaluation: ${item.checklistResult.sourceEvaluation.evaluation || 'N/A'}, Comment: ${item.checklistResult.sourceEvaluation.comment || 'N/A'}`;
+      }
+      return info;
+    })
+    .join('\n');
+}
diff --git a/src/mastra/workflows/reviewChat/planResearchStep.ts b/src/mastra/workflows/reviewChat/planResearchStep.ts
new file mode 100644
index 000000000..a921ecfbc
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/planResearchStep.ts
@@ -0,0 +1,126 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../schema';
+import { stepStatus } from '../types';
+import { getReviewRepository } from '@/adapter/db';
+import { getMainLogger } from '@/main/lib/logger';
+import { normalizeUnknownError, internalError } from '@/main/lib/error';
+import { ReviewChatPlanningAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import { reviewChatInputSchema } from '.';
+import {
+  judgeReviewMode,
+  buildPlanningChecklistInfo,
+} from './lib';
+
+const logger = getMainLogger();
+
+// Step 1: 調査計画作成
+const planResearchStepOutputSchema = baseStepOutputSchema.extend({
+  researchTasks: z
+    .array(
+      z.object({
+        documentCacheId: z.number(),
+        researchContent: z.string(),
+        reasoning: z.string(), // 調査理由を追加
+      }),
+    )
+    .optional(),
+});
+
+export const planResearchStep = createStep({
+  id: 'planResearchStep',
+  description: '調査計画を作成するステップ',
+  inputSchema: reviewChatInputSchema,
+  outputSchema: planResearchStepOutputSchema,
+  execute: async ({ inputData, bail, mastra }) => {
+    try {
+      const { reviewHistoryId, checklistIds, question } = inputData;
+      const reviewRepository = getReviewRepository();
+
+      // チェックリスト結果と個別レビュー結果を取得
+      const checklistResults =
+        await reviewRepository.getChecklistResultsWithIndividualResults(
+          reviewHistoryId,
+          checklistIds,
+        );
+
+      // ドキュメント一覧を取得
+      const documentCaches =
+        await reviewRepository.getReviewDocumentCaches(reviewHistoryId);
+
+      // RuntimeContext作成
+      const availableDocuments = documentCaches.map((doc) => ({
+        id: doc.id,
+        fileName: doc.fileName,
+      }));
+
+      // レビュー方式を判定（ヘルパー関数を利用）
+      const reviewMode = judgeReviewMode(checklistResults);
+
+      // チェックリスト情報の文字列を生成（ヘルパー関数を利用）
+      const checklistInfo = buildPlanningChecklistInfo(checklistResults);
+
+      // RuntimeContext作成
+      const runtimeContext =
+        await createRuntimeContext<ReviewChatPlanningAgentRuntimeContext>();
+      runtimeContext.set('availableDocuments', availableDocuments);
+      runtimeContext.set('checklistInfo', checklistInfo);
+      runtimeContext.set('reviewMode', reviewMode);
+
+      // 構造化出力用のスキーマ
+      const researchTasksSchema = z.object({
+        tasks: z.array(
+          z.object({
+            reasoning: z
+              .string()
+              .describe('Reason for selecting this document for research'),
+            documentId: z.string().describe('Document ID to investigate'),
+            researchContent: z
+              .string()
+              .describe('Detailed research instructions for this document'),
+          }),
+        ),
+      });
+
+      // Mastraエージェント経由でAI呼び出し（構造化出力）
+      const planningAgent = mastra.getAgent('reviewChatPlanningAgent');
+      const result = await planningAgent.generate(question, {
+        runtimeContext,
+        output: researchTasksSchema,
+      });
+
+      const { success, reason } = judgeFinishReason(result.finishReason);
+      if (!success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'AI_API_ERROR',
+          messageParams: { detail: reason },
+        });
+      }
+
+      // 構造化出力から調査タスクを取得
+      const researchTasks = (result.object?.tasks || []).map((task) => ({
+        documentCacheId: Number(task.documentId),
+        researchContent: task.researchContent,
+        reasoning: task.reasoning,
+      }));
+
+      return {
+        status: 'success' as stepStatus,
+        researchTasks,
+      };
+    } catch (error) {
+      logger.error(error, '調査計画の作成に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: normalizedError.message,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
new file mode 100644
index 000000000..b129d5910
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/researchDocument/getTotalChunksStep.ts
@@ -0,0 +1,56 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../schema';
+import { stepStatus } from '../../types';
+import { getReviewRepository } from '@/adapter/db';
+import { getMainLogger } from '@/main/lib/logger';
+import { normalizeUnknownError } from '@/main/lib/error';
+
+const logger = getMainLogger();
+
+export const getTotalChunksStepInputSchema = z.object({
+  reviewHistoryId: z.string(),
+  documentCacheId: z.number(),
+  researchContent: z.string(),
+});
+
+export const getTotalChunksStepOutputSchema = baseStepOutputSchema.extend({
+  reviewHistoryId: z.string(),
+  documentCacheId: z.number(),
+  researchContent: z.string(),
+  totalChunks: z.number(),
+});
+
+export const getTotalChunksStep = createStep({
+  id: 'getTotalChunksStep',
+  description: '最大チャンク数を取得するステップ',
+  inputSchema: getTotalChunksStepInputSchema,
+  outputSchema: getTotalChunksStepOutputSchema,
+  execute: async ({ inputData, bail }) => {
+    try {
+      const { reviewHistoryId, documentCacheId, researchContent } = inputData;
+      const reviewRepository = getReviewRepository();
+
+      // 既存の最大チャンク数を取得
+      const totalChunks = await reviewRepository.getMaxTotalChunksForDocument(
+        documentCacheId,
+      );
+
+      return {
+        status: 'success' as stepStatus,
+        reviewHistoryId,
+        documentCacheId,
+        researchContent,
+        totalChunks,
+      };
+    } catch (error) {
+      logger.error(error, '最大チャンク数の取得に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: normalizedError.message,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/reviewChat/researchDocument/index.ts b/src/mastra/workflows/reviewChat/researchDocument/index.ts
new file mode 100644
index 000000000..5c5366304
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/researchDocument/index.ts
@@ -0,0 +1,254 @@
+// @ts-ignore
+import { createWorkflow } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../schema';
+import { stepStatus } from '../../types';
+import { getReviewRepository } from '@/adapter/db';
+import { getMainLogger } from '@/main/lib/logger';
+import { makeChunksByCount } from '@/mastra/lib/util';
+import {
+  getTotalChunksStep,
+  getTotalChunksStepInputSchema,
+} from './getTotalChunksStep';
+import {
+  researchChunkStep,
+  researchChunkStepInputSchema,
+} from './researchDocumentChunk';
+import { internalError } from '@/main/lib/error';
+
+const logger = getMainLogger();
+
+const researchDocumentWithRetryInputSchema = z.object({
+  reviewHistoryId: z.string(),
+  documentCacheId: z.number(),
+  researchContent: z.string(),
+  reasoning: z.string(),
+  checklistIds: z.array(z.number()),
+  question: z.string(),
+});
+
+const researchDocumentWithRetryOutputSchema = baseStepOutputSchema.extend({
+  documentCacheId: z.number().optional(),
+  researchResult: z.string().optional(),
+});
+
+const chunkResearchInnerWorkflowInputSchema = baseStepOutputSchema.extend({
+  checklistIds: z.array(z.number()),
+  question: z.string(),
+  retryCount: z.number(),
+  reviewHistoryId: z.string(),
+  documentCacheId: z.number(),
+  researchContent: z.string(),
+  reasoning: z.string(),
+  totalChunks: z.number(),
+  researchResult: z.string().optional(),
+  finishReason: z.enum(['success', 'error', 'content_length']),
+});
+
+export const researchDocumentWithRetryWorkflow = createWorkflow({
+  id: 'researchDocumentWithRetryWorkflow',
+  inputSchema: researchDocumentWithRetryInputSchema,
+  outputSchema: researchDocumentWithRetryOutputSchema,
+})
+  .map(async ({ inputData }) => {
+    return inputData as z.infer<typeof getTotalChunksStepInputSchema>;
+  })
+  .then(getTotalChunksStep)
+  .map(async ({ inputData, getInitData, bail }) => {
+    if (inputData.status === 'failed') {
+      return bail(inputData);
+    }
+    const initData = (await getInitData()) as z.infer<
+      typeof researchDocumentWithRetryInputSchema
+    >;
+    return {
+      ...inputData,
+      checklistIds: initData.checklistIds,
+      question: initData.question,
+      reasoning: initData.reasoning,
+      retryCount: 0,
+      finishReason: 'error' as const,
+    } as z.infer<typeof chunkResearchInnerWorkflowInputSchema>;
+  })
+  .dountil(
+    createWorkflow({
+      id: 'chunkResearchInnerWorkflow',
+      inputSchema: chunkResearchInnerWorkflowInputSchema,
+      outputSchema: chunkResearchInnerWorkflowInputSchema,
+    })
+      .map(async ({ inputData }) => {
+        const {
+          reviewHistoryId,
+          documentCacheId,
+          researchContent,
+          totalChunks,
+        } = inputData;
+        const reviewRepository = getReviewRepository();
+
+        // ドキュメントキャッシュを取得
+        const documentCache =
+          await reviewRepository.getReviewDocumentCacheById(documentCacheId);
+
+        if (!documentCache) {
+          throw internalError({
+            expose: true,
+            messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
+          });
+        }
+
+        // ドキュメントをtotalChunks分に分割
+        const chunks: Array<{ text?: string; images?: string[] }> = [];
+
+        if (documentCache.processMode === 'text' && documentCache.textContent) {
+          // テキストをチャンク分割
+          const chunkRanges = makeChunksByCount(
+            documentCache.textContent,
+            totalChunks,
+            300,
+          );
+          chunkRanges.forEach((range) => {
+            chunks.push({
+              text: documentCache.textContent!.substring(
+                range.start,
+                range.end,
+              ),
+            });
+          });
+        } else if (
+          documentCache.processMode === 'image' &&
+          documentCache.imageData
+        ) {
+          // 画像配列をチャンク分割
+          const chunkRanges = makeChunksByCount(
+            documentCache.imageData,
+            totalChunks,
+            3,
+          );
+          chunkRanges.forEach((range) => {
+            chunks.push({
+              images: documentCache.imageData!.slice(range.start, range.end),
+            });
+          });
+        }
+
+        // 各チャンクに対する調査タスクを作成
+        return chunks.map((chunk, index) => ({
+          reviewHistoryId,
+          documentCacheId,
+          researchContent,
+          chunkContent: chunk,
+          chunkIndex: index,
+          totalChunks,
+          fileName: documentCache.fileName,
+          checklistIds: inputData.checklistIds,
+          question: inputData.question,
+          reasoning: inputData.reasoning,
+        })) as z.infer<typeof researchChunkStepInputSchema>[];
+      })
+      .foreach(researchChunkStep, { concurrency: 5 })
+      .map(async ({ inputData, bail, getInitData }) => {
+        const initData = (await getInitData()) as z.infer<
+          typeof chunkResearchInnerWorkflowInputSchema
+        >;
+
+        const results = inputData;
+
+        // いずれかのチャンクでコンテキスト長エラーがあったかチェック
+        const hasContentLengthError = results.some(
+          (result) => result.finishReason === 'content_length',
+        );
+
+        // コンテキスト長エラーがない場合、失敗が一つでもある場合は失敗として返す
+        if (
+          !hasContentLengthError &&
+          results.some((result) => result.status === 'failed')
+        ) {
+          const failed = results.find((result) => result.status === 'failed');
+          return {
+            status: 'failed' as stepStatus,
+            errorMessage: failed?.errorMessage,
+            finishReason: 'error' as const,
+            retryCount: initData.retryCount,
+            documentCacheId: initData.documentCacheId,
+          } as z.infer<typeof chunkResearchInnerWorkflowInputSchema>;
+        }
+
+        // リトライ回数が5回を超えたら終了
+        // レビュー実行時にドキュメント分割できることを確認しているため、ここには到達しないはず
+        if (initData.retryCount >= 5) {
+          return {
+            status: 'failed' as stepStatus,
+            errorMessage: 'ドキュメントが長すぎて処理できませんでした。',
+            finishReason: 'error' as const,
+            retryCount: initData.retryCount,
+            documentCacheId: initData.documentCacheId,
+          } as z.infer<typeof chunkResearchInnerWorkflowInputSchema>;
+        }
+
+        if (hasContentLengthError) {
+          // チャンク数を増やして再試行
+          return {
+            status: 'success' as stepStatus,
+            reviewHistoryId: initData.reviewHistoryId,
+            documentCacheId: initData.documentCacheId,
+            researchContent: initData.researchContent,
+            reasoning: initData.reasoning,
+            totalChunks: initData.totalChunks + 1,
+            finishReason: 'content_length' as const,
+            checklistIds: initData.checklistIds,
+            question: initData.question,
+            retryCount: initData.retryCount + 1,
+          } as z.infer<typeof chunkResearchInnerWorkflowInputSchema>;
+        }
+
+        // すべて成功したらチャンク結果を統合
+        // ドキュメントキャッシュを取得
+        const reviewRepository = getReviewRepository();
+        const documentCache = await reviewRepository.getReviewDocumentCacheById(
+          initData.documentCacheId,
+        );
+        if (!documentCache) {
+          throw internalError({
+            expose: true,
+            messageCode: 'REVIEW_DOCUMENT_CACHE_NOT_FOUND',
+          });
+        }
+        // チャンク情報は削除し、調査結果のみを結合
+        const combinedResult = results
+          .filter((result) => result.chunkResult)
+          .map(
+            (result) =>
+              `Document Name:\n${documentCache.fileName}${initData.totalChunks > 1 ? ` ※(Chunk ${result.chunkIndex! + 1}/${initData.totalChunks})(split into chunks because the full content did not fit into context)` : ''}\nResearch Findings:\n${result.chunkResult}`,
+          )
+          .join('\n\n---\n\n');
+
+        return {
+          status: 'success' as stepStatus,
+          documentCacheId: initData.documentCacheId,
+          researchResult: combinedResult,
+          finishReason: 'success' as const,
+          retryCount: initData.retryCount,
+        } as z.infer<typeof chunkResearchInnerWorkflowInputSchema>;
+      })
+      .commit(),
+    async ({ inputData }) => {
+      // 再試行上限または成功したら終了
+      if (inputData.retryCount >= 5) {
+        return true;
+      }
+      if (inputData.finishReason !== 'content_length') {
+        return true;
+      }
+      return false;
+    },
+  )
+  .map(async ({ inputData }) => {
+    // 最終結果を返す
+    return {
+      status: inputData.status,
+      documentCacheId: inputData.documentCacheId,
+      researchResult: inputData.researchResult,
+      errorMessage: inputData.errorMessage,
+    };
+  })
+  .commit();
diff --git a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
new file mode 100644
index 000000000..0e25ac1fa
--- /dev/null
+++ b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
@@ -0,0 +1,160 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../schema';
+import { stepStatus } from '../../types';
+import { getMainLogger } from '@/main/lib/logger';
+import { normalizeUnknownError, internalError } from '@/main/lib/error';
+import { ReviewChatResearchAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+  judgeErrorIsContentLengthError,
+} from '@/mastra/lib/agentUtils';
+import { getReviewRepository } from '@/adapter/db';
+import {
+  judgeReviewMode,
+  buildResearchChecklistInfo,
+} from '../lib';
+
+const logger = getMainLogger();
+
+export const researchChunkStepInputSchema = z.object({
+  reviewHistoryId: z.string(),
+  documentCacheId: z.number(),
+  researchContent: z.string(),
+  chunkContent: z.object({
+    text: z.string().optional(),
+    images: z.array(z.string()).optional(),
+  }),
+  chunkIndex: z.number(),
+  totalChunks: z.number(),
+  fileName: z.string(),
+  checklistIds: z.array(z.number()),
+  question: z.string(),
+  reasoning: z.string(),
+});
+
+const researchChunkStepOutputSchema = baseStepOutputSchema.extend({
+  chunkResult: z.string().optional(),
+  chunkIndex: z.number().optional(),
+  finishReason: z.enum(['success', 'error', 'content_length']).optional(),
+});
+
+export const researchChunkStep = createStep({
+  id: 'researchChunkStep',
+  description: 'チャンク単位でドキュメントを調査するステップ',
+  inputSchema: researchChunkStepInputSchema,
+  outputSchema: researchChunkStepOutputSchema,
+  execute: async ({ inputData, bail, mastra, getInitData }) => {
+    try {
+      const {
+        researchContent,
+        chunkContent,
+        chunkIndex,
+        totalChunks,
+        fileName,
+        reviewHistoryId,
+        checklistIds,
+        question,
+        reasoning,
+      } = inputData;
+
+      // チェックリスト情報を生成（ヘルパー関数を利用）
+      const reviewRepository = getReviewRepository();
+      const checklistResults =
+        await reviewRepository.getChecklistResultsWithIndividualResults(
+          reviewHistoryId,
+          checklistIds,
+        );
+
+      // レビューモードを判定（ヘルパー関数を利用）
+      const reviewMode = judgeReviewMode(checklistResults);
+
+      // チェックリスト情報の文字列を生成（ヘルパー関数を利用）
+      const checklistInfo = buildResearchChecklistInfo(checklistResults);
+
+      // RuntimeContext作成
+      const runtimeContext =
+        await createRuntimeContext<ReviewChatResearchAgentRuntimeContext>();
+      runtimeContext.set('researchContent', researchContent);
+      runtimeContext.set('totalChunks', totalChunks);
+      runtimeContext.set('chunkIndex', chunkIndex);
+      runtimeContext.set('fileName', fileName);
+      runtimeContext.set('checklistInfo', checklistInfo);
+      runtimeContext.set('userQuestion', question);
+      runtimeContext.set('reasoning', reasoning);
+      runtimeContext.set('reviewMode', reviewMode);
+
+      // メッセージを作成
+      const messageContent = [];
+
+      if (chunkContent.text) {
+        // テキストチャンクの場合
+        messageContent.push({
+          type: 'text' as const,
+          text: `Document: ${fileName}\n\nResearch Instructions: ${researchContent}\n\nDocument Content:\n${chunkContent.text}`,
+        });
+      } else if (chunkContent.images && chunkContent.images.length > 0) {
+        // 画像チャンクの場合
+        messageContent.push({
+          type: 'text' as const,
+          text: `Document: ${fileName}\n\nResearch Instructions: ${researchContent}\n\nPlease analyze the following document images:`,
+        });
+
+        chunkContent.images.forEach((imageBase64) => {
+          messageContent.push({
+            type: 'image' as const,
+            image: imageBase64,
+          });
+        });
+      }
+
+      // Mastraエージェント経由でAI呼び出し
+      const researchAgent = mastra.getAgent('reviewChatResearchAgent');
+      const result = await researchAgent.generate(
+        {
+          role: 'user',
+          content: messageContent,
+        },
+        {
+          runtimeContext,
+        },
+      );
+
+      const { success, reason } = judgeFinishReason(result.finishReason);
+
+      if (!success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'AI_API_ERROR',
+          messageParams: { detail: reason },
+        });
+      }
+
+      return {
+        status: 'success' as stepStatus,
+        chunkIndex,
+        chunkResult: result.text,
+        finishReason: 'success' as const,
+      };
+    } catch (error) {
+      // コンテキスト長エラーの場合は特別な処理
+      if (judgeErrorIsContentLengthError(error)) {
+        return {
+          status: 'success' as stepStatus,
+          chunkIndex: inputData.chunkIndex,
+          finishReason: 'content_length' as const,
+        };
+      }
+
+      logger.error(error, 'チャンク調査に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: normalizedError.message,
+        finishReason: 'error' as const,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
index 14ac3da86..e477a12a4 100644
--- a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
@@ -1,40 +1,46 @@
-import { z } from "zod";
-import { baseStepOutputSchema } from "../../schema";
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../schema';
 // @ts-ignore
-import { createStep } from "@mastra/core";
+import { createStep } from '@mastra/core';
 // @ts-ignore
-import { MastraError } from "@mastra/core/error";
+import { MastraError } from '@mastra/core/error';
 import { NoObjectGeneratedError } from 'ai';
-import { getReviewRepository } from "@/adapter/db";
-import { extractAIAPISafeError, internalError, normalizeUnknownError } from "@/main/lib/error";
-import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from ".";
-import { stepStatus } from "../../types";
-import { splitChecklistEquallyByMaxSize } from "../lib";
-import { createRuntimeContext } from "@/mastra/lib/agentUtils";
-import { ClassifyCategoryAgentRuntimeContext } from "@/mastra/agents/workflowAgents";
-import { getMainLogger } from "@/main/lib/logger";
+import { getReviewRepository } from '@/adapter/db';
+import {
+  extractAIAPISafeError,
+  internalError,
+  normalizeUnknownError,
+} from '@/main/lib/error';
+import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from '.';
+import { stepStatus } from '../../types';
+import { splitChecklistEquallyByMaxSize } from '../lib';
+import { createRuntimeContext } from '@/mastra/lib/agentUtils';
+import { ClassifyCategoryAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import { getMainLogger } from '@/main/lib/logger';
 
 const logger = getMainLogger();
 
 export const classifyChecklistsByCategoryInputSchema = z.object({
-  reviewHistoryId: z.string().describe("レビュー履歴ID"),
+  reviewHistoryId: z.string().describe('レビュー履歴ID'),
 });
 
 // カテゴリ分類ステップの出力スキーマ
-export const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
-  categories: z
-    .array(
-      z.object({
-        name: z.string(),
-        checklists: z.array(
-          z.object({
-            id: z.number(),
-            content: z.string().describe('チェックリストの内容'),
-          }),
-        ),
-      }),
-    ).optional(),
-});
+export const classifyChecklistsByCategoryOutputSchema =
+  baseStepOutputSchema.extend({
+    categories: z
+      .array(
+        z.object({
+          name: z.string(),
+          checklists: z.array(
+            z.object({
+              id: z.number(),
+              content: z.string().describe('チェックリストの内容'),
+            }),
+          ),
+        }),
+      )
+      .optional(),
+  });
 
 export const classifyChecklistsByCategoryStep = createStep({
   id: 'classifyChecklistsByCategoryStep',
diff --git a/src/mastra/workflows/sourceReview/executeReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/index.ts
index 0972e2670..f96b79902 100644
--- a/src/mastra/workflows/sourceReview/executeReview/index.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/index.ts
@@ -9,6 +9,7 @@ import { classifyChecklistsByCategoryStep } from './classifyChecklistStep';
 import { smallDocumentReviewExecutionStep } from './smallDocumentReviewStep';
 import { largeDocumentReviewWorkflow } from './largeDocumentReview';
 import { extractedDocumentSchema, uploadedFileSchema } from './schema';
+import { getReviewRepository } from '@/adapter/db';
 
 const logger = getMainLogger();
 
@@ -54,6 +55,7 @@ export const executeReviewWorkflowInputSchema = z.object({
 export const executeReviewWorkflowOutputSchema = baseStepOutputSchema;
 
 export const documentReviewExecutionInputSchema = z.object({
+  reviewHistoryId: z.string().describe('レビュー履歴ID'),
   additionalInstructions: z
     .string()
     .optional()
@@ -143,8 +145,52 @@ export const executeReviewWorkflow = createWorkflow({
       typeof executeReviewWorkflowInputSchema
     >;
 
+    // 既存のレビュー結果を全て削除
+    const reviewRepository = getReviewRepository();
+    // 大量ドキュメント結果キャッシュを削除
+    await reviewRepository.deleteReviewLargedocumentResultCaches(
+      initData.reviewHistoryId,
+    );
+    // ドキュメントキャッシュを削除（ファイルシステムのキャッシュも削除）
+    await reviewRepository.deleteReviewDocumentCaches(initData.reviewHistoryId);
+    // レビュー結果を削除
+    await reviewRepository.deleteAllReviewResults(initData.reviewHistoryId);
+
+    // documentModeを保存
+    await reviewRepository.updateReviewHistoryDocumentMode(
+      initData.reviewHistoryId,
+      initData.documentMode,
+    );
+
+    // ドキュメントキャッシュを保存
+    for (const document of textExtractionResult.extractedDocuments || []) {
+      if (!document) continue;
+      const savedCache = await reviewRepository.createReviewDocumentCache({
+        reviewHistoryId: initData.reviewHistoryId,
+        fileName: document.name || '',
+        processMode: document.processMode || 'text',
+        textContent: document.textContent,
+        imageData: document.imageData,
+      });
+      // キャッシュIDを付与
+      document.cacheId = savedCache.id;
+    }
+
+    // レビュー対象の統合ドキュメント名を保存
+    const targetDocumentName = (textExtractionResult.extractedDocuments || [])
+      .map((doc) => doc?.name || '')
+      .filter((name) => name)
+      .join('/');
+    if (targetDocumentName) {
+      await reviewRepository.updateReviewHistoryTargetDocumentName(
+        initData.reviewHistoryId,
+        targetDocumentName,
+      );
+    }
+
     return classifyChecklistsResult.categories!.map((category) => {
       return {
+        reviewHistoryId: initData.reviewHistoryId,
         documents: textExtractionResult.extractedDocuments!,
         checklists: category.checklists,
         additionalInstructions: initData.additionalInstructions,
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
index cafb8793c..e1187dce7 100644
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
@@ -87,7 +87,10 @@ export const consolidateReviewStep = createStep({
       // 個別レビュー結果を整理
       const consolidatedInput = documentsWithReviewResults.map((docResult) => {
         return {
-          originalName: docResult?.originalName || docResult?.name || `Document ${docResult.id}`,
+          originalName:
+            docResult?.originalName ||
+            docResult?.name ||
+            `Document ${docResult.id}`,
           documentName: docResult?.name || `Document ${docResult.id}`,
           reviewResults: docResult.reviewResults,
         };
@@ -102,7 +105,7 @@ export const consolidateReviewStep = createStep({
             text: `Please consolidate the following individual document review results into a comprehensive final review.
 
 ## Document Set Information:
-Original Files: ${[...new Set(consolidatedInput.map(doc => doc.originalName))].join(', ')}
+Original Files: ${[...new Set(consolidatedInput.map((doc) => doc.originalName))].join(', ')}
 
 ## Individual Document Review Results:
 ${consolidatedInput
@@ -187,32 +190,16 @@ Please provide a consolidated review that synthesizes all individual document re
           });
         }
 
-        // 統合レビュー結果をDBに保存（複数ファイルの情報を統合）
+        // 統合レビュー結果をDBに保存
         if (
           consolidatedResult.object &&
           Array.isArray(consolidatedResult.object)
         ) {
-          const combinedFileIds = documentsWithReviewResults
-            .map((f) => f.id)
-            .join('/');
-          const idsHash = createHash('md5')
-            .update(combinedFileIds)
-            .digest('hex');
-          const combinedFileNames = [
-            ...new Set(
-              documentsWithReviewResults.map(
-                (f) => f.originalName || f.name,
-              ),
-            ),
-          ].join('/');
-
           await reviewRepository.upsertReviewResult(
             consolidatedResult.object.map((result) => ({
               reviewChecklistId: result.checklistId,
               evaluation: result.evaluation as ReviewEvaluation,
               comment: result.comment,
-              fileId: idsHash,
-              fileName: combinedFileNames,
             })),
           );
         }
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
index c6f8371b8..2a7fbbf02 100644
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
@@ -12,6 +12,7 @@ import {
 import { baseStepOutputSchema } from '@/mastra/workflows/schema';
 import { makeChunksByCount } from '@/mastra/lib/util';
 import { extractedDocumentSchema } from '../schema';
+import { getReviewRepository } from '@/adapter/db';
 
 const logger = getMainLogger();
 
@@ -155,8 +156,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
                 ...initData.originalDocument,
                 id: `${initData.originalDocument.id}_part${index + 1}`,
                 name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+                originalName:
+                  initData.originalDocument.originalName ||
+                  initData.originalDocument.name,
                 textContent: chunk,
+                totalChunks: splitCount,
+                chunkIndex: index,
               },
             })),
             retryCount: nextRetryCount,
@@ -182,8 +187,12 @@ const individualDocumentReviewWorkflow = createWorkflow({
                 ...initData.originalDocument,
                 id: `${initData.originalDocument.id}_part${index + 1}`,
                 name: `${initData.originalDocument.name} (part ${index + 1}) (split into parts because the full content did not fit into context)`,
-                originalName: initData.originalDocument.originalName || initData.originalDocument.name,
+                originalName:
+                  initData.originalDocument.originalName ||
+                  initData.originalDocument.name,
                 imageData: chunk,
+                totalChunks: splitCount,
+                chunkIndex: index,
               },
             })),
             retryCount: nextRetryCount,
@@ -221,6 +230,29 @@ const individualDocumentReviewWorkflow = createWorkflow({
         errorMessage: inputData.errorMessage,
       } as z.infer<typeof individualDocumentReviewWorkflowOutputSchema>;
     }
+
+    // 個別レビュー結果を保存
+    const reviewRepository = getReviewRepository();
+    for (const result of inputData.reviewResults || []) {
+      const targetDocument = inputData.reviewInput.find((input) => {
+        return result.documentId === input.document.id;
+      })?.document;
+      if (!targetDocument) {
+        logger.warn(
+          `Could not find target document for review result: documentId=${result.documentId}, checklistId=${result.checklistId}`,
+        );
+        continue;
+      }
+      await reviewRepository.createReviewLargedocumentResultCache({
+        reviewDocumentCacheId: inputData.originalDocument.cacheId!,
+        reviewChecklistId: result.checklistId,
+        comment: result.comment,
+        totalChunks: targetDocument.totalChunks ?? 1,
+        chunkIndex: targetDocument.chunkIndex ?? 0,
+        individualFileName: targetDocument.name,
+      });
+    }
+
     return {
       status: 'success' as stepStatus,
       documentsWithReviewResults: inputData.reviewInput.map((input) => {
@@ -251,9 +283,12 @@ export const largeDocumentReviewWorkflow = createWorkflow({
     return inputData.documents.map(
       (document) =>
         ({
+          reviewHistoryId: inputData.reviewHistoryId,
           document: {
             ...document,
             originalName: document.name, // 分割された場合に元の名前を保持するため
+            totalChunks: 1,
+            chunkIndex: 0,
           },
           checklists: inputData.checklists,
           additionalInstructions: inputData.additionalInstructions,
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
index 4416735c4..702e48796 100644
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
@@ -15,13 +15,17 @@ import { getMainLogger } from '@/main/lib/logger';
 import { createCombinedMessageFromExtractedDocument } from '../../lib';
 import { getChecklistsErrorMessage } from '../lib';
 import { extractedDocumentSchema } from '../schema';
+import { getReviewRepository } from '@/adapter/db';
 
 const logger = getMainLogger();
 
 // 個別ドキュメントレビューステップの入力スキーマ
 export const individualDocumentReviewStepInputSchema = z.object({
+  reviewHistoryId: z.string().describe('レビュー履歴ID'),
   document: extractedDocumentSchema.extend({
     originalName: z.string(),
+    totalChunks: z.number().optional(), // ドキュメント分割総数
+    chunkIndex: z.number().optional(), // 何番目のチャンクか（0から始まる）
   }),
   // チェックリスト
   checklists: z.array(
@@ -99,6 +103,7 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
       let attempt = 0;
       let targetChecklists = checklists;
       const allReviewResults: Array<{
+        documentId: string;
         checklistId: number;
         comment: string;
       }> = [];
@@ -191,7 +196,6 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
       // 全てのレビューが成功した場合
       return {
         status: 'success' as stepStatus,
-        documentId: document.id,
         reviewResults: allReviewResults,
         finishReason: 'success',
       };
diff --git a/src/mastra/workflows/sourceReview/executeReview/lib.ts b/src/mastra/workflows/sourceReview/executeReview/lib.ts
index b4bde036c..3f303042b 100644
--- a/src/mastra/workflows/sourceReview/executeReview/lib.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/lib.ts
@@ -1,7 +1,15 @@
-export const getChecklistErrorMesssage = (checklist: { id: number; content: string }, errorMessage: string) => {
+export const getChecklistErrorMesssage = (
+  checklist: { id: number; content: string },
+  errorMessage: string,
+) => {
   return `・${checklist.content}:${errorMessage}`;
 };
 
-export const getChecklistsErrorMessage = (checklists: { id: number; content: string }[], errorMessage: string) => {
-  return checklists.map((checklist) => getChecklistErrorMesssage(checklist, errorMessage)).join('\n');
-}
+export const getChecklistsErrorMessage = (
+  checklists: { id: number; content: string }[],
+  errorMessage: string,
+) => {
+  return checklists
+    .map((checklist) => getChecklistErrorMesssage(checklist, errorMessage))
+    .join('\n');
+};
diff --git a/src/mastra/workflows/sourceReview/executeReview/schema.ts b/src/mastra/workflows/sourceReview/executeReview/schema.ts
index 18b138b5d..853493160 100644
--- a/src/mastra/workflows/sourceReview/executeReview/schema.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/schema.ts
@@ -1,7 +1,7 @@
 import { z } from 'zod';
 
 export const uploadedFileSchema = z.object({
-  id: z.string(),
+  id: z.string(),  // テキスト抽出前、アップロード直後にのみ使用される一時的なID
   name: z.string(),
   path: z.string(),
   type: z.string(),
@@ -11,7 +11,8 @@ export const uploadedFileSchema = z.object({
 });
 
 export const extractedDocumentSchema = z.object({
-  id: z.string(),
+  id: z.string(),  // テキスト抽出後、レビュー実行wf内でのみ使用される一時的なID
+  cacheId: z.number().optional(),
   name: z.string(),
   path: z.string(),
   type: z.string(),
diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
index 33bc9e881..0b1e0746a 100644
--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
@@ -133,20 +133,13 @@ Please review the document against the above checklist items.`;
             messageParams: { detail: reason },
           });
         }
-        // レビュー結果をDBに保存（複数ファイルの情報を統合）
+        // レビュー結果をDBに保存
         if (reviewResult.object && Array.isArray(reviewResult.object)) {
-          const combinedFileIds = documents.map((f) => f.id).join('/');
-          const idsHash = createHash('md5')
-            .update(combinedFileIds)
-            .digest('hex');
-          const combinedFileNames = documents.map((f) => f.name).join('/');
           await reviewRepository.upsertReviewResult(
             reviewResult.object.map((result) => ({
               reviewChecklistId: result.checklistId,
               evaluation: result.evaluation as ReviewEvaluation,
               comment: result.comment,
-              fileId: idsHash,
-              fileName: combinedFileNames,
             })),
           );
         }
@@ -169,7 +162,10 @@ Please review the document against the above checklist items.`;
         // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
         return bail({
           status: 'failed' as stepStatus,
-          errorMessage: getChecklistsErrorMessage(targetChecklists, 'AIの出力にレビュー結果が含まれませんでした'),
+          errorMessage: getChecklistsErrorMessage(
+            targetChecklists,
+            'AIの出力にレビュー結果が含まれませんでした',
+          ),
         });
       }
       // 全てのレビューが成功した場合
diff --git a/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts b/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts
index 6a7cb652d..935475237 100644
--- a/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts
@@ -22,8 +22,7 @@ export const textExtractionOutputSchema = baseStepOutputSchema.extend({
 
 export const textExtractionStep = createStep({
   id: 'textExtractionStep',
-  description:
-    'ドキュメントからテキストを抽出し、ワークフロー用のIDを付与するステップ',
+  description: 'ドキュメントからテキストを抽出するステップ',
   inputSchema: textExtractionInputSchema,
   outputSchema: textExtractionOutputSchema,
   execute: async ({ inputData, abortSignal, bail }) => {
@@ -36,7 +35,7 @@ export const textExtractionStep = createStep({
     })();
 
     try {
-      const extractedDocuments = [];
+      const extractedDocuments: z.infer<typeof extractedDocumentSchema>[] = [];
 
       // 各ファイルからテキストを抽出
       for (const file of files) {
@@ -56,7 +55,7 @@ export const textExtractionStep = createStep({
             path: file.path,
             type: file.type,
             processMode: file.processMode,
-            imageMode: file.imageMode,
+            imageMode: file.imageMode as 'merged' | 'pages' | undefined,
             textContent: undefined,
             imageData: file.imageData,
           });
@@ -70,8 +69,8 @@ export const textExtractionStep = createStep({
             path: file.path,
             type: file.type,
             textContent: content,
-            processMode: file.processMode,
-            imageMode: file.imageMode,
+            processMode: file.processMode as 'text' | 'image' | undefined,
+            imageMode: file.imageMode as 'merged' | 'pages' | undefined,
             imageData: undefined,
           });
         }
diff --git a/src/mastra/workflows/sourceReview/lib.ts b/src/mastra/workflows/sourceReview/lib.ts
index 4eed29a81..9518de038 100644
--- a/src/mastra/workflows/sourceReview/lib.ts
+++ b/src/mastra/workflows/sourceReview/lib.ts
@@ -122,7 +122,9 @@ export async function createCombinedMessage(
       }
     } else {
       // テキスト抽出処理
-      const { content: fileContent } = await FileExtractor.extractText(file.path);
+      const { content: fileContent } = await FileExtractor.extractText(
+        file.path,
+      );
 
       // ファイルごとに個別のcontent要素として追加
       content.push({
@@ -181,7 +183,11 @@ export function createCombinedMessageFromExtractedDocument(
     if (document.imageData && document.imageData.length > 0) {
       // 各ページごとに個別の説明と画像を追加
       const totalPages = document.imageData.length;
-      for (let pageIndex = 0; pageIndex < document.imageData.length; pageIndex++) {
+      for (
+        let pageIndex = 0;
+        pageIndex < document.imageData.length;
+        pageIndex++
+      ) {
         const currentPage = pageIndex + 1;
 
         // ページ番号を含むテキスト説明を追加
diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
index 9af029444..aec3ea97f 100644
--- a/src/messages/ja/template.ts
+++ b/src/messages/ja/template.ts
@@ -33,4 +33,5 @@ export const template = {
   REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR: `CSVファイルからのチェックリスト抽出中に予期せぬエラーが発生しました`,
   AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
   AI_MESSAGE_TOO_LARGE: `AIへの入力データが大きすぎます。入力データを減らしてください。`,
+  REVIEW_DOCUMENT_CACHE_NOT_FOUND: `レビュー時にアップロードしたドキュメント情報が失われています。レビューを再実行してください`,
 } as const;
diff --git a/src/renderer/components/chat/MessageItem.tsx b/src/renderer/components/chat/MessageItem.tsx
index 4a8877c44..5345514e0 100644
--- a/src/renderer/components/chat/MessageItem.tsx
+++ b/src/renderer/components/chat/MessageItem.tsx
@@ -313,7 +313,8 @@ const renderPart = (
         <Accordion sx={{ width: '100%' }} key={ti.toolCallId}>
           <AccordionSummary expandIcon={<ExpandMoreIcon />}>
             <Box sx={{ display: 'flex', alignItems: 'center' }}>
-              {ti.toolName === 'documentQueryTool' ? (
+              {ti.toolName === 'documentQueryTool' ||
+              ti.toolCallId.startsWith('reviewChatResearchDocument-') ? (
                 <SearchIcon sx={{ mr: 1 }} />
               ) : (
                 <SmartToyOutlinedIcon sx={{ mr: 1 }} />
@@ -387,6 +388,7 @@ interface MessageProps {
   onEditStart: (messageId: string) => void;
   onEditContentChange: (content: string) => void;
   onEditCancel: () => void;
+  disableEdit?: boolean;
 }
 
 const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
@@ -400,6 +402,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
       onEditStart,
       onEditCancel,
       onEditContentChange,
+      disableEdit = false,
     },
     ref,
   ) => {
@@ -420,7 +423,7 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
               maxWidth: isUser && !isEditing ? '70%' : '100%',
               width: isUser && !isEditing ? undefined : '100%',
               textAlign: 'left',
-              '&:hover .editBtn': { opacity: 1 },
+              ...(!disableEdit && { '&:hover .editBtn': { opacity: 1 } }),
             }}
           >
             <Paper
@@ -432,28 +435,31 @@ const MessageItem = forwardRef<HTMLDivElement, MessageProps>(
                 position: 'relative',
               }}
             >
-              {isUser && !message.experimental_attachments && !isEditing && (
-                <IconButton
-                  className="editBtn"
-                  size="small"
-                  onClick={() => {
-                    onEditStart?.(message.id);
-                    onEditContentChange(message.content ?? '');
-                  }}
-                  sx={{
-                    position: 'absolute',
-                    right: -36,
-                    top: '50%',
-                    transform: 'translateY(-50%)',
-                    opacity: 0,
-                    transition: 'opacity 0.2s',
-                    bgcolor: 'background.paper',
-                  }}
-                  data-testid={`edit-message-button-${message.id}`}
-                >
-                  <EditIcon fontSize="small" />
-                </IconButton>
-              )}
+              {isUser &&
+                !message.experimental_attachments &&
+                !isEditing &&
+                !disableEdit && (
+                  <IconButton
+                    className="editBtn"
+                    size="small"
+                    onClick={() => {
+                      onEditStart?.(message.id);
+                      onEditContentChange(message.content ?? '');
+                    }}
+                    sx={{
+                      position: 'absolute',
+                      right: -36,
+                      top: '50%',
+                      transform: 'translateY(-50%)',
+                      opacity: 0,
+                      transition: 'opacity 0.2s',
+                      bgcolor: 'background.paper',
+                    }}
+                    data-testid={`edit-message-button-${message.id}`}
+                  >
+                    <EditIcon fontSize="small" />
+                  </IconButton>
+                )}
               {/* eslint-disable-next-line */}
               {isEditing && !message.experimental_attachments && isUser ? (
                 <Box sx={{ p: 1, width: '100%' }}>
diff --git a/src/renderer/components/chat/MessageList.tsx b/src/renderer/components/chat/MessageList.tsx
index e8325677a..321206563 100644
--- a/src/renderer/components/chat/MessageList.tsx
+++ b/src/renderer/components/chat/MessageList.tsx
@@ -14,6 +14,8 @@ interface MessageListProps {
   onEditSubmit: () => void;
   onEditContentChange: (ontent: string) => void;
   onEditCancel: () => void;
+  loadingMessage?: string;
+  disableEdit?: boolean;
 }
 
 const MessageList: React.FC<MessageListProps> = ({
@@ -27,6 +29,8 @@ const MessageList: React.FC<MessageListProps> = ({
   onEditSubmit,
   onEditContentChange,
   onEditCancel,
+  loadingMessage = 'AIKATA作業中…',
+  disableEdit = false,
 }) => {
   const bottomRef = useRef<HTMLDivElement>(null);
 
@@ -64,12 +68,13 @@ const MessageList: React.FC<MessageListProps> = ({
               onEditSubmit={onEditSubmit}
               onEditContentChange={onEditContentChange}
               onEditCancel={onEditCancel}
+              disableEdit={disableEdit}
             />
           </Box>
         );
       })}
 
-      {status === 'streaming' && (
+      {(status === 'streaming' || status === 'submitted') && (
         <Box
           sx={{
             display: 'flex',
@@ -80,7 +85,7 @@ const MessageList: React.FC<MessageListProps> = ({
         >
           <CircularProgress size={24} />
           <Box component="span" sx={{ ml: 1 }}>
-            AIKATA作業中…
+            {loadingMessage}
           </Box>
         </Box>
       )}
diff --git a/src/renderer/components/common/SettingsModal.tsx b/src/renderer/components/common/SettingsModal.tsx
index c5b8d8a92..335ef9d7a 100644
--- a/src/renderer/components/common/SettingsModal.tsx
+++ b/src/renderer/components/common/SettingsModal.tsx
@@ -10,7 +10,7 @@ import {
 } from '@mui/material';
 import Modal from './Modal';
 import useSettingsStore from '../../hooks/useSettings';
-import { StoreSchema as Settings } from '../../../main/store';
+import { StoreSchema as Settings } from '../../../adapter/db/electron-store/store';
 
 interface SettingsModalProps {
   open: boolean;
diff --git a/src/renderer/components/review/ChecklistMentionInput.tsx b/src/renderer/components/review/ChecklistMentionInput.tsx
new file mode 100644
index 000000000..978c8d7be
--- /dev/null
+++ b/src/renderer/components/review/ChecklistMentionInput.tsx
@@ -0,0 +1,364 @@
+import React, { useState, useCallback, useMemo, useRef } from 'react';
+import {
+  Box,
+  IconButton,
+  InputAdornment,
+  Paper,
+  TextField,
+  Chip,
+  Popover,
+  List,
+  ListItem,
+  ListItemButton,
+  ListItemText,
+} from '@mui/material';
+import {
+  Send as SendIcon,
+  StopCircleOutlined as StopIcon,
+} from '@mui/icons-material';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+
+/* ---------- 型定義 ---------- */
+
+export interface ChecklistOption {
+  id: number;
+  content: string;
+}
+
+interface ChecklistMentionInputProps {
+  handleSubmit: (e: React.FormEvent) => void;
+  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
+  message: string;
+  disabled?: boolean;
+  placeholder?: string;
+  isStreaming?: boolean;
+  onStop?: () => void;
+  checklists: ChecklistOption[];
+  selectedChecklistIds: number[];
+  onChecklistSelect: (ids: number[]) => void;
+}
+
+const ChecklistMentionInput: React.FC<ChecklistMentionInputProps> = ({
+  handleSubmit,
+  handleInputChange,
+  message,
+  disabled = false,
+  placeholder = 'メッセージを入力...',
+  isStreaming = false,
+  onStop,
+  checklists,
+  selectedChecklistIds,
+  onChecklistSelect,
+}) => {
+  const [isComposing, setIsComposing] = useState(false);
+  const [showMentionMenu, setShowMentionMenu] = useState(false);
+  const [mentionSearchText, setMentionSearchText] = useState('');
+  const inputRef = useRef<HTMLDivElement>(null);
+  const addAlert = useAlertStore((state) => state.addAlert);
+
+  /* ---------- チェックリストオプション ---------- */
+  const checklistOptions = useMemo(() => {
+    return checklists.map((cl) => ({ id: cl.id, content: cl.content }));
+  }, [checklists]);
+
+  /* ---------- フィルタリングされたチェックリストオプション ---------- */
+  const filteredOptions = useMemo(() => {
+    if (!mentionSearchText) return checklistOptions;
+    const lowerSearch = mentionSearchText.toLowerCase();
+    return checklistOptions.filter((option) =>
+      option.content.toLowerCase().includes(lowerSearch),
+    );
+  }, [checklistOptions, mentionSearchText]);
+
+  /* ---------- @メンション検出 ---------- */
+  const detectMention = useCallback((text: string) => {
+    const atIndex = text.lastIndexOf('@');
+    if (atIndex === -1) return null;
+
+    // @が行の先頭にあるかチェック
+    if (atIndex > 0) {
+      const beforeAt = text[atIndex - 1];
+      // @の直前が改行でない場合はnullを返す
+      if (beforeAt !== '\n') return null;
+    }
+
+    // @以降の文字列を取得
+    const afterAt = text.slice(atIndex + 1);
+    // 空白や改行があれば@メンション終了とみなす
+    if (/\s/.test(afterAt)) return null;
+
+    return { atIndex, searchText: afterAt };
+  }, []);
+
+  /* ---------- 入力変更ハンドラ ---------- */
+  const handleChange = useCallback(
+    (e: React.ChangeEvent<HTMLInputElement>) => {
+      const newValue = e.target.value;
+      handleInputChange(e);
+
+      // @メンション検出
+      const mention = detectMention(newValue);
+      if (mention) {
+        setShowMentionMenu(true);
+        setMentionSearchText(mention.searchText);
+      } else {
+        setShowMentionMenu(false);
+        setMentionSearchText('');
+      }
+    },
+    [handleInputChange, detectMention],
+  );
+
+  /* ---------- チェックリスト選択ハンドラ ---------- */
+  const handleChecklistSelect = useCallback(
+    (checklist: ChecklistOption | null) => {
+      if (!checklist) return;
+
+      const mention = detectMention(message);
+      if (!mention) return;
+
+      // @検索文字列を削除
+      const beforeAt = message.slice(0, mention.atIndex);
+      const afterMention = message.slice(
+        mention.atIndex + 1 + mention.searchText.length,
+      );
+      const newMessage = beforeAt + afterMention;
+
+      // 入力値を更新
+      const syntheticEvent = {
+        target: { value: newMessage },
+      } as React.ChangeEvent<HTMLInputElement>;
+      handleInputChange(syntheticEvent);
+
+      // 選択リストに追加（重複チェック）
+      if (!selectedChecklistIds.includes(checklist.id)) {
+        onChecklistSelect([...selectedChecklistIds, checklist.id]);
+      }
+
+      // メニューを閉じる
+      setShowMentionMenu(false);
+      setMentionSearchText('');
+    },
+    [
+      message,
+      detectMention,
+      handleInputChange,
+      selectedChecklistIds,
+      onChecklistSelect,
+    ],
+  );
+
+  /* ---------- 送信ハンドラ（バリデーション付き） ---------- */
+  const handleSubmitWithValidation = useCallback(
+    (e: React.FormEvent) => {
+      e.preventDefault();
+
+      // チェックリストが一つも選択されていない場合は警告
+      if (selectedChecklistIds.length === 0) {
+        addAlert({
+          message: '@でチェックリストを一つ以上選択してください',
+          severity: 'warning',
+        });
+        return;
+      }
+      handleSubmit(e);
+    },
+    [selectedChecklistIds, handleSubmit, addAlert],
+  );
+
+  /* ---------- Enter キー送信（Shift+Enter で改行） ---------- */
+  const handleKeyDown = (e: React.KeyboardEvent) => {
+    if (e.key === 'Enter' && !isComposing) {
+      // @メンションメニューが表示されている場合は完全一致をチェック
+      if (showMentionMenu && mentionSearchText) {
+        const exactMatch = filteredOptions.find(
+          (option) =>
+            option.content.toLowerCase() === mentionSearchText.toLowerCase(),
+        );
+        if (exactMatch) {
+          // 完全一致した場合は自動選択
+          e.preventDefault();
+          handleChecklistSelect(exactMatch);
+          return;
+        }
+      }
+
+      // Shift+Enterの場合は改行を許可（preventDefaultしない）
+      if (!e.shiftKey) {
+        e.preventDefault();
+        handleSubmitWithValidation(e);
+      }
+    }
+  };
+
+  /* ---------- IME 制御 ---------- */
+  const handleCompositionStart = () => setIsComposing(true);
+  const handleCompositionEnd = () => setIsComposing(false);
+
+  /* ============================================================= */
+
+  return (
+    <Box sx={{ p: 2, width: '100%', mx: 'auto' }}>
+      {/* 選択中のチェックリスト表示 */}
+      {selectedChecklistIds.length > 0 && (
+        <Box
+          sx={{
+            mb: 1,
+            display: 'flex',
+            flexDirection: 'column',
+            alignItems: 'flex-start',
+            gap: 0.5,
+            overflow: 'auto',
+            maxHeight: 100,
+            pb: 0.5,
+          }}
+        >
+          {selectedChecklistIds.map((id) => {
+            const checklist = checklists.find((cl) => cl.id === id);
+            if (!checklist) return null;
+            return (
+              <Chip
+                key={id}
+                label={checklist.content}
+                size="small"
+                color="primary"
+                variant="outlined"
+                onDelete={() => {
+                  onChecklistSelect(
+                    selectedChecklistIds.filter((cid) => cid !== id),
+                  );
+                }}
+              />
+            );
+          })}
+        </Box>
+      )}
+
+      {/* 入力欄 ----------------------------------------------------------- */}
+      <Paper
+        component="form"
+        onSubmit={handleSubmitWithValidation}
+        elevation={3}
+        sx={{
+          p: '2px 4px',
+          display: 'flex',
+          alignItems: 'center',
+          borderRadius: 2,
+          position: 'relative',
+        }}
+      >
+        {/* メインのテキストフィールド */}
+        <TextField
+          ref={inputRef}
+          fullWidth
+          multiline
+          minRows={1}
+          maxRows={6}
+          placeholder={placeholder}
+          variant="outlined"
+          value={message}
+          onChange={handleChange}
+          onKeyDown={handleKeyDown}
+          onCompositionStart={handleCompositionStart}
+          onCompositionEnd={handleCompositionEnd}
+          disabled={disabled}
+          slotProps={{
+            input: {
+              sx: {
+                p: 1,
+                '& fieldset': { border: 'none' },
+              },
+              endAdornment: (
+                <InputAdornment position="end">
+                  {isStreaming ? (
+                    <IconButton
+                      color="primary"
+                      onClick={onStop}
+                      data-testid="review-chat-stop-button"
+                    >
+                      <StopIcon />
+                    </IconButton>
+                  ) : (
+                    <IconButton
+                      color="primary"
+                      type="submit"
+                      disabled={disabled || !message.trim()}
+                      data-testid="review-chat-send-button"
+                    >
+                      <SendIcon />
+                    </IconButton>
+                  )}
+                </InputAdornment>
+              ),
+            },
+          }}
+        />
+
+        {/* @メンション選択メニュー */}
+        <Popover
+          open={showMentionMenu}
+          anchorEl={inputRef.current}
+          onClose={() => {
+            setShowMentionMenu(false);
+            setMentionSearchText('');
+          }}
+          anchorOrigin={{
+            vertical: 'top',
+            horizontal: 'left',
+          }}
+          transformOrigin={{
+            vertical: 'bottom',
+            horizontal: 'left',
+          }}
+          disableAutoFocus
+          disableEnforceFocus
+          disableRestoreFocus
+          slotProps={{
+            paper: {
+              sx: {
+                maxHeight: 200,
+                width: inputRef.current?.offsetWidth || 300,
+                overflow: 'auto',
+              },
+            },
+          }}
+        >
+          <List dense>
+            {filteredOptions.length > 0 ? (
+              filteredOptions.map((option) => (
+                <ListItem key={option.id} disablePadding>
+                  <ListItemButton
+                    onClick={() => handleChecklistSelect(option)}
+                    selected={selectedChecklistIds.includes(option.id)}
+                  >
+                    <ListItemText
+                      primary={`@${option.content}`}
+                      primaryTypographyProps={{
+                        sx: {
+                          fontWeight:
+                            option.content.toLowerCase() ===
+                            mentionSearchText.toLowerCase()
+                              ? 'bold'
+                              : 'normal',
+                        },
+                      }}
+                    />
+                  </ListItemButton>
+                </ListItem>
+              ))
+            ) : (
+              <ListItem>
+                <ListItemText
+                  primary="該当するチェックリストがありません"
+                  sx={{ color: 'text.secondary', fontStyle: 'italic' }}
+                />
+              </ListItem>
+            )}
+          </List>
+        </Popover>
+      </Paper>
+    </Box>
+  );
+};
+
+export default ChecklistMentionInput;
diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
index 2d2322987..db5d2f479 100644
--- a/src/renderer/components/review/ReviewArea.tsx
+++ b/src/renderer/components/review/ReviewArea.tsx
@@ -6,11 +6,11 @@ import {
   Stack,
   Typography,
   LinearProgress,
-  Alert,
 } from '@mui/material';
 import CheckBoxIcon from '@mui/icons-material/CheckBox';
 import RateReviewIcon from '@mui/icons-material/RateReview';
 import StopIcon from '@mui/icons-material/Stop';
+import ChatIcon from '@mui/icons-material/Chat';
 import {
   ReviewChecklistEdit,
   ReviewChecklistResult,
@@ -25,6 +25,7 @@ import {
 import { ReviewAreaProps } from './types';
 import ReviewChecklistSection from './ReviewChecklistSection';
 import ReviewSourceModal from './ReviewSourceModal';
+import ReviewChatPanel from './ReviewChatPanel';
 import { ReviewApi } from '../../service/reviewApi';
 import { useAlertStore } from '../../stores/alertStore';
 import { getSafeErrorMessage } from '../../lib/error';
@@ -47,6 +48,9 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   const [checklistResults, setChecklistResults] = useState<
     ReviewChecklistResult[]
   >([]);
+  const [targetDocumentName, setTargetDocumentName] = useState<string | null>(
+    null,
+  );
   // チェックリスト更新処理中であるかどうか
   const [isSaving, setIsSaving] = useState(false);
   const [isExtracting, setIsExtracting] = useState(false);
@@ -58,6 +62,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   const [evaluationSettings, setEvaluationSettings] =
     useState<CustomEvaluationSettings>(defaultEvaluationSettings);
 
+  // チャット関連の状態管理
+  const [chatPanelOpen, setChatPanelOpen] = useState(false);
+  const [chatPanelWidth, setChatPanelWidth] = useState(500);
+  const [isResizing, setIsResizing] = useState(false);
+
   const addAlert = useAlertStore((state) => state.addAlert);
 
   // イベント購読の解除関数を管理
@@ -73,6 +82,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
       { throwError: true, showAlert: true },
     );
     setChecklistResults(result?.checklistResults || []);
+    setTargetDocumentName(result?.targetDocumentName || null);
   }, [selectedReviewHistoryId]);
 
   // チェックリスト抽出完了の共通処理ハンドラー
@@ -180,6 +190,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
     setAdditionalInstructions('');
     setCommentFormat(defaultCommentFormat);
     setEvaluationSettings(defaultEvaluationSettings);
+    setChatPanelOpen(false);
 
     // 初期データ取得（エラーが発生しなくなるまでポーリング）
     const loadInitialData = async () => {
@@ -526,6 +537,38 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
     setIsSaving(false);
   };
 
+  // リサイズハンドラ
+  const handleMouseDown = (e: React.MouseEvent) => {
+    setIsResizing(true);
+    e.preventDefault();
+  };
+
+  useEffect(() => {
+    if (!isResizing) return;
+
+    const handleMouseMove = (e: MouseEvent) => {
+      // 画面右端からのマウス位置を計算
+      const newWidth = window.innerWidth - e.clientX;
+      // 最小幅350px、最大幅は画面の65%まで
+      const minWidth = 350;
+      const maxWidth = window.innerWidth * 0.65;
+      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
+      setChatPanelWidth(clampedWidth);
+    };
+
+    const handleMouseUp = () => {
+      setIsResizing(false);
+    };
+
+    document.addEventListener('mousemove', handleMouseMove);
+    document.addEventListener('mouseup', handleMouseUp);
+
+    return () => {
+      document.removeEventListener('mousemove', handleMouseMove);
+      document.removeEventListener('mouseup', handleMouseUp);
+    };
+  }, [isResizing]);
+
   return (
     <Box
       sx={{
@@ -548,15 +591,10 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
           {(isExtracting || isReviewing) && (
             <Box sx={{ mb: 2 }}>
               <LinearProgress />
-              {/* <Alert severity="info" sx={{ mt: 1 }}>
-                {isExtracting
-                  ? 'チェックリスト抽出実行中...'
-                  : 'レビュー実行中...'}
-              </Alert> */}
             </Box>
           )}
 
-          {/* ヘッダー部分 */}
+          {/* ヘッダー部分 - 主要アクションボタン */}
           <Stack
             direction="row"
             justifyContent="space-between"
@@ -600,25 +638,85 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
               >
                 {isReviewing ? 'キャンセル' : 'レビュー実行'}
               </Button>
+              <Button
+                variant="contained"
+                color="primary"
+                startIcon={<ChatIcon />}
+                onClick={() => setChatPanelOpen(true)}
+                disabled={
+                  !selectedReviewHistoryId ||
+                  isExtracting ||
+                  isReviewing ||
+                  checklistResults.filter((cl) => cl.sourceEvaluation?.comment)
+                    .length === 0
+                }
+              >
+                質問
+              </Button>
             </Stack>
           </Stack>
 
-          {/* メインコンテンツ */}
-          <Paper
+          {/* メインコンテンツ - Split View */}
+          <Box
             sx={{
-              p: 2,
-              flex: 1,
               display: 'flex',
-              flexDirection: 'column',
+              flexDirection: 'row',
+              flex: 1,
               minHeight: 0,
+              gap: 0,
             }}
           >
-            <ReviewChecklistSection
-              checklistResults={checklistResults}
-              isLoading={isExtracting || isReviewing}
-              onSave={handleSaveChecklist}
-            />
-          </Paper>
+            {/* レビュー結果エリア */}
+            <Paper
+              sx={{
+                p: 2,
+                flex: 1,
+                display: 'flex',
+                flexDirection: 'column',
+                minHeight: 0,
+                minWidth: chatPanelOpen ? 400 : 0,
+                overflow: 'hidden',
+              }}
+            >
+              <ReviewChecklistSection
+                checklistResults={checklistResults}
+                isLoading={isExtracting || isReviewing}
+                onSave={handleSaveChecklist}
+                targetDocumentName={targetDocumentName}
+              />
+            </Paper>
+
+            {/* リサイズハンドル */}
+            {chatPanelOpen && (
+              <Box
+                onMouseDown={handleMouseDown}
+                sx={{
+                  width: '6px',
+                  cursor: 'col-resize',
+                  bgcolor: 'divider',
+                  transition: 'background-color 0.2s',
+                  flexShrink: 0,
+                  userSelect: 'none',
+                }}
+              />
+            )}
+
+            {/* チャットパネル */}
+            {selectedReviewHistoryId && (
+              <ReviewChatPanel
+                open={chatPanelOpen}
+                onClose={() => setChatPanelOpen(false)}
+                reviewHistoryId={selectedReviewHistoryId}
+                checklists={checklistResults
+                  .filter((cl) => cl.sourceEvaluation?.comment)
+                  .map((cl) => ({
+                    id: cl.id,
+                    content: cl.content,
+                  }))}
+                width={chatPanelWidth}
+              />
+            )}
+          </Box>
 
           {/* モーダル */}
           <ReviewSourceModal
diff --git a/src/renderer/components/review/ReviewChatPanel.tsx b/src/renderer/components/review/ReviewChatPanel.tsx
new file mode 100644
index 000000000..525cfea7b
--- /dev/null
+++ b/src/renderer/components/review/ReviewChatPanel.tsx
@@ -0,0 +1,265 @@
+import React, { useState, useEffect, useCallback } from 'react';
+import { useChat } from '@ai-sdk/react';
+import { Box, Divider, IconButton } from '@mui/material';
+import CloseIcon from '@mui/icons-material/Close';
+import { v4 as uuid } from 'uuid';
+import { ChatMessage } from '@/types';
+import { IpcRequestPayload, IpcChannels } from '@/types/ipc';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+import { getSafeErrorMessage } from '@/renderer/lib/error';
+import MessageList from '../chat/MessageList';
+import ChecklistMentionInput, {
+  ChecklistOption,
+} from './ChecklistMentionInput';
+import { ReviewChatApi } from '../../service/reviewChatApi';
+
+interface ReviewChatPanelProps {
+  open: boolean;
+  onClose: () => void;
+  reviewHistoryId: string;
+  checklists: ChecklistOption[];
+  width?: number;
+}
+
+// customFetch関数 - ChatArea.tsxを参考に実装
+const customFetch: typeof fetch = async (input, init) => {
+  if (typeof input === 'string' && input === '/api/review-chat') {
+    let unsubscribe: () => void;
+    const encoder = new TextEncoder();
+    const reviewChatApi = ReviewChatApi.getInstance();
+
+    const stream = new ReadableStream({
+      start(controller) {
+        unsubscribe = reviewChatApi.streamResponse({
+          onMessage(raw) {
+            controller.enqueue(encoder.encode(raw));
+          },
+          onDone() {
+            controller.close();
+          },
+          onError(err) {
+            controller.error(err);
+          },
+        });
+
+        const { reviewHistoryId, checklistIds, question } = JSON.parse(
+          init!.body as string,
+        ) as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
+
+        init?.signal?.addEventListener('abort', () => {
+          reviewChatApi.abortChat(reviewHistoryId, {
+            showAlert: false,
+            throwError: true,
+          });
+          unsubscribe();
+          controller.close();
+        });
+
+        reviewChatApi.sendMessage(reviewHistoryId, checklistIds, question, {
+          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
+          showAlert: false,
+          throwError: false,
+        });
+      },
+      cancel() {
+        unsubscribe();
+      },
+    });
+
+    return new Response(stream, {
+      headers: {
+        // SSE＋Data Stream Protocol ヘッダ
+        'Content-Type': 'text/event-stream; charset=utf-8',
+        'x-vercel-ai-data-stream': 'v1',
+      },
+    });
+  }
+
+  return fetch(input, init);
+};
+
+// プレースホルダーテキストを取得する関数
+const getPlaceholderText = (status: string): string => {
+  if (status === 'submitted') return 'メッセージ送信中…';
+  return '@でチェックリストを選択して質問してください';
+};
+
+const ReviewChatPanel: React.FC<ReviewChatPanelProps> = ({
+  open,
+  onClose,
+  reviewHistoryId,
+  checklists,
+  width = 500,
+}) => {
+  const [input, setInput] = useState<string>('');
+  const [selectedChecklistIds, setSelectedChecklistIds] = useState<number[]>(
+    [],
+  );
+  const addAlert = useAlertStore((state) => state.addAlert);
+
+  const { messages, setMessages, reload, status, error, stop } = useChat({
+    id: reviewHistoryId,
+    api: '/api/review-chat',
+    fetch: customFetch,
+    experimental_throttle: 75,
+    experimental_prepareRequestBody: (request) => {
+      // Ensure messages array is not empty and get the last message
+      const lastMessage =
+        request.messages.length > 0
+          ? request.messages[request.messages.length - 1]
+          : null;
+      if (!lastMessage) {
+        throw new Error('送信メッセージの取得に失敗しました');
+      }
+
+      // Return the structured body for API route
+      return {
+        reviewHistoryId,
+        checklistIds: selectedChecklistIds,
+        question: lastMessage.content,
+      } as IpcRequestPayload<typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE>;
+    },
+    onError(err) {
+      console.error('useChat error:', err);
+    },
+  });
+
+  // useChatのエラーをアラートとして表示
+  useEffect(() => {
+    if (error) {
+      addAlert({
+        message: getSafeErrorMessage(error),
+        severity: 'error',
+      });
+    }
+  }, [error, addAlert]);
+
+  // レビューID変更時にチャット内容を初期化
+  useEffect(() => {
+    setMessages([]);
+    setInput('');
+    setSelectedChecklistIds([]);
+  }, [reviewHistoryId, setMessages]);
+
+  /* ---------- メッセージ送信処理 ---------- */
+  const handleInputChange = useCallback(
+    (e: React.ChangeEvent<HTMLInputElement>) => {
+      setInput(e.target.value);
+    },
+    [],
+  );
+
+  const handleSubmit = useCallback(
+    async (e: React.FormEvent) => {
+      e.preventDefault();
+      if (!input.trim()) return;
+
+      // チェックリスト未選択の場合は警告
+      if (selectedChecklistIds.length === 0) {
+        addAlert({
+          message: '@でチェックリストを選択してください',
+          severity: 'warning',
+        });
+        return;
+      }
+
+      // 選択されたチェックリストの内容を取得してフォーマット
+      const selectedChecklistContents = selectedChecklistIds
+        .map((id) => {
+          const checklist = checklists.find((cl) => cl.id === id);
+          return checklist ? `@${checklist.content}` : null;
+        })
+        .filter((content): content is string => content !== null);
+
+      // チェックリスト部分 + 空行 + 本文の形式でメッセージを構築
+      const formattedContent =
+        selectedChecklistContents.length > 0
+          ? `${selectedChecklistContents.join('\n')}\n\n${input}`
+          : input;
+
+      const newMessage: ChatMessage = {
+        id: uuid(),
+        role: 'user',
+        content: formattedContent,
+        parts: [
+          {
+            type: 'text',
+            text: formattedContent,
+          },
+        ],
+      };
+
+      setInput('');
+      setMessages((prev) => [...prev, newMessage]);
+      reload();
+    },
+    [input, selectedChecklistIds, checklists, addAlert, setMessages, reload],
+  );
+
+  if (!open) return null;
+
+  return (
+    <Box
+      sx={{
+        width,
+        minWidth: 300,
+        height: '100%',
+        display: 'flex',
+        flexDirection: 'column',
+        borderLeft: 1,
+        borderColor: 'divider',
+        bgcolor: 'background.paper',
+        position: 'relative',
+      }}
+    >
+      {/* ヘッダー（閉じるボタン） */}
+      <Box
+        sx={{
+          display: 'flex',
+          justifyContent: 'flex-end',
+          p: 1,
+          borderBottom: 1,
+          borderColor: 'divider',
+        }}
+      >
+        <IconButton size="small" onClick={onClose}>
+          <CloseIcon />
+        </IconButton>
+      </Box>
+
+      {/* メッセージリスト */}
+      <MessageList
+        messages={messages}
+        loading={false}
+        status={status}
+        editContent=""
+        disabled={status === 'submitted' || status === 'streaming'}
+        editingMessageId=""
+        onEditStart={() => {}}
+        onEditContentChange={() => {}}
+        onEditSubmit={async () => {}}
+        onEditCancel={() => {}}
+        loadingMessage="ドキュメントの調査中..."
+        disableEdit
+      />
+
+      <Divider />
+
+      {/* メッセージ入力 */}
+      <ChecklistMentionInput
+        handleSubmit={handleSubmit}
+        handleInputChange={handleInputChange}
+        message={input}
+        disabled={status === 'submitted' || status === 'streaming'}
+        placeholder={getPlaceholderText(status)}
+        isStreaming={status === 'streaming'}
+        onStop={stop}
+        checklists={checklists}
+        selectedChecklistIds={selectedChecklistIds}
+        onChecklistSelect={setSelectedChecklistIds}
+      />
+    </Box>
+  );
+};
+
+export default ReviewChatPanel;
diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
index d37a5b5c9..7b00c802b 100644
--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++ b/src/renderer/components/review/ReviewChecklistSection.tsx
@@ -58,6 +58,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
   checklistResults,
   isLoading,
   onSave,
+  targetDocumentName,
 }) => {
   // --- ステート ---
   const [editingId, setEditingId] = useState<number | null>(null);
@@ -94,11 +95,11 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
     setIsAddingNew(false);
     setNewContent('');
   };
-  const handleSort = (fileId: string) => {
-    if (sortBy === fileId) {
+  const handleSort = () => {
+    if (sortBy === 'evaluation') {
       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
     } else {
-      setSortBy(fileId);
+      setSortBy('evaluation');
       setSortDirection('desc');
     }
   };
@@ -110,35 +111,15 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
     downloadCSV(csvContent, filename);
   };
 
-  // --- ユニークファイル抽出 ---
-  const uniqueSources = useMemo(() => {
-    const map = new Map<string, { id: string; fileName: string }>();
-    checklistResults.forEach((cl) => {
-      cl.sourceEvaluations?.forEach((ev) => {
-        if (!map.has(ev.fileId)) {
-          map.set(ev.fileId, {
-            id: ev.fileId,
-            fileName: ev.fileName,
-          });
-        }
-      });
-    });
-    return Array.from(map.values());
-  }, [checklistResults]);
-
   // --- ソート ---
   // 動的評価項目対応のため、文字列順ソートを使用
   const sortedResults = useMemo(() => {
-    if (sortBy == null) return checklistResults;
+    if (sortBy !== 'evaluation') return checklistResults;
 
     return [...checklistResults].sort((a, b) => {
-      // 対象ファイルの評価を取得。未評価は空文字扱い
-      const aEv =
-        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
-        '';
-      const bEv =
-        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
-        '';
+      // 評価を取得。未評価は空文字扱い
+      const aEv = a.sourceEvaluation?.evaluation ?? '';
+      const bEv = b.sourceEvaluation?.evaluation ?? '';
 
       // 文字列順で比較
       if (sortDirection === 'desc') {
@@ -169,41 +150,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
         >
           チェックリスト
         </TableCell>
-        {uniqueSources.map((src) => (
-          <TableCell
-            key={src.id}
-            align="center"
-            sx={{
-              minWidth: 200,
-            }}
+        <TableCell
+          align="center"
+          sx={{
+            minWidth: 300,
+          }}
+        >
+          <TableSortLabel
+            active={sortBy === 'evaluation'}
+            direction={sortBy === 'evaluation' ? sortDirection : 'desc'}
+            onClick={() => handleSort()}
           >
-            <Box
-              sx={{
-                maxHeight: '4.5em',
-                overflow: 'hidden',
-                overflowY: 'auto',
-                lineHeight: '1.5em',
-                whiteSpace: 'normal',
-                wordBreak: 'break-all',
-                '&:hover': {
-                  overflowY: 'auto',
-                },
-              }}
-            >
-              <Tooltip title={src.fileName} placement="top">
-                <div>
-                  <TableSortLabel
-                    active={sortBy === src.id}
-                    direction={sortBy === src.id ? sortDirection : 'desc'}
-                    onClick={() => handleSort(src.id)}
-                  >
-                    {src.fileName}
-                  </TableSortLabel>
-                </div>
+            {targetDocumentName ? (
+              <Tooltip title={targetDocumentName} placement="top">
+                <Box
+                  component="span"
+                  sx={{
+                    maxHeight: '4.5em',
+                    overflow: 'hidden',
+                    textOverflow: 'ellipsis',
+                    wordBreak: 'break-all',
+                    whiteSpace: 'normal',
+                  }}
+                >
+                  レビュー結果 ({targetDocumentName})
+                </Box>
               </Tooltip>
-            </Box>
-          </TableCell>
-        ))}
+            ) : (
+              'レビュー結果'
+            )}
+          </TableSortLabel>
+        </TableCell>
         <TableCell align="center" sx={{ minWidth: 120 }}>
           操作
         </TableCell>
@@ -231,44 +208,37 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
           )}
         </Box>
       </TableCell>
-      {/* 評価列 */}
-      {uniqueSources.map((src) => {
-        const ev = checklist.sourceEvaluations?.find(
-          (x) => x.fileId === src.id,
-        );
-        return (
-          <TableCell
-            key={src.id}
-            align="center"
-            sx={{ p: 1, verticalAlign: 'top' }}
-          >
-            <Box>
-              {ev?.evaluation && (
-                <Stack spacing={1} alignItems="center">
-                  <Typography
-                    variant="body2"
-                    sx={{
-                      color: getEvaluationColor(ev.evaluation),
-                      fontWeight: 'bold',
-                      textDecoration: 'underline',
-                      textDecorationColor: getEvaluationColor(ev.evaluation),
-                      textDecorationThickness: '2px',
-                      textUnderlineOffset: '3px',
-                    }}
-                  >
-                    {ev.evaluation}
-                  </Typography>
-                  {ev.comment && (
-                    <Typography variant="body2" sx={commentBoxSx}>
-                      {ev.comment}
-                    </Typography>
-                  )}
-                </Stack>
+      {/* レビュー結果列 */}
+      <TableCell align="center" sx={{ p: 1, verticalAlign: 'top' }}>
+        <Box>
+          {checklist.sourceEvaluation?.evaluation && (
+            <Stack spacing={1} alignItems="center">
+              <Typography
+                variant="body2"
+                sx={{
+                  color: getEvaluationColor(
+                    checklist.sourceEvaluation.evaluation,
+                  ),
+                  fontWeight: 'bold',
+                  textDecoration: 'underline',
+                  textDecorationColor: getEvaluationColor(
+                    checklist.sourceEvaluation.evaluation,
+                  ),
+                  textDecorationThickness: '2px',
+                  textUnderlineOffset: '3px',
+                }}
+              >
+                {checklist.sourceEvaluation.evaluation}
+              </Typography>
+              {checklist.sourceEvaluation.comment && (
+                <Typography variant="body2" sx={commentBoxSx}>
+                  {checklist.sourceEvaluation.comment}
+                </Typography>
               )}
-            </Box>
-          </TableCell>
-        );
-      })}
+            </Stack>
+          )}
+        </Box>
+      </TableCell>
       {/* 操作 */}
       <TableCell align="center" sx={{ p: 1 }}>
         <Stack direction="row" spacing={1} justifyContent="center">
@@ -321,10 +291,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
           />
         </Box>
       </TableCell>
-      {uniqueSources.map((_, i) => (
-        // eslint-disable-next-line
-        <TableCell key={i} />
-      ))}
+      <TableCell />
       <TableCell align="center" sx={{ p: 1 }}>
         <Stack direction="row" spacing={1} justifyContent="center">
           <IconButton
diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
index 2599bdf7c..1f662086c 100644
--- a/src/renderer/components/review/types.ts
+++ b/src/renderer/components/review/types.ts
@@ -18,6 +18,7 @@ export interface ReviewChecklistSectionProps {
   checklistResults: ReviewChecklistResult[];
   isLoading: boolean;
   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
+  targetDocumentName?: string | null;
 }
 
 // ReviewSourceModalのProps型
diff --git a/src/renderer/lib/csvUtils.ts b/src/renderer/lib/csvUtils.ts
index 7cfdefb6c..c5aac8405 100644
--- a/src/renderer/lib/csvUtils.ts
+++ b/src/renderer/lib/csvUtils.ts
@@ -36,27 +36,8 @@ export const convertReviewResultsToCSV = (
     return 'チェックリスト\n';
   }
 
-  // ユニークなソースファイルを抽出
-  const uniqueSources = new Map<string, { id: string; fileName: string }>();
-  checklistResults.forEach((checklist) => {
-    checklist.sourceEvaluations?.forEach((ev) => {
-      if (!uniqueSources.has(ev.fileId)) {
-        uniqueSources.set(ev.fileId, {
-          id: ev.fileId,
-          fileName: ev.fileName,
-        });
-      }
-    });
-  });
-
-  const sources = Array.from(uniqueSources.values());
-
   // ヘッダー行を構築
-  const headers = ['チェックリスト'];
-  sources.forEach((source) => {
-    headers.push(`${source.fileName}_評価`);
-    headers.push(`${source.fileName}_コメント`);
-  });
+  const headers = ['チェックリスト', '評価', 'コメント'];
 
   const csvRows: string[] = [];
 
@@ -65,18 +46,11 @@ export const convertReviewResultsToCSV = (
 
   // データ行を追加
   checklistResults.forEach((checklist) => {
-    const row: string[] = [checklist.content];
-
-    sources.forEach((source) => {
-      const evaluation = checklist.sourceEvaluations?.find(
-        (ev) => ev.fileId === source.id,
-      );
-
-      // 評価値
-      row.push(evaluation?.evaluation || '');
-      // コメント
-      row.push(evaluation?.comment || '');
-    });
+    const row: string[] = [
+      checklist.content,
+      checklist.sourceEvaluation?.evaluation || '',
+      checklist.sourceEvaluation?.comment || '',
+    ];
 
     csvRows.push(row.map(escapeCSVField).join(','));
   });
diff --git a/src/renderer/service/chatApi.ts b/src/renderer/service/chatApi.ts
index 7e99d3fcf..ae3995928 100644
--- a/src/renderer/service/chatApi.ts
+++ b/src/renderer/service/chatApi.ts
@@ -129,9 +129,13 @@ export class ChatApi implements IChatApi {
     roomId: string,
     options?: ApiServiceDefaultOptions,
   ): Promise<void> {
-    await invokeApi(() => window.electron.chat.requestAbort({
-      threadId: roomId,
-    }), options);
+    await invokeApi(
+      () =>
+        window.electron.chat.requestAbort({
+          threadId: roomId,
+        }),
+      options,
+    );
   }
 
   public async getChatMessages(
@@ -146,7 +150,10 @@ export class ChatApi implements IChatApi {
     title: string,
     options?: ApiServiceDefaultOptions,
   ): Promise<void> {
-    await invokeApi(() => window.electron.chat.createThread({ roomId, title }), options);
+    await invokeApi(
+      () => window.electron.chat.createThread({ roomId, title }),
+      options,
+    );
   }
 
   public async sendMessage(
@@ -154,7 +161,10 @@ export class ChatApi implements IChatApi {
     messages: ChatMessage[],
     options?: ApiServiceDefaultOptions,
   ): Promise<void> {
-    await invokeApi(() => window.electron.chat.sendMessage({ roomId, messages }), options);
+    await invokeApi(
+      () => window.electron.chat.sendMessage({ roomId, messages }),
+      options,
+    );
     console.log('Message sent via IPC:', { roomId, messages });
   }
 
@@ -163,9 +173,13 @@ export class ChatApi implements IChatApi {
     messageId: string,
     options?: ApiServiceDefaultOptions,
   ): Promise<void> {
-    await invokeApi(() => window.electron.chat.deleteMessagesBeforeSpecificId({
-      threadId: roomId,
-      messageId,
-    }), options);
+    await invokeApi(
+      () =>
+        window.electron.chat.deleteMessagesBeforeSpecificId({
+          threadId: roomId,
+          messageId,
+        }),
+      options,
+    );
   }
 }
diff --git a/src/renderer/service/fsApi.ts b/src/renderer/service/fsApi.ts
index bf8cc05a5..69f5b5f9b 100644
--- a/src/renderer/service/fsApi.ts
+++ b/src/renderer/service/fsApi.ts
@@ -40,7 +40,10 @@ export class FsApi implements IFsApi {
     options: OpenDialogOptions,
     apiOptions?: ApiServiceDefaultOptions,
   ): Promise<{ filePaths: string[]; canceled: boolean } | null> {
-    return invokeApi(() => window.electron.fs.showOpenDialog(options), apiOptions);
+    return invokeApi(
+      () => window.electron.fs.showOpenDialog(options),
+      apiOptions,
+    );
   }
 
   public async readFile(
diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
index 02fc24edb..1ed208b6f 100644
--- a/src/renderer/service/reviewApi.ts
+++ b/src/renderer/service/reviewApi.ts
@@ -27,6 +27,7 @@ export interface IReviewApi {
     options?: ApiServiceDefaultOptions,
   ): Promise<{
     checklistResults?: ReviewChecklistResult[];
+    targetDocumentName?: string | null;
   } | null>;
   getReviewInstruction(
     historyId: string,
@@ -118,6 +119,7 @@ export class ReviewApi implements IReviewApi {
     options?: ApiServiceDefaultOptions,
   ): Promise<{
     checklistResults?: ReviewChecklistResult[];
+    targetDocumentName?: string | null;
   } | null> {
     return invokeApi(
       () => window.electron.review.getHistoryDetail(historyId),
diff --git a/src/renderer/service/reviewChatApi.ts b/src/renderer/service/reviewChatApi.ts
new file mode 100644
index 000000000..f3da0c3d2
--- /dev/null
+++ b/src/renderer/service/reviewChatApi.ts
@@ -0,0 +1,136 @@
+import { IpcChannels, IpcEventPayload } from '@/types';
+import { invokeApi } from '../lib/apiUtils';
+import { ApiServiceDefaultOptions } from '../types';
+import { ElectronPushClient } from '../lib/ElectronPushClient';
+
+export interface IReviewChatApi {
+  streamResponse(callbacks: {
+    onMessage: (
+      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
+    ) => void;
+    onDone: () => void;
+    onError: (error: Error) => void;
+  }): () => void;
+  abortChat(
+    reviewHistoryId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+  sendMessage(
+    reviewHistoryId: string,
+    checklistIds: number[],
+    question: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void>;
+}
+
+// IPC通信を使用してレビューチャット機能を提供するAPIサービス
+export class ReviewChatApi implements IReviewChatApi {
+  // シングルトン変数
+  private static instance: ReviewChatApi;
+
+  // コンストラクタをprivateにして外部からのインスタンス化を防止
+  private constructor() {}
+
+  // シングルトンインスタンスを取得するための静的メソッド
+  public static getInstance(): ReviewChatApi {
+    if (!ReviewChatApi.instance) {
+      ReviewChatApi.instance = new ReviewChatApi();
+    }
+    return ReviewChatApi.instance;
+  }
+
+  /**
+   * ストリーミング応答の購読
+   * @param callbacks ストリーミングイベントのコールバック
+   * @returns 購読解除用の関数
+   */
+  public streamResponse(callbacks: {
+    onMessage: (
+      chunk: IpcEventPayload<typeof IpcChannels.REVIEW_CHAT_STREAM_RESPONSE>,
+    ) => void;
+    onDone: () => void;
+    onError: (error: Error) => void;
+  }): () => void {
+    const pushClient = new ElectronPushClient();
+    const abortController = new AbortController();
+
+    // ストリーミングイベントの購読
+    pushClient.subscribe(
+      IpcChannels.REVIEW_CHAT_STREAM_RESPONSE,
+      (event) => {
+        callbacks.onMessage(event.payload);
+      },
+      { signal: abortController.signal },
+    );
+
+    // 完了イベント（レビューチャット専用）
+    pushClient.subscribe(
+      IpcChannels.REVIEW_CHAT_COMPLETE,
+      () => {
+        // 購読を解除
+        abortController.abort();
+        // 完了コールバックを呼び出し
+        callbacks.onDone();
+      },
+      { signal: abortController.signal },
+    );
+
+    // エラーイベント（レビューチャット専用）
+    pushClient.subscribe(
+      IpcChannels.REVIEW_CHAT_ERROR,
+      (event) => {
+        // 購読を解除
+        abortController.abort();
+        // エラーコールバックを呼び出し
+        callbacks.onError(
+          new Error(event.payload.message || '予期せぬエラーが発生しました'),
+        );
+      },
+      { signal: abortController.signal },
+    );
+
+    // 購読解除のためのクリーンアップ
+    return () => {
+      abortController.abort();
+    };
+  }
+
+  /**
+   * レビューチャットの中断
+   * @param reviewHistoryId レビュー履歴ID
+   * @param options APIサービスのオプション
+   */
+  public async abortChat(
+    reviewHistoryId: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(
+      () => window.electron.review.abortChat(reviewHistoryId),
+      options,
+    );
+  }
+
+  /**
+   * レビューチャットメッセージ送信
+   * @param reviewHistoryId レビュー履歴ID
+   * @param checklistIds チェックリストID配列
+   * @param question ユーザからの質問
+   * @param options APIサービスのオプション
+   */
+  public async sendMessage(
+    reviewHistoryId: string,
+    checklistIds: number[],
+    question: string,
+    options?: ApiServiceDefaultOptions,
+  ): Promise<void> {
+    await invokeApi(
+      () =>
+        window.electron.review.sendChatMessage({
+          reviewHistoryId,
+          checklistIds,
+          question,
+        }),
+      options,
+    );
+  }
+}
diff --git a/src/renderer/service/settingsApi.ts b/src/renderer/service/settingsApi.ts
index 8ec061cbf..a2cdeecc5 100644
--- a/src/renderer/service/settingsApi.ts
+++ b/src/renderer/service/settingsApi.ts
@@ -47,7 +47,10 @@ export class SettingsApi implements ISettingsApi {
     messageId: string,
     options?: ApiServiceDefaultOptions,
   ): Promise<void> {
-    await invokeApi(() => window.electron.settings.removeMessage(messageId), options);
+    await invokeApi(
+      () => window.electron.settings.removeMessage(messageId),
+      options,
+    );
   }
 
   public async reinitialize(options?: ApiServiceDefaultOptions): Promise<void> {
@@ -64,7 +67,10 @@ export class SettingsApi implements ISettingsApi {
     settings: Settings,
     options?: ApiServiceDefaultOptions,
   ): Promise<boolean | null> {
-    return invokeApi(() => window.electron.settings.setSettings(settings), options);
+    return invokeApi(
+      () => window.electron.settings.setSettings(settings),
+      options,
+    );
   }
 
   public async subscribeSettingsUpdateFinished(
diff --git a/src/renderer/service/sourceApi.ts b/src/renderer/service/sourceApi.ts
index 76b2f9c6f..2500ff69b 100644
--- a/src/renderer/service/sourceApi.ts
+++ b/src/renderer/service/sourceApi.ts
@@ -49,10 +49,14 @@ export class SourceApi implements ISourceApi {
     enabled: boolean,
     options?: ApiServiceDefaultOptions,
   ): Promise<void> {
-    await invokeApi(() => window.electron.source.updateSourceEnabled({
-      sourceId: id,
-      isEnabled: enabled,
-    }), options);
+    await invokeApi(
+      () =>
+        window.electron.source.updateSourceEnabled({
+          sourceId: id,
+          isEnabled: enabled,
+        }),
+      options,
+    );
   }
 
   public async subscribeSourceReloadFinished(
diff --git a/src/types/error.ts b/src/types/error.ts
index a4fd32185..ad22f0b75 100644
--- a/src/types/error.ts
+++ b/src/types/error.ts
@@ -14,10 +14,7 @@ export type ErrorCode =
 /**
  * フロントエンドで利用するエラーコード
  */
-export type FrontErrorCode =
-  | 'APP_API'
-  | 'APP_API_CALL'
-  | 'INTERNAL';
+export type FrontErrorCode = 'APP_API' | 'APP_API_CALL' | 'INTERNAL';
 
 /**
  * クライアントへ返す標準エラー形
diff --git a/src/types/ipc.ts b/src/types/ipc.ts
index 0fc449d82..69d3b10bd 100644
--- a/src/types/ipc.ts
+++ b/src/types/ipc.ts
@@ -81,6 +81,11 @@ export const IpcChannels = {
   REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
   REVIEW_EXECUTE_ABORT: 'review-execute-abort', // レビュー実行処理をキャンセルする
   REVIEW_HISTORY_UPDATED: 'review-history-updated', // レビュー履歴が更新された際の通知
+  REVIEW_CHAT_SEND_MESSAGE: 'review-chat-send-message', // レビューチャットメッセージ送信
+  REVIEW_CHAT_STREAM_RESPONSE: 'review-chat-stream-response', // レビューチャットストリーミング応答
+  REVIEW_CHAT_COMPLETE: 'review-chat-complete', // レビューチャット完了
+  REVIEW_CHAT_ERROR: 'review-chat-error', // レビューチャットエラー
+  REVIEW_CHAT_ABORT: 'review-chat-abort', // レビューチャット中断
 } as const;
 
 export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
@@ -150,6 +155,12 @@ export type IpcRequestPayloadMap = {
     documentMode: DocumentMode;
   };
   [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
+  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: {
+    reviewHistoryId: string;
+    checklistIds: number[];
+    question: string;
+  };
+  [IpcChannels.REVIEW_CHAT_ABORT]: string; // review history id
 };
 
 export type IpcResponsePayloadMap = {
@@ -189,6 +200,7 @@ export type IpcResponsePayloadMap = {
   [IpcChannels.REVIEW_GET_HISTORIES]: IpcResult<RevieHistory[]>;
   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: IpcResult<{
     checklistResults?: ReviewChecklistResult[];
+    targetDocumentName?: string | null;
   }>;
   [IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]: IpcResult<{
     additionalInstructions?: string;
@@ -201,6 +213,8 @@ export type IpcResponsePayloadMap = {
   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: IpcResult;
   [IpcChannels.REVIEW_EXECUTE_CALL]: IpcResult;
   [IpcChannels.REVIEW_EXECUTE_ABORT]: IpcResult;
+  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: IpcResult;
+  [IpcChannels.REVIEW_CHAT_ABORT]: IpcResult;
 };
 
 export type IpcEventPayloadMap = {
@@ -227,6 +241,9 @@ export type IpcEventPayloadMap = {
     currentSheet?: number;
     totalSheets?: number;
   };
+  [IpcChannels.REVIEW_CHAT_STREAM_RESPONSE]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
+  [IpcChannels.REVIEW_CHAT_COMPLETE]: unknown;
+  [IpcChannels.REVIEW_CHAT_ERROR]: { message: string };
 };
 
 /**
@@ -287,4 +304,8 @@ export const IpcNameMap = {
   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: 'チェックリストの更新',
   [IpcChannels.REVIEW_EXECUTE_CALL]: 'ドキュメントレビューの実行',
   [IpcChannels.REVIEW_EXECUTE_ABORT]: 'ドキュメントレビューの中断',
+  [IpcChannels.REVIEW_CHAT_SEND_MESSAGE]: 'レビューチャットメッセージ送信',
+  [IpcChannels.REVIEW_CHAT_COMPLETE]: 'レビューチャット完了',
+  [IpcChannels.REVIEW_CHAT_ERROR]: 'レビューチャットエラー',
+  [IpcChannels.REVIEW_CHAT_ABORT]: 'レビューチャット中断',
 };
diff --git a/src/types/message.ts b/src/types/message.ts
index 979bb1cda..a4065ae2e 100644
--- a/src/types/message.ts
+++ b/src/types/message.ts
@@ -11,6 +11,7 @@ export type MessageCode =
   | 'GITLAB_API_CONNECTION_ERROR'
   | 'REDMINE_API_CONNECTION_ERROR'
   | 'REDMINE_API_ERROR'
+  | 'FS_OPEN_DIALOG_ERROR'
   | 'FILE_TEXT_EXTRACTION_ERROR'
   | 'FS_CONVERT_OFFICE_TO_PDF_ERROR'
   | 'SOURCE_REGISTRATION_DIR_READING_ERROR'
@@ -18,8 +19,10 @@ export type MessageCode =
   | 'REVIEW_CHECKLIST_EXTRACTION_ERROR'
   | 'REVIEW_CHECKLIST_EXTRACTION_OVER_MAX_TOKENS'
   | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
+  | 'REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM'
   | 'REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR'
   | 'REVIEW_EXECUTION_ERROR'
   | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
   | 'AI_API_ERROR'
-  | 'AI_MESSAGE_TOO_LARGE';
+  | 'AI_MESSAGE_TOO_LARGE'
+  | 'REVIEW_DOCUMENT_CACHE_NOT_FOUND';
diff --git a/src/types/review.ts b/src/types/review.ts
index 52578ffaa..d4c93cf18 100644
--- a/src/types/review.ts
+++ b/src/types/review.ts
@@ -1,6 +1,7 @@
 export interface RevieHistory {
   id: string; // reviewHistoriesのid
   title: string;
+  targetDocumentName?: string | null; // レビュー対象の統合ドキュメント名
   additionalInstructions: string | null;
   commentFormat?: string | null;
   evaluationSettings?: CustomEvaluationSettings | null; // カスタム評定項目設定
@@ -13,6 +14,8 @@ export interface ReviewChecklist {
   id: number;
   reviewHistoryId: string;
   content: string;
+  evaluation?: ReviewEvaluation | null; // A, B, C, - 評価
+  comment?: string | null; // レビューコメント
   createdBy: ReviewChecklistCreatedBy;
   createdAt: string;
   updatedAt: string;
@@ -39,12 +42,10 @@ export type ReviewChecklistCreatedBy = 'user' | 'system';
 export type ReviewChecklistResult = {
   id: number; // チェックリストのID
   content: string;
-  sourceEvaluations?: {
-    fileId: string;
-    fileName: string;
+  sourceEvaluation?: {
     evaluation?: ReviewEvaluation; // カスタム評定項目対応
     comment?: string;
-  }[];
+  };
 };
 
 // チェックリストの編集内容を表す型
@@ -92,8 +93,30 @@ export type ReviewExecutionResultStatus =
 
 // 処理ステータスの型定義
 export type ProcessingStatus =
-  | 'idle'        // アイドル状態
-  | 'extracting'  // チェックリスト抽出中
-  | 'extracted'   // チェックリスト抽出完了
-  | 'reviewing'   // レビュー実行中
-  | 'completed';  // レビュー完了
+  | 'idle' // アイドル状態
+  | 'extracting' // チェックリスト抽出中
+  | 'extracted' // チェックリスト抽出完了
+  | 'reviewing' // レビュー実行中
+  | 'completed'; // レビュー完了
+
+// レビュードキュメントキャッシュ（サービス層で使用）
+export interface ReviewDocumentCache {
+  id: number;
+  reviewHistoryId: string;
+  fileName: string; // ワークフロー内での名前（分割時は "xxx (part 1)" など）
+  processMode: ProcessMode;
+  textContent?: string; // processMode='text'の場合
+  imageData?: string[]; // processMode='image'の場合
+  createdAt: string;
+  updatedAt: string;
+}
+
+// レビュー大量ドキュメント結果キャッシュ（大量ドキュメントレビューの個別レビュー結果）
+export interface ReviewLargedocumentResultCache {
+  reviewDocumentCacheId: number;
+  reviewChecklistId: number;
+  comment: string;
+  totalChunks: number; // ドキュメント分割総数
+  chunkIndex: number; // 何番目のチャンクか（0から始まる）
+  individualFileName: string; // 分割後の個別ドキュメント名（"xxx (part 1)" など）
+}
