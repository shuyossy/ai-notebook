diff --git a/.clinerules b/.clinerules
index 0ed9eb19f..62bc3dae7 100644
--- a/.clinerules
+++ b/.clinerules
@@ -1,21 +1,49 @@
 # アプリケーション概要
-- 情報源となるソースを元にAIとチャットできるデスクトップアプリ
+- AIを利用した様々な機能を利用できるデスクトップアプリ
+  - 情報源となるソースを元にAIとチャットできる
+  - チェックリストを元にAIが指定したソースをレビューする（新規追加）
 - UIはElectronとReact、バックエンドはMastraをベースに開発する
 
 # 実装上の注意
 - Mastraについては実装する際はまずMCPでドキュメントや実装例を参考にしてから正確な情報やベストプラクティスに基づいてコーディングすること
 - プロジェクト全体を把握して、全ての実装が必要箇所を正しく洗い出してから実装すること
-- UIは実際に市場に投入できるくらいレベルの高い、スタイリッシュなUIにすること
+- 既存資源（型情報やコンポーネントなど）を積極的に活用して効率的に実装すること
+  - 既存のコードの修正は真に必要な場合に限ること
+- UIは実際に市場に投入できるくらいレベルの高いUIにすること
 - TypeScriptやzodを用いた型安全なコードを意識すること
 - electronについてはelectron-react-boilerplateのテンプレートを適用済み
-- コメントは日本語で記載すること
+- プロンプトは英語で記載すること
+  - プロンプトの内容はベストプラクティスに基づいて実装すること
+  - 一般的で自然な英語表現にすること
+- コードのコメントは日本語で記載すること
 - Reactライブラリが使えるのであれば積極的に利用すること
     - 特にUIについてはMUIを第一優先に使い、カスタマイズしたい場合はshadcn/uiを利用すること
     - ライブラリを追加する際は安定稼働バージョンを採用すること
 - eslintについては単純なフォーマットエラーの場合は対応する必要はない
-- 不明点があれば適当に実装するのではなく、質問すること
+
+# 代表的なフォルダ説明（いくつかファイルもピックアップして説明）
+- `src/db`：データベース関連のコード
+  - `schema.ts`：データベースのスキーマ定義
+- `src/main/types`：アプリで利用する型・zodスキーマの定義
+  - `index.ts`：アプリ全体で利用する型定義
+  - `ipc.ts`：Electron IPC通信で利用する型定義
+- `src/main`: Electronのメインプロセス関連のコード
+  - `src/main.ts`: Electronのメインプロセスのエントリポイント、IPC通信のハンドラの具体的な処理の定義やアプリケーションの初期化処理などを含む
+  - `src/main/preload`: ElectronのPreloadスクリプト、レンダラープロセスに公開するハンドラを定義
+  - `src/main/store.ts`: electron-storeを利用してアプリケーションの設定や状態の保存・取得を行う、ここではstoreの初期化や設定の定義を行う
+  - `src/main/utils`: メインプロセスで利用するユーティリティ関数
+    - `src/main/utils/fileExtractor.ts`: 登録されたソースのテキスト情報を抽出する関数
+- `src/renderer/components`：Reactコンポーネント
+  - `src/renderer/components/common/AlertMessage`: エラーメッセージ表示用のコンポーネント（エージェント初期化時のメッセージやカスタムエラーメッセージを表示できる）
+- `src/mastra`: Mastraを利用したAI関連のコード
+  - `src/mastra/agents/prompt.ts`: Mastraのエージェントのプロンプト定義を一箇所に集約（エージェントやワークフロー内で利用するプロンプトを定義）
+  - `src/mastra/agents/orchestrator.ts`: 汎用チャット機能で利用するAIエージェントの定義（`src/mastra/config`や`src/mastra/model`を呼び出してエージェントを作成する）
+  - `src/mastra/workflows`: Mastraのワークフロー定義
+    - `src/mastra/workflows/types.ts`: ワークフローで利用する型定義
+    - `src/mastra/workflows/schema.ts`: ワークフローで利用するzodスキーマ定義（ワークフローを作成する際は、各Stepのoutputschemaは必ず本ファイル内に定義されているbaseStepOutputSchemaを継承するようにしてください）
 
 # テスト作成時の注意
+- 明確な指示がある場合以外はテストコードを作成しないこと
 - 外部ライブラリとの結合をテストする場合はできるだけ実際のライブラリを使用すること
   - 実際のライブラリの利用が難しい場合はモックを利用すること
   - Electron IPCはモックを利用すること
diff --git a/.eslintrc.js b/.eslintrc.js
index 7d8010a77..3c46b85d7 100644
--- a/.eslintrc.js
+++ b/.eslintrc.js
@@ -16,6 +16,7 @@ module.exports = {
     '@typescript-eslint/no-unused-vars': 'error',
     'no-console': 'off',
     'no-await-in-loop': 'off',
+    'class-methods-use-this': 'off',
     'react/require-default-props': 'off', // パラメータのデストラクチャリングでデフォルト値を設定する方式を許可
     'react/function-component-definition': [
       'error',
diff --git a/.gitignore b/.gitignore
index 522483d95..025b4f02a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -40,7 +40,7 @@ dist
 
 # original
 source
-db
+/db
 local_docker
 mcp.log
 electron-store
diff --git a/drizzle/migrations/0003_outgoing_cobalt_man.sql b/drizzle/migrations/0003_outgoing_cobalt_man.sql
new file mode 100644
index 000000000..f608dad07
--- /dev/null
+++ b/drizzle/migrations/0003_outgoing_cobalt_man.sql
@@ -0,0 +1,28 @@
+CREATE TABLE `review_checklist_sources` (
+	`review_checklist_id` integer NOT NULL,
+	`source_id` integer NOT NULL,
+	`evaluation` text,
+	`comment` text,
+	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
+	PRIMARY KEY(`review_checklist_id`, `source_id`),
+	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade,
+	FOREIGN KEY (`source_id`) REFERENCES `sources`(`id`) ON UPDATE no action ON DELETE cascade
+);
+--> statement-breakpoint
+CREATE TABLE `review_checklists` (
+	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
+	`review_history_id` text NOT NULL,
+	`content` text NOT NULL,
+	`created_by` text NOT NULL,
+	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
+	FOREIGN KEY (`review_history_id`) REFERENCES `review_histories`(`id`) ON UPDATE no action ON DELETE cascade
+);
+--> statement-breakpoint
+CREATE TABLE `review_histories` (
+	`id` text PRIMARY KEY NOT NULL,
+	`title` text NOT NULL,
+	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+	`updated_at` text DEFAULT (current_timestamp) NOT NULL
+);
diff --git a/drizzle/migrations/meta/0003_snapshot.json b/drizzle/migrations/meta/0003_snapshot.json
new file mode 100644
index 000000000..ff185fbe7
--- /dev/null
+++ b/drizzle/migrations/meta/0003_snapshot.json
@@ -0,0 +1,368 @@
+{
+  "version": "6",
+  "dialect": "sqlite",
+  "id": "e4779464-5d36-4a28-a701-899c1b816205",
+  "prevId": "e95a2e10-172d-46b3-9273-9b703dbab422",
+  "tables": {
+    "review_checklist_sources": {
+      "name": "review_checklist_sources",
+      "columns": {
+        "review_checklist_id": {
+          "name": "review_checklist_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "evaluation": {
+          "name": "evaluation",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklist_sources_review_checklist_id_review_checklists_id_fk": {
+          "name": "review_checklist_sources_review_checklist_id_review_checklists_id_fk",
+          "tableFrom": "review_checklist_sources",
+          "tableTo": "review_checklists",
+          "columnsFrom": [
+            "review_checklist_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        },
+        "review_checklist_sources_source_id_sources_id_fk": {
+          "name": "review_checklist_sources_source_id_sources_id_fk",
+          "tableFrom": "review_checklist_sources",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {
+        "review_checklist_sources_review_checklist_id_source_id_pk": {
+          "columns": [
+            "review_checklist_id",
+            "source_id"
+          ],
+          "name": "review_checklist_sources_review_checklist_id_source_id_pk"
+        }
+      },
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_checklists": {
+      "name": "review_checklists",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "content": {
+          "name": "content",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_by": {
+          "name": "created_by",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklists_review_history_id_review_histories_id_fk": {
+          "name": "review_checklists_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_checklists",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_histories": {
+      "name": "review_histories",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "text",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "sources": {
+      "name": "sources",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "path": {
+          "name": "path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "status": {
+          "name": "status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "error": {
+          "name": "error",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "is_enabled": {
+          "name": "is_enabled",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": 1
+        }
+      },
+      "indexes": {
+        "sources_path_unique": {
+          "name": "sources_path_unique",
+          "columns": [
+            "path"
+          ],
+          "isUnique": true
+        }
+      },
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "topics": {
+      "name": "topics",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "name": {
+          "name": "name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "topics_source_id_sources_id_fk": {
+          "name": "topics_source_id_sources_id_fk",
+          "tableFrom": "topics",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    }
+  },
+  "views": {},
+  "enums": {},
+  "_meta": {
+    "schemas": {},
+    "tables": {},
+    "columns": {}
+  },
+  "internal": {
+    "indexes": {}
+  }
+}
\ No newline at end of file
diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
index 693d5fdea..6313c7bd6 100644
--- a/drizzle/migrations/meta/_journal.json
+++ b/drizzle/migrations/meta/_journal.json
@@ -22,6 +22,13 @@
       "when": 1745808321139,
       "tag": "0002_bent_silhouette",
       "breakpoints": true
+    },
+    {
+      "idx": 3,
+      "version": "6",
+      "when": 1749952232695,
+      "tag": "0003_outgoing_cobalt_man",
+      "breakpoints": true
     }
   ]
 }
\ No newline at end of file
diff --git a/package.json b/package.json
index 87a8604ad..66fc12f6b 100644
--- a/package.json
+++ b/package.json
@@ -14,7 +14,7 @@
     "lint:fix": "cross-env NODE_ENV=development eslint . --ext .js,.jsx,.ts,.tsx --fix",
     "lint:backend": "eslint src --ext .ts",
     "lint:backend:fix": "eslint src --ext .ts --fix",
-    "format": "prettier --write \"src/**/*.ts\"",
+    "format": "prettier --write \"src/**\"",
     "package": "ts-node ./.erb/scripts/clean.js dist && npm run build && electron-builder build --publish never && npm run build:dll",
     "rebuild": "electron-rebuild --parallel --types prod,dev,optional --module-dir release/app",
     "prestart": "cross-env NODE_ENV=development TS_NODE_TRANSPILE_ONLY=true NODE_OPTIONS=\"-r ts-node/register --no-warnings\" webpack --config ./.erb/configs/webpack.config.main.dev.ts",
diff --git a/src/db/index.ts b/src/db/index.ts
index 80efb8ffa..0a96f5ad2 100644
--- a/src/db/index.ts
+++ b/src/db/index.ts
@@ -33,6 +33,9 @@ const initializeDatabase = async () => {
     // データベースの存在チェック
     await client.execute('SELECT 1 FROM sources LIMIT 1');
     await client.execute('SELECT 1 FROM topics LIMIT 1');
+    await client.execute('SELECT 1 FROM review_histories LIMIT 1');
+    await client.execute('SELECT 1 FROM review_checklists LIMIT 1');
+    await client.execute('SELECT 1 FROM review_checklist_sources LIMIT 1');
     // eslint-disable-next-line
   } catch (error) {
     // データベースが存在しない場合、マイグレーションを実行
diff --git a/src/db/repository/repositoryError.ts b/src/db/repository/repositoryError.ts
new file mode 100644
index 000000000..627a4d7e8
--- /dev/null
+++ b/src/db/repository/repositoryError.ts
@@ -0,0 +1,16 @@
+/**
+ * リポジトリ層で発生したエラーを表す共通クラス
+ */
+export class RepositoryError extends Error {
+  public readonly originalError?: Error;
+
+  constructor(message: string, originalError?: Error) {
+    super(message);
+    this.name = 'RepositoryError';
+    this.originalError = originalError;
+    // スタックトレースを保持
+    if (originalError?.stack) {
+      this.stack = originalError.stack;
+    }
+  }
+}
diff --git a/src/db/repository/reviewRepository.ts b/src/db/repository/reviewRepository.ts
new file mode 100644
index 000000000..2b20c1621
--- /dev/null
+++ b/src/db/repository/reviewRepository.ts
@@ -0,0 +1,411 @@
+import { eq, and } from 'drizzle-orm';
+import type {
+  ReviewHistory,
+  ReviewChecklist,
+  ReviewChecklistSource,
+} from '../schema';
+import {
+  reviewHistories,
+  reviewChecklists,
+  reviewChecklistSources,
+  sources,
+} from '../schema';
+import getDb from '..';
+import type {
+  ReviewChecklistResult,
+  ReviewEvaluation,
+  ReviewChecklistCreatedBy,
+} from '../../main/types';
+import { RepositoryError } from './repositoryError';
+
+/**
+ * ドキュメントレビューで利用するDBアクセス用のインターフェース
+ */
+export interface ReviewRepository {
+  // レビュー履歴
+  createReviewHistory(title: string, id?: string): Promise<ReviewHistory>;
+  getReviewHistory(id: string): Promise<ReviewHistory | null>;
+  getAllReviewHistories(): Promise<ReviewHistory[]>;
+  updateReviewHistoryTitle(id: string, title: string): Promise<void>;
+  deleteReviewHistory(id: string): Promise<void>;
+
+  // チェックリスト
+  createChecklist(
+    reviewHistoryId: string,
+    content: string,
+    createdBy: ReviewChecklistCreatedBy,
+  ): Promise<ReviewChecklist>;
+  getChecklists(reviewHistoryId: string): Promise<ReviewChecklist[]>;
+  updateChecklist(id: number, content: string): Promise<ReviewChecklist>;
+  deleteChecklist(id: number): Promise<void>;
+  deleteSystemCreatedChecklists(reviewHistoryId: string): Promise<void>;
+
+  // レビュー結果
+  upsertReviewResult(
+    results: {
+      reviewChecklistId: number;
+      sourceId: number;
+      evaluation: ReviewEvaluation;
+      comment: string;
+    }[],
+  ): Promise<ReviewChecklistSource[]>;
+  getReviewResults(reviewChecklistId: number): Promise<ReviewChecklistSource[]>;
+  deleteReviewResults(
+    reviewChecklistId: number,
+    sourceId: number,
+  ): Promise<void>;
+  getReviewChecklistResults(
+    reviewHistoryId: string,
+  ): Promise<ReviewChecklistResult[]>;
+  deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
+}
+
+let reviewRepository: ReviewRepository | null = null;
+
+/**
+ * Drizzle ORM を使用したレビューリポジトリの実装
+ */
+class DrizzleReviewRepository implements ReviewRepository {
+  /** レビュー履歴を作成 */
+  async createReviewHistory(
+    title: string,
+    id?: string,
+  ): Promise<ReviewHistory> {
+    try {
+      const db = await getDb();
+      const [history] = await db
+        .insert(reviewHistories)
+        .values({ title, id })
+        .returning();
+      return history;
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー履歴の作成に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** レビュー履歴を取得（存在しない場合は null） */
+  async getReviewHistory(id: string): Promise<ReviewHistory | null> {
+    try {
+      const db = await getDb();
+      const [history] = await db
+        .select()
+        .from(reviewHistories)
+        .where(eq(reviewHistories.id, id));
+      return history || null;
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー履歴の取得に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** 全レビュー履歴を取得 */
+  async getAllReviewHistories(): Promise<ReviewHistory[]> {
+    try {
+      const db = await getDb();
+      return await db
+        .select()
+        .from(reviewHistories)
+        .orderBy(reviewHistories.updatedAt);
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー履歴一覧の取得に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** レビュー履歴タイトルを更新 */
+  async updateReviewHistoryTitle(id: string, title: string): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .update(reviewHistories)
+        .set({ title })
+        .where(eq(reviewHistories.id, id));
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー履歴の更新に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** レビュー履歴を削除 */
+  async deleteReviewHistory(id: string): Promise<void> {
+    try {
+      const db = await getDb();
+      await db.delete(reviewHistories).where(eq(reviewHistories.id, id));
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー履歴の削除に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** チェックリストを作成 */
+  async createChecklist(
+    reviewHistoryId: string,
+    content: string,
+    createdBy: ReviewChecklistCreatedBy,
+  ): Promise<ReviewChecklist> {
+    try {
+      const db = await getDb();
+      const [checklist] = await db
+        .insert(reviewChecklists)
+        .values({ reviewHistoryId, content, createdBy })
+        .returning();
+      return checklist;
+    } catch (err) {
+      throw new RepositoryError(
+        `チェックリストの作成に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** チェックリスト一覧を取得 */
+  async getChecklists(reviewHistoryId: string): Promise<ReviewChecklist[]> {
+    try {
+      const db = await getDb();
+      return await db
+        .select()
+        .from(reviewChecklists)
+        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+        .orderBy(reviewChecklists.updatedAt);
+    } catch (err) {
+      throw new RepositoryError(
+        `チェックリストの取得に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** チェックリストを更新 */
+  async updateChecklist(id: number, content: string): Promise<ReviewChecklist> {
+    try {
+      const db = await getDb();
+      const [checklist] = await db
+        .update(reviewChecklists)
+        .set({ content })
+        .where(eq(reviewChecklists.id, id))
+        .returning();
+      if (!checklist) {
+        throw new RepositoryError(`チェックリストID ${id} が見つかりません`);
+      }
+      return checklist;
+    } catch (err) {
+      if (err instanceof RepositoryError) throw err;
+      throw new RepositoryError(
+        `チェックリストの更新に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** チェックリストを削除 */
+  async deleteChecklist(id: number): Promise<void> {
+    try {
+      const db = await getDb();
+      await db.delete(reviewChecklists).where(eq(reviewChecklists.id, id));
+    } catch (err) {
+      throw new RepositoryError(
+        `チェックリストの削除に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** システム作成チェックリストを削除 */
+  async deleteSystemCreatedChecklists(reviewHistoryId: string): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .delete(reviewChecklists)
+        .where(
+          and(
+            eq(reviewChecklists.reviewHistoryId, reviewHistoryId),
+            eq(reviewChecklists.createdBy, 'system'),
+          ),
+        );
+    } catch (err) {
+      throw new RepositoryError(
+        `システム作成チェックリストの削除に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** レビュー結果を作成 */
+  async upsertReviewResult(
+    results: {
+      reviewChecklistId: number;
+      sourceId: number;
+      evaluation: ReviewEvaluation;
+      comment: string;
+    }[],
+  ): Promise<ReviewChecklistSource[]> {
+    try {
+      const db = await getDb();
+      const upsertedResults: ReviewChecklistSource[] = [];
+      for (const result of results) {
+        const [upserted] = await db
+          .insert(reviewChecklistSources)
+          .values(result)
+          .onConflictDoUpdate({
+            target: [
+              reviewChecklistSources.reviewChecklistId,
+              reviewChecklistSources.sourceId,
+            ],
+            set: {
+              evaluation: result.evaluation,
+              comment: result.comment,
+            },
+          })
+          .returning();
+        upsertedResults.push(upserted);
+      }
+      return upsertedResults;
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー結果の作成に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** レビュー結果一覧を取得 */
+  async getReviewResults(
+    reviewChecklistId: number,
+  ): Promise<ReviewChecklistSource[]> {
+    try {
+      const db = await getDb();
+      return await db
+        .select()
+        .from(reviewChecklistSources)
+        .where(eq(reviewChecklistSources.reviewChecklistId, reviewChecklistId));
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー結果の取得に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** レビュー結果を削除 */
+  async deleteReviewResults(
+    reviewChecklistId: number,
+    sourceId: number,
+  ): Promise<void> {
+    try {
+      const db = await getDb();
+      await db
+        .delete(reviewChecklistSources)
+        .where(
+          and(
+            eq(reviewChecklistSources.reviewChecklistId, reviewChecklistId),
+            eq(reviewChecklistSources.sourceId, sourceId),
+          ),
+        );
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー結果の削除に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** チェックリスト結果を取得してグルーピング */
+  async getReviewChecklistResults(
+    reviewHistoryId: string,
+  ): Promise<ReviewChecklistResult[]> {
+    try {
+      const db = await getDb();
+      const rows = await db
+        .select({
+          checklistId: reviewChecklists.id,
+          content: reviewChecklists.content,
+          sourceId: reviewChecklistSources.sourceId,
+          sourcePath: sources.path,
+          evaluation: reviewChecklistSources.evaluation,
+          comment: reviewChecklistSources.comment,
+        })
+        .from(reviewChecklists)
+        .leftJoin(
+          reviewChecklistSources,
+          eq(reviewChecklistSources.reviewChecklistId, reviewChecklists.id),
+        )
+        .leftJoin(sources, eq(reviewChecklistSources.sourceId, sources.id))
+        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+        .orderBy(reviewChecklists.createdAt);
+
+      const map = new Map<number, ReviewChecklistResult>();
+      for (const row of rows) {
+        let group = map.get(row.checklistId);
+        if (!group) {
+          group = {
+            id: row.checklistId,
+            content: row.content,
+            sourceEvaluations: [],
+          };
+          map.set(row.checklistId, group);
+        }
+        if (row.sourceId !== null) {
+          group.sourceEvaluations!.push({
+            sourceId: row.sourceId,
+            sourceFileName: row.sourcePath?.split('/').pop() ?? '',
+            evaluation: row.evaluation as ReviewEvaluation,
+            comment: row.comment ?? undefined,
+          });
+        }
+      }
+      return Array.from(map.values());
+    } catch (err) {
+      throw new RepositoryError(
+        `チェックリスト結果の取得に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+
+  /** すべてのレビュー結果を削除 */
+  async deleteAllReviewResults(reviewHistoryId: string): Promise<void> {
+    try {
+      const db = await getDb();
+      const checklists = await db
+        .select({ id: reviewChecklists.id })
+        .from(reviewChecklists)
+        .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId));
+
+      // チェックリストが無ければ何もしない
+      if (checklists.length === 0) return;
+
+      for (const { id } of checklists) {
+        await db
+          .delete(reviewChecklistSources)
+          .where(eq(reviewChecklistSources.reviewChecklistId, id));
+      }
+    } catch (err) {
+      throw new RepositoryError(
+        `レビュー結果の全削除に失敗しました: ${(err as Error).message}`,
+        err as Error,
+      );
+    }
+  }
+}
+
+/**
+ * ドキュメントレビュー用のリポジトリを取得
+ * @returns ReviewRepositoryのインスタンス
+ */
+export function getReviewRepository(): ReviewRepository {
+  if (!reviewRepository) {
+    reviewRepository = new DrizzleReviewRepository();
+  }
+  return reviewRepository;
+}
diff --git a/src/db/repository/sourceRepository.ts b/src/db/repository/sourceRepository.ts
new file mode 100644
index 000000000..8c0489dbd
--- /dev/null
+++ b/src/db/repository/sourceRepository.ts
@@ -0,0 +1,45 @@
+import { eq, inArray } from 'drizzle-orm';
+import getDb from '..';
+import type { Source } from '../schema';
+import { sources } from '../schema';
+
+export interface SourceRepository {
+  /**
+   * ソースを取得する
+   * @param sourceId ソースのID
+   * @returns ソース情報
+   */
+  getSourceById(sourceId: number): Promise<Source | null>;
+
+  /**
+   * idで指定された複数ソース取得する
+   * @returns ソースの配列
+   */
+  getSourcesByIds(sourceIds: number[]): Promise<Source[]>;
+}
+
+let sourceRepository: SourceRepository | null = null;
+
+class DrizzleSourceRepository implements SourceRepository {
+  async getSourceById(sourceId: number): Promise<Source | null> {
+    const db = await getDb();
+    const [source] = await db
+      .select()
+      .from(sources)
+      .where(eq(sources.id, sourceId))
+      .limit(1);
+    return source || null;
+  }
+
+  async getSourcesByIds(sourceIds: number[]): Promise<Source[]> {
+    const db = await getDb();
+    return db.select().from(sources).where(inArray(sources.id, sourceIds));
+  }
+}
+
+export function getSourceRepository(): SourceRepository {
+  if (!sourceRepository) {
+    sourceRepository = new DrizzleSourceRepository();
+  }
+  return sourceRepository;
+}
diff --git a/src/db/schema.ts b/src/db/schema.ts
index 2e640caa0..8a11a9a77 100644
--- a/src/db/schema.ts
+++ b/src/db/schema.ts
@@ -3,8 +3,10 @@ import {
   sqliteTable,
   text,
   customType,
+  primaryKey,
 } from 'drizzle-orm/sqlite-core';
 import { sql } from 'drizzle-orm';
+import { v4 as uuidv4 } from 'uuid';
 import type { ProcessStatus } from '../main/types';
 
 /**
@@ -51,8 +53,70 @@ export const topics = sqliteTable('topics', {
     .$onUpdate(() => sql`(current_timestamp)`),
 });
 
-// ソースとトピックの関係性を定義
+// レビュー履歴を格納するテーブル
+export const reviewHistories = sqliteTable('review_histories', {
+  id: text('id')
+    .primaryKey()
+    .$default(() => uuidv4()), // 汎用チャット機能のコードを活用できるように、MastraのThreadと同じく主キーは文字列とする
+  title: text('title').notNull(), // ソースのtitleを/区切りで結合
+  createdAt: text('created_at')
+    .notNull()
+    .default(sql`(current_timestamp)`),
+  updatedAt: text('updated_at')
+    .notNull()
+    .default(sql`(current_timestamp)`)
+    .$onUpdate(() => sql`(current_timestamp)`),
+});
+
+// レビューチェックリストを格納するテーブル
+export const reviewChecklists = sqliteTable('review_checklists', {
+  id: integer('id').primaryKey({ autoIncrement: true }),
+  reviewHistoryId: text('review_history_id')
+    .notNull()
+    .references(() => reviewHistories.id, { onDelete: 'cascade' }),
+  content: text('content').notNull(), // チェックリスト項目
+  createdBy: text('created_by').notNull(), // 'user' or 'system'
+  createdAt: text('created_at')
+    .notNull()
+    .default(sql`(current_timestamp)`),
+  updatedAt: text('updated_at')
+    .notNull()
+    .default(sql`(current_timestamp)`)
+    .$onUpdate(() => sql`(current_timestamp)`),
+});
+
+// レビューチェックリストとソースの中間テーブル
+export const reviewChecklistSources = sqliteTable(
+  'review_checklist_sources',
+  {
+    reviewChecklistId: integer('review_checklist_id')
+      .notNull()
+      .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
+    sourceId: integer('source_id')
+      .notNull()
+      .references(() => sources.id, { onDelete: 'cascade' }),
+    evaluation: text('evaluation'), // A, B, C評価
+    comment: text('comment'), // レビューコメント
+    createdAt: text('created_at')
+      .notNull()
+      .default(sql`(current_timestamp)`),
+    updatedAt: text('updated_at')
+      .notNull()
+      .default(sql`(current_timestamp)`)
+      .$onUpdate(() => sql`(current_timestamp)`),
+  },
+  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.sourceId] })],
+);
+
+// 型定義
 export type Source = typeof sources.$inferSelect;
 export type InsertSource = typeof sources.$inferInsert;
 export type Topic = typeof topics.$inferSelect;
 export type InsertTopic = typeof topics.$inferInsert;
+export type ReviewHistory = typeof reviewHistories.$inferSelect;
+export type InsertReviewHistory = typeof reviewHistories.$inferInsert;
+export type ReviewChecklist = typeof reviewChecklists.$inferSelect;
+export type InsertReviewChecklist = typeof reviewChecklists.$inferInsert;
+export type ReviewChecklistSource = typeof reviewChecklistSources.$inferSelect;
+export type InsertReviewChecklistSource =
+  typeof reviewChecklistSources.$inferInsert;
diff --git a/src/main/main.ts b/src/main/main.ts
index 7783b1541..d5141c5e2 100644
--- a/src/main/main.ts
+++ b/src/main/main.ts
@@ -23,7 +23,9 @@ import {
   TransformStream,
 } from 'node:stream/web';
 import { sourceRegistrationWorkflow } from '../mastra/workflows/sourceRegistration';
-import { type Source } from '../db/schema';
+import { checklistExtractionWorkflow } from '../mastra/workflows/sourceReview/checklistExtraction';
+import { reviewExecutionWorkflow } from '../mastra/workflows/sourceReview/reviewExecution';
+import type { Source } from '../db/schema';
 import {
   IpcChannels,
   IpcResponsePayloadMap,
@@ -34,11 +36,13 @@ import { getOrchestratorSystemPrompt } from '../mastra/agents/prompts';
 import { sources } from '../db/schema';
 import getDb from '../db';
 import SourceRegistrationManager from '../mastra/workflows/sourceRegistrationManager';
+import SourceReviewManager from '../mastra/workflows/sourceReview/sourceReviewManager';
 import { getOrchestrator } from '../mastra/agents/orchestrator';
 import MenuBuilder from './menu';
 import { resolveHtmlPath } from './utils/util';
 import { initStore, getStore } from './store';
 import { RedmineBaseInfo } from '../mastra/tools/redmine';
+import { ReviewService } from './service/review/reviewService';
 
 class AppUpdater {
   constructor() {
@@ -156,7 +160,11 @@ const initializeMastra = async (): Promise<void> => {
     // Mastraインスタンスを初期化
     mastraInstance = new Mastra({
       agents: { orchestratorAgent: agent },
-      workflows: { sourceRegistrationWorkflow },
+      workflows: {
+        sourceRegistrationWorkflow,
+        checklistExtractionWorkflow,
+        reviewExecutionWorkflow,
+      },
       logger,
     });
 
@@ -690,6 +698,180 @@ const setupSourceHandlers = () => {
   );
 };
 
+const setupReviewHandlers = () => {
+  // レビュー履歴の取得ハンドラ
+  ipcMain.handle(
+    IpcChannels.REVIEW_GET_HISTORIES,
+    async (): Promise<
+      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORIES]
+    > => {
+      try {
+        const service = ReviewService.getInstance();
+        const histories = await service.getReviewHistories();
+
+        return {
+          success: true,
+          histories,
+        };
+      } catch (error) {
+        console.error('レビュー履歴の取得中にエラーが発生:', error);
+        return {
+          success: false,
+          error: (error as Error).message,
+        };
+      }
+    },
+  );
+
+  // チェックリストの取得ハンドラ
+  ipcMain.handle(
+    IpcChannels.REVIEW_GET_HISTORY_DETAIL,
+    async (
+      _,
+      historyId: string,
+    ): Promise<
+      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORY_DETAIL]
+    > => {
+      try {
+        const service = ReviewService.getInstance();
+        const checklistResults =
+          await service.getReviewHistoryDetail(historyId);
+
+        return {
+          success: true,
+          checklistResults,
+        };
+      } catch (error) {
+        console.error('チェックリストの取得中にエラーが発生:', error);
+        return {
+          success: false,
+          error: (error as Error).message,
+        };
+      }
+    },
+  );
+
+  // レビュー履歴の削除ハンドラ
+  ipcMain.handle(
+    IpcChannels.REVIEW_DELETE_HISTORY,
+    async (
+      _,
+      historyId: string,
+    ): Promise<
+      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_DELETE_HISTORY]
+    > => {
+      try {
+        const service = ReviewService.getInstance();
+        await service.deleteReviewHistory(historyId);
+
+        return { success: true };
+      } catch (error) {
+        console.error('レビュー履歴の削除中にエラーが発生:', error);
+        return {
+          success: false,
+          error: (error as Error).message,
+        };
+      }
+    },
+  );
+
+  // チェックリスト抽出ハンドラ
+  ipcMain.handle(
+    IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL,
+    async (
+      event,
+      {
+        reviewHistoryId,
+        sourceIds,
+      }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL],
+    ): Promise<
+      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]
+    > => {
+      try {
+        const manager = SourceReviewManager.getInstance();
+
+        // 非同期でチェックリスト抽出処理を実行
+        const result = manager.extractChecklistWithNotification(
+          reviewHistoryId,
+          sourceIds,
+          event,
+        );
+
+        return result;
+      } catch (error) {
+        console.error('チェックリスト抽出処理開始時にエラーが発生:', error);
+        return {
+          success: false,
+          error: (error as Error).message,
+        };
+      }
+    },
+  );
+
+  // チェックリストの更新ハンドラ
+  ipcMain.handle(
+    IpcChannels.REVIEW_UPDATE_CHECKLIST,
+    async (
+      _,
+      {
+        reviewHistoryId,
+        checklistEdits,
+      }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_UPDATE_CHECKLIST],
+    ): Promise<
+      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_UPDATE_CHECKLIST]
+    > => {
+      try {
+        const service = ReviewService.getInstance();
+        const result = await service.updateChecklists(
+          reviewHistoryId,
+          checklistEdits,
+        );
+
+        return result;
+      } catch (error) {
+        console.error('チェックリストの更新中にエラーが発生:', error);
+        return {
+          success: false,
+          error: (error as Error).message,
+        };
+      }
+    },
+  );
+
+  // レビュー実施ハンドラ
+  ipcMain.handle(
+    IpcChannels.REVIEW_EXECUTE_CALL,
+    async (
+      event,
+      {
+        reviewHistoryId,
+        sourceIds,
+      }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL],
+    ): Promise<
+      IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL]
+    > => {
+      try {
+        const manager = SourceReviewManager.getInstance();
+
+        // 非同期でレビュー実行処理を実行
+        manager.executeReviewWithNotification(
+          reviewHistoryId,
+          sourceIds,
+          event,
+        );
+
+        return { success: true };
+      } catch (error) {
+        console.error('レビュー実行処理開始中にエラーが発生:', error);
+        return {
+          success: false,
+          error: (error as Error).message,
+        };
+      }
+    },
+  );
+};
+
 // ソース登録処理の実行
 const initializeSourceRegistration = async () => {
   console.log('ソースファイルの初期登録を開始します...');
@@ -820,6 +1002,7 @@ const initialize = async () => {
   setupChatHandlers();
   setupFsHandlers();
   setupSourceHandlers();
+  setupReviewHandlers();
   initializeSourceRegistration();
 };
 
diff --git a/src/main/preload.ts b/src/main/preload.ts
index 536963ac2..7d6a12b9b 100644
--- a/src/main/preload.ts
+++ b/src/main/preload.ts
@@ -167,6 +167,107 @@ const electronHandler = {
       });
     },
   },
+  review: {
+    // レビュー履歴一覧を取得する
+    getHistories: async (): Promise<
+      IpcResponsePayload<typeof IpcChannels.REVIEW_GET_HISTORIES>
+    > => {
+      return ipcRenderer.invoke(IpcChannels.REVIEW_GET_HISTORIES);
+    },
+    // レビュー履歴詳細を取得する
+    getHistoryDetail: async (
+      historyId: string,
+    ): Promise<
+      IpcResponsePayload<typeof IpcChannels.REVIEW_GET_HISTORY_DETAIL>
+    > => {
+      return ipcRenderer.invoke(
+        IpcChannels.REVIEW_GET_HISTORY_DETAIL,
+        historyId,
+      );
+    },
+    // レビュー履歴を削除する
+    deleteHistory: async (
+      historyId: string,
+    ): Promise<
+      IpcResponsePayload<typeof IpcChannels.REVIEW_DELETE_HISTORY>
+    > => {
+      return ipcRenderer.invoke(IpcChannels.REVIEW_DELETE_HISTORY, historyId);
+    },
+    // チェックリストを抽出する
+    extractChecklist: async (
+      params: IpcRequestPayload<
+        typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL
+      >,
+    ): Promise<
+      IpcResponsePayload<typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL>
+    > => {
+      return ipcRenderer.invoke(
+        IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL,
+        params,
+      );
+    },
+    // チェックリストを更新する
+    updateChecklist: async (
+      params: IpcRequestPayload<typeof IpcChannels.REVIEW_UPDATE_CHECKLIST>,
+    ): Promise<
+      IpcResponsePayload<typeof IpcChannels.REVIEW_UPDATE_CHECKLIST>
+    > => {
+      return ipcRenderer.invoke(IpcChannels.REVIEW_UPDATE_CHECKLIST, params);
+    },
+    // ドキュメントレビューを実行する
+    execute: async (
+      params: IpcRequestPayload<typeof IpcChannels.REVIEW_EXECUTE_CALL>,
+    ): Promise<IpcResponsePayload<typeof IpcChannels.REVIEW_EXECUTE_CALL>> => {
+      return ipcRenderer.invoke(IpcChannels.REVIEW_EXECUTE_CALL, params);
+    },
+    // チェックリスト抽出完了イベントを購読する
+    onExtractChecklistFinished: (
+      callback: (
+        payload: IpcEventPayload<
+          typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
+        >,
+      ) => void,
+    ) => {
+      const subscription = (
+        _event: IpcRendererEvent,
+        payload: IpcEventPayload<
+          typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
+        >,
+      ) => {
+        callback(payload);
+      };
+      ipcRenderer.on(
+        IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+        subscription,
+      );
+      return () => {
+        ipcRenderer.removeListener(
+          IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+          subscription,
+        );
+      };
+    },
+    // ドキュメントレビュー実行完了イベントを購読する
+    onExecuteReviewFinished: (
+      callback: (
+        payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
+      ) => void,
+    ) => {
+      const subscription = (
+        _event: IpcRendererEvent,
+        payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
+      ) => {
+        callback(payload);
+      };
+      ipcRenderer.on(IpcChannels.REVIEW_EXECUTE_FINISHED, subscription);
+      return () => {
+        ipcRenderer.removeListener(
+          IpcChannels.REVIEW_EXECUTE_FINISHED,
+          subscription,
+        );
+      };
+    },
+  },
   ipcRenderer: {
     sendMessage(channel: Channels, ...args: unknown[]) {
       ipcRenderer.send(channel, ...args);
diff --git a/src/main/service/review/reviewService.ts b/src/main/service/review/reviewService.ts
new file mode 100644
index 000000000..bad0141b2
--- /dev/null
+++ b/src/main/service/review/reviewService.ts
@@ -0,0 +1,94 @@
+import { getReviewRepository } from '../../../db/repository/reviewRepository';
+import { ReviewChecklistEdit } from '../../types';
+import { generateReviewTitle } from '../../../mastra/workflows/sourceReview/lib';
+
+export class ReviewService {
+  /**
+   * シングルトンインスタンスを保持
+   */
+  // eslint-disable-next-line
+  private static instance: ReviewService | null = null;
+
+  private repository = getReviewRepository();
+
+  /**
+   * シングルトンインスタンスを取得
+   */
+  public static getInstance(): ReviewService {
+    if (!ReviewService.instance) {
+      ReviewService.instance = new ReviewService();
+    }
+    return ReviewService.instance;
+  }
+
+  /**
+   * レビュー履歴一覧を取得
+   */
+  public async getReviewHistories() {
+    return this.repository.getAllReviewHistories();
+  }
+
+  /**
+   * レビュー履歴の詳細（チェックリスト結果）を取得
+   */
+  public async getReviewHistoryDetail(reviewHistoryId: string) {
+    return this.repository.getReviewChecklistResults(reviewHistoryId);
+  }
+
+  /**
+   * レビュー履歴を削除
+   */
+  public async deleteReviewHistory(reviewHistoryId: string) {
+    return this.repository.deleteReviewHistory(reviewHistoryId);
+  }
+
+  /**
+   * チェックリストを更新
+   */
+  public async updateChecklists(
+    reviewHistoryId: string,
+    checklistEdits: ReviewChecklistEdit[],
+  ) {
+    try {
+      // レビュー履歴が存在しない場合は新規作成
+      let reviewHistory =
+        await this.repository.getReviewHistory(reviewHistoryId);
+      if (reviewHistory === null) {
+        reviewHistory = await this.repository.createReviewHistory(
+          generateReviewTitle(),
+          reviewHistoryId,
+        );
+      }
+
+      // チェックリストの編集を実行
+      // 現状は一度に一つのチェックリスト編集しか行わない（checklistEditsの要素数は1つ）の想定なので、トランザクション制御などは行わない
+      for (const edit of checklistEdits) {
+        if (edit.id === null) {
+          // 新規作成
+          if (edit.content) {
+            await this.repository.createChecklist(
+              reviewHistoryId,
+              edit.content,
+              'user',
+            );
+          }
+        } else if (edit.delete) {
+          // 削除
+          await this.repository.deleteChecklist(edit.id);
+        } else if (edit.content) {
+          // 更新
+          await this.repository.updateChecklist(edit.id, edit.content);
+        }
+      }
+
+      return { success: true };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      return {
+        success: false,
+        error: `チェックリスト更新処理でエラーが発生しました: ${errorMessage}`,
+      };
+    }
+  }
+}
diff --git a/src/main/types/index.ts b/src/main/types/index.ts
index f3ae2c765..fc3d86996 100644
--- a/src/main/types/index.ts
+++ b/src/main/types/index.ts
@@ -47,3 +47,43 @@ export type AgentBootStatus = {
   messages?: AgentBootMessage[];
   tools?: AgentToolStatus;
 };
+
+// レビュー評価の型定義
+export type ReviewEvaluation = 'A' | 'B' | 'C';
+
+// チェックリストの作成元
+export type ReviewChecklistCreatedBy = 'user' | 'system';
+
+// 最終的に画面に表示するチェックリストの型
+export type ReviewChecklistResult = {
+  id: number; // チェックリストのID
+  content: string;
+  sourceEvaluations?: {
+    sourceId: number;
+    sourceFileName: string;
+    evaluation?: ReviewEvaluation;
+    comment?: string;
+  }[];
+};
+
+// チェックリストの編集内容を表す型
+export type ReviewChecklistEdit = {
+  id: number | null; // 新規作成時はnull
+  content?: string; // 削除の場合は指定不要
+  delete?: boolean; // trueの場合は削除対象
+};
+
+// パス定義
+export const ROUTES = {
+  CHAT: '/',
+  REVIEW: '/review',
+} as const;
+
+/**
+ * リポジトリ操作の結果型
+ */
+export type RepositoryResult<T> = {
+  success: boolean;
+  data?: T;
+  error?: string;
+};
diff --git a/src/main/types/ipc.ts b/src/main/types/ipc.ts
index 137105d47..462650f93 100644
--- a/src/main/types/ipc.ts
+++ b/src/main/types/ipc.ts
@@ -1,5 +1,11 @@
-import type { ChatMessage, ChatRoom, AgentBootStatus } from '.';
-import type { Source } from '../../db/schema';
+import type {
+  ChatMessage,
+  ChatRoom,
+  AgentBootStatus,
+  ReviewChecklistResult,
+  ReviewChecklistEdit,
+} from '.';
+import type { Source, ReviewHistory } from '../../db/schema';
 
 /**
  * IPC通信で使用するチャネル名の定義
@@ -35,6 +41,16 @@ export const IpcChannels = {
 
   // ファイルシステム関連
   FS_CHECK_PATH_EXISTS: 'fs-check-path-exists',
+
+  // ドキュメントレビュー関連
+  REVIEW_GET_HISTORIES: 'review-get-histories', // ドキュメント履歴切り替え時やチェックリスト抽出・ドキュメントレビュー時のポーリング処理にて呼び出される
+  REVIEW_GET_HISTORY_DETAIL: 'review-get-history-detail',
+  REVIEW_DELETE_HISTORY: 'review-delete-history',
+  REVIEW_EXTRACT_CHECKLIST_CALL: 'review-extract-checklist-call', // チェックリスト抽出処理を開始する
+  REVIEW_EXTRACT_CHECKLIST_FINISHED: 'review-extract-checklist-finished', // チェックリスト抽出が完了した際の通知
+  REVIEW_UPDATE_CHECKLIST: 'review-update-checklist',
+  REVIEW_EXECUTE_CALL: 'review-execute', // ドキュメントレビューを開始する
+  REVIEW_EXECUTE_FINISHED: 'review-execute-finished', // レビュー実行が完了した際の通知
 } as const;
 
 export type IpcChannel = (typeof IpcChannels)[keyof typeof IpcChannels];
@@ -75,6 +91,23 @@ export type IpcRequestPayloadMap = {
     oldContent: string;
     oldCreatedAt: Date;
   };
+
+  // ドキュメントレビュー関連
+  [IpcChannels.REVIEW_GET_HISTORIES]: undefined;
+  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: string; // review history id
+  [IpcChannels.REVIEW_DELETE_HISTORY]: string; // review history id
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
+    reviewHistoryId: string;
+    sourceIds: number[];
+  };
+  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: {
+    reviewHistoryId: string;
+    checklistEdits: ReviewChecklistEdit[];
+  };
+  [IpcChannels.REVIEW_EXECUTE_CALL]: {
+    reviewHistoryId: string;
+    sourceIds: number[];
+  };
 };
 
 export type IpcResponsePayloadMap = {
@@ -107,12 +140,45 @@ export type IpcResponsePayloadMap = {
   [IpcChannels.CHAT_CREATE_THREAD]: { success: boolean; error?: string };
   [IpcChannels.CHAT_ABORT_REQUEST]: { success: boolean; error?: string };
   [IpcChannels.CHAT_EDIT_HISTORY]: { success: boolean; error?: string };
+
+  // ドキュメントレビュー関連
+  [IpcChannels.REVIEW_GET_HISTORIES]: {
+    success: boolean;
+    histories?: ReviewHistory[];
+    error?: string;
+  };
+  [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: {
+    success: boolean;
+    checklistResults?: ReviewChecklistResult[];
+    error?: string;
+  };
+  [IpcChannels.REVIEW_DELETE_HISTORY]: { success: boolean; error?: string };
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
+    success: boolean;
+    error?: string;
+  };
+  [IpcChannels.REVIEW_UPDATE_CHECKLIST]: {
+    success: boolean;
+    error?: string;
+  };
+  [IpcChannels.REVIEW_EXECUTE_CALL]: {
+    success: boolean;
+    error?: string;
+  };
 };
 
 export type IpcEventPayloadMap = {
   [IpcChannels.CHAT_STREAM]: any; // AI SDKが定義するDataStreamが入る想定(型がexportされていないためany型)
   [IpcChannels.CHAT_COMPLETE]: unknown;
   [IpcChannels.CHAT_ERROR]: { message: string };
+  [IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED]: {
+    success: boolean;
+    error?: string;
+  };
+  [IpcChannels.REVIEW_EXECUTE_FINISHED]: {
+    success: boolean;
+    error?: string;
+  };
 };
 
 /**
diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
index b6666041e..59e7f80a2 100644
--- a/src/mastra/agents/prompts.ts
+++ b/src/mastra/agents/prompts.ts
@@ -225,3 +225,54 @@ If information is not found in the document, respond with "This information is n
 Document:
 ${content}
 `;
+
+/**
+ * チェックリスト抽出用のシステムプロンプト
+ */
+export const CHECKLIST_EXTRACTION_SYSTEM_PROMPT = `
+You are a checklist extraction assistant.
+Given a document, first decide whether it is a checklist document.
+Then, extract **every checklist item** exactly as written, **without changing or paraphrasing**.
+Ensure you never omit or alter any checklist text.
+Respond with the checklist items in Japanese.
+`;
+
+/**
+ * チェックリストのトピック分類用のシステムプロンプト
+ */
+export const CHECKLIST_CATEGORY_CLASSIFICATION_SYSTEM_PROMPT = `
+You are a categorization assistant.
+When given a list of checklists (each with an ID and content), partition them into up to 10 meaningful categories.
+Important: Every single checklist item must be assigned to one category. No items should be left unclassified.
+`;
+
+/**
+ * Generates the system prompt for the document review execution agent.
+ * @param checklists - Array of checklist items with id and content
+ * @returns A string to use as system instructions for the review agent
+ */
+export function getDocumentReviewExecutionPrompt(
+  checklists: Array<{ id: number; content: string }>,
+): string {
+  // Build a human-readable list of checklist items
+  const formattedList = checklists
+    .map((item) => `ID: ${item.id} - ${item.content}`)
+    .join('\n');
+
+  return `You are a professional document reviewer. Your job is to evaluate the user-provided document against a set of checklist items.
+
+Checklist items:
+${formattedList}
+
+Instructions:
+1. For each checklist item, assign one of the following ratings:
+   - A: Excellent - fully meets the criterion.
+   - B: Satisfactory - partially meets the criterion.
+   - C: Needs Improvement - does not meet the criterion.
+2. Provide a comment in Japanese for each item.
+   - Discuss every relevant part of the document that corresponds to the item.
+   - If some sections satisfy the item and others do not, comment on each occurrence separately; do not offer only a general summary.
+3. Ensure no checklist item is omitted.
+4. Review the entire document for each checklist item before concluding.
+`;
+}
diff --git a/src/mastra/workflows/schema.ts b/src/mastra/workflows/schema.ts
new file mode 100644
index 000000000..ac31676c6
--- /dev/null
+++ b/src/mastra/workflows/schema.ts
@@ -0,0 +1,7 @@
+import { z } from 'zod';
+
+// 各ステップの共通出力スキーマ部分
+export const baseStepOutputSchema = z.object({
+  status: z.enum(['success', 'failed']),
+  errorMessage: z.string().optional(),
+});
diff --git a/src/mastra/workflows/sourceRegistration.ts b/src/mastra/workflows/sourceRegistration.ts
index d046c267a..0976417a4 100644
--- a/src/mastra/workflows/sourceRegistration.ts
+++ b/src/mastra/workflows/sourceRegistration.ts
@@ -10,6 +10,8 @@ import {
   EXTRACT_TOPIC_AND_SUMMARY_SYSTEM_PROMPT,
 } from '../agents/prompts';
 import openAICompatibleModel from '../agents/model/openAICompatible';
+import { stepStatus } from './types';
+import { baseStepOutputSchema } from './schema';
 
 // ファイルパスを入力とするスキーマ
 const triggerSchema = z.object({
@@ -17,14 +19,6 @@ const triggerSchema = z.object({
   content: z.string().describe('登録するソースの内容'),
 });
 
-type stepStatus = 'success' | 'failed';
-
-// 各ステップの共通出力スキーマ部分
-const baseStepOutputSchema = z.object({
-  status: z.enum(['success', 'failed']),
-  errorMessage: z.string().optional(),
-});
-
 // ソース分析と登録のステップ
 const analyzeSourceStep = new Step({
   id: 'analyzeSourceStep',
diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
new file mode 100644
index 000000000..47a4aba0d
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
@@ -0,0 +1,149 @@
+import { Step, Workflow } from '@mastra/core/workflows';
+import { z } from 'zod';
+import { Agent } from '@mastra/core/agent';
+import path from 'path';
+import { getReviewRepository } from '../../../db/repository/reviewRepository';
+import { getSourceRepository } from '../../../db/repository/sourceRepository';
+import { CHECKLIST_EXTRACTION_SYSTEM_PROMPT } from '../../agents/prompts';
+import { Source } from '../../../db/schema';
+import FileExtractor from '../../../main/utils/fileExtractor';
+import { baseStepOutputSchema } from '../schema';
+import { stepStatus } from '../types';
+import openAICompatibleModel from '../../agents/model/openAICompatible';
+
+// ワークフローの入力スキーマ
+const triggerSchema = z.object({
+  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+  sourceIds: z
+    .array(z.number())
+    .describe('チェックリストを抽出するソースのIDリスト'),
+});
+
+const checklistExtractionStep = new Step({
+  id: 'checklistExtractionStep',
+  description: '各ソースからチェックリストを抽出するステップ',
+  outputSchema: baseStepOutputSchema,
+  execute: async ({ context }) => {
+    // レビュー用のリポジトリを取得
+    const reviewRepository = getReviewRepository();
+    const sourceRepository = getSourceRepository();
+    // トリガーから入力を取得
+    const { reviewHistoryId, sourceIds } = context.triggerData as z.infer<
+      typeof triggerSchema
+    >;
+    const errorMessages: string[] = [
+      'チェックリスト抽出処理で以下エラーが発生しました',
+    ];
+
+    try {
+      // 既存のシステム作成チェックリストを削除
+      await reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
+
+      // 各ソースを並行して処理
+      const extractionPromises = sourceIds.map(async (sourceId) => {
+        let source: Source | null = null;
+        try {
+          source = await sourceRepository.getSourceById(sourceId);
+
+          if (source === null) {
+            throw new Error(`ソースID ${sourceId} が見つかりません`);
+          }
+
+          // ファイル内容を抽出
+          const { content } = await FileExtractor.extractText(source.path);
+
+          const checklistExtractionAgent = new Agent({
+            name: 'checklistExtractionAgent',
+            instructions: CHECKLIST_EXTRACTION_SYSTEM_PROMPT,
+            model: openAICompatibleModel(),
+          });
+          const outputSchema = z.object({
+            isChecklistDocument: z
+              .boolean()
+              .describe('Whether the given source is a checklist document'),
+            checklists: z
+              .array(z.string().describe('Checklist item'))
+              .optional()
+              .describe('Extracted checklists'),
+          });
+
+          const extractionResult = await checklistExtractionAgent.generate(
+            content,
+            {
+              output: outputSchema,
+            },
+          );
+
+          if (!extractionResult.object.isChecklistDocument) {
+            throw new Error(
+              `ソース "${source.title}" はチェックリスト抽出に適さないドキュメントです`,
+            );
+          }
+
+          if (
+            !extractionResult.object.checklists ||
+            extractionResult.object.checklists.length === 0
+          ) {
+            throw new Error(
+              `ソース "${source.title}" からチェックリストが抽出されませんでした`,
+            );
+          }
+
+          // 抽出されたチェックリストをDBに保存
+          for (const checklistItem of extractionResult.object.checklists) {
+            await reviewRepository.createChecklist(
+              reviewHistoryId,
+              checklistItem,
+              'system',
+            );
+          }
+        } catch (error) {
+          const errorMessageList: string[] = [];
+          if (source) {
+            errorMessageList.push(
+              `${path.basename(source.path)}のチェックリスト抽出でエラー: `,
+            );
+          }
+          errorMessageList.push(
+            error instanceof Error ? error.message : '不明なエラー',
+          );
+          errorMessages.push(errorMessageList.join(''));
+        }
+      });
+
+      // 全ての抽出処理が完了するまで待機
+      await Promise.all(extractionPromises);
+
+      // エラーがあれば失敗として返す
+      if (errorMessages.length > 1) {
+        throw new Error();
+      }
+
+      return {
+        status: 'success' as stepStatus,
+      };
+    } catch (error) {
+      errorMessages.push(
+        error instanceof Error && error.message
+          ? error.message
+          : '不明なエラー',
+      );
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: errorMessages.join('\n'),
+      };
+    }
+  },
+});
+
+/**
+ * 各ソースからチェックリストを抽出するワークフロー
+ */
+export const checklistExtractionWorkflow = new Workflow({
+  name: 'checklistExtractionWorkflow',
+  triggerSchema,
+});
+
+// ワークフローを構築
+// eslint-disable-next-line
+checklistExtractionWorkflow.step(checklistExtractionStep).commit();
diff --git a/src/mastra/workflows/sourceReview/lib.ts b/src/mastra/workflows/sourceReview/lib.ts
new file mode 100644
index 000000000..39ea5f89a
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/lib.ts
@@ -0,0 +1,9 @@
+import { format } from 'date-fns';
+
+export function generateReviewTitle(sourceTitles: string[] = []): string {
+  const now = format(new Date(), 'yyyy-MM-dd HH:mm:ss');
+  if (sourceTitles.length > 0) {
+    return sourceTitles.join(' / ');
+  }
+  return `New Review-${now}`;
+}
diff --git a/src/mastra/workflows/sourceReview/reviewExecution.ts b/src/mastra/workflows/sourceReview/reviewExecution.ts
new file mode 100644
index 000000000..0bcd99f46
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/reviewExecution.ts
@@ -0,0 +1,297 @@
+import { Workflow, Step } from '@mastra/core/workflows';
+import { Agent } from '@mastra/core/agent';
+import { z } from 'zod';
+import path from 'path';
+import { getReviewRepository } from '../../../db/repository/reviewRepository';
+import { getSourceRepository } from '../../../db/repository/sourceRepository';
+import {
+  CHECKLIST_CATEGORY_CLASSIFICATION_SYSTEM_PROMPT,
+  getDocumentReviewExecutionPrompt,
+} from '../../agents/prompts';
+import FileExtractor from '../../../main/utils/fileExtractor';
+import type { ReviewEvaluation } from '../../../main/types';
+import { baseStepOutputSchema } from '../schema';
+import openAICompatibleModel from '../../agents/model/openAICompatible';
+import { stepStatus } from '../types';
+
+// カテゴリ分類ステップの出力スキーマ
+const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
+  categories: z
+    .array(
+      z.object({
+        name: z.string(),
+        checklists: z.array(
+          z.object({
+            id: z.number(),
+            content: z.string().describe('チェックリストの内容'),
+          }),
+        ),
+      }),
+    )
+    .optional(),
+});
+
+// ワークフローの入力スキーマ
+const triggerSchema = z.object({
+  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+  sourceIds: z.array(z.number()).describe('レビュー対象ソースのIDリスト'),
+});
+
+/**
+ * レビュー実行ワークフロー
+ */
+export const reviewExecutionWorkflow = new Workflow({
+  name: 'reviewExecutionWorkflow',
+  triggerSchema,
+});
+
+// ステップ1: チェックリストをカテゴリごとに分類
+const classifyChecklistsByCategoryStep = new Step({
+  id: 'classifyChecklistsByCategoryStep',
+  description: 'チェックリストをカテゴリごとに分類するステップ',
+  outputSchema: classifyChecklistsByCategoryOutputSchema,
+  execute: async ({ context }) => {
+    // トリガーから入力を取得
+    const { reviewHistoryId } = context.triggerData as z.infer<
+      typeof triggerSchema
+    >;
+
+    // レビューリポジトリを取得
+    const repository = getReviewRepository();
+
+    try {
+      // チェックリストを取得
+      const checklistsResult = await repository.getChecklists(reviewHistoryId);
+      if (!checklistsResult || checklistsResult.length === 0) {
+        throw new Error('レビュー対象のチェックリストが見つかりません');
+      }
+
+      // チェックリストデータを整形
+      const checklistData = checklistsResult.map((c) => ({
+        id: c.id,
+        content: c.content,
+      }));
+
+      // カテゴリ分類エージェントを使用して分類
+      const classifiCategoryAgent = new Agent({
+        name: 'classifyCategoryAgent',
+        instructions: CHECKLIST_CATEGORY_CLASSIFICATION_SYSTEM_PROMPT,
+        model: openAICompatibleModel(),
+      });
+      const outputSchema = z.object({
+        categories: z
+          .array(
+            z.object({
+              name: z.string().describe('Category name'),
+              checklistIds: z
+                .array(z.number())
+                .describe('Array of checklist IDs belonging to the category'),
+            }),
+          )
+          .describe('Classified categories'),
+      });
+      // チェックリスト項目をカテゴリごとに分類
+      const classificationResult = await classifiCategoryAgent.generate(
+        `checklist items:
+  ${checklistData.map((item) => `ID: ${item.id} - ${item.content}`).join('\n')}`,
+        {
+          output: outputSchema,
+        },
+      );
+      // 分類結果の妥当性をチェック
+      // 全てのチェックリストが分類されているか確認
+      const classifiedChecklists = classificationResult.object.categories;
+      if (!classifiedChecklists || classifiedChecklists.length === 0) {
+        throw new Error('チェックリストの分類に失敗しました');
+      }
+      const checklistIds = new Set(checklistData.map((c) => c.id));
+      const categorizedChecklistIds = new Set(
+        classifiedChecklists.flatMap((c) => c.checklistIds),
+      );
+      // 分類されていないチェックリストを「その他」カテゴリに追加
+      const uncategorizedChecklistIds = Array.from(checklistIds).filter(
+        (id) => !categorizedChecklistIds.has(id),
+      );
+      if (uncategorizedChecklistIds.length > 0) {
+        classifiedChecklists.push({
+          name: 'その他',
+          checklistIds: uncategorizedChecklistIds,
+        });
+      }
+      // 複数カテゴリに属するチェックリストは、最初のカテゴリにのみ属するようにする
+      const seen = new Set<number>();
+      const categories = classifiedChecklists.map(
+        ({ name, checklistIds: cIds }) => {
+          // そのカテゴリで初めて現れるIDだけを取り出す
+          const uniqueIds = cIds.filter((id) => !seen.has(id));
+          uniqueIds.forEach((id) => seen.add(id));
+          // content をつけたオブジェクトに変換
+          const checklists = uniqueIds.map((id) => {
+            const item = checklistData.find((c) => c.id === id)!;
+            return { id: item.id, content: item.content };
+          });
+          return { name, checklists };
+        },
+      );
+      return {
+        status: 'success' as stepStatus,
+        categories,
+      };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: `ドキュメントレビュー実行時にエラーが発生しました: ${errorMessage}`,
+      };
+    }
+  },
+});
+
+// ステップ2: チェックリストごとにレビューを実行
+const reviewExecutionStep = new Step({
+  id: 'reviewExecutionStep',
+  description: 'チェックリストごとにレビューを実行するステップ',
+  outputSchema: baseStepOutputSchema,
+  execute: async ({ context }) => {
+    // レビュー対象のソースID
+    const { sourceIds } = context.triggerData as z.infer<typeof triggerSchema>;
+    // ステップ1からの入力を取得
+    const { categories } = context.getStepResult(
+      'classifyChecklistsByCategoryStep',
+    )! as z.infer<typeof classifyChecklistsByCategoryOutputSchema>;
+
+    // リポジトリを取得
+    const reviewRepository = getReviewRepository();
+    const sourceRepository = getSourceRepository();
+
+    // チェックリストを全量チェックできなかったドキュメントを格納
+    // key: ファイル名, value: エラー内容
+    const errorDocuments = new Map<string, string[]>();
+
+    try {
+      const reviewAgent = new Agent({
+        name: 'reviewAgent',
+        instructions: '',
+        model: openAICompatibleModel(),
+      });
+
+      // 各カテゴリ、ソースごとにレビューを実行
+      for (const category of categories!) {
+        for (const sourceId of sourceIds) {
+          // ソースの内容を取得
+          const source = await sourceRepository.getSourceById(sourceId);
+          if (!source) {
+            throw new Error(`ソースID ${sourceId} が見つかりません`);
+          }
+          const { content } = await FileExtractor.extractText(source.path);
+          // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
+          // レビュー結果に含まれなかったチェックリストは再度レビューを実行する（最大試行回数は3回）
+          const maxAttempts = 3;
+          let attempt = 0;
+          let reviewTargetChecklists = category.checklists;
+          while (attempt < maxAttempts) {
+            try {
+              const outputSchema = z.array(
+                z.object({
+                  checklistId: z.number(),
+                  evaluation: z.enum(['A', 'B', 'C']).describe('evaluation'),
+                  comment: z.string().describe('evaluation comment'),
+                }),
+              );
+              // レビューエージェントを使用してレビューを実行
+              const reviewResult = await reviewAgent.generate(content, {
+                output: outputSchema,
+                instructions: getDocumentReviewExecutionPrompt(
+                  reviewTargetChecklists,
+                ),
+              });
+              // レビュー結果をDBに保存
+              await reviewRepository.upsertReviewResult(
+                reviewResult.object.map((result) => ({
+                  reviewChecklistId: result.checklistId,
+                  sourceId,
+                  evaluation: result.evaluation as ReviewEvaluation,
+                  comment: result.comment,
+                })),
+              );
+              // レビュー結果に含まれなかったチェックリストを抽出
+              const reviewedChecklistIds = new Set(
+                reviewResult.object.map((result) => result.checklistId),
+              );
+              reviewTargetChecklists = reviewTargetChecklists.filter(
+                (checklist) => !reviewedChecklistIds.has(checklist.id),
+              );
+              if (reviewTargetChecklists.length === 0) {
+                // 全てのチェックリストがレビューされた場合、成功
+                break;
+              }
+            } catch (error) {
+              const errorMessage =
+                error instanceof Error ? error.message : '不明なエラー';
+              // レビューに失敗したチェックリストを記録
+              if (!errorDocuments.has(path.basename(source.path))) {
+                errorDocuments.set(path.basename(source.path), []);
+              }
+              errorDocuments
+                .get(path.basename(source.path))!
+                .push(errorMessage);
+            } finally {
+              attempt += 1;
+            }
+          }
+          if (attempt >= maxAttempts) {
+            // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
+            if (!errorDocuments.has(path.basename(source.path))) {
+              errorDocuments.set(path.basename(source.path), []);
+            }
+            errorDocuments
+              .get(path.basename(source.path))!
+              .push(
+                `最大試行回数(${maxAttempts})内で全てのチェックリストに対してレビューが完了しませんでした`,
+              );
+          }
+        }
+      }
+      // errorDocumentsが空でない場合、レビューに失敗したドキュメントを返す
+      if (errorDocuments.size > 0) {
+        const errorMessage = `以下ドキュメントのレビュー中にエラーが発生しました:
+        ${Array.from(errorDocuments.entries())
+          .map(
+            ([fileName, errors]) =>
+              `${fileName}:\n  - ${errors.join('\n  - ')}`,
+          )
+          .join('\n')}`;
+        return {
+          status: 'failed' as stepStatus,
+          errorMessage,
+        };
+      }
+      // 全てのレビューが成功した場合
+      return {
+        status: 'success' as stepStatus,
+        output: {
+          success: true,
+        },
+      };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: `ドキュメントレビュー実行時にエラーが発生しました: ${errorMessage}`,
+      };
+    }
+  },
+});
+
+// ワークフローを構築
+// eslint-disable-next-line
+reviewExecutionWorkflow
+  .step(classifyChecklistsByCategoryStep)
+  .then(reviewExecutionStep, {
+    when: {
+      'classifyChecklistsByCategoryStep.status': 'success',
+    },
+  })
+  .commit();
diff --git a/src/mastra/workflows/sourceReview/sourceReviewManager.ts b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
new file mode 100644
index 000000000..f86a197ba
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
@@ -0,0 +1,309 @@
+import { IpcMainInvokeEvent } from 'electron';
+import { getReviewRepository } from '../../../db/repository/reviewRepository';
+import { getSourceRepository } from '../../../db/repository/sourceRepository';
+import { getMastra } from '../../../main/main';
+import {
+  IpcChannels,
+  IpcEventPayloadMap,
+  IpcResponsePayloadMap,
+} from '../../../main/types/ipc';
+import { generateReviewTitle } from './lib';
+import { ReviewHistory } from '../../../db/schema';
+
+/**
+ * ソースレビュー処理を管理するクラス
+ */
+export default class SourceReviewManager {
+  // eslint-disable-next-line
+  private static instance: SourceReviewManager | null = null;
+
+  private reviewRepository = getReviewRepository();
+
+  private sourceRepository = getSourceRepository();
+
+  /**
+   * シングルトンインスタンスを取得
+   */
+  public static getInstance(): SourceReviewManager {
+    if (!SourceReviewManager.instance) {
+      SourceReviewManager.instance = new SourceReviewManager();
+    }
+    return SourceReviewManager.instance;
+  }
+
+  /**
+   * チェックリスト抽出処理を実行
+   * @param reviewHistoryId レビュー履歴ID（新規の場合は生成）
+   * @param sourceIds ソースIDの配列
+   * @returns 処理結果
+   */
+  public async extractChecklist(
+    reviewHistoryId: string,
+    sourceIds: number[],
+  ): Promise<{ success: boolean; error?: string }> {
+    try {
+      let reviewHistory: ReviewHistory | null;
+      reviewHistory =
+        await this.reviewRepository.getReviewHistory(reviewHistoryId);
+      // レビュー履歴が存在しない場合は新規作成
+      if (reviewHistory === null) {
+        reviewHistory = await this.reviewRepository.createReviewHistory(
+          generateReviewTitle(),
+          reviewHistoryId,
+        );
+      } else {
+        // 既存のレビュー履歴がある場合は、システム作成チェックリストを削除
+        await this.reviewRepository.deleteSystemCreatedChecklists(
+          reviewHistory.id,
+        );
+      }
+
+      let success = false;
+      let errorMessage;
+
+      // Mastraワークフローを実行
+      const mastra = getMastra();
+      const workflow = mastra.getWorkflow('checklistExtractionWorkflow');
+
+      if (!workflow) {
+        return {
+          success: false,
+          error: 'チェックリスト抽出ワークフローが見つかりません',
+        };
+      }
+
+      const run = workflow.createRun();
+      const runResult = await run.start({
+        triggerData: {
+          reviewHistoryId,
+          sourceIds,
+        },
+      });
+
+      // 結果を確認
+      const extractResult = runResult.results.checklistExtractionStep;
+      switch (extractResult.status) {
+        case 'success':
+          if (extractResult.output?.status === 'success') {
+            success = true;
+          }
+          if (extractResult.output?.status === 'failed') {
+            success = false;
+            errorMessage = extractResult.output.errorMessage;
+          }
+          break;
+        case 'failed':
+          success = false;
+          errorMessage = extractResult.error;
+          break;
+        default:
+          success = false;
+          errorMessage = 'チェックリスト抽出処理が不明な状態で終了しました';
+      }
+      return {
+        success,
+        error: errorMessage,
+      };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      return {
+        success: false,
+        error: `チェックリスト抽出処理でエラーが発生しました: ${errorMessage}`,
+      };
+    }
+  }
+
+  /**
+   * レビュー実行処理を実行
+   * @param reviewHistoryId レビュー履歴ID
+   * @param sourceIds ソースIDの配列
+   * @returns 処理結果
+   */
+  public async executeReview(
+    reviewHistoryId: string,
+    sourceIds: number[],
+  ): Promise<{ success: boolean; error?: string }> {
+    try {
+      // レビュー履歴の存在確認
+      const reviewHistory =
+        await this.reviewRepository.getReviewHistory(reviewHistoryId);
+      if (!reviewHistory) {
+        return {
+          success: false,
+          error: `チェックリストが一度も作成されていません`,
+        };
+      }
+
+      let success = false;
+      let errorMessage;
+
+      // Mastraワークフローを実行
+      const mastra = getMastra();
+      const workflow = mastra.getWorkflow('reviewExecutionWorkflow');
+
+      if (!workflow) {
+        return {
+          success: false,
+          error: 'レビュー実行ワークフローが見つかりません',
+        };
+      }
+
+      // タイトルの変更
+      // 全てのソースを取得
+      const sources = await this.sourceRepository.getSourcesByIds(sourceIds);
+      const reviewTitle = generateReviewTitle(sources.map((s) => s.title));
+      // レビュー履歴のタイトルを更新
+      await this.reviewRepository.updateReviewHistoryTitle(
+        reviewHistory.id,
+        reviewTitle,
+      );
+
+      const run = workflow.createRun();
+      const result = await run.start({
+        triggerData: {
+          reviewHistoryId,
+          sourceIds,
+        },
+      });
+
+      // 結果を確認
+      for (const step of Object.values(result.results)) {
+        switch (step.status) {
+          case 'success':
+            if (step.output?.status === 'success') {
+              success = true;
+            }
+            if (step.output?.status === 'failed') {
+              success = false;
+              errorMessage = step.output.errorMessage;
+            }
+            break;
+          case 'failed':
+            success = false;
+            errorMessage = step.error;
+            break;
+          default:
+            success = false;
+            errorMessage = 'レビュー実行処理が不明な状態で終了しました';
+        }
+        if (!success) {
+          break; // 最初の失敗でループを抜ける
+        }
+      }
+      return {
+        success,
+        error: errorMessage,
+      };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      return {
+        success: false,
+        error: `レビュー実行処理でエラーが発生しました: ${errorMessage}`,
+      };
+    }
+  }
+
+  /**
+   * IPC通信でチェックリスト抽出処理を実行し、完了時にイベントを送信
+   * @param reviewHistoryId レビュー履歴ID
+   * @param sourceIds ソースIDの配列
+   * @param mainWindow メインウィンドウ
+   */
+  public extractChecklistWithNotification(
+    reviewHistoryId: string,
+    sourceIds: number[],
+    event: IpcMainInvokeEvent,
+  ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL] {
+    try {
+      this.extractChecklist(reviewHistoryId, sourceIds)
+        .then((res) => {
+          // 完了イベントを送信
+          event.sender.send(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
+            success: res.success,
+            error: res.error,
+          } as IpcEventPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED]);
+          return true;
+        })
+        .catch((error) => {
+          const errorMessage =
+            error instanceof Error ? error.message : '不明なエラー';
+          const errorResult = {
+            success: false,
+            error: errorMessage,
+          };
+          // エラーイベントを送信
+          event.sender.send(
+            IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+            errorResult,
+          );
+        });
+      return {
+        success: true,
+      };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      const errorResult = {
+        success: false,
+        error: errorMessage,
+      };
+      // エラーイベントを送信
+      event.sender.send(
+        IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+        errorResult,
+      );
+      return errorResult;
+    }
+  }
+
+  /**
+   * IPC通信でレビュー実行処理を実行し、完了時にイベントを送信
+   * @param reviewHistoryId レビュー履歴ID
+   * @param sourceIds ソースIDの配列
+   * @param mainWindow メインウィンドウ
+   */
+  public executeReviewWithNotification(
+    reviewHistoryId: string,
+    sourceIds: number[],
+    event: IpcMainInvokeEvent,
+  ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL] {
+    try {
+      this.executeReview(reviewHistoryId, sourceIds)
+        .then((res) => {
+          // 完了イベントを送信
+          event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, {
+            success: res.success,
+            error: res.error,
+          } as IpcEventPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_FINISHED]);
+          return true;
+        })
+        .catch((error) => {
+          const errorMessage =
+            error instanceof Error ? error.message : '不明なエラー';
+          const errorResult = {
+            success: false,
+            error: errorMessage,
+          } as IpcEventPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_FINISHED];
+          // エラーイベントを送信
+          event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, errorResult);
+        });
+      return {
+        success: true,
+      };
+    } catch (error) {
+      const errorMessage =
+        error instanceof Error ? error.message : '不明なエラー';
+      const errorResult = {
+        success: false,
+        error: errorMessage,
+      };
+
+      // エラーイベントを送信
+      event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, errorResult);
+
+      return errorResult;
+    }
+  }
+}
diff --git a/src/mastra/workflows/types.ts b/src/mastra/workflows/types.ts
new file mode 100644
index 000000000..e65eab090
--- /dev/null
+++ b/src/mastra/workflows/types.ts
@@ -0,0 +1 @@
+export type stepStatus = 'success' | 'failed';
diff --git a/src/renderer/App.tsx b/src/renderer/App.tsx
index 542f78114..ca2a750f7 100644
--- a/src/renderer/App.tsx
+++ b/src/renderer/App.tsx
@@ -10,18 +10,22 @@ import {
 import './App.css';
 import Sidebar from './components/sidebar/Sidebar';
 import ChatArea from './components/chat/ChatArea';
+import ReviewArea from './components/review/ReviewArea';
 import SnackbarNotification from './components/common/SnackbarNotification';
 import { sourceService } from './services/sourceService';
+import { ROUTES } from '../main/types';
+import ChatRoomList from './components/sidebar/ChatRoomList';
+import ReviewHistoryList from './components/review/ReviewHistoryList';
 
 // テーマの設定
 const theme = createTheme({
   palette: {
     primary: {
-      main: '#ff7474',
+      main: '#BA0009',
       light: '#ff5252',
     },
     secondary: {
-      main: '#f50057',
+      main: '#BA5F00',
     },
     // background: {
     //   default: '#f5f5f5',
@@ -54,6 +58,9 @@ const theme = createTheme({
 
 function App() {
   const [selectedRoomId, setSelectedRoomId] = useState<string | null>(null);
+  const [selectedReviewHistoryId, setSelectedReviewHistoryId] = useState<
+    string | null
+  >(null);
   const [snackbar, setSnackbar] = useState<{
     open: boolean;
     message: string;
@@ -64,11 +71,6 @@ function App() {
     severity: 'info',
   });
 
-  // チャットルーム選択ハンドラ
-  const handleRoomSelect = (roomId: string) => {
-    setSelectedRoomId(roomId);
-  };
-
   // スナックバー表示ヘルパー
   const showSnackbar = (message: string, severity: AlertColor) => {
     setSnackbar({
@@ -110,38 +112,61 @@ function App() {
     <ThemeProvider theme={theme}>
       <CssBaseline />
       <Router>
-        <Routes>
-          <Route
-            path="/"
-            element={
-              <Box
-                sx={{
-                  display: 'flex',
-                  height: '100vh',
-                }}
-              >
-                {/* サイドバー */}
-                <Sidebar
-                  selectedRoomId={selectedRoomId}
-                  onRoomSelect={handleRoomSelect}
-                  onReloadSources={handleReloadSources}
-                  showSnackbar={showSnackbar}
-                />
+        <Box
+          sx={{
+            display: 'flex',
+            height: '100vh',
+          }}
+        >
+          {/* サイドバー */}
+          <Sidebar
+            onReloadSources={handleReloadSources}
+            showSnackbar={showSnackbar}
+          >
+            <Routes>
+              <Route
+                path={ROUTES.CHAT}
+                element={
+                  <ChatRoomList
+                    onRoomSelect={setSelectedRoomId}
+                    selectedRoomId={selectedRoomId}
+                  />
+                }
+              />
+              <Route
+                path={ROUTES.REVIEW}
+                element={
+                  <ReviewHistoryList
+                    onReviewHistorySelect={setSelectedReviewHistoryId}
+                    selectedReviewHistoryId={selectedReviewHistoryId}
+                  />
+                }
+              />
+            </Routes>
+          </Sidebar>
 
-                {/* メインコンテンツ */}
-                <ChatArea selectedRoomId={selectedRoomId} />
+          {/* メインコンテンツ */}
+          <Routes>
+            <Route
+              path={ROUTES.CHAT}
+              element={<ChatArea selectedRoomId={selectedRoomId} />}
+            />
+            <Route
+              path={ROUTES.REVIEW}
+              element={
+                <ReviewArea selectedReviewHistoryId={selectedReviewHistoryId} />
+              }
+            />
+          </Routes>
 
-                {/* 通知 */}
-                <SnackbarNotification
-                  open={snackbar.open}
-                  message={snackbar.message}
-                  severity={snackbar.severity}
-                  onClose={handleCloseSnackbar}
-                />
-              </Box>
-            }
+          {/* 通知 */}
+          <SnackbarNotification
+            open={snackbar.open}
+            message={snackbar.message}
+            severity={snackbar.severity}
+            onClose={handleCloseSnackbar}
           />
-        </Routes>
+        </Box>
       </Router>
     </ThemeProvider>
   );
diff --git a/src/renderer/components/chat/ChatArea.tsx b/src/renderer/components/chat/ChatArea.tsx
index ce4fc8fd3..3f7d34393 100644
--- a/src/renderer/components/chat/ChatArea.tsx
+++ b/src/renderer/components/chat/ChatArea.tsx
@@ -1,65 +1,13 @@
-import React, { useState, useEffect, memo } from 'react';
+import React, { useState, useEffect } from 'react';
 import { useChat } from '@ai-sdk/react';
-import { Box, Divider, Typography, Alert } from '@mui/material';
+import { Box, Divider, Typography } from '@mui/material';
 import { v4 as uuid } from 'uuid';
 import useAgentStatus from '../../hooks/useAgentStatus';
 import MessageList from './MessageList';
 import MessageInput from './MessageInput';
 import { chatService } from '../../services/chatService';
 import { ChatMessage } from '../../../main/types';
-import { useAgentStore } from '../../stores/agentStore';
-
-interface AlertMessage {
-  id: string;
-  type: 'success' | 'info' | 'warning' | 'error' | undefined;
-  content: string;
-}
-interface AlertManagerProps {
-  additionalAlerts: AlertMessage[] | undefined;
-  closeAdditionalAlerts?: (id: string) => void;
-}
-const AlertManager: React.FC<AlertManagerProps> = memo(
-  ({ additionalAlerts, closeAdditionalAlerts }: AlertManagerProps) => {
-    const { status, closeMessage } = useAgentStore();
-    return (
-      <Box
-        sx={{
-          position: 'absolute',
-          top: 20,
-          left: '50%',
-          transform: 'translateX(-50%)',
-          width: 'fit-content',
-          maxWidth: '80%',
-          zIndex: 1000,
-          display: 'flex',
-          flexDirection: 'column',
-          gap: 1,
-        }}
-      >
-        {status.messages?.map((message) => (
-          <Alert
-            key={message.id}
-            severity={message.type}
-            sx={{ whiteSpace: 'pre-line' }}
-            onClose={() => closeMessage(message.id)}
-          >
-            {message.content}
-          </Alert>
-        ))}
-        {additionalAlerts?.map((alert) => (
-          <Alert
-            key={alert.id}
-            severity={alert.type}
-            sx={{ whiteSpace: 'pre-line' }}
-            onClose={() => closeAdditionalAlerts?.(alert.id)}
-          >
-            {alert.content}
-          </Alert>
-        ))}
-      </Box>
-    );
-  },
-);
+import AlertManager, { AlertMessage } from '../common/AlertMessage';
 
 // ai-sdk提供のcreateDataStreamResponseを使ってストリーミングレスポンスを取得する場合の関数
 // なぜか適切なヘッダが付与されないので、利用しない
@@ -374,7 +322,7 @@ const ChatArea: React.FC<ChatAreaProps> = ({ selectedRoomId }) => {
           }}
         >
           <Typography variant="h6" color="text.secondary">
-            チャットルームを選択してください
+            新規チャットを開始または既存のチャットを選択してください
           </Typography>
         </Box>
       )}
diff --git a/src/renderer/components/common/AlertMessage.tsx b/src/renderer/components/common/AlertMessage.tsx
new file mode 100644
index 000000000..a919efd27
--- /dev/null
+++ b/src/renderer/components/common/AlertMessage.tsx
@@ -0,0 +1,65 @@
+import React, { memo } from 'react';
+import { Box, Alert } from '@mui/material';
+import { useAgentStore } from '../../stores/agentStore';
+
+export interface AlertMessage {
+  id: string;
+  type: 'success' | 'info' | 'warning' | 'error' | undefined;
+  content: string;
+}
+
+interface AlertManagerProps {
+  additionalAlerts?: AlertMessage[];
+  closeAdditionalAlerts?: (id: string) => void;
+  position?: 'top' | 'bottom';
+}
+
+const AlertManager: React.FC<AlertManagerProps> = memo(
+  ({
+    additionalAlerts,
+    closeAdditionalAlerts,
+    position = 'top',
+  }: AlertManagerProps) => {
+    const { status, closeMessage } = useAgentStore();
+
+    return (
+      <Box
+        sx={{
+          position: 'absolute',
+          [position]: 20,
+          left: '50%',
+          transform: 'translateX(-50%)',
+          width: 'fit-content',
+          maxWidth: '80%',
+          zIndex: 1000,
+          display: 'flex',
+          flexDirection: 'column',
+          gap: 1,
+        }}
+      >
+        {status.messages?.map((message) => (
+          <Alert
+            key={message.id}
+            severity={message.type}
+            sx={{ whiteSpace: 'pre-line' }}
+            onClose={() => closeMessage(message.id)}
+          >
+            {message.content}
+          </Alert>
+        ))}
+        {additionalAlerts?.map((alert) => (
+          <Alert
+            key={alert.id}
+            severity={alert.type}
+            sx={{ whiteSpace: 'pre-line' }}
+            onClose={() => closeAdditionalAlerts?.(alert.id)}
+          >
+            {alert.content}
+          </Alert>
+        ))}
+      </Box>
+    );
+  },
+);
+
+export default AlertManager;
diff --git a/src/renderer/components/common/SourceListModal.tsx b/src/renderer/components/common/SourceListModal.tsx
index 4b6dad504..1770a6968 100644
--- a/src/renderer/components/common/SourceListModal.tsx
+++ b/src/renderer/components/common/SourceListModal.tsx
@@ -328,7 +328,7 @@ function SourceListModal({
                 </TableCell>
                 <TableCell>ファイルパス</TableCell>
                 <TableCell>タイトル（生成）</TableCell>
-                <TableCell>ステータス</TableCell>
+                <TableCell>初期化処理ステータス</TableCell>
                 <TableCell>最終更新</TableCell>
               </TableRow>
             </TableHead>
diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
new file mode 100644
index 000000000..1330bf923
--- /dev/null
+++ b/src/renderer/components/review/ReviewArea.tsx
@@ -0,0 +1,369 @@
+import React, { useEffect, useState, useCallback } from 'react';
+import {
+  Box,
+  Button,
+  Paper,
+  CircularProgress,
+  Stack,
+  Typography,
+} from '@mui/material';
+import AddIcon from '@mui/icons-material/Add';
+import RateReviewIcon from '@mui/icons-material/RateReview';
+import { v4 as uuid } from 'uuid';
+import { ReviewAreaProps, ModalMode } from './types';
+import ReviewChecklistSection from './ReviewChecklistSection';
+import ReviewSourceModal from './ReviewSourceModal';
+import {
+  ReviewChecklistEdit,
+  ReviewChecklistResult,
+} from '../../../main/types';
+import AlertManager, { AlertMessage } from '../common/AlertMessage';
+import { reviewService } from '../../services/reviewService';
+
+const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+  // 状態管理
+  const [checklistResults, setChecklistResults] = useState<
+    ReviewChecklistResult[]
+  >([]);
+  // チェックリスト更新処理中であるかどうか
+  const [isSaving, setIsSaving] = useState(false);
+  const [isExtracting, setIsExtracting] = useState(false);
+  const [isReviewing, setIsReviewing] = useState(false);
+  const [isModalOpen, setIsModalOpen] = useState(false);
+  const [additionalAlerts, setAdditionalAlerts] = useState<AlertMessage[]>([]);
+  const [modalMode, setModalMode] = useState<ModalMode | null>(null);
+
+  // メッセージアラートが閉じられる際の挙動
+  const closeAdditionalAlerts = (id: string) => {
+    setAdditionalAlerts((prev) => prev.filter((alert) => alert.id !== id));
+  };
+
+  // チェックリスト取得
+  const fetchChecklistResults = useCallback(async () => {
+    if (!selectedReviewHistoryId) return;
+
+    try {
+      const result = await reviewService.getReviewHistoryDetail(
+        selectedReviewHistoryId,
+      );
+      setChecklistResults(result.checklists || []);
+    } catch (error) {
+      setAdditionalAlerts((prev) => [
+        ...prev,
+        {
+          id: uuid(),
+          type: 'error',
+          content: `チェックリストの取得中にエラーが発生しました: ${(error as Error).message}`,
+        },
+      ]);
+    }
+  }, [selectedReviewHistoryId]);
+
+  // 選択中の履歴が変更されたら、チェックリスト取得のポーリングを開始
+  useEffect(() => {
+    if (!selectedReviewHistoryId) return;
+
+    // チェックリストの初期取得
+    fetchChecklistResults();
+
+    // ポーリングの開始
+    const timer = setInterval(fetchChecklistResults, 5000);
+
+    // eslint-disable-next-line
+    return () => {
+      clearInterval(timer);
+    };
+  }, [selectedReviewHistoryId, fetchChecklistResults]);
+
+  // チェックリストの抽出処理
+  const handleExtractChecklist = useCallback(
+    async (sourceIds: number[]) => {
+      if (!selectedReviewHistoryId) return;
+
+      try {
+        setIsExtracting(true);
+        setIsModalOpen(false);
+
+        // チェックリスト抽出処理を開始
+        const result = await window.electron.review.extractChecklist({
+          reviewHistoryId: selectedReviewHistoryId,
+          sourceIds,
+        });
+
+        if (!result.success) {
+          throw new Error(result.error);
+        }
+
+        // 抽出完了イベントの購読を開始
+        const unsubscribe = reviewService.subscribeChecklistExtractionFinished(
+          (payload) => {
+            if (payload.success) {
+              setAdditionalAlerts((prev) => [
+                ...prev,
+                {
+                  id: uuid(),
+                  type: 'success',
+                  content: 'チェックリストの抽出が完了しました',
+                },
+              ]);
+            } else {
+              setAdditionalAlerts((prev) => [
+                ...prev,
+                {
+                  id: uuid(),
+                  type: 'error',
+                  content: `チェックリストの抽出に失敗しました: ${payload.error}`,
+                },
+              ]);
+            }
+            setIsExtracting(false);
+            unsubscribe();
+          },
+        );
+      } catch (error) {
+        setAdditionalAlerts((prev) => [
+          ...prev,
+          {
+            id: uuid(),
+            type: 'error',
+            content: `チェックリストの抽出処理実行時にエラーが発生しました: ${(error as Error).message}`,
+          },
+        ]);
+        setIsExtracting(false);
+      }
+    },
+    [selectedReviewHistoryId],
+  );
+
+  // レビュー実行処理
+  const handleExecuteReview = useCallback(
+    async (sourceIds: number[]) => {
+      if (!selectedReviewHistoryId) return;
+
+      try {
+        setIsReviewing(true);
+        setIsModalOpen(false);
+
+        // レビュー実行処理を開始
+        const result = await window.electron.review.execute({
+          reviewHistoryId: selectedReviewHistoryId,
+          sourceIds,
+        });
+
+        if (!result.success) {
+          throw new Error(result.error);
+        }
+
+        // レビュー完了イベントの購読を開始
+        const unsubscribe = reviewService.subscribeReviewExecutionFinished(
+          (payload) => {
+            if (payload.success) {
+              setAdditionalAlerts((prev) => [
+                ...prev,
+                {
+                  id: uuid(),
+                  type: 'success',
+                  content: 'レビューが完了しました',
+                },
+              ]);
+            } else {
+              setAdditionalAlerts((prev) => [
+                ...prev,
+                {
+                  id: uuid(),
+                  type: 'error',
+                  content: `レビューに失敗しました: ${payload.error}`,
+                },
+              ]);
+            }
+            setIsReviewing(false);
+            unsubscribe();
+          },
+        );
+      } catch (error) {
+        setAdditionalAlerts((prev) => [
+          ...prev,
+          {
+            id: uuid(),
+            type: 'error',
+            content: `レビュー処理実行時にエラーが発生しました: ${(error as Error).message}`,
+          },
+        ]);
+        setIsReviewing(false);
+      }
+    },
+    [selectedReviewHistoryId],
+  );
+
+  const handleModalSubmit = useCallback(
+    async (sourceIds: number[]) => {
+      if (modalMode === 'extract') {
+        await handleExtractChecklist(sourceIds);
+      } else if (modalMode === 'review') {
+        await handleExecuteReview(sourceIds);
+      }
+    },
+    [modalMode, handleExtractChecklist, handleExecuteReview],
+  );
+
+  // チェックリストの更新処理
+  const handleSaveChecklist = async (checklists: ReviewChecklistEdit[]) => {
+    if (!selectedReviewHistoryId) return;
+
+    try {
+      setIsSaving(true);
+      const result = await window.electron.review.updateChecklist({
+        reviewHistoryId: selectedReviewHistoryId,
+        checklistEdits: checklists,
+      });
+
+      if (result.success) {
+        setAdditionalAlerts((prev) => [
+          ...prev,
+          {
+            id: uuid(),
+            type: 'success',
+            content: 'チェックリストが更新されました',
+          },
+        ]);
+        await fetchChecklistResults();
+      } else {
+        throw new Error(result.error);
+      }
+    } catch (error) {
+      setAdditionalAlerts((prev) => [
+        ...prev,
+        {
+          id: uuid(),
+          type: 'error',
+          content: `チェックリストの更新中にエラーが発生しました: ${(error as Error).message}`,
+        },
+      ]);
+    } finally {
+      setIsSaving(false);
+    }
+  };
+
+  return (
+    <Box
+      sx={{
+        width: 'calc(100% - 280px)',
+        display: 'flex',
+        flexDirection: 'column',
+        flexGrow: 1,
+        p: 3,
+        position: 'relative',
+        right: 0,
+        top: 0,
+        bottom: 0,
+        height: '100vh',
+        overflow: 'hidden',
+      }}
+    >
+      {/* アラートメッセージ */}
+      <AlertManager
+        additionalAlerts={additionalAlerts}
+        closeAdditionalAlerts={closeAdditionalAlerts}
+      />
+      {selectedReviewHistoryId && (
+        <>
+          {/* ヘッダー部分 */}
+          <Stack
+            direction="row"
+            justifyContent="space-between"
+            alignItems="center"
+            mb={3}
+          >
+            <Stack direction="row" spacing={2}>
+              <Button
+                variant="contained"
+                startIcon={<AddIcon />}
+                onClick={() => {
+                  setModalMode('extract');
+                  setIsModalOpen(true);
+                }}
+                disabled={
+                  !selectedReviewHistoryId || isExtracting || isReviewing
+                }
+              >
+                {isExtracting ? (
+                  <CircularProgress size={24} color="inherit" />
+                ) : (
+                  'チェックリスト抽出'
+                )}
+              </Button>
+              <Button
+                variant="contained"
+                color="primary"
+                startIcon={<RateReviewIcon />}
+                onClick={() => {
+                  setModalMode('review');
+                  setIsModalOpen(true);
+                }}
+                disabled={
+                  !selectedReviewHistoryId ||
+                  isExtracting ||
+                  isReviewing ||
+                  checklistResults.length === 0
+                }
+              >
+                {isReviewing ? (
+                  <CircularProgress size={24} color="inherit" />
+                ) : (
+                  'レビュー実行'
+                )}
+              </Button>
+            </Stack>
+          </Stack>
+
+          {/* メインコンテンツ */}
+          <Paper
+            sx={{
+              p: 2,
+              flex: 1,
+              display: 'flex',
+              flexDirection: 'column',
+              minHeight: 0,
+            }}
+          >
+            <ReviewChecklistSection
+              checklistResults={checklistResults}
+              isLoading={isExtracting || isReviewing}
+              onSave={handleSaveChecklist}
+            />
+          </Paper>
+
+          {/* モーダル */}
+          <ReviewSourceModal
+            open={isModalOpen}
+            onClose={() => {
+              setModalMode(null);
+              setIsModalOpen(false);
+            }}
+            onSubmit={handleModalSubmit}
+            selectedReviewHistoryId={selectedReviewHistoryId || null}
+            disabled={isSaving || isExtracting || isReviewing}
+            modalMode={modalMode!}
+          />
+        </>
+      )}
+      {/* チェックリストが選択されていない場合のメッセージ */}
+      {!selectedReviewHistoryId && (
+        <Box
+          sx={{
+            height: '100%',
+            display: 'flex',
+            justifyContent: 'center',
+            alignItems: 'center',
+          }}
+        >
+          <Typography variant="h6" color="text.secondary">
+            新規レビューを開始または既存のレビュー履歴を選択してください
+          </Typography>
+        </Box>
+      )}
+    </Box>
+  );
+};
+
+export default ReviewArea;
diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
new file mode 100644
index 000000000..e4624e782
--- /dev/null
+++ b/src/renderer/components/review/ReviewChecklistSection.tsx
@@ -0,0 +1,315 @@
+import React, { useState, useMemo } from 'react';
+import {
+  Box,
+  Table,
+  TableBody,
+  TableCell,
+  TableContainer,
+  TableHead,
+  TableRow,
+  TableSortLabel,
+  Paper,
+  IconButton,
+  Button,
+  TextField,
+  Stack,
+  Chip,
+  Typography,
+} from '@mui/material';
+import AddIcon from '@mui/icons-material/Add';
+import DeleteIcon from '@mui/icons-material/Delete';
+import EditIcon from '@mui/icons-material/Edit';
+import SaveIcon from '@mui/icons-material/Save';
+import CancelIcon from '@mui/icons-material/Cancel';
+import { ReviewChecklistSectionProps } from './types';
+import { ReviewEvaluation } from '../../../main/types';
+
+// 評価ごとの色マッピング
+const evaluationColors: Record<ReviewEvaluation, string> = {
+  A: '#4caf50', // 緑
+  B: '#ffb74d', // オレンジ
+  C: '#f44336', // 赤
+};
+
+const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+  checklistResults,
+  isLoading,
+  onSave,
+}) => {
+  // --- ステート ---
+  const [editingId, setEditingId] = useState<number | null>(null);
+  const [editingContent, setEditingContent] = useState('');
+  const [isAddingNew, setIsAddingNew] = useState(false);
+  const [newContent, setNewContent] = useState('');
+  const [sortBy, setSortBy] = useState<number | null>(null);
+  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
+
+  // --- ハンドラ ---
+  const handleStartEdit = (id: number, content: string) => {
+    setEditingId(id);
+    setEditingContent(content);
+  };
+  const handleCancelEdit = () => {
+    setEditingId(null);
+    setEditingContent('');
+  };
+  const handleSave = async () => {
+    if (editingId == null) return;
+    await onSave([{ content: editingContent, id: editingId }]);
+    setEditingId(null);
+    setEditingContent('');
+  };
+  const handleDelete = async (id: number) => {
+    await onSave([{ id, delete: true }]);
+  };
+  const handleCancelAdd = () => {
+    setIsAddingNew(false);
+    setNewContent('');
+  };
+  const handleSaveNew = async () => {
+    await onSave([{ content: newContent, id: null }]);
+    setIsAddingNew(false);
+    setNewContent('');
+  };
+  const handleSort = (sourceId: number) => {
+    if (sortBy === sourceId) {
+      setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
+    } else {
+      setSortBy(sourceId);
+      setSortDirection('desc');
+    }
+  };
+
+  // --- ユニークソース抽出 ---
+  const uniqueSources = useMemo(() => {
+    const map = new Map<number, { id: number; fileName: string }>();
+    checklistResults.forEach((cl) => {
+      cl.sourceEvaluations?.forEach((ev) => {
+        if (!map.has(ev.sourceId)) {
+          map.set(ev.sourceId, {
+            id: ev.sourceId,
+            fileName: ev.sourceFileName,
+          });
+        }
+      });
+    });
+    return Array.from(map.values());
+  }, [checklistResults]);
+
+  // --- ソート ---
+  const sortedResults = useMemo(() => {
+    if (sortBy == null) return checklistResults;
+    return [...checklistResults].sort((a, b) => {
+      const aEv =
+        a.sourceEvaluations?.find((ev) => ev.sourceId === sortBy)?.evaluation ??
+        null;
+      const bEv =
+        b.sourceEvaluations?.find((ev) => ev.sourceId === sortBy)?.evaluation ??
+        null;
+      if (aEv === null && bEv !== null) return 1;
+      if (aEv !== null && bEv === null) return -1;
+      if (aEv === null && bEv === null) return 0;
+      return sortDirection === 'desc'
+        ? (aEv as string).localeCompare(bEv as string)
+        : (bEv as string).localeCompare(aEv as string);
+    });
+  }, [checklistResults, sortBy, sortDirection]);
+
+  // --- ボックス用スタイル ---
+  const contentBoxSx = {
+    maxHeight: '15em',
+    overflowY: 'auto',
+    whiteSpace: 'pre-wrap',
+    wordBreak: 'break-word' as const,
+  };
+  const commentBoxSx = { ...contentBoxSx };
+
+  // --- ヘッダ ---
+  const renderHeader = () => (
+    <TableHead>
+      <TableRow>
+        {/* チェックリスト列を固定幅 */}
+        <TableCell
+          sx={{ minWidth: 250, whiteSpace: 'normal', wordBreak: 'break-word' }}
+        >
+          チェックリスト
+        </TableCell>
+        {uniqueSources.map((src) => (
+          <TableCell key={src.id} align="center" sx={{ minWidth: 200 }}>
+            <TableSortLabel
+              active={sortBy === src.id}
+              direction={sortBy === src.id ? sortDirection : 'desc'}
+              onClick={() => handleSort(src.id)}
+            >
+              {src.fileName}
+            </TableSortLabel>
+          </TableCell>
+        ))}
+        <TableCell align="center" sx={{ minWidth: 120 }}>
+          操作
+        </TableCell>
+      </TableRow>
+    </TableHead>
+  );
+
+  // --- 行 ---
+  const renderRow = (checklist: (typeof checklistResults)[0]) => (
+    <TableRow key={checklist.id}>
+      {/* チェックリスト */}
+      <TableCell sx={{ p: 1, verticalAlign: 'top' }}>
+        <Box sx={contentBoxSx}>
+          {editingId === checklist.id ? (
+            <TextField
+              fullWidth
+              multiline
+              value={editingContent}
+              onChange={(e) => setEditingContent(e.target.value)}
+              variant="outlined"
+              size="small"
+            />
+          ) : (
+            checklist.content
+          )}
+        </Box>
+      </TableCell>
+      {/* 評価列 */}
+      {uniqueSources.map((src) => {
+        const ev = checklist.sourceEvaluations?.find(
+          (x) => x.sourceId === src.id,
+        );
+        return (
+          <TableCell
+            key={src.id}
+            align="center"
+            sx={{ p: 1, verticalAlign: 'top' }}
+          >
+            <Box sx={commentBoxSx}>
+              {ev?.evaluation && (
+                <Stack spacing={1} alignItems="center">
+                  <Chip
+                    label={ev.evaluation}
+                    sx={{
+                      bgcolor: evaluationColors[ev.evaluation],
+                      color: 'white',
+                      fontWeight: 'bold',
+                      fontSize: '0.75rem',
+                    }}
+                  />
+                  {ev.comment && (
+                    <Typography variant="body2" sx={commentBoxSx}>
+                      {ev.comment}
+                    </Typography>
+                  )}
+                </Stack>
+              )}
+            </Box>
+          </TableCell>
+        );
+      })}
+      {/* 操作 */}
+      <TableCell align="center" sx={{ p: 1 }}>
+        <Stack direction="row" spacing={1} justifyContent="center">
+          {editingId === checklist.id ? (
+            <>
+              <IconButton size="small" onClick={handleSave} color="primary">
+                <SaveIcon />
+              </IconButton>
+              <IconButton size="small" onClick={handleCancelEdit} color="error">
+                <CancelIcon />
+              </IconButton>
+            </>
+          ) : (
+            <>
+              <IconButton
+                size="small"
+                onClick={() => handleStartEdit(checklist.id, checklist.content)}
+                disabled={isLoading}
+              >
+                <EditIcon />
+              </IconButton>
+              <IconButton
+                size="small"
+                onClick={() => handleDelete(checklist.id)}
+                color="error"
+                disabled={isLoading}
+              >
+                <DeleteIcon />
+              </IconButton>
+            </>
+          )}
+        </Stack>
+      </TableCell>
+    </TableRow>
+  );
+
+  // --- 追加行 ---
+  const renderAdd = () => (
+    <TableRow>
+      <TableCell sx={{ p: 1 }}>
+        <Box sx={contentBoxSx}>
+          <TextField
+            fullWidth
+            multiline
+            value={newContent}
+            onChange={(e) => setNewContent(e.target.value)}
+            variant="outlined"
+            size="small"
+            placeholder="新しいチェックリスト項目を入力"
+          />
+        </Box>
+      </TableCell>
+      {uniqueSources.map((_, i) => (
+        <TableCell key={i} />
+      ))}
+      <TableCell align="center" sx={{ p: 1 }}>
+        <Stack direction="row" spacing={1} justifyContent="center">
+          <IconButton
+            size="small"
+            onClick={handleSaveNew}
+            color="primary"
+            disabled={!newContent.trim()}
+          >
+            <SaveIcon />
+          </IconButton>
+          <IconButton size="small" onClick={handleCancelAdd} color="error">
+            <CancelIcon />
+          </IconButton>
+        </Stack>
+      </TableCell>
+    </TableRow>
+  );
+
+  return (
+    <Box
+      sx={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0 }}
+    >
+      <Stack direction="row" justifyContent="flex-end" mb={2}>
+        <Button
+          variant="outlined"
+          startIcon={<AddIcon />}
+          onClick={() => setIsAddingNew(true)}
+          disabled={isLoading || isAddingNew}
+        >
+          チェックリスト追加
+        </Button>
+      </Stack>
+      <Box sx={{ flex: 1, minHeight: 0, overflow: 'auto' }}>
+        <TableContainer
+          component={Paper}
+          variant="outlined"
+          sx={{ width: '100%', overflowX: 'auto' }}
+        >
+          <Table size="small" stickyHeader>
+            {renderHeader()}
+            <TableBody>
+              {sortedResults.map((cl) => renderRow(cl))}
+              {isAddingNew && renderAdd()}
+            </TableBody>
+          </Table>
+        </TableContainer>
+      </Box>
+    </Box>
+  );
+};
+
+export default ReviewChecklistSection;
diff --git a/src/renderer/components/review/ReviewHistoryList.tsx b/src/renderer/components/review/ReviewHistoryList.tsx
new file mode 100644
index 000000000..8f355e7c1
--- /dev/null
+++ b/src/renderer/components/review/ReviewHistoryList.tsx
@@ -0,0 +1,210 @@
+import React, { useState, useEffect, useCallback } from 'react';
+import {
+  List,
+  ListItem,
+  ListItemButton,
+  ListItemText,
+  IconButton,
+  Typography,
+  Box,
+  Tooltip,
+  Menu,
+  MenuItem,
+  CircularProgress,
+  Divider,
+  Button,
+} from '@mui/material';
+import { MoreVert as MoreIcon } from '@mui/icons-material';
+import AddCircleOutlineOutlinedIcon from '@mui/icons-material/AddCircleOutlineOutlined';
+import { v4 as uuidv4 } from 'uuid';
+import type { ReviewHistory } from '../../../db/schema';
+import { reviewService } from '../../services/reviewService';
+
+interface ReviewHistoryListProps {
+  selectedReviewHistoryId?: string | null;
+  onReviewHistorySelect: (roomId: string | null) => void;
+}
+
+function ReviewHistoryList({
+  selectedReviewHistoryId = null,
+  onReviewHistorySelect,
+}: ReviewHistoryListProps) {
+  const [reviewHistories, setReviewHistories] = useState<ReviewHistory[]>([]);
+  const [loading, setLoading] = useState(true);
+  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
+  // メニュー選択中のレビュー履歴ID
+  const [activeReviewId, setActiveHistoryId] = useState<string | null>(null);
+
+  // レビュー履歴一覧を取得
+  const fetchReviewHistories = useCallback(async () => {
+    try {
+      const histories = await reviewService.getHistories();
+      // updatedAtで降順ソート
+      const sortedHistories = [...histories].sort(
+        (a, b) =>
+          new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime(),
+      );
+      setReviewHistories(sortedHistories);
+      setLoading(false);
+    } catch (error) {
+      console.error(error);
+      setLoading(true);
+    }
+  }, []);
+
+  // 初期データ読み込み
+  useEffect(() => {
+    fetchReviewHistories();
+  }, [fetchReviewHistories]);
+
+  // メニュー操作
+  const handleMenuOpen = (
+    event: React.MouseEvent<HTMLElement>,
+    roomId: string,
+  ) => {
+    event.stopPropagation();
+    setMenuAnchorEl(event.currentTarget);
+    setActiveHistoryId(roomId);
+  };
+
+  const handleMenuClose = () => {
+    setMenuAnchorEl(null);
+    setActiveHistoryId(null);
+  };
+
+  // レビュー履歴削除
+  const handleDeleteRoom = async () => {
+    if (!activeReviewId) return;
+
+    try {
+      await reviewService.deleteHistory(activeReviewId);
+      // 削除した履歴が選択中だった場合は選択を解除
+      if (selectedReviewHistoryId === activeReviewId) {
+        onReviewHistorySelect(null);
+      }
+
+      // 一覧を再取得して最新状態を反映
+      fetchReviewHistories();
+    } catch (error) {
+      console.error(error);
+    } finally {
+      handleMenuClose();
+    }
+  };
+
+  // レビュー履歴の更新をトリガーする関数
+  const refreshReviewHistories = useCallback(() => {
+    fetchReviewHistories();
+  }, [fetchReviewHistories]);
+
+  // レビュー履歴の定期更新
+  useEffect(() => {
+    const interval = setInterval(refreshReviewHistories, 5000);
+    return () => clearInterval(interval);
+  }, [refreshReviewHistories]);
+
+  // 新しいレビューを開始
+  const handleCreateReview = () => {
+    // 新しいUUIDを生成してルームIDとして使用
+    const newReviewId = uuidv4();
+    // 選択状態を更新
+    onReviewHistorySelect(newReviewId);
+    // モーダルは表示せず、すぐにレビュー画面に遷移
+  };
+
+  const renderContent = () => {
+    // ローディング中は「レビュー履歴取得中」とスピナーを表示
+    if (loading) {
+      return (
+        <Box sx={{ p: 3, textAlign: 'center' }}>
+          <CircularProgress size={24} sx={{ mb: 1 }} />
+          <Typography variant="body2" color="text.secondary">
+            ドキュメントレビュー履歴取得中
+          </Typography>
+        </Box>
+      );
+    }
+
+    // レビュー履歴がない場合は「レビュー履歴がありません」と表示
+    if (reviewHistories.length === 0) {
+      return (
+        <Box sx={{ p: 3, textAlign: 'center' }}>
+          <Typography variant="body2" color="text.secondary">
+            ドキュメントレビュー履歴がありません
+          </Typography>
+        </Box>
+      );
+    }
+
+    return (
+      <>
+        <List disablePadding>
+          {reviewHistories.map((reviewHistory) => (
+            <ListItem
+              key={reviewHistory.id}
+              disablePadding
+              secondaryAction={
+                <IconButton
+                  edge="end"
+                  aria-label="more"
+                  onClick={(e) => handleMenuOpen(e, reviewHistory.id)}
+                >
+                  <MoreIcon />
+                </IconButton>
+              }
+            >
+              <ListItemButton
+                selected={selectedReviewHistoryId === reviewHistory.id}
+                onClick={() => onReviewHistorySelect(reviewHistory.id)}
+                sx={{ pr: 6 }}
+              >
+                <Tooltip title={reviewHistory.title} placement="right">
+                  <ListItemText
+                    primary={reviewHistory.title}
+                    primaryTypographyProps={{
+                      noWrap: true,
+                      sx: {
+                        overflow: 'hidden',
+                        textOverflow: 'ellipsis',
+                      },
+                    }}
+                  />
+                </Tooltip>
+              </ListItemButton>
+            </ListItem>
+          ))}
+        </List>
+        {/* チャットルームメニュー */}
+        <Menu
+          anchorEl={menuAnchorEl}
+          open={Boolean(menuAnchorEl)}
+          onClose={handleMenuClose}
+        >
+          <MenuItem onClick={handleDeleteRoom}>削除</MenuItem>
+        </Menu>
+      </>
+    );
+  };
+
+  return (
+    <Box>
+      <Box
+        sx={{ py: 1, px: 2, pt: 0, display: 'flex', justifyContent: 'start' }}
+      >
+        <Button
+          startIcon={<AddCircleOutlineOutlinedIcon />}
+          onClick={handleCreateReview}
+          sx={{ fontSize: '1rem' }}
+          disabled={loading}
+          // fullWidth
+        >
+          新規レビュー
+        </Button>
+      </Box>
+      <Divider />
+      {renderContent()}
+    </Box>
+  );
+}
+
+export default React.memo(ReviewHistoryList);
diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
new file mode 100644
index 000000000..722a44c8e
--- /dev/null
+++ b/src/renderer/components/review/ReviewSourceModal.tsx
@@ -0,0 +1,303 @@
+import React, { useEffect, useState } from 'react';
+import {
+  Modal,
+  Box,
+  Typography,
+  Button,
+  TableContainer,
+  Table,
+  TableHead,
+  TableRow,
+  TableCell,
+  TableBody,
+  Paper,
+  Tooltip,
+  Chip,
+  Checkbox,
+} from '@mui/material';
+import {
+  Check as CheckIcon,
+  Error as ErrorIcon,
+  Sync as SyncIcon,
+  HourglassEmpty as ProcessingIcon,
+  Help as UnknownIcon,
+} from '@mui/icons-material';
+
+import { Source } from '../../../db/schema';
+import { ReviewSourceModalProps } from './types';
+
+function SourceListModal({
+  open,
+  onClose,
+  onSubmit,
+  selectedReviewHistoryId,
+  disabled,
+  modalMode,
+}: ReviewSourceModalProps): React.ReactElement {
+  const [sources, setSources] = useState<Source[]>([]);
+  const [checkedSources, setCheckedSources] = useState<{
+    [key: number]: boolean;
+  }>({});
+  const [processing, setProcessing] = useState(true);
+
+  // チェック状態の更新
+  // ソースの更新状態が変わったときにチェック状態を更新する
+  // 元のチェック状態とマージする
+  useEffect(() => {
+    const newCheckedSources: { [key: number]: boolean } = {};
+    sources.forEach((source) => {
+      newCheckedSources[source.id] = checkedSources[source.id] || false;
+    });
+    setCheckedSources(newCheckedSources);
+    // eslint-disable-next-line
+  }, [sources]);
+
+  // modalMode, selectedReviewHistoryIdが変わったときにチェック状態を初期化する
+  // checkedSourceを全てfalseにする
+  useEffect(() => {
+    setCheckedSources((prev) => {
+      Object.keys(prev).forEach((key) => {
+        prev[+key] = false;
+      });
+      return { ...prev };
+    });
+  }, [modalMode, selectedReviewHistoryId]);
+
+  // チェックボックスの変更ハンドラ
+  const handleSourceCheckChange = async (sourceId: number) => {
+    setCheckedSources((prev) => ({
+      ...prev,
+      [sourceId]: !prev[sourceId],
+    }));
+  };
+
+  // 全選択/全解除の切り替えハンドラ
+  const handleSelectAllChange = () => {
+    const someUnchecked = Object.values(checkedSources).some(
+      (checked) => !checked,
+    );
+    const newCheckedState = { ...checkedSources };
+
+    // 一つでもチェックが外れているものがあれば全選択、すべてチェック済みなら全解除
+    const newValue = someUnchecked;
+
+    // すべてのソースのチェック状態を更新
+    sources.forEach((source) => {
+      newCheckedState[source.id] = newValue;
+    });
+    setCheckedSources(newCheckedState);
+  };
+
+  // ソースデータの定期更新（processingステータスがある場合のみ）
+  useEffect(() => {
+    const fetchSources = async () => {
+      try {
+        const response = await window.electron.source.getSources();
+        const responseSources: Source[] = response.sources || [];
+        setSources(responseSources);
+        const newProcessing = responseSources.some(
+          (s: Source) => s.status === 'idle' || s.status === 'processing',
+        );
+        setProcessing(newProcessing);
+      } catch (error) {
+        console.error('ソースデータの取得に失敗しました:', error);
+      }
+    };
+
+    const intervalId = setInterval(fetchSources, 5000);
+
+    return () => {
+      if (intervalId) {
+        clearInterval(intervalId);
+      }
+    };
+  }, []);
+
+  const handleClick = () => {
+    if (disabled) return;
+    onSubmit(
+      Object.keys(checkedSources)
+        .filter((key) => {
+          return checkedSources[+key];
+        })
+        .map((key) => +key),
+    );
+  };
+
+  const getButtonText = () => {
+    if (modalMode === 'review') {
+      return 'ドキュメントレビュー実行';
+    }
+    if (modalMode === 'extract') {
+      return 'チェックリスト抽出';
+    }
+    return null;
+  };
+
+  const getTitle = () => {
+    if (modalMode === 'review') {
+      return 'ドキュメントレビュー対象ドキュメント選択';
+    }
+    if (modalMode === 'extract') {
+      return 'チェックリスト抽出対象ドキュメント選択';
+    }
+    return 'ソース選択';
+  };
+
+  const getStatusIcon = (status: Source['status'], error?: Source['error']) => {
+    switch (status) {
+      case 'completed':
+        return (
+          <Chip
+            icon={<CheckIcon />}
+            label="完了"
+            color="success"
+            size="small"
+            variant="outlined"
+          />
+        );
+      case 'failed':
+        return (
+          <Tooltip
+            data-testid="sourcelistmodal-error-tooltip"
+            title={error ?? '不明なエラー'}
+          >
+            <Chip
+              icon={<ErrorIcon />}
+              label="エラー"
+              color="error"
+              size="small"
+              variant="outlined"
+            />
+          </Tooltip>
+        );
+      case 'processing':
+        return (
+          <Chip
+            icon={<ProcessingIcon />}
+            label="処理中"
+            color="primary"
+            size="small"
+            variant="outlined"
+          />
+        );
+      case 'idle':
+        return (
+          <Chip
+            icon={<SyncIcon />}
+            label="待機中"
+            color="default"
+            size="small"
+            variant="outlined"
+          />
+        );
+      default:
+        return (
+          <Chip
+            icon={<UnknownIcon />}
+            label="不明"
+            color="default"
+            size="small"
+            variant="outlined"
+          />
+        );
+    }
+  };
+
+  return (
+    <Modal open={open} onClose={onClose}>
+      <Box
+        sx={{
+          position: 'absolute',
+          top: '50%',
+          left: '50%',
+          transform: 'translate(-50%, -50%)',
+          width: '80%',
+          maxWidth: 800,
+          bgcolor: 'background.paper',
+          boxShadow: 24,
+          p: 4,
+          maxHeight: '90vh',
+          overflow: 'auto',
+          borderRadius: 1,
+        }}
+      >
+        <Typography variant="h6" component="h2" gutterBottom>
+          {getTitle()}
+        </Typography>
+
+        <Box sx={{ mb: 2, display: 'flex', justifyContent: 'flex-end' }}>
+          <Tooltip title="ソース登録ディレクトリ内のファイル内容と同期します">
+            <Button
+              variant="contained"
+              onClick={handleClick}
+              disabled={
+                processing ||
+                disabled ||
+                Object.keys(checkedSources).length === 0
+              }
+              startIcon={<SyncIcon />}
+            >
+              {processing ? 'ドキュメント初期化処理中...' : getButtonText()}
+            </Button>
+          </Tooltip>
+        </Box>
+
+        <TableContainer component={Paper}>
+          <Table>
+            <TableHead>
+              <TableRow>
+                <TableCell padding="checkbox">
+                  <Checkbox
+                    indeterminate={
+                      Object.values(checkedSources).some(
+                        (checked) => checked,
+                      ) &&
+                      Object.values(checkedSources).some((checked) => !checked)
+                    }
+                    checked={
+                      Object.values(checkedSources).length > 0 &&
+                      Object.values(checkedSources).every((checked) => checked)
+                    }
+                    onChange={handleSelectAllChange}
+                    disabled={processing}
+                  />
+                </TableCell>
+                <TableCell>ファイルパス</TableCell>
+                <TableCell>タイトル（生成）</TableCell>
+                <TableCell>初期化処理ステータス</TableCell>
+              </TableRow>
+            </TableHead>
+            <TableBody>
+              {sources.map((source) => (
+                <TableRow
+                  key={source.id}
+                  sx={{
+                    '&:last-child td, &:last-child th': { border: 0 },
+                    backgroundColor:
+                      source.status === 'failed' ? 'error.lighter' : 'inherit',
+                  }}
+                >
+                  <TableCell padding="checkbox">
+                    <Checkbox
+                      checked={checkedSources[source.id] || false}
+                      onChange={() => handleSourceCheckChange(source.id)}
+                      disabled={processing}
+                    />
+                  </TableCell>
+                  <TableCell>{source.path}</TableCell>
+                  <TableCell>{source.title}</TableCell>
+                  <TableCell>
+                    {getStatusIcon(source.status, source.error)}
+                  </TableCell>
+                </TableRow>
+              ))}
+            </TableBody>
+          </Table>
+        </TableContainer>
+      </Box>
+    </Modal>
+  );
+}
+
+export default React.memo(SourceListModal);
diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
new file mode 100644
index 000000000..e02ed4286
--- /dev/null
+++ b/src/renderer/components/review/types.ts
@@ -0,0 +1,36 @@
+import {
+  ReviewChecklistEdit,
+  ReviewChecklistResult,
+} from '../../../main/types';
+import { Source } from '../../../db/schema';
+
+// ReviewAreaのProps型
+export interface ReviewAreaProps {
+  selectedReviewHistoryId: string | null;
+}
+
+// ReviewChecklistSectionのProps型
+export interface ReviewChecklistSectionProps {
+  checklistResults: ReviewChecklistResult[];
+  isLoading: boolean;
+  onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
+}
+
+export type ModalMode = 'extract' | 'review';
+
+// ReviewSourceModalのProps型
+export interface ReviewSourceModalProps {
+  open: boolean;
+  onClose: () => void;
+  onSubmit: (sourceIds: number[]) => void;
+  selectedReviewHistoryId: string | null;
+  disabled?: boolean;
+  modalMode: ModalMode;
+}
+
+// ソースファイルセレクタのProps型
+export interface SourceSelectorProps {
+  sources: Source[];
+  selectedSourceIds: number[];
+  onChange: (sourceIds: number[]) => void;
+}
diff --git a/src/renderer/components/sidebar/ChatRoomList.tsx b/src/renderer/components/sidebar/ChatRoomList.tsx
index 67278686e..151a23321 100644
--- a/src/renderer/components/sidebar/ChatRoomList.tsx
+++ b/src/renderer/components/sidebar/ChatRoomList.tsx
@@ -1,4 +1,4 @@
-import React from 'react';
+import React, { useState, useEffect, useCallback } from 'react';
 import {
   List,
   ListItem,
@@ -8,86 +8,202 @@ import {
   Typography,
   Box,
   Tooltip,
+  Menu,
+  MenuItem,
   CircularProgress,
+  Divider,
+  Button,
 } from '@mui/material';
 import { MoreVert as MoreIcon } from '@mui/icons-material';
+import AddCircleOutlineOutlinedIcon from '@mui/icons-material/AddCircleOutlineOutlined';
+import { v4 as uuidv4 } from 'uuid';
 import type { ChatRoom } from '../../../main/types';
+import { chatService } from '../../services/chatService';
 
 interface ChatRoomListProps {
-  rooms: ChatRoom[];
-  selectedRoomId: string | null;
+  selectedRoomId?: string | null;
   onRoomSelect: (roomId: string) => void;
-  onMenuOpen: (event: React.MouseEvent<HTMLElement>, roomId: string) => void;
-  loading?: boolean;
 }
 
 function ChatRoomList({
-  rooms,
-  selectedRoomId,
+  selectedRoomId = null,
   onRoomSelect,
-  onMenuOpen,
-  loading,
 }: ChatRoomListProps) {
-  // ローディング中は「チャット履歴取得中」とスピナーを表示
-  if (loading) {
-    return (
-      <Box sx={{ p: 3, textAlign: 'center' }}>
-        <CircularProgress size={24} sx={{ mb: 1 }} />
-        <Typography variant="body2" color="text.secondary">
-          チャット履歴取得中
-        </Typography>
-      </Box>
-    );
-  }
+  const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
+  const [loading, setLoading] = useState(true);
+  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
+  // メニュー選択中のチャットルームID
+  const [activeRoomId, setActiveRoomId] = useState<string | null>(null);
+
+  // チャットルーム一覧を取得
+  const fetchChatRooms = useCallback(async () => {
+    try {
+      const rooms = await chatService.getChatRooms();
+      // updatedAtで降順ソート
+      const sortedRooms = [...rooms].sort(
+        (a, b) =>
+          new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime(),
+      );
+      setChatRooms(sortedRooms);
+      setLoading(false);
+    } catch (error) {
+      console.error(error);
+      setLoading(true);
+    }
+  }, []);
+
+  // 初期データ読み込み
+  useEffect(() => {
+    fetchChatRooms();
+  }, [fetchChatRooms]);
+
+  // メニュー操作
+  const handleMenuOpen = (
+    event: React.MouseEvent<HTMLElement>,
+    roomId: string,
+  ) => {
+    event.stopPropagation();
+    setMenuAnchorEl(event.currentTarget);
+    setActiveRoomId(roomId);
+  };
+
+  const handleMenuClose = () => {
+    setMenuAnchorEl(null);
+    setActiveRoomId(null);
+  };
+
+  // チャットルーム削除
+  const handleDeleteRoom = async () => {
+    if (!activeRoomId) return;
+
+    try {
+      await chatService.deleteChatRoom(activeRoomId);
+      // 削除したルームが選択中だった場合は選択を解除
+      if (selectedRoomId === activeRoomId) {
+        onRoomSelect('');
+      }
+
+      // 一覧を再取得して最新状態を反映
+      fetchChatRooms();
+    } catch (error) {
+      console.error(error);
+    } finally {
+      handleMenuClose();
+    }
+  };
+
+  // チャットルーム一覧の更新をトリガーする関数
+  const refreshChatRooms = useCallback(() => {
+    fetchChatRooms();
+  }, [fetchChatRooms]);
+
+  // チャットルーム一覧の定期更新
+  useEffect(() => {
+    const interval = setInterval(refreshChatRooms, 5000);
+    return () => clearInterval(interval);
+  }, [refreshChatRooms]);
+
+  // 新しいチャットを開始
+  const handleCreateRoom = () => {
+    // 新しいUUIDを生成してルームIDとして使用
+    const newRoomId = uuidv4();
+    // 選択状態を更新
+    onRoomSelect(newRoomId);
+    // モーダルは表示せず、すぐにチャット画面に遷移
+  };
+
+  const renderContent = () => {
+    // ローディング中は「チャット履歴取得中」とスピナーを表示
+    if (loading) {
+      return (
+        <Box sx={{ p: 3, textAlign: 'center' }}>
+          <CircularProgress size={24} sx={{ mb: 1 }} />
+          <Typography variant="body2" color="text.secondary">
+            チャット履歴取得中
+          </Typography>
+        </Box>
+      );
+    }
+
+    // チャットルームがない場合は「チャットルームがありません」と表示
+    if (chatRooms.length === 0) {
+      return (
+        <Box sx={{ p: 3, textAlign: 'center' }}>
+          <Typography variant="body2" color="text.secondary">
+            チャット履歴がありません
+          </Typography>
+        </Box>
+      );
+    }
 
-  // チャットルームがない場合は「チャットルームがありません」と表示
-  if (rooms.length === 0) {
     return (
-      <Box sx={{ p: 3, textAlign: 'center' }}>
-        <Typography variant="body2" color="text.secondary">
-          チャット履歴がありません
-        </Typography>
-      </Box>
+      <>
+        <List disablePadding>
+          {chatRooms.map((room) => (
+            <ListItem
+              key={room.id}
+              disablePadding
+              secondaryAction={
+                <IconButton
+                  edge="end"
+                  aria-label="more"
+                  onClick={(e) => handleMenuOpen(e, room.id)}
+                >
+                  <MoreIcon />
+                </IconButton>
+              }
+            >
+              <ListItemButton
+                selected={selectedRoomId === room.id}
+                onClick={() => onRoomSelect(room.id)}
+                sx={{ pr: 6 }}
+              >
+                <Tooltip title={room.title} placement="right">
+                  <ListItemText
+                    primary={room.title}
+                    primaryTypographyProps={{
+                      noWrap: true,
+                      sx: {
+                        overflow: 'hidden',
+                        textOverflow: 'ellipsis',
+                      },
+                    }}
+                  />
+                </Tooltip>
+              </ListItemButton>
+            </ListItem>
+          ))}
+        </List>
+        {/* チャットルームメニュー */}
+        <Menu
+          anchorEl={menuAnchorEl}
+          open={Boolean(menuAnchorEl)}
+          onClose={handleMenuClose}
+        >
+          <MenuItem onClick={handleDeleteRoom}>削除</MenuItem>
+        </Menu>
+      </>
     );
-  }
+  };
 
   return (
-    <List disablePadding>
-      {rooms.map((room) => (
-        <ListItem
-          key={room.id}
-          disablePadding
-          secondaryAction={
-            <IconButton
-              edge="end"
-              aria-label="more"
-              onClick={(e) => onMenuOpen(e, room.id)}
-            >
-              <MoreIcon />
-            </IconButton>
-          }
+    <Box>
+      <Box
+        sx={{ py: 1, px: 2, pt: 0, display: 'flex', justifyContent: 'start' }}
+      >
+        <Button
+          startIcon={<AddCircleOutlineOutlinedIcon />}
+          onClick={handleCreateRoom}
+          sx={{ fontSize: '1rem' }}
+          disabled={loading}
+          // fullWidth
         >
-          <ListItemButton
-            selected={selectedRoomId === room.id}
-            onClick={() => onRoomSelect(room.id)}
-            sx={{ pr: 6 }}
-          >
-            <Tooltip title={room.title} placement="right">
-              <ListItemText
-                primary={room.title}
-                primaryTypographyProps={{
-                  noWrap: true,
-                  sx: {
-                    overflow: 'hidden',
-                    textOverflow: 'ellipsis',
-                  },
-                }}
-              />
-            </Tooltip>
-          </ListItemButton>
-        </ListItem>
-      ))}
-    </List>
+          新規チャット
+        </Button>
+      </Box>
+      <Divider />
+      {renderContent()}
+    </Box>
   );
 }
 
diff --git a/src/renderer/components/sidebar/Sidebar.tsx b/src/renderer/components/sidebar/Sidebar.tsx
index c65cd99af..c93b30e61 100644
--- a/src/renderer/components/sidebar/Sidebar.tsx
+++ b/src/renderer/components/sidebar/Sidebar.tsx
@@ -1,26 +1,20 @@
-import React, { useState, useEffect, useCallback } from 'react';
-import { Box, Menu, MenuItem, Divider, AlertColor } from '@mui/material';
-import { v4 as uuidv4 } from 'uuid';
+import React, { useState, useCallback } from 'react';
+import { Box, AlertColor } from '@mui/material';
 import SourceListModal from '../common/SourceListModal';
 import SettingsModal from '../common/SettingsModal';
-import { ChatRoom } from '../../../main/types';
-import { chatService } from '../../services/chatService';
 import SidebarHeader from './SidebarHeader';
-import ChatRoomList from './ChatRoomList';
 import SidebarFooter from './SidebarFooter';
 
 interface SidebarProps {
-  selectedRoomId: string | null;
-  onRoomSelect: (roomId: string) => void;
-  onReloadSources: () => void; // ソース読み込み処理を実行する関数
+  onReloadSources: () => void;
   showSnackbar: (message: string, severity: AlertColor) => void;
+  children?: React.ReactNode;
 }
 
 function Sidebar({
-  selectedRoomId,
-  onRoomSelect,
   onReloadSources,
   showSnackbar,
+  children = null,
 }: SidebarProps) {
   const [isSourceListOpen, setIsSourceListOpen] = useState(false);
   const [settingsHasError, setSettingsHasError] = useState(false);
@@ -28,10 +22,7 @@ function Sidebar({
     processing: boolean;
     enabledCount: number;
   }>({ processing: false, enabledCount: 0 });
-  const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
-  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
-  const [activeRoomId, setActiveRoomId] = useState<string | null>(null);
-  const [loading, setLoading] = useState(true);
+
   const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
 
   const onSettingsUpdated = useCallback(() => {
@@ -39,83 +30,6 @@ function Sidebar({
     showSnackbar('設定を更新しました', 'success');
   }, [showSnackbar]);
 
-  // チャットルーム一覧を取得
-  const fetchChatRooms = useCallback(async () => {
-    try {
-      const rooms = await chatService.getChatRooms();
-      // updatedAtで降順ソート
-      const sortedRooms = [...rooms].sort(
-        (a, b) =>
-          new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime(),
-      );
-      setChatRooms(sortedRooms);
-      setLoading(false);
-    } catch (error) {
-      console.error(error);
-      setLoading(true);
-    }
-  }, []);
-
-  // 初期データ読み込み
-  useEffect(() => {
-    fetchChatRooms();
-  }, [fetchChatRooms]);
-
-  // メニュー操作
-  const handleMenuOpen = (
-    event: React.MouseEvent<HTMLElement>,
-    roomId: string,
-  ) => {
-    event.stopPropagation();
-    setMenuAnchorEl(event.currentTarget);
-    setActiveRoomId(roomId);
-  };
-
-  const handleMenuClose = () => {
-    setMenuAnchorEl(null);
-    setActiveRoomId(null);
-  };
-
-  // チャットルーム削除
-  const handleDeleteRoom = async () => {
-    if (!activeRoomId) return;
-
-    try {
-      await chatService.deleteChatRoom(activeRoomId);
-      // 削除したルームが選択中だった場合は選択を解除
-      if (selectedRoomId === activeRoomId) {
-        onRoomSelect('');
-      }
-
-      // 一覧を再取得して最新状態を反映
-      fetchChatRooms();
-    } catch (error) {
-      console.error(error);
-    } finally {
-      handleMenuClose();
-    }
-  };
-
-  // 新しいチャットを開始
-  const handleNewChat = () => {
-    // 新しいUUIDを生成してルームIDとして使用
-    const newRoomId = uuidv4();
-    // 選択状態を更新
-    onRoomSelect(newRoomId);
-    // モーダルは表示せず、すぐにチャット画面に遷移
-  };
-
-  // チャットルーム一覧の更新をトリガーする関数
-  const refreshChatRooms = useCallback(() => {
-    fetchChatRooms();
-  }, [fetchChatRooms]);
-
-  // チャットルーム一覧の定期更新
-  useEffect(() => {
-    const interval = setInterval(refreshChatRooms, 5000);
-    return () => clearInterval(interval);
-  }, [refreshChatRooms]);
-
   // 設定モーダルを開く
   const handleSettingsClick = () => {
     setIsSettingsModalOpen(true);
@@ -133,10 +47,9 @@ function Sidebar({
         borderColor: 'divider',
       }}
     >
-      <SidebarHeader onCreateRoom={handleNewChat} />
-      <Divider />
+      <SidebarHeader />
 
-      {/* チャットルーム一覧 */}
+      {/* メイン部分 */}
       <Box
         sx={{
           flex: 1,
@@ -151,13 +64,7 @@ function Sidebar({
         }}
         className="hidden-scrollbar"
       >
-        <ChatRoomList
-          rooms={chatRooms}
-          selectedRoomId={selectedRoomId}
-          onRoomSelect={onRoomSelect}
-          onMenuOpen={handleMenuOpen}
-          loading={loading}
-        />
+        {children}
       </Box>
 
       <SidebarFooter
@@ -184,15 +91,6 @@ function Sidebar({
         onSettingsUpdated={onSettingsUpdated}
         onValidChange={(isValid) => setSettingsHasError(!isValid)}
       />
-
-      {/* チャットルームメニュー */}
-      <Menu
-        anchorEl={menuAnchorEl}
-        open={Boolean(menuAnchorEl)}
-        onClose={handleMenuClose}
-      >
-        <MenuItem onClick={handleDeleteRoom}>削除</MenuItem>
-      </Menu>
     </Box>
   );
 }
diff --git a/src/renderer/components/sidebar/SidebarHeader.tsx b/src/renderer/components/sidebar/SidebarHeader.tsx
index 4387f3048..5da616cc6 100644
--- a/src/renderer/components/sidebar/SidebarHeader.tsx
+++ b/src/renderer/components/sidebar/SidebarHeader.tsx
@@ -1,27 +1,87 @@
 import React from 'react';
-import { Box, Button } from '@mui/material';
-import { Add as AddIcon } from '@mui/icons-material';
+import {
+  Box,
+  FormControl,
+  MenuItem,
+  Select,
+  SelectChangeEvent,
+  Stack,
+  InputBase,
+  Typography,
+} from '@mui/material';
+import ChatOutlinedIcon from '@mui/icons-material/ChatOutlined';
+import ChecklistOutlinedIcon from '@mui/icons-material/ChecklistOutlined';
+import { useNavigate, useLocation } from 'react-router-dom';
+import { ROUTES } from '../../../main/types';
+import useAgentStatus from '../../hooks/useAgentStatus';
 
-interface SidebarHeaderProps {
-  onCreateRoom: () => void;
-}
+interface SidebarHeaderProps {}
+
+const FEATURES = [
+  { value: ROUTES.CHAT, label: 'チャット', icon: <ChatOutlinedIcon /> },
+  {
+    value: ROUTES.REVIEW,
+    label: 'ドキュメントレビュー',
+    icon: <ChecklistOutlinedIcon />,
+  },
+] as const;
+
+const SidebarHeader: React.FC<SidebarHeaderProps> = () => {
+  const { status } = useAgentStatus();
+  const navigate = useNavigate();
+  const location = useLocation();
+
+  // 現在の機能を取得
+  const getCurrentFeature = () => {
+    if (location.pathname.startsWith(ROUTES.REVIEW)) {
+      return ROUTES.REVIEW;
+    }
+    return ROUTES.CHAT;
+  };
+
+  // 機能切り替えハンドラ
+  const handleFeatureChange = (event: SelectChangeEvent<string>) => {
+    console.log('機能切り替え:', event.target.value);
+    navigate(event.target.value);
+  };
 
-function SidebarHeader({ onCreateRoom }: SidebarHeaderProps) {
   return (
-    <>
-      {/* 新規チャットボタン */}
-      <Box sx={{ p: 2, display: 'flex', justifyContent: 'start' }}>
-        <Button
-          variant="contained"
-          startIcon={<AddIcon />}
-          onClick={onCreateRoom}
-          // fullWidth
-        >
-          New Chat
-        </Button>
+    <Stack spacing={2} sx={{ py: 1, px: 2, pt: 2, pb: 0 }}>
+      <Box>
+        <FormControl variant="standard" size="small">
+          <Select
+            value={getCurrentFeature()}
+            onChange={handleFeatureChange}
+            displayEmpty
+            disabled={status.state !== 'ready'}
+            input={
+              <InputBase
+                sx={{ '&:before, &:after': { borderBottom: 'none' } }}
+              />
+            }
+            sx={{
+              borderRadius: 2,
+            }}
+          >
+            {FEATURES.map((feature) => (
+              <MenuItem key={feature.value} value={feature.value}>
+                <Box
+                  sx={{
+                    display: 'flex',
+                    alignItems: 'center',
+                    gap: 0.2,
+                  }}
+                >
+                  {feature.icon}
+                  <Typography>{feature.label}</Typography>
+                </Box>
+              </MenuItem>
+            ))}
+          </Select>
+        </FormControl>
       </Box>
-    </>
+    </Stack>
   );
-}
+};
 
-export default React.memo(SidebarHeader);
+export default SidebarHeader;
diff --git a/src/renderer/services/reviewService.ts b/src/renderer/services/reviewService.ts
new file mode 100644
index 000000000..fd5edd165
--- /dev/null
+++ b/src/renderer/services/reviewService.ts
@@ -0,0 +1,104 @@
+import { ReviewHistory } from '../../db/schema';
+import { IpcChannels, IpcEventPayload } from '../../main/types/ipc';
+
+// IPC通信を使用してメインプロセスとやり取りするレビュー機能用のサービス
+export const reviewService = {
+  /**
+   * ドキュメントレビュー履歴を取得
+   * @returns ドキュメントレビュー履歴配列
+   */
+  getHistories: async (): Promise<ReviewHistory[]> => {
+    try {
+      // IPCを使用してメインプロセスから取得
+      const result = await window.electron.review.getHistories();
+      if (!result || !result.success) {
+        throw new Error(result?.error || '不明なエラー');
+      }
+      return result.histories || [];
+    } catch (error) {
+      console.error('ドキュメントレビュー履歴の取得に失敗しました:', error);
+      throw error;
+    }
+  },
+
+  /**
+   * ドキュメントレビュー履歴を削除
+   * @param reviewHistoryId ドキュメントレビュー履歴ID
+   */
+  deleteHistory: async (reviewHistoryId: string): Promise<void> => {
+    try {
+      // IPCを使用してメインプロセスから削除
+      const result =
+        await window.electron.review.deleteHistory(reviewHistoryId);
+      if (!result.success) {
+        throw new Error(result?.error || '不明なエラー');
+      }
+    } catch (error) {
+      console.error('ドキュメントレビュー履歴の削除に失敗しました:', error);
+      throw error;
+    }
+  },
+
+  /**
+   * ドキュメントレビュー履歴の詳細情報抽出
+   * @param reviewHistoryId ドキュメントレビュー履歴ID
+   * @returns 抽出されたチェックリスト
+   */
+  getReviewHistoryDetail: async (historyId: string) => {
+    try {
+      const result = await window.electron.review.getHistoryDetail(historyId);
+      if (!result.success) {
+        throw new Error(result.error || '不明なエラー');
+      }
+      return {
+        checklists: result.checklistResults || [],
+      };
+    } catch (error) {
+      console.error('チェックリストの取得に失敗しました:', error);
+      throw error;
+    }
+  },
+
+  /**
+   * チェックリスト抽出を呼び出す
+   * @param reviewHistoryId レビュー履歴ID
+   * @param sourceIds 抽出対象のソースID配列
+   * @returns チェックリスト抽出結果
+   */
+  callChecklistExtraction: async (
+    reviewHistoryId: string,
+    sourceIds: number[],
+  ) => {
+    try {
+      const result = await window.electron.review.extractChecklist({
+        reviewHistoryId,
+        sourceIds,
+      });
+      if (!result.success) {
+        throw new Error(result.error || '不明なエラー');
+      }
+      return result;
+    } catch (error) {
+      console.error('チェックリスト抽出の呼び出しに失敗しました:', error);
+      throw error;
+    }
+  },
+
+  subscribeChecklistExtractionFinished: (
+    callback: (payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED>) => void,
+  ) => {
+    return window.electron.review.onExtractChecklistFinished((payload) => {
+      callback(payload);
+    });
+  },
+
+  subscribeReviewExecutionFinished: (
+    callback: (payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>) => void,
+  ) => {
+    return window.electron.review.onExecuteReviewFinished((payload) => {
+      callback(payload);
+    });
+  },
+};
+
+export default reviewService;
