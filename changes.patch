diff --git a/.erb/configs/webpack.config.renderer.dev.ts b/.erb/configs/webpack.config.renderer.dev.ts
index a6ca87e90..a406528c9 100644
--- a/.erb/configs/webpack.config.renderer.dev.ts
+++ b/.erb/configs/webpack.config.renderer.dev.ts
@@ -1,5 +1,5 @@
 import 'webpack-dev-server';
-import path from 'path';
+import path, { join } from 'path';
 import fs from 'fs';
 import webpack from 'webpack';
 import HtmlWebpackPlugin from 'html-webpack-plugin';
@@ -7,6 +7,7 @@ import chalk from 'chalk';
 import { merge } from 'webpack-merge';
 import { execSync, spawn } from 'child_process';
 import ReactRefreshWebpackPlugin from '@pmmmwh/react-refresh-webpack-plugin';
+import CopyPlugin from 'copy-webpack-plugin';
 import baseConfig from './webpack.config.base';
 import webpackPaths from './webpack.paths';
 import checkNodeEnv from '../scripts/check-node-env';
@@ -162,6 +163,22 @@ const configuration: webpack.Configuration = {
       isDevelopment: process.env.NODE_ENV !== 'production',
       nodeModules: webpackPaths.appNodeModulesPath,
     }),
+
+    new CopyPlugin({
+      patterns: [
+        {
+          from: path.resolve(__dirname, '../../drizzle'),
+          to: path.resolve(__dirname, '../../release/app/drizzle'),
+        },
+        {
+          from: join(
+            path.dirname(require.resolve('pdfjs-dist/package.json')),
+            'legacy/build/pdf.worker.mjs',
+          ),
+          to: 'pdf.worker.mjs', // 出力先 (resources に入る)
+        },
+      ],
+    }),
   ],
 
   node: {
diff --git a/.erb/configs/webpack.config.renderer.prod.ts b/.erb/configs/webpack.config.renderer.prod.ts
index c30a09a42..15720d77f 100644
--- a/.erb/configs/webpack.config.renderer.prod.ts
+++ b/.erb/configs/webpack.config.renderer.prod.ts
@@ -2,7 +2,7 @@
  * Build config for electron renderer process
  */
 
-import path from 'path';
+import path, { join } from 'path';
 import webpack from 'webpack';
 import HtmlWebpackPlugin from 'html-webpack-plugin';
 import MiniCssExtractPlugin from 'mini-css-extract-plugin';
@@ -14,6 +14,7 @@ import baseConfig from './webpack.config.base';
 import webpackPaths from './webpack.paths';
 import checkNodeEnv from '../scripts/check-node-env';
 import deleteSourceMaps from '../scripts/delete-source-maps';
+import CopyPlugin from 'copy-webpack-plugin';
 
 checkNodeEnv('production');
 deleteSourceMaps();
@@ -147,6 +148,22 @@ const configuration: webpack.Configuration = {
     new webpack.DefinePlugin({
       'process.type': '"renderer"',
     }),
+
+    new CopyPlugin({
+      patterns: [
+        {
+          from: path.resolve(__dirname, '../../drizzle'),
+          to: path.resolve(__dirname, '../../release/app/drizzle'),
+        },
+        {
+          from: join(
+            path.dirname(require.resolve('pdfjs-dist/package.json')),
+            'legacy/build/pdf.worker.mjs',
+          ),
+          to: 'pdf.worker.mjs', // 出力先 (resources に入る)
+        },
+      ],
+    }),
   ],
 };
 
diff --git a/.mcp.json b/.mcp.json
index 0d7dc4434..8be50ce70 100644
--- a/.mcp.json
+++ b/.mcp.json
@@ -23,6 +23,15 @@
         "--project",
         "."
       ]
+    },
+    "context7": {
+      "type": "stdio",
+      "command": "npx",
+      "args": [
+        "--yes",
+        "@upstash/context7-mcp"
+      ],
+      "env": {}
     }
   }
 }
diff --git a/.serena/.gitignore b/.serena/.gitignore
new file mode 100644
index 000000000..14d86ad62
--- /dev/null
+++ b/.serena/.gitignore
@@ -0,0 +1 @@
+/cache
diff --git a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl
index dca715d63..6b30e8cde 100644
Binary files a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl and b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl differ
diff --git a/.serena/project.yml b/.serena/project.yml
index 9b2c2e9ea..6df9d2f23 100644
--- a/.serena/project.yml
+++ b/.serena/project.yml
@@ -35,7 +35,7 @@ ignored_files:
   - "*.png"
   - "*.pdf"
   - "*.zip"
-# max_file_size: 1048576  # 1MB（バイナリも含む総バイト数）
+max_file_size: 1048576  # 1MB（バイナリも含む総バイト数）
 show_logs: true
 use_lsp: true
 # セキュリティ設定
diff --git a/CLAUDE.md b/CLAUDE.md
index 0066c7179..cd52c82ee 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -170,3 +170,35 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
 - eslintについては単純なフォーマットエラーの場合は対応する必要はない
 - 将来的に本アプリをwebアプリとして利用した場合に、利用者ごとに状態を保持しなければならないような処理の場合はクラスを利用し、アプリで一つの状態を保持するような場合にはモジュールとしてシングルトン変数や関数を利用すること
 - テストについては指示されない限り、実行も修正もしなくてよい
+
+## 依頼タスク: 完了
+### 要件
+1. ドキュメントレビューで、チェックリスト作成やチェック実行をする際のドキュメント指定方法を変更し、従来の選択方式からファイルアップロード機能に変更する
+  - 複数ファイルをアップロード可能
+2. アップロードするファイルがPDFの場合は、テキスト情報を抽出するか、画像として送信するか選択することができる
+
+### UI要件
+- モーダルの変更(`src/renderer/components/review/ReviewSourceModal.tsx`)
+  - 従来の登録済みドキュメントの選択方式は完全に削除
+  - ファイルアップロードボタン追加(複数ファイル選択可能)
+  - アップロード予定のファイル一覧表示
+    - ファイル名を確認可能(パスは不要)
+    - 特定ファイルを指定して送信対象から削除することも可能
+    - ファイルがPDFの場合は画像かテキスト抽出か選択可能
+      - ツールチップで「ファイルが図形オブジェクトを多数含んでいる場合は画像で送信することで精度が上がる場合があります」と表示すること
+  - ファイルアップロードにした場合も、登録済みドキュメント選択方式の場合と変わらないユーザ体験になるようにすること
+    - チェックリスト抽出やチェック実行を実行中の場合は、モーダル内のボタンが非活性になり、実行内容によってモーダルの横にローディングアイコンを配置する(例：チェックリスト抽出を実行中の場合は「チェックリスト抽出」ボタンの横にローディングアイコンを配置する)
+    - 実行完了の際はその旨を通知する
+    - 実行が成功しても失敗してもボタンの非活性を解除する
+
+### 要件実装時の注意
+- ファイルアップロードについては、画像化PDFを除き、Mainプロセスに選択されたファイルのパスを送ること（Mainプロセスにパスからテキストを抽出する仕組みが整えてあるため
+  - Mainプロセスでは連携されたパスをファイルテキスト抽出処理(`src/main/utils/fileExtractor.ts`)に渡すだけでテキスト抽出処理ができるはず
+    - ただし、レビュー機能ではファイルキャッシュしないこと
+  - ブラウザでの絶対パスの取得について
+    - 通常のブラウザAPIでは取得不可なので、electronの機能(dialog等)を利用すること
+- PDFを画像としてアップロードする場合に限り、ブラウザ内でPDFを画像に変換しMainプロセスに送り、その画像をAIに送信すること
+  - （現在インストールされていて、`src/main/utils/fileExtractor.ts`で利用されている）pdfjs-distを利用してください
+  - AIに画像を送信する方法についてはMastraのMCPを参照して確認すること
+- ドキュメントレビュー機能における処理ドキュメント選択において従来の登録済みドキュメントの選択方式は完全に削除する
+  - モーダル画面やworkflowの修正が必要
diff --git a/changes.patch b/changes.patch
index 5af2b2ce0..405a62f2c 100644
--- a/changes.patch
+++ b/changes.patch
@@ -1,659 +1,3221 @@
-diff --git a/changes.patch b/changes.patch
-index 5d2aa955e..e69de29bb 100644
---- a/changes.patch
-+++ b/changes.patch
-@@ -1,490 +0,0 @@
--diff --git a/CLAUDE.md b/CLAUDE.md
--index cc0ee48b6..0066c7179 100644
----- a/CLAUDE.md
--+++ b/CLAUDE.md
--@@ -61,7 +61,9 @@ npm run db:studio
--   - チェックリストをあるドキュメントから抽出して、そのリストを元に別のドキュメントのレビューを実行する機能
--     - サブ機能は以下（Mastraのworkflowを利用して実装）
--       - チェックリスト抽出機能
---      - （上記で抽出したチェックリストに対して）ドキュメントレビュー実行機能
--+        - チェックリストドキュメントからのチェックリスト項目抽出機能
--+        - 一般ドキュメントからのチェックリスト項目作成機能
--+      - （上記で抽出したチェックリスト項目に対して）ドキュメントレビュー実行機能
-- 
-- ### 技術スタック
-- - **フレームワーク**: Electron(electron-react-boilerplate) + React + TypeScript
--diff --git a/src/main/main.ts b/src/main/main.ts
--index 70b3248fc..5c5b21191 100644
----- a/src/main/main.ts
--+++ b/src/main/main.ts
--@@ -612,6 +612,7 @@ const setupReviewHandlers = () => {
--         reviewHistoryId,
--         sourceIds,
--         documentType,
--+        checklistRequirements,
--       }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL],
--     ): Promise<
--       IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]
--@@ -625,6 +626,7 @@ const setupReviewHandlers = () => {
--           sourceIds,
--           event,
--           documentType,
--+          checklistRequirements,
--         );
-- 
--         return result;
--diff --git a/src/main/types/ipc.ts b/src/main/types/ipc.ts
--index cd88b8ef3..b85808772 100644
----- a/src/main/types/ipc.ts
--+++ b/src/main/types/ipc.ts
--@@ -101,6 +101,7 @@ export type IpcRequestPayloadMap = {
--     reviewHistoryId: string;
--     sourceIds: number[];
--     documentType?: DocumentType;
--+    checklistRequirements?: string;
--   };
--   [IpcChannels.REVIEW_UPDATE_CHECKLIST]: {
--     reviewHistoryId: string;
--diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
--index 650675245..a2a9dede0 100644
----- a/src/mastra/agents/prompts.ts
--+++ b/src/mastra/agents/prompts.ts
--@@ -5,6 +5,7 @@ import {
--   ChecklistExtractionAgentRuntimeContext,
--   ClassifyCategoryAgentRuntimeContext,
--   ReviewExecuteAgentRuntimeContext,
--+  TopicExtractionAgentRuntimeContext,
--   TopicChecklistAgentRuntimeContext,
-- } from './workflowAgents';
-- 
--@@ -264,7 +265,13 @@ ${extractedItems.length > 0 ? 'Create **additional checklist items that compleme
-- `;
-- }
-- 
---export function getTopicExtractionPrompt(): string {
--+export function getTopicExtractionPrompt({
--+  runtimeContext,
--+}: {
--+  runtimeContext?: RuntimeContext<TopicExtractionAgentRuntimeContext>;
--+} = {}): string {
--+  const checklistRequirements = runtimeContext?.get('checklistRequirements');
--+
--   return `
-- You are a professional document analysis specialist who extracts independent topics from documents.
-- 
--@@ -275,16 +282,25 @@ Guidelines for topic extraction:
-- - Identify major themes or sections within the document
-- - Each topic should be independent and cover a specific area
-- - Provide a clear, concise title for each topic
---- Include a brief but informative description for each topic
-- - Focus on topics that would benefit from separate review criteria
-- - Aim for 3-8 topics per document (adjust based on document complexity)
-- - Topics should be specific enough to generate targeted checklist items
-- 
---**Important:**
--+${
--+  checklistRequirements
--+    ? `**Special Requirements for Topic Selection:**
--+The user has specified the following requirements for checklist creation:
--+"${checklistRequirements}"
--+
--+Please prioritize topics that align with these requirements when extracting topics from the document. Focus on areas that would enable creating checklist items that meet the specified criteria.
--+
--+`
--+    : ''
--+}**Important:**
-- - Extract topics that represent different aspects or areas of the document
-- - Avoid overlapping or redundant topics
-- - Each topic should be substantial enough to warrant dedicated checklist items
---- Focus on topics that are relevant for document quality and review purposes
--+- Focus on topics that are relevant for document quality and review purposes${checklistRequirements ? '\\n- Prioritize topics that align with the user-specified requirements above' : ''}
-- `;
-- }
-- 
--@@ -294,6 +310,8 @@ export function getTopicChecklistCreationPrompt({
--   runtimeContext: RuntimeContext<TopicChecklistAgentRuntimeContext>;
-- }): string {
--   const title = runtimeContext.get('topic').title;
--+  const checklistRequirements = runtimeContext.get('checklistRequirements');
--+
--   return `
-- You are a senior "Document Review Checklist Designer" specialized in turning a **specific topic** into **practical, verifiable checklist items**.
-- 
--@@ -303,7 +321,17 @@ Analyze the given topic and **produce only checklist items strictly relevant to
-- ## Topic (authoritative context; read carefully)
-- - Title: ${title}
-- 
---## Output Style
--+${
--+  checklistRequirements
--+    ? `## Special Requirements
--+The user has specified the following requirements for checklist creation:
--+"${checklistRequirements}"
--+
--+Please ensure that the checklist items you create align with these requirements and prioritize aspects that meet the specified criteria.
--+
--+`
--+    : ''
--+}## Output Style
-- - Write in **the same language as the topic description**. If unclear, default to **Japanese**.
-- - Provide **5–15 items** unless the topic naturally yields fewer high-quality items.
-- - **Do NOT add unnecessary prefixes or suffixes** to checklist items
--@@ -315,6 +343,7 @@ Each checklist item MUST be:
-- - **Actionable**: If it fails, it implies a clear remediation.
-- - **Risk-aware**: Prefer items that surface **common failure modes** or **risks** within this topic.
-- - **Evidence-oriented**: Suggest **what evidence** to collect (e.g., sections, tables, figures, metadata, citations, configs).
--+${checklistRequirements ? '- **Requirements-aligned**: Prioritize aspects that align with the user-specified requirements above.' : ''}
-- 
-- ## Coverage Hints (use only if relevant to THIS topic)
-- - **Quality & Accuracy**: definitions, metrics, calculations, references, data lineage, units, versioning.
--@@ -327,11 +356,11 @@ Each checklist item MUST be:
-- ## Hard Constraints
-- - **Stay strictly within the topic** above. Do NOT drift into unrelated areas.
-- - **Avoid generic items** that could apply to any document (e.g., "typos are fixed", "overall quality is good").
---- **No speculative content** beyond the topic’s scope.
--+- **No speculative content** beyond the topic's scope.
-- - **Be concise but unambiguous**. Prefer checkability over prose.
---- **Reference ALL relevant parts of the topic**: Ensure you consider every portion of the topic’s description and implied scope so that **no important aspect is omitted** when creating checklist items.
--+- **Reference ALL relevant parts of the topic**: Ensure you consider every portion of the topic's description and implied scope so that **no important aspect is omitted** when creating checklist items.
-- 
---Now produce the checklist items **only for the topic: ${title} , following all requirements.
--+Now produce the checklist items **only for the topic: ${title}**, following all requirements${checklistRequirements ? ' and ensuring alignment with the user-specified requirements' : ''}.
-- `;
-- }
-- 
--diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
--index fdb9ef746..2194e4a26 100644
----- a/src/mastra/agents/workflowAgents.ts
--+++ b/src/mastra/agents/workflowAgents.ts
--@@ -28,8 +28,13 @@ export type ReviewExecuteAgentRuntimeContext = BaseRuntimeContext & {
--   checklistItems: { id: number; content: string }[];
-- };
-- 
--+export type TopicExtractionAgentRuntimeContext = BaseRuntimeContext & {
--+  checklistRequirements?: string;
--+};
--+
-- export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
---  topic: { title: string; description: string };
--+  topic: { title: string };
--+  checklistRequirements?: string;
-- };
-- 
-- export const summarizeSourceAgent = new Agent({
--diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
--index 825b6130f..9c195e810 100644
----- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
--+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
--@@ -12,6 +12,7 @@ import { baseStepOutputSchema } from '../schema';
-- import { stepStatus } from '../types';
-- import {
--   ChecklistExtractionAgentRuntimeContext,
--+  TopicExtractionAgentRuntimeContext,
--   TopicChecklistAgentRuntimeContext,
-- } from '../../agents/workflowAgents';
-- import { createRuntimeContext } from '../../agents/lib';
--@@ -28,6 +29,10 @@ const triggerSchema = z.object({
--     .describe(
--       'ドキュメント種別: checklist=チェックリストドキュメント, general=一般ドキュメント',
--     ),
--+  checklistRequirements: z
--+    .string()
--+    .optional()
--+    .describe('一般ドキュメント用のチェックリスト作成要件'),
-- });
-- 
-- // チェックリストドキュメント用のステップ出力スキーマ
--@@ -41,7 +46,6 @@ const topicExtractionStepOutputSchema = baseStepOutputSchema.extend({
--     .array(
--       z.object({
--         title: z.string(),
---        description: z.string(),
--         sourceId: z.number(),
--       }),
--     )
--@@ -274,7 +278,7 @@ const topicExtractionStep = createStep({
--   execute: async ({ inputData, mastra, bail }) => {
--     const sourceRepository = getSourceRepository();
--     const reviewRepository = getReviewRepository();
---    const { sourceIds, reviewHistoryId } = inputData;
--+    const { sourceIds, reviewHistoryId, checklistRequirements } = inputData;
--     const errorMessages: string[] = [
--       'チェックリスト作成処理中にエラーが発生しました',
--     ];
--@@ -282,7 +286,6 @@ const topicExtractionStep = createStep({
--     try {
--       const allTopics: Array<{
--         title: string;
---        description: string;
--         sourceId: number;
--       }> = [];
-- 
--@@ -305,12 +308,15 @@ const topicExtractionStep = createStep({
--               .array(
--                 z.object({
--                   title: z.string().describe('Topic title'),
---                  description: z.string().describe('Topic description'),
--                 }),
--               )
--               .describe('Extracted topics from the document'),
--           });
---          const runtimeContext = createRuntimeContext();
--+          const runtimeContext =
--+            createRuntimeContext<TopicExtractionAgentRuntimeContext>();
--+          if (checklistRequirements) {
--+            runtimeContext.set('checklistRequirements', checklistRequirements);
--+          }
-- 
--           const extractionResult = await topicExtractionAgent.generate(
--             content,
--@@ -347,8 +353,7 @@ const topicExtractionStep = createStep({
-- 
--       await Promise.all(extractionPromises);
--       console.log(
---        'トピック抽出完了:\n' +
---          allTopics.map((t) => `${t.title}: ${t.description}`).join('\n'),
--+        'トピック抽出完了:\n' + allTopics.map((t) => `${t.title}`).join('\n'),
--       );
-- 
--       // エラーがあれば失敗として返す
--@@ -394,13 +399,14 @@ const topicChecklistCreationStep = createStep({
--   description: 'トピックに基づいてチェックリスト項目を作成するステップ',
--   inputSchema: z.object({
--     title: z.string(),
---    description: z.string(),
--     sourceId: z.number(),
--     reviewHistoryId: z.string(),
--+    checklistRequirements: z.string().optional(),
--   }),
--   outputSchema: topicChecklistStepOutputSchema,
--   execute: async ({ inputData, mastra, bail }) => {
---    const { title, description, sourceId, reviewHistoryId } = inputData;
--+    const { title, sourceId, reviewHistoryId, checklistRequirements } =
--+      inputData;
--     const sourceRepository = getSourceRepository();
--     const reviewRepository = getReviewRepository();
--     const errorMessages: string[] = [
--@@ -423,7 +429,10 @@ const topicChecklistCreationStep = createStep({
-- 
--       const runtimeContext =
--         createRuntimeContext<TopicChecklistAgentRuntimeContext>();
---      runtimeContext.set('topic', { title, description });
--+      runtimeContext.set('topic', { title });
--+      if (checklistRequirements) {
--+        runtimeContext.set('checklistRequirements', checklistRequirements);
--+      }
-- 
--       const result = await topicChecklistAgent.generate(content, {
--         output: outputSchema,
--@@ -573,9 +582,9 @@ export const checklistExtractionWorkflow = createWorkflow({
-- 
--           return topicResult.topics.map((topic) => ({
--             title: topic.title,
---            description: topic.description,
--             sourceId: topic.sourceId,
--             reviewHistoryId: initData.reviewHistoryId,
--+            checklistRequirements: initData.checklistRequirements,
--           }));
--         })
--         // Step2: 各トピックに対してチェックリスト作成（foreachでループ）
--diff --git a/src/mastra/workflows/sourceReview/sourceReviewManager.ts b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
--index 953392cbb..79800bd46 100644
----- a/src/mastra/workflows/sourceReview/sourceReviewManager.ts
--+++ b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
--@@ -43,6 +43,7 @@ export default class SourceReviewManager {
--     reviewHistoryId: string,
--     sourceIds: number[],
--     documentType: DocumentType = 'checklist',
--+    checklistRequirements?: string,
--   ): Promise<{ success: boolean; error?: string }> {
--     try {
--       let reviewHistory: ReviewHistory | null;
--@@ -77,6 +78,7 @@ export default class SourceReviewManager {
--           reviewHistoryId,
--           sourceIds,
--           documentType,
--+          checklistRequirements,
--         },
--       });
-- 
--@@ -171,9 +173,10 @@ export default class SourceReviewManager {
--     sourceIds: number[],
--     event: IpcMainInvokeEvent,
--     documentType: DocumentType = 'checklist',
--+    checklistRequirements?: string,
--   ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL] {
--     try {
---      this.extractChecklist(reviewHistoryId, sourceIds, documentType)
--+      this.extractChecklist(reviewHistoryId, sourceIds, documentType, checklistRequirements)
--         .then((res) => {
--           // 完了イベントを送信
--           event.sender.send(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
--diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
--index 3e667af69..56bf1fbde 100644
----- a/src/renderer/components/review/ReviewArea.tsx
--+++ b/src/renderer/components/review/ReviewArea.tsx
--@@ -77,7 +77,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
-- 
--   // チェックリストの抽出処理
--   const handleExtractChecklist = useCallback(
---    async (sourceIds: number[], documentType?: DocumentType) => {
--+    async (
--+      sourceIds: number[],
--+      documentType?: DocumentType,
--+      checklistRequirements?: string,
--+    ) => {
--       if (!selectedReviewHistoryId) return;
-- 
--       try {
--@@ -89,6 +93,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
--           reviewHistoryId: selectedReviewHistoryId,
--           sourceIds,
--           documentType,
--+          checklistRequirements,
--         });
-- 
--         if (!result.success) {
--@@ -197,9 +202,17 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
--   );
-- 
--   const handleModalSubmit = useCallback(
---    async (sourceIds: number[], documentType?: DocumentType) => {
--+    async (
--+      sourceIds: number[],
--+      documentType?: DocumentType,
--+      checklistRequirements?: string,
--+    ) => {
--       if (modalMode === 'extract') {
---        await handleExtractChecklist(sourceIds, documentType);
--+        await handleExtractChecklist(
--+          sourceIds,
--+          documentType,
--+          checklistRequirements,
--+        );
--       } else if (modalMode === 'review') {
--         await handleExecuteReview(sourceIds);
--       }
--diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
--index 419d0d1d5..65ceefc9b 100644
----- a/src/renderer/components/review/ReviewSourceModal.tsx
--+++ b/src/renderer/components/review/ReviewSourceModal.tsx
--@@ -20,6 +20,7 @@ import {
--   FormControlLabel,
--   Radio,
--   FormLabel,
--+  TextField,
-- } from '@mui/material';
-- import {
--   Check as CheckIcon,
--@@ -46,6 +47,7 @@ function SourceListModal({
--   }>({});
--   const [processing, setProcessing] = useState(true);
--   const [documentType, setDocumentType] = useState<DocumentType>('checklist');
--+  const [checklistRequirements, setChecklistRequirements] = useState('');
-- 
--   // チェック状態の更新
--   // ソースの更新状態が変わったときにチェック状態を更新する
--@@ -73,6 +75,8 @@ function SourceListModal({
--     });
--     // ドキュメント種別もリセット
--     setDocumentType('checklist');
--+    // チェックリスト作成要件もリセット
--+    setChecklistRequirements('');
--   }, [modalMode, selectedReviewHistoryId]);
-- 
--   // チェックボックスの変更ハンドラ
--@@ -148,6 +152,11 @@ function SourceListModal({
--         })
--         .map((key) => +key),
--       modalMode === 'extract' ? documentType : undefined,
--+      modalMode === 'extract' &&
--+        documentType === 'general' &&
--+        checklistRequirements.trim() !== ''
--+        ? checklistRequirements.trim()
--+        : undefined,
--     );
--   };
-- 
--@@ -299,27 +308,46 @@ function SourceListModal({
--         </Alert>
-- 
--         {modalMode === 'extract' && (
---          <FormControl component="fieldset" sx={{ mb: 2 }}>
---            <FormLabel component="legend">ドキュメント種別</FormLabel>
---            <RadioGroup
---              row
---              value={documentType}
---              onChange={(e) => setDocumentType(e.target.value as DocumentType)}
---            >
---              <FormControlLabel
---                value="checklist"
---                control={<Radio />}
---                label="チェックリストドキュメント（既存項目を抽出）"
---                disabled={processing}
---              />
---              <FormControlLabel
---                value="general"
---                control={<Radio />}
---                label="一般ドキュメント（新規チェックリスト作成）"
--+          <>
--+            <FormControl component="fieldset" sx={{ mb: 2 }}>
--+              <FormLabel component="legend">ドキュメント種別</FormLabel>
--+              <RadioGroup
--+                row
--+                value={documentType}
--+                onChange={(e) =>
--+                  setDocumentType(e.target.value as DocumentType)
--+                }
--+              >
--+                <FormControlLabel
--+                  value="checklist"
--+                  control={<Radio />}
--+                  label="チェックリストドキュメント（既存項目を抽出）"
--+                  disabled={processing}
--+                />
--+                <FormControlLabel
--+                  value="general"
--+                  control={<Radio />}
--+                  label="一般ドキュメント（新規チェックリスト作成）"
--+                  disabled={processing}
--+                />
--+              </RadioGroup>
--+            </FormControl>
--+
--+            {documentType === 'general' && (
--+              <TextField
--+                fullWidth
--+                multiline
--+                rows={5}
--+                label="チェックリスト作成要件"
--+                placeholder="例：セキュリティ観点での確認項目を重視、品質管理に関するチェック項目を中心に"
--+                value={checklistRequirements}
--+                onChange={(e) => setChecklistRequirements(e.target.value)}
--                 disabled={processing}
--+                sx={{ mb: 2 }}
--+                helperText="どのような観点でチェックリストを作成したいか具体的に記載してください（任意）"
--               />
---            </RadioGroup>
---          </FormControl>
--+            )}
--+          </>
--         )}
-- 
--         <Box sx={{ mb: 2, display: 'flex', justifyContent: 'flex-end' }}>
--diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
--index 6bc69c9e6..55c81e159 100644
----- a/src/renderer/components/review/types.ts
--+++ b/src/renderer/components/review/types.ts
--@@ -25,7 +25,11 @@ export type DocumentType = 'checklist' | 'general';
-- export interface ReviewSourceModalProps {
--   open: boolean;
--   onClose: () => void;
---  onSubmit: (sourceIds: number[], documentType?: DocumentType) => void;
--+  onSubmit: (
--+    sourceIds: number[],
--+    documentType?: DocumentType,
--+    checklistRequirements?: string,
--+  ) => void;
--   selectedReviewHistoryId: string | null;
--   disabled?: boolean;
--   modalMode: ModalMode;
-diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
-index a2a9dede0..8418fb85b 100644
---- a/src/mastra/agents/prompts.ts
-+++ b/src/mastra/agents/prompts.ts
-@@ -279,6 +279,7 @@ Your task is to analyze the provided document and identify distinct, independent
- 
- Guidelines for topic extraction:
- - Write in the same language as the document. If unclear, default to Japanese.
-+- Explain the reason why that topic is necessary for creating checklist items.
- - Identify major themes or sections within the document
- - Each topic should be independent and cover a specific area
- - Provide a clear, concise title for each topic
-@@ -319,7 +320,7 @@ You are a senior "Document Review Checklist Designer" specialized in turning a *
- Analyze the given topic and **produce only checklist items strictly relevant to this topic** that reviewers can directly apply during document reviews.
- 
- ## Topic (authoritative context; read carefully)
--- Title: ${title}
-+- ${title}
- 
- ${
-   checklistRequirements
-@@ -333,6 +334,7 @@ Please ensure that the checklist items you create align with these requirements
-     : ''
- }## Output Style
- - Write in **the same language as the topic description**. If unclear, default to **Japanese**.
-+- Explain the reason why the checklist items based on the document are valuable.
- - Provide **5–15 items** unless the topic naturally yields fewer high-quality items.
- - **Do NOT add unnecessary prefixes or suffixes** to checklist items
- 
-diff --git a/src/mastra/index.ts b/src/mastra/index.ts
-index 09a8e2f6c..c69c2da72 100644
---- a/src/mastra/index.ts
-+++ b/src/mastra/index.ts
-@@ -3,7 +3,7 @@
- // @ts-ignore
- import { Mastra } from '@mastra/core';
- // @ts-ignore
--import { createLogger } from '@mastra/core/logger';
-+import { ConsoleLogger } from '@mastra/core/logger';
- import { orchestrator } from './agents/orchestrator';
- import { documentExpertAgent } from './agents/toolAgents';
+diff --git a/.erb/configs/webpack.config.renderer.dev.ts b/.erb/configs/webpack.config.renderer.dev.ts
+index a6ca87e90..a406528c9 100644
+--- a/.erb/configs/webpack.config.renderer.dev.ts
++++ b/.erb/configs/webpack.config.renderer.dev.ts
+@@ -1,5 +1,5 @@
+ import 'webpack-dev-server';
+-import path from 'path';
++import path, { join } from 'path';
+ import fs from 'fs';
+ import webpack from 'webpack';
+ import HtmlWebpackPlugin from 'html-webpack-plugin';
+@@ -7,6 +7,7 @@ import chalk from 'chalk';
+ import { merge } from 'webpack-merge';
+ import { execSync, spawn } from 'child_process';
+ import ReactRefreshWebpackPlugin from '@pmmmwh/react-refresh-webpack-plugin';
++import CopyPlugin from 'copy-webpack-plugin';
+ import baseConfig from './webpack.config.base';
+ import webpackPaths from './webpack.paths';
+ import checkNodeEnv from '../scripts/check-node-env';
+@@ -162,6 +163,22 @@ const configuration: webpack.Configuration = {
+       isDevelopment: process.env.NODE_ENV !== 'production',
+       nodeModules: webpackPaths.appNodeModulesPath,
+     }),
++
++    new CopyPlugin({
++      patterns: [
++        {
++          from: path.resolve(__dirname, '../../drizzle'),
++          to: path.resolve(__dirname, '../../release/app/drizzle'),
++        },
++        {
++          from: join(
++            path.dirname(require.resolve('pdfjs-dist/package.json')),
++            'legacy/build/pdf.worker.mjs',
++          ),
++          to: 'pdf.worker.mjs', // 出力先 (resources に入る)
++        },
++      ],
++    }),
+   ],
+ 
+   node: {
+diff --git a/.erb/configs/webpack.config.renderer.prod.ts b/.erb/configs/webpack.config.renderer.prod.ts
+index c30a09a42..15720d77f 100644
+--- a/.erb/configs/webpack.config.renderer.prod.ts
++++ b/.erb/configs/webpack.config.renderer.prod.ts
+@@ -2,7 +2,7 @@
+  * Build config for electron renderer process
+  */
+ 
+-import path from 'path';
++import path, { join } from 'path';
+ import webpack from 'webpack';
+ import HtmlWebpackPlugin from 'html-webpack-plugin';
+ import MiniCssExtractPlugin from 'mini-css-extract-plugin';
+@@ -14,6 +14,7 @@ import baseConfig from './webpack.config.base';
+ import webpackPaths from './webpack.paths';
+ import checkNodeEnv from '../scripts/check-node-env';
+ import deleteSourceMaps from '../scripts/delete-source-maps';
++import CopyPlugin from 'copy-webpack-plugin';
+ 
+ checkNodeEnv('production');
+ deleteSourceMaps();
+@@ -147,6 +148,22 @@ const configuration: webpack.Configuration = {
+     new webpack.DefinePlugin({
+       'process.type': '"renderer"',
+     }),
++
++    new CopyPlugin({
++      patterns: [
++        {
++          from: path.resolve(__dirname, '../../drizzle'),
++          to: path.resolve(__dirname, '../../release/app/drizzle'),
++        },
++        {
++          from: join(
++            path.dirname(require.resolve('pdfjs-dist/package.json')),
++            'legacy/build/pdf.worker.mjs',
++          ),
++          to: 'pdf.worker.mjs', // 出力先 (resources に入る)
++        },
++      ],
++    }),
+   ],
+ };
+ 
+diff --git a/.mcp.json b/.mcp.json
+index 0d7dc4434..8be50ce70 100644
+--- a/.mcp.json
++++ b/.mcp.json
+@@ -23,6 +23,15 @@
+         "--project",
+         "."
+       ]
++    },
++    "context7": {
++      "type": "stdio",
++      "command": "npx",
++      "args": [
++        "--yes",
++        "@upstash/context7-mcp"
++      ],
++      "env": {}
+     }
+   }
+ }
+diff --git a/.serena/.gitignore b/.serena/.gitignore
+new file mode 100644
+index 000000000..14d86ad62
+--- /dev/null
++++ b/.serena/.gitignore
+@@ -0,0 +1 @@
++/cache
+diff --git a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl
+index dca715d63..f7ec5a477 100644
+Binary files a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl and b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl differ
+diff --git a/.serena/project.yml b/.serena/project.yml
+index 9b2c2e9ea..6df9d2f23 100644
+--- a/.serena/project.yml
++++ b/.serena/project.yml
+@@ -35,7 +35,7 @@ ignored_files:
+   - "*.png"
+   - "*.pdf"
+   - "*.zip"
+-# max_file_size: 1048576  # 1MB（バイナリも含む総バイト数）
++max_file_size: 1048576  # 1MB（バイナリも含む総バイト数）
+ show_logs: true
+ use_lsp: true
+ # セキュリティ設定
+diff --git a/CLAUDE.md b/CLAUDE.md
+index 0066c7179..cd52c82ee 100644
+--- a/CLAUDE.md
++++ b/CLAUDE.md
+@@ -170,3 +170,35 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
+ - eslintについては単純なフォーマットエラーの場合は対応する必要はない
+ - 将来的に本アプリをwebアプリとして利用した場合に、利用者ごとに状態を保持しなければならないような処理の場合はクラスを利用し、アプリで一つの状態を保持するような場合にはモジュールとしてシングルトン変数や関数を利用すること
+ - テストについては指示されない限り、実行も修正もしなくてよい
++
++## 依頼タスク: 完了
++### 要件
++1. ドキュメントレビューで、チェックリスト作成やチェック実行をする際のドキュメント指定方法を変更し、従来の選択方式からファイルアップロード機能に変更する
++  - 複数ファイルをアップロード可能
++2. アップロードするファイルがPDFの場合は、テキスト情報を抽出するか、画像として送信するか選択することができる
++
++### UI要件
++- モーダルの変更(`src/renderer/components/review/ReviewSourceModal.tsx`)
++  - 従来の登録済みドキュメントの選択方式は完全に削除
++  - ファイルアップロードボタン追加(複数ファイル選択可能)
++  - アップロード予定のファイル一覧表示
++    - ファイル名を確認可能(パスは不要)
++    - 特定ファイルを指定して送信対象から削除することも可能
++    - ファイルがPDFの場合は画像かテキスト抽出か選択可能
++      - ツールチップで「ファイルが図形オブジェクトを多数含んでいる場合は画像で送信することで精度が上がる場合があります」と表示すること
++  - ファイルアップロードにした場合も、登録済みドキュメント選択方式の場合と変わらないユーザ体験になるようにすること
++    - チェックリスト抽出やチェック実行を実行中の場合は、モーダル内のボタンが非活性になり、実行内容によってモーダルの横にローディングアイコンを配置する(例：チェックリスト抽出を実行中の場合は「チェックリスト抽出」ボタンの横にローディングアイコンを配置する)
++    - 実行完了の際はその旨を通知する
++    - 実行が成功しても失敗してもボタンの非活性を解除する
++
++### 要件実装時の注意
++- ファイルアップロードについては、画像化PDFを除き、Mainプロセスに選択されたファイルのパスを送ること（Mainプロセスにパスからテキストを抽出する仕組みが整えてあるため
++  - Mainプロセスでは連携されたパスをファイルテキスト抽出処理(`src/main/utils/fileExtractor.ts`)に渡すだけでテキスト抽出処理ができるはず
++    - ただし、レビュー機能ではファイルキャッシュしないこと
++  - ブラウザでの絶対パスの取得について
++    - 通常のブラウザAPIでは取得不可なので、electronの機能(dialog等)を利用すること
++- PDFを画像としてアップロードする場合に限り、ブラウザ内でPDFを画像に変換しMainプロセスに送り、その画像をAIに送信すること
++  - （現在インストールされていて、`src/main/utils/fileExtractor.ts`で利用されている）pdfjs-distを利用してください
++  - AIに画像を送信する方法についてはMastraのMCPを参照して確認すること
++- ドキュメントレビュー機能における処理ドキュメント選択において従来の登録済みドキュメントの選択方式は完全に削除する
++  - モーダル画面やworkflowの修正が必要
+diff --git a/drizzle/migrations/0004_adorable_abomination.sql b/drizzle/migrations/0004_adorable_abomination.sql
+new file mode 100644
+index 000000000..847a9f90c
+--- /dev/null
++++ b/drizzle/migrations/0004_adorable_abomination.sql
+@@ -0,0 +1,13 @@
++CREATE TABLE `review_checklist_results` (
++	`review_checklist_id` integer NOT NULL,
++	`file_id` text NOT NULL,
++	`file_name` text NOT NULL,
++	`evaluation` text NOT NULL,
++	`comment` text,
++	`created_at` text DEFAULT (current_timestamp) NOT NULL,
++	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
++	PRIMARY KEY(`review_checklist_id`, `file_id`),
++	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
++);
++--> statement-breakpoint
++DROP TABLE `review_checklist_sources`;
+\ No newline at end of file
+diff --git a/drizzle/migrations/meta/0004_snapshot.json b/drizzle/migrations/meta/0004_snapshot.json
+new file mode 100644
+index 000000000..403c6cf39
+--- /dev/null
++++ b/drizzle/migrations/meta/0004_snapshot.json
+@@ -0,0 +1,362 @@
++{
++  "version": "6",
++  "dialect": "sqlite",
++  "id": "362051e0-23e2-46a5-88e8-952bfb3e5be4",
++  "prevId": "e4779464-5d36-4a28-a701-899c1b816205",
++  "tables": {
++    "review_checklist_results": {
++      "name": "review_checklist_results",
++      "columns": {
++        "review_checklist_id": {
++          "name": "review_checklist_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "file_id": {
++          "name": "file_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "file_name": {
++          "name": "file_name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "evaluation": {
++          "name": "evaluation",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "comment": {
++          "name": "comment",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_checklist_results_review_checklist_id_review_checklists_id_fk": {
++          "name": "review_checklist_results_review_checklist_id_review_checklists_id_fk",
++          "tableFrom": "review_checklist_results",
++          "tableTo": "review_checklists",
++          "columnsFrom": [
++            "review_checklist_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {
++        "review_checklist_results_review_checklist_id_file_id_pk": {
++          "columns": [
++            "review_checklist_id",
++            "file_id"
++          ],
++          "name": "review_checklist_results_review_checklist_id_file_id_pk"
++        }
++      },
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_checklists": {
++      "name": "review_checklists",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "review_history_id": {
++          "name": "review_history_id",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "content": {
++          "name": "content",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_by": {
++          "name": "created_by",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "review_checklists_review_history_id_review_histories_id_fk": {
++          "name": "review_checklists_review_history_id_review_histories_id_fk",
++          "tableFrom": "review_checklists",
++          "tableTo": "review_histories",
++          "columnsFrom": [
++            "review_history_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "review_histories": {
++      "name": "review_histories",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "text",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "sources": {
++      "name": "sources",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "path": {
++          "name": "path",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "title": {
++          "name": "title",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "status": {
++          "name": "status",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "'idle'"
++        },
++        "error": {
++          "name": "error",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": false,
++          "autoincrement": false
++        },
++        "is_enabled": {
++          "name": "is_enabled",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": 1
++        }
++      },
++      "indexes": {
++        "sources_path_unique": {
++          "name": "sources_path_unique",
++          "columns": [
++            "path"
++          ],
++          "isUnique": true
++        }
++      },
++      "foreignKeys": {},
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    },
++    "topics": {
++      "name": "topics",
++      "columns": {
++        "id": {
++          "name": "id",
++          "type": "integer",
++          "primaryKey": true,
++          "notNull": true,
++          "autoincrement": true
++        },
++        "source_id": {
++          "name": "source_id",
++          "type": "integer",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "name": {
++          "name": "name",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "summary": {
++          "name": "summary",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false
++        },
++        "created_at": {
++          "name": "created_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        },
++        "updated_at": {
++          "name": "updated_at",
++          "type": "text",
++          "primaryKey": false,
++          "notNull": true,
++          "autoincrement": false,
++          "default": "(current_timestamp)"
++        }
++      },
++      "indexes": {},
++      "foreignKeys": {
++        "topics_source_id_sources_id_fk": {
++          "name": "topics_source_id_sources_id_fk",
++          "tableFrom": "topics",
++          "tableTo": "sources",
++          "columnsFrom": [
++            "source_id"
++          ],
++          "columnsTo": [
++            "id"
++          ],
++          "onDelete": "cascade",
++          "onUpdate": "no action"
++        }
++      },
++      "compositePrimaryKeys": {},
++      "uniqueConstraints": {},
++      "checkConstraints": {}
++    }
++  },
++  "views": {},
++  "enums": {},
++  "_meta": {
++    "schemas": {},
++    "tables": {},
++    "columns": {}
++  },
++  "internal": {
++    "indexes": {}
++  }
++}
+\ No newline at end of file
+diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
+index 6313c7bd6..1315c768b 100644
+--- a/drizzle/migrations/meta/_journal.json
++++ b/drizzle/migrations/meta/_journal.json
+@@ -29,6 +29,13 @@
+       "when": 1749952232695,
+       "tag": "0003_outgoing_cobalt_man",
+       "breakpoints": true
++    },
++    {
++      "idx": 4,
++      "version": "6",
++      "when": 1756909323206,
++      "tag": "0004_adorable_abomination",
++      "breakpoints": true
+     }
+   ]
+ }
+\ No newline at end of file
+diff --git a/package-lock.json b/package-lock.json
+index ba32ee2b8..46bcccd6f 100644
+--- a/package-lock.json
++++ b/package-lock.json
+@@ -5105,6 +5105,207 @@
+         "node": ">=10"
+       }
+     },
++    "node_modules/@mapbox/node-pre-gyp": {
++      "version": "1.0.11",
++      "resolved": "https://registry.npmjs.org/@mapbox/node-pre-gyp/-/node-pre-gyp-1.0.11.tgz",
++      "integrity": "sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==",
++      "dev": true,
++      "license": "BSD-3-Clause",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "detect-libc": "^2.0.0",
++        "https-proxy-agent": "^5.0.0",
++        "make-dir": "^3.1.0",
++        "node-fetch": "^2.6.7",
++        "nopt": "^5.0.0",
++        "npmlog": "^5.0.1",
++        "rimraf": "^3.0.2",
++        "semver": "^7.3.5",
++        "tar": "^6.1.11"
++      },
++      "bin": {
++        "node-pre-gyp": "bin/node-pre-gyp"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/are-we-there-yet": {
++      "version": "2.0.0",
++      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-2.0.0.tgz",
++      "integrity": "sha512-Ci/qENmwHnsYo9xKIcUJN5LeDKdJ6R1Z1j9V/J5wyq8nh/mYPEpIKJbBZXtZjG04HiK7zV/p6Vs9952MrMeUIw==",
++      "deprecated": "This package is no longer supported.",
++      "dev": true,
++      "license": "ISC",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "delegates": "^1.0.0",
++        "readable-stream": "^3.6.0"
++      },
++      "engines": {
++        "node": ">=10"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/gauge": {
++      "version": "3.0.2",
++      "resolved": "https://registry.npmjs.org/gauge/-/gauge-3.0.2.tgz",
++      "integrity": "sha512-+5J6MS/5XksCuXq++uFRsnUd7Ovu1XenbeuIuNRJxYWjgQbPuFhT14lAvsWfqfAmnwluf1OwMjz39HjfLPci0Q==",
++      "deprecated": "This package is no longer supported.",
++      "dev": true,
++      "license": "ISC",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "aproba": "^1.0.3 || ^2.0.0",
++        "color-support": "^1.1.2",
++        "console-control-strings": "^1.0.0",
++        "has-unicode": "^2.0.1",
++        "object-assign": "^4.1.1",
++        "signal-exit": "^3.0.0",
++        "string-width": "^4.2.3",
++        "strip-ansi": "^6.0.1",
++        "wide-align": "^1.1.2"
++      },
++      "engines": {
++        "node": ">=10"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/make-dir": {
++      "version": "3.1.0",
++      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
++      "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "semver": "^6.0.0"
++      },
++      "engines": {
++        "node": ">=8"
++      },
++      "funding": {
++        "url": "https://github.com/sponsors/sindresorhus"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/make-dir/node_modules/semver": {
++      "version": "6.3.1",
++      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
++      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
++      "dev": true,
++      "license": "ISC",
++      "optional": true,
++      "peer": true,
++      "bin": {
++        "semver": "bin/semver.js"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/node-fetch": {
++      "version": "2.7.0",
++      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
++      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "whatwg-url": "^5.0.0"
++      },
++      "engines": {
++        "node": "4.x || >=6.0.0"
++      },
++      "peerDependencies": {
++        "encoding": "^0.1.0"
++      },
++      "peerDependenciesMeta": {
++        "encoding": {
++          "optional": true
++        }
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/nopt": {
++      "version": "5.0.0",
++      "resolved": "https://registry.npmjs.org/nopt/-/nopt-5.0.0.tgz",
++      "integrity": "sha512-Tbj67rffqceeLpcRXrT7vKAN8CwfPeIBgM7E6iBkmKLV7bEMwpGgYLGv0jACUsECaa/vuxP0IjEont6umdMgtQ==",
++      "dev": true,
++      "license": "ISC",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "abbrev": "1"
++      },
++      "bin": {
++        "nopt": "bin/nopt.js"
++      },
++      "engines": {
++        "node": ">=6"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/npmlog": {
++      "version": "5.0.1",
++      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-5.0.1.tgz",
++      "integrity": "sha512-AqZtDUWOMKs1G/8lwylVjrdYgqA4d9nu8hc+0gzRxlDb1I10+FHBGMXs6aiQHFdCUUlqH99MUMuLfzWDNDtfxw==",
++      "deprecated": "This package is no longer supported.",
++      "dev": true,
++      "license": "ISC",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "are-we-there-yet": "^2.0.0",
++        "console-control-strings": "^1.1.0",
++        "gauge": "^3.0.0",
++        "set-blocking": "^2.0.0"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/rimraf": {
++      "version": "3.0.2",
++      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
++      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
++      "deprecated": "Rimraf versions prior to v4 are no longer supported",
++      "dev": true,
++      "license": "ISC",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "glob": "^7.1.3"
++      },
++      "bin": {
++        "rimraf": "bin.js"
++      },
++      "funding": {
++        "url": "https://github.com/sponsors/isaacs"
++      }
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/tr46": {
++      "version": "0.0.3",
++      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
++      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/webidl-conversions": {
++      "version": "3.0.1",
++      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
++      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==",
++      "dev": true,
++      "license": "BSD-2-Clause",
++      "optional": true,
++      "peer": true
++    },
++    "node_modules/@mapbox/node-pre-gyp/node_modules/whatwg-url": {
++      "version": "5.0.0",
++      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
++      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "tr46": "~0.0.3",
++        "webidl-conversions": "^3.0.0"
++      }
++    },
+     "node_modules/@mastra/core": {
+       "version": "0.14.1",
+       "resolved": "https://registry.npmjs.org/@mastra/core/-/core-0.14.1.tgz",
+@@ -13329,6 +13530,24 @@
+       ],
+       "license": "CC-BY-4.0"
+     },
++    "node_modules/canvas": {
++      "version": "2.11.2",
++      "resolved": "https://registry.npmjs.org/canvas/-/canvas-2.11.2.tgz",
++      "integrity": "sha512-ItanGBMrmRV7Py2Z+Xhs7cT+FNt5K0vPL4p9EZ/UX/Mu7hFbkxSjKF2KVtPwX7UYWp7dRKnrTvReflgrItJbdw==",
++      "dev": true,
++      "hasInstallScript": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "@mapbox/node-pre-gyp": "^1.0.0",
++        "nan": "^2.17.0",
++        "simple-get": "^3.0.3"
++      },
++      "engines": {
++        "node": ">=6"
++      }
++    },
+     "node_modules/ccount": {
+       "version": "2.0.1",
+       "resolved": "https://registry.npmjs.org/ccount/-/ccount-2.0.1.tgz",
+@@ -25232,6 +25451,15 @@
+         "url": "https://github.com/sponsors/raouldeheer"
+       }
+     },
++    "node_modules/nan": {
++      "version": "2.23.0",
++      "resolved": "https://registry.npmjs.org/nan/-/nan-2.23.0.tgz",
++      "integrity": "sha512-1UxuyYGdoQHcGg87Lkqm3FzefucTa0NAiOcuRsDmysep3c1LVCRK2krrUDafMWtjSG04htvAmvg96+SDknOmgQ==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true
++    },
+     "node_modules/nanoid": {
+       "version": "3.3.11",
+       "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
+@@ -29808,6 +30036,73 @@
+       "dev": true,
+       "license": "ISC"
+     },
++    "node_modules/simple-concat": {
++      "version": "1.0.1",
++      "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
++      "integrity": "sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==",
++      "dev": true,
++      "funding": [
++        {
++          "type": "github",
++          "url": "https://github.com/sponsors/feross"
++        },
++        {
++          "type": "patreon",
++          "url": "https://www.patreon.com/feross"
++        },
++        {
++          "type": "consulting",
++          "url": "https://feross.org/support"
++        }
++      ],
++      "license": "MIT",
++      "optional": true,
++      "peer": true
++    },
++    "node_modules/simple-get": {
++      "version": "3.1.1",
++      "resolved": "https://registry.npmjs.org/simple-get/-/simple-get-3.1.1.tgz",
++      "integrity": "sha512-CQ5LTKGfCpvE1K0n2us+kuMPbk/q0EKl82s4aheV9oXjFEz6W/Y7oQFVJuU6QG77hRT4Ghb5RURteF5vnWjupA==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "decompress-response": "^4.2.0",
++        "once": "^1.3.1",
++        "simple-concat": "^1.0.0"
++      }
++    },
++    "node_modules/simple-get/node_modules/decompress-response": {
++      "version": "4.2.1",
++      "resolved": "https://registry.npmjs.org/decompress-response/-/decompress-response-4.2.1.tgz",
++      "integrity": "sha512-jOSne2qbyE+/r8G1VU+G/82LBs2Fs4LAsTiLSHOCOMZQl2OKZ6i8i4IyHemTe+/yIXOtTcRQMzPcgyhoFlqPkw==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "dependencies": {
++        "mimic-response": "^2.0.0"
++      },
++      "engines": {
++        "node": ">=8"
++      }
++    },
++    "node_modules/simple-get/node_modules/mimic-response": {
++      "version": "2.1.0",
++      "resolved": "https://registry.npmjs.org/mimic-response/-/mimic-response-2.1.0.tgz",
++      "integrity": "sha512-wXqjST+SLt7R009ySCglWBCFpjUygmCIfD790/kVbiGmUgfYGuB14PiTd5DwVxSV4NcYHjzMkoj5LjQZwTQLEA==",
++      "dev": true,
++      "license": "MIT",
++      "optional": true,
++      "peer": true,
++      "engines": {
++        "node": ">=8"
++      },
++      "funding": {
++        "url": "https://github.com/sponsors/sindresorhus"
++      }
++    },
+     "node_modules/simple-update-notifier": {
+       "version": "2.0.0",
+       "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
+diff --git a/src/db/repository/reviewRepository.ts b/src/db/repository/reviewRepository.ts
+index d113164f4..aacc552bf 100644
+--- a/src/db/repository/reviewRepository.ts
++++ b/src/db/repository/reviewRepository.ts
+@@ -3,17 +3,16 @@ import path from 'path';
+ import type {
+   ReviewHistory,
+   ReviewChecklist,
+-  ReviewChecklistSource,
++  ReviewChecklistResult as DBReviewChecklistResult,
+ } from '../schema';
  import {
-@@ -24,7 +24,7 @@ import { reviewExecutionWorkflow } from './workflows/sourceReview/reviewExecutio
- const logLevel = process.env.NODE_ENV === 'production' ? 'info' : 'debug';
- 
- // ロガーの作成
--const logger = createLogger({
-+const logger = new ConsoleLogger({
-   name: 'AIKATA',
-   level: logLevel,
+   reviewHistories,
+   reviewChecklists,
+-  reviewChecklistSources,
+-  sources,
++  reviewChecklistResults,
+ } from '../schema';
+ import getDb from '..';
+ import type {
+-  ReviewChecklistResult,
++  ReviewChecklistResultDisplay,
+   ReviewEvaluation,
+   ReviewChecklistCreatedBy,
+ } from '../../main/types';
+@@ -45,19 +44,22 @@ export interface ReviewRepository {
+   upsertReviewResult(
+     results: {
+       reviewChecklistId: number;
+-      sourceId: number;
+       evaluation: ReviewEvaluation;
+       comment: string;
++      fileId: string;
++      fileName: string;
+     }[],
+-  ): Promise<ReviewChecklistSource[]>;
+-  getReviewResults(reviewChecklistId: number): Promise<ReviewChecklistSource[]>;
++  ): Promise<DBReviewChecklistResult[]>;
++  getReviewResults(
++    reviewChecklistId: number,
++  ): Promise<DBReviewChecklistResult[]>;
+   deleteReviewResults(
+     reviewChecklistId: number,
+     sourceId: number,
+   ): Promise<void>;
+   getReviewChecklistResults(
+     reviewHistoryId: string,
+-  ): Promise<ReviewChecklistResult[]>;
++  ): Promise<ReviewChecklistResultDisplay[]>;
+   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
+ }
+ 
+@@ -246,22 +248,23 @@ class DrizzleReviewRepository implements ReviewRepository {
+   async upsertReviewResult(
+     results: {
+       reviewChecklistId: number;
+-      sourceId: number;
+       evaluation: ReviewEvaluation;
+       comment: string;
++      fileId: string;
++      fileName: string;
+     }[],
+-  ): Promise<ReviewChecklistSource[]> {
++  ): Promise<DBReviewChecklistResult[]> {
+     try {
+       const db = await getDb();
+-      const upsertedResults: ReviewChecklistSource[] = [];
++      const upsertedResults: DBReviewChecklistResult[] = [];
+       for (const result of results) {
+         const [upserted] = await db
+-          .insert(reviewChecklistSources)
++          .insert(reviewChecklistResults)
+           .values(result)
+           .onConflictDoUpdate({
+             target: [
+-              reviewChecklistSources.reviewChecklistId,
+-              reviewChecklistSources.sourceId,
++              reviewChecklistResults.reviewChecklistId,
++              reviewChecklistResults.fileId,
+             ],
+             set: {
+               evaluation: result.evaluation,
+@@ -283,13 +286,13 @@ class DrizzleReviewRepository implements ReviewRepository {
+   /** レビュー結果一覧を取得 */
+   async getReviewResults(
+     reviewChecklistId: number,
+-  ): Promise<ReviewChecklistSource[]> {
++  ): Promise<DBReviewChecklistResult[]> {
+     try {
+       const db = await getDb();
+       return await db
+         .select()
+-        .from(reviewChecklistSources)
+-        .where(eq(reviewChecklistSources.reviewChecklistId, reviewChecklistId));
++        .from(reviewChecklistResults)
++        .where(eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId));
+     } catch (err) {
+       throw new RepositoryError(
+         `レビュー結果の取得に失敗しました: ${(err as Error).message}`,
+@@ -306,11 +309,11 @@ class DrizzleReviewRepository implements ReviewRepository {
+     try {
+       const db = await getDb();
+       await db
+-        .delete(reviewChecklistSources)
++        .delete(reviewChecklistResults)
+         .where(
+           and(
+-            eq(reviewChecklistSources.reviewChecklistId, reviewChecklistId),
+-            eq(reviewChecklistSources.sourceId, sourceId),
++            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
++            eq(reviewChecklistResults.fileId, sourceId.toString()),
+           ),
+         );
+     } catch (err) {
+@@ -324,28 +327,27 @@ class DrizzleReviewRepository implements ReviewRepository {
+   /** チェックリスト結果を取得してグルーピング */
+   async getReviewChecklistResults(
+     reviewHistoryId: string,
+-  ): Promise<ReviewChecklistResult[]> {
++  ): Promise<ReviewChecklistResultDisplay[]> {
+     try {
+       const db = await getDb();
+       const rows = await db
+         .select({
+           checklistId: reviewChecklists.id,
+           content: reviewChecklists.content,
+-          sourceId: reviewChecklistSources.sourceId,
+-          sourcePath: sources.path,
+-          evaluation: reviewChecklistSources.evaluation,
+-          comment: reviewChecklistSources.comment,
++          fileId: reviewChecklistResults.fileId,
++          fileName: reviewChecklistResults.fileName,
++          evaluation: reviewChecklistResults.evaluation,
++          comment: reviewChecklistResults.comment,
+         })
+         .from(reviewChecklists)
+         .leftJoin(
+-          reviewChecklistSources,
+-          eq(reviewChecklistSources.reviewChecklistId, reviewChecklists.id),
++          reviewChecklistResults,
++          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
+         )
+-        .leftJoin(sources, eq(reviewChecklistSources.sourceId, sources.id))
+         .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
+         .orderBy(reviewChecklists.createdAt);
+ 
+-      const map = new Map<number, ReviewChecklistResult>();
++      const map = new Map<number, ReviewChecklistResultDisplay>();
+       for (const row of rows) {
+         let group = map.get(row.checklistId);
+         if (!group) {
+@@ -356,10 +358,10 @@ class DrizzleReviewRepository implements ReviewRepository {
+           };
+           map.set(row.checklistId, group);
+         }
+-        if (row.sourceId !== null) {
++        if (row.fileId !== null && row.fileName !== null) {
+           group.sourceEvaluations!.push({
+-            sourceId: row.sourceId,
+-            sourceFileName: row.sourcePath ? path.basename(row.sourcePath) : '',
++            fileId: row.fileId,
++            fileName: row.fileName,
+             evaluation: row.evaluation as ReviewEvaluation,
+             comment: row.comment ?? undefined,
+           });
+@@ -388,8 +390,8 @@ class DrizzleReviewRepository implements ReviewRepository {
+ 
+       for (const { id } of checklists) {
+         await db
+-          .delete(reviewChecklistSources)
+-          .where(eq(reviewChecklistSources.reviewChecklistId, id));
++          .delete(reviewChecklistResults)
++          .where(eq(reviewChecklistResults.reviewChecklistId, id));
+       }
+     } catch (err) {
+       throw new RepositoryError(
+diff --git a/src/db/schema.ts b/src/db/schema.ts
+index 8a11a9a77..62d70bd5f 100644
+--- a/src/db/schema.ts
++++ b/src/db/schema.ts
+@@ -85,17 +85,16 @@ export const reviewChecklists = sqliteTable('review_checklists', {
+     .$onUpdate(() => sql`(current_timestamp)`),
  });
+ 
+-// レビューチェックリストとソースの中間テーブル
+-export const reviewChecklistSources = sqliteTable(
+-  'review_checklist_sources',
++// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
++export const reviewChecklistResults = sqliteTable(
++  'review_checklist_results',
+   {
+     reviewChecklistId: integer('review_checklist_id')
+       .notNull()
+       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
+-    sourceId: integer('source_id')
+-      .notNull()
+-      .references(() => sources.id, { onDelete: 'cascade' }),
+-    evaluation: text('evaluation'), // A, B, C評価
++    fileId: text('file_id').notNull(), // アップロードファイルのID
++    fileName: text('file_name').notNull(), // ファイル名
++    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
+     comment: text('comment'), // レビューコメント
+     createdAt: text('created_at')
+       .notNull()
+@@ -105,7 +104,7 @@ export const reviewChecklistSources = sqliteTable(
+       .default(sql`(current_timestamp)`)
+       .$onUpdate(() => sql`(current_timestamp)`),
+   },
+-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.sourceId] })],
++  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
+ );
+ 
+ // 型定義
+@@ -117,6 +116,6 @@ export type ReviewHistory = typeof reviewHistories.$inferSelect;
+ export type InsertReviewHistory = typeof reviewHistories.$inferInsert;
+ export type ReviewChecklist = typeof reviewChecklists.$inferSelect;
+ export type InsertReviewChecklist = typeof reviewChecklists.$inferInsert;
+-export type ReviewChecklistSource = typeof reviewChecklistSources.$inferSelect;
+-export type InsertReviewChecklistSource =
+-  typeof reviewChecklistSources.$inferInsert;
++export type ReviewChecklistResult = typeof reviewChecklistResults.$inferSelect;
++export type InsertReviewChecklistResult =
++  typeof reviewChecklistResults.$inferInsert;
+diff --git a/src/main/main.ts b/src/main/main.ts
+index 5c5b21191..c53dd98e2 100644
+--- a/src/main/main.ts
++++ b/src/main/main.ts
+@@ -10,7 +10,14 @@
+  */
+ import path from 'path';
+ import fs from 'fs/promises';
+-import { app, BrowserWindow, shell, ipcMain, crashReporter } from 'electron';
++import {
++  app,
++  BrowserWindow,
++  shell,
++  ipcMain,
++  crashReporter,
++  dialog,
++} from 'electron';
+ import { autoUpdater } from 'electron-updater';
+ import log from 'electron-log';
+ import { createDataStream, APICallError } from 'ai';
+@@ -450,6 +457,43 @@ const setupFsHandlers = () => {
+       }
+     },
+   );
++
++  ipcMain.handle(
++    IpcChannels.FS_SHOW_OPEN_DIALOG,
++    async (
++      _,
++      options: {
++        title: string;
++        filters?: { name: string; extensions: string[] }[];
++        properties?: (
++          | 'openFile'
++          | 'openDirectory'
++          | 'multiSelections'
++          | 'showHiddenFiles'
++          | 'createDirectory'
++          | 'promptToCreate'
++          | 'noResolveAliases'
++          | 'treatPackageAsDirectory'
++          | 'dontAddToRecent'
++        )[];
++      },
++    ) => {
++      const result = await dialog.showOpenDialog(options);
++      return result;
++    },
++  );
++  ipcMain.handle(
++    IpcChannels.FS_READ_FILE,
++    async (_, filePath: string): Promise<Uint8Array> => {
++      try {
++        const data = await fs.readFile(filePath);
++        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
++      } catch (error) {
++        console.error('ファイルの読み込み中にエラーが発生:', error);
++        throw error;
++      }
++    },
++  );
+ };
+ 
+ const setupSourceHandlers = () => {
+@@ -610,7 +654,7 @@ const setupReviewHandlers = () => {
+       event,
+       {
+         reviewHistoryId,
+-        sourceIds,
++        files,
+         documentType,
+         checklistRequirements,
+       }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL],
+@@ -623,7 +667,7 @@ const setupReviewHandlers = () => {
+         // 非同期でチェックリスト抽出処理を実行
+         const result = manager.extractChecklistWithNotification(
+           reviewHistoryId,
+-          sourceIds,
++          files,
+           event,
+           documentType,
+           checklistRequirements,
+@@ -676,7 +720,7 @@ const setupReviewHandlers = () => {
+       event,
+       {
+         reviewHistoryId,
+-        sourceIds,
++        files,
+       }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL],
+     ): Promise<
+       IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL]
+@@ -685,11 +729,7 @@ const setupReviewHandlers = () => {
+         const manager = SourceReviewManager.getInstance();
+ 
+         // 非同期でレビュー実行処理を実行
+-        manager.executeReviewWithNotification(
+-          reviewHistoryId,
+-          sourceIds,
+-          event,
+-        );
++        manager.executeReviewWithNotification(reviewHistoryId, files, event);
+ 
+         return { success: true };
+       } catch (error) {
+diff --git a/src/main/preload.ts b/src/main/preload.ts
+index 19b3eef1f..07577d2d7 100644
+--- a/src/main/preload.ts
++++ b/src/main/preload.ts
+@@ -37,6 +37,16 @@ const electronHandler = {
+     access: async (path: string): Promise<boolean> => {
+       return ipcRenderer.invoke(IpcChannels.FS_CHECK_PATH_EXISTS, path);
+     },
++    showOpenDialog: async (options: {
++      title: string;
++      filters?: { name: string; extensions: string[] }[];
++      properties?: string[];
++    }) => {
++      return ipcRenderer.invoke(IpcChannels.FS_SHOW_OPEN_DIALOG, options);
++    },
++    readFile: async (filePath: string): Promise<Uint8Array> => {
++      return ipcRenderer.invoke(IpcChannels.FS_READ_FILE, filePath);
++    },
+   },
+   store: {
+     get: async (
+diff --git a/src/main/types/index.ts b/src/main/types/index.ts
+index a8fd2fc07..f80cd09de 100644
+--- a/src/main/types/index.ts
++++ b/src/main/types/index.ts
+@@ -55,12 +55,12 @@ export type ReviewEvaluation = 'A' | 'B' | 'C' | '-';
+ export type ReviewChecklistCreatedBy = 'user' | 'system';
+ 
+ // 最終的に画面に表示するチェックリストの型
+-export type ReviewChecklistResult = {
++export type ReviewChecklistResultDisplay = {
+   id: number; // チェックリストのID
+   content: string;
+   sourceEvaluations?: {
+-    sourceId: number;
+-    sourceFileName: string;
++    fileId: string;
++    fileName: string;
+     evaluation?: ReviewEvaluation;
+     comment?: string;
+   }[];
+diff --git a/src/main/types/ipc.ts b/src/main/types/ipc.ts
+index b85808772..b1d631fc5 100644
+--- a/src/main/types/ipc.ts
++++ b/src/main/types/ipc.ts
+@@ -2,11 +2,14 @@ import type {
+   ChatMessage,
+   ChatRoom,
+   SettingsSavingStatus,
+-  ReviewChecklistResult,
++  ReviewChecklistResultDisplay,
+   ReviewChecklistEdit,
+ } from '.';
+ import type { Source, ReviewHistory } from '../../db/schema';
+-import type { DocumentType } from '../../renderer/components/review/types';
++import type {
++  DocumentType,
++  UploadFile,
++} from '../../renderer/components/review/types';
+ 
+ /**
+  * IPC通信で使用するチャネル名の定義
+@@ -43,6 +46,8 @@ export const IpcChannels = {
+ 
+   // ファイルシステム関連
+   FS_CHECK_PATH_EXISTS: 'fs-check-path-exists',
++  FS_SHOW_OPEN_DIALOG: 'fs-show-open-dialog',
++  FS_READ_FILE: 'fs-read-file',
+ 
+   // ドキュメントレビュー関連
+   REVIEW_GET_HISTORIES: 'review-get-histories', // ドキュメント履歴切り替え時やチェックリスト抽出・ドキュメントレビュー時のポーリング処理にて呼び出される
+@@ -68,6 +73,12 @@ export type IpcRequestPayloadMap = {
+ 
+   // ファイルシステム関連
+   [IpcChannels.FS_CHECK_PATH_EXISTS]: string;
++  [IpcChannels.FS_SHOW_OPEN_DIALOG]: {
++    title: string;
++    filters?: { name: string; extensions: string[] }[];
++    properties?: string[];
++  };
++  [IpcChannels.FS_READ_FILE]: string; // file path
+ 
+   // ストア関連
+   [IpcChannels.GET_STORE_VALUE]: string;
+@@ -99,7 +110,7 @@ export type IpcRequestPayloadMap = {
+   [IpcChannels.REVIEW_DELETE_HISTORY]: string; // review history id
+   [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
+     reviewHistoryId: string;
+-    sourceIds: number[];
++    files: UploadFile[];
+     documentType?: DocumentType;
+     checklistRequirements?: string;
+   };
+@@ -109,7 +120,7 @@ export type IpcRequestPayloadMap = {
+   };
+   [IpcChannels.REVIEW_EXECUTE_CALL]: {
+     reviewHistoryId: string;
+-    sourceIds: number[];
++    files: UploadFile[];
+   };
+ };
+ 
+@@ -121,6 +132,11 @@ export type IpcResponsePayloadMap = {
+ 
+   // ファイルシステム関連
+   [IpcChannels.FS_CHECK_PATH_EXISTS]: boolean;
++  [IpcChannels.FS_SHOW_OPEN_DIALOG]: {
++    filePaths: string[];
++    canceled: boolean;
++  };
++  [IpcChannels.FS_READ_FILE]: Uint8Array; // ファイルのバイナリデータ
+ 
+   // ストア関連
+   [IpcChannels.GET_STORE_VALUE]: unknown;
+@@ -155,7 +171,7 @@ export type IpcResponsePayloadMap = {
+   };
+   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: {
+     success: boolean;
+-    checklistResults?: ReviewChecklistResult[];
++    checklistResults?: ReviewChecklistResultDisplay[];
+     error?: string;
+   };
+   [IpcChannels.REVIEW_DELETE_HISTORY]: { success: boolean; error?: string };
+diff --git a/src/mastra/workflows/libs.ts b/src/mastra/workflows/libs.ts
+index fd9bcbc23..f7d235093 100644
+--- a/src/mastra/workflows/libs.ts
++++ b/src/mastra/workflows/libs.ts
+@@ -21,6 +21,13 @@ export function checkStatus(result: WorkflowResult<any, any>): {
+     };
+   }
+ 
++  // ネストワークフロー使ってない場合
++  if (!result.result || !Array.isArray(result.result)) {
++    const value = result.result as z.infer<typeof baseStepOutputSchema>;
++    return value;
++  }
++
++  // ネストワークフローを使っている場合
+   // Object.valuesでオブジェクトの値だけを配列として取り出す
+   const values = Object.values(result.result);
+ 
+diff --git a/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts b/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
+index ec5215f71..7144a779a 100644
+--- a/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
++++ b/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
+@@ -164,6 +164,7 @@ export default class SourceRegistrationManager {
+               });
+ 
+               // 結果を確認
++              console.log('apply checkStatus', JSON.stringify(result));
+               const checkResult = checkStatus(result);
+ 
+               resultList.push({
 diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
-index 9c195e810..fbb1fe0cc 100644
+index 064a45609..037a84b77 100644
 --- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
 +++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
-@@ -16,6 +16,8 @@ import {
+@@ -3,10 +3,8 @@ import { APICallError, NoObjectGeneratedError } from 'ai';
+ import { createStep, createWorkflow } from '@mastra/core/workflows';
+ import { MastraError } from '@mastra/core/error';
+ import { z } from 'zod';
+-import path from 'path';
+ import { getReviewRepository } from '../../../db/repository/reviewRepository';
+ import { getSourceRepository } from '../../../db/repository/sourceRepository';
+-import { Source } from '../../../db/schema';
+ import FileExtractor from '../../../main/utils/fileExtractor';
+ import { baseStepOutputSchema } from '../schema';
+ import { stepStatus } from '../types';
+@@ -16,13 +14,24 @@ import {
    TopicChecklistAgentRuntimeContext,
  } from '../../agents/workflowAgents';
  import { createRuntimeContext } from '../../agents/lib';
-+import { title } from 'process';
-+import { check } from 'zod/v4';
++import { UploadFile } from '../../../renderer/components/review/types';
  
  // ワークフローの入力スキーマ
  const triggerSchema = z.object({
-@@ -58,7 +60,7 @@ const topicChecklistStepOutputSchema = baseStepOutputSchema.extend({
- });
+   reviewHistoryId: z.string().describe('レビュー履歴ID'),
+-  sourceIds: z
+-    .array(z.number())
+-    .describe('チェックリストを抽出するソースのIDリスト'),
++  files: z
++    .array(
++      z.object({
++        id: z.string(),
++        name: z.string(),
++        path: z.string(),
++        type: z.string(),
++        pdfProcessMode: z.enum(['text', 'image']).optional(),
++        pdfImageMode: z.enum(['merged', 'pages']).optional(),
++        imageData: z.array(z.string()).optional(),
++      }),
++    )
++    .describe('アップロードファイルのリスト'),
+   documentType: z
+     .enum(['checklist', 'general'])
+     .default('checklist')
+@@ -46,7 +55,8 @@ const topicExtractionStepOutputSchema = baseStepOutputSchema.extend({
+     .array(
+       z.object({
+         title: z.string(),
+-        sourceId: z.number(),
++        file: triggerSchema.shape.files.element,
++        content: z.string().optional(),
+       }),
+     )
+     .optional(),
+@@ -72,7 +82,7 @@ const checklistDocumentExtractionStep = createStep({
+     const reviewRepository = getReviewRepository();
+     const sourceRepository = getSourceRepository();
+     // トリガーから入力を取得
+-    const { reviewHistoryId, sourceIds, documentType } = inputData;
++    const { reviewHistoryId, files } = inputData;
+     const errorMessages: string[] = [
+       'チェックリスト抽出処理中に以下エラーが発生しました',
+     ];
+@@ -81,19 +91,9 @@ const checklistDocumentExtractionStep = createStep({
+       // 既存のシステム作成チェックリストを削除
+       await reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
+ 
+-      // 各ソースを並行して処理
+-      const extractionPromises = sourceIds.map(async (sourceId) => {
+-        let source: Source | null = null;
++      // 各ファイルを並行して処理
++      const extractionPromises = files.map(async (file: UploadFile) => {
+         try {
+-          source = await sourceRepository.getSourceById(sourceId);
+-
+-          if (source === null) {
+-            throw new Error(`ドキュメントID ${sourceId} が見つかりません`);
+-          }
+-
+-          // ファイル内容を抽出
+-          const { content } = await FileExtractor.extractText(source.path);
+-
+           const checklistExtractionAgent = mastra.getAgent(
+             'checklistExtractionAgent',
+           );
+@@ -109,6 +109,60 @@ const checklistDocumentExtractionStep = createStep({
+           // これまでに抽出したチェックリスト項目を蓄積する配列
+           const accumulated: string[] = [];
+ 
++          let message;
++
++          // PDFで画像として処理する場合
++          if (
++            file.type === 'application/pdf' &&
++            file.pdfProcessMode === 'image' &&
++            file.imageData &&
++            file.imageData.length > 0
++          ) {
++            if (file.imageData.length > 1) {
++              // ページ別画像モード: すべてのページを含むメッセージを作成
++              const imageMessage = {
++                role: 'user' as const,
++                content: [
++                  {
++                    type: 'text' as const,
++                    text: `Please extract checklist items from this document: ${file.name} (All ${file.imageData.length} pages)`,
++                  },
++                  // すべてのページ画像を含める
++                  ...file.imageData.map((imageData) => ({
++                    type: 'image' as const,
++                    image: imageData,
++                    mimeType: 'image/png',
++                  })),
++                ],
++              };
++
++              message = imageMessage;
++            } else {
++              // 統合画像モード: 単一メッセージ
++              const imageMessage = {
++                role: 'user' as const,
++                content: [
++                  {
++                    type: 'text' as const,
++                    text: `Please extract checklist items from this document: ${file.name}`,
++                  },
++                  {
++                    type: 'image' as const,
++                    image: file.imageData[0],
++                    mimeType: 'image/png',
++                  },
++                ],
++              };
++
++              message = imageMessage;
++            }
++            // 画像化PDF以外はテキスト抽出処理
++          } else {
++            // テキスト抽出処理
++            const { content } = await FileExtractor.extractText(file.path);
++            message = content;
++          }
++
+           // 最大試行回数
+           const MAX_ATTEMPTS = 5;
+           let attempts = 0;
+@@ -120,7 +174,7 @@ const checklistDocumentExtractionStep = createStep({
+             // これまでに抽出したチェックリスト項目
+             runtimeContext.set('extractedItems', accumulated);
+             const extractionResult = await checklistExtractionAgent.generate(
+-              content,
++              message,
+               {
+                 output: outputSchema,
+                 runtimeContext,
+@@ -182,9 +236,10 @@ const checklistDocumentExtractionStep = createStep({
+             }
+ 
+             // 抽出されたチェックリストから新規のものを蓄積
+-            const newChecklists = extractionResult.object.newChecklists.filter(
+-              (item) => !accumulated.includes(item),
+-            );
++            const newChecklists =
++              extractionResult.object.newChecklists?.filter(
++                (item: string) => !accumulated.includes(item),
++              ) || [];
+             accumulated.push(...newChecklists);
  
- // チェックリスト統合の出力スキーマ
--const checklistIntegrationStepOutputSchema = baseStepOutputSchema;
-+// const checklistIntegrationStepOutputSchema = baseStepOutputSchema;
+             // 抽出されたチェックリストをDBに保存
+@@ -229,11 +284,7 @@ const checklistDocumentExtractionStep = createStep({
+           } else {
+             errorDetail = JSON.stringify(error);
+           }
+-          if (source) {
+-            errorMessage += `- ${path.basename(source.path)}のチェックリスト抽出でエラー: ${errorDetail}`;
+-          } else {
+-            errorMessage += `- チェックリスト抽出処理でエラーが発生しました: ${errorDetail}`;
+-          }
++          errorMessage += `- ${file.name}のチェックリスト抽出でエラー: ${errorDetail}`;
+           errorMessages.push(errorMessage);
+         }
+       });
+@@ -276,9 +327,8 @@ const topicExtractionStep = createStep({
+   inputSchema: triggerSchema,
+   outputSchema: topicExtractionStepOutputSchema,
+   execute: async ({ inputData, mastra, bail }) => {
+-    const sourceRepository = getSourceRepository();
+     const reviewRepository = getReviewRepository();
+-    const { sourceIds, reviewHistoryId, checklistRequirements } = inputData;
++    const { files, reviewHistoryId, checklistRequirements } = inputData;
+     const errorMessages: string[] = [
+       'チェックリスト作成処理中にエラーが発生しました',
+     ];
+@@ -286,22 +336,66 @@ const topicExtractionStep = createStep({
+     try {
+       const allTopics: Array<{
+         title: string;
+-        sourceId: number;
++        file: z.infer<typeof triggerSchema.shape.files.element>;
++        content?: string;
+       }> = [];
+ 
+-      // 各ソースからトピックを抽出
+-      const extractionPromises = sourceIds.map(async (sourceId) => {
+-        let source: Source | null = null;
++      // 各ファイルからトピックを抽出
++      const extractionPromises = files.map(async (file: UploadFile) => {
+         try {
+-          source = await sourceRepository.getSourceById(sourceId);
++          let message;
++          let outputContent: string | undefined = undefined;
  
- // === チェックリストドキュメント用ステップ ===
+-          if (source === null) {
+-            throw new Error(`ソースID ${sourceId} が見つかりません`);
++          // PDFで画像として処理する場合
++          if (
++            file.type === 'application/pdf' &&
++            file.pdfProcessMode === 'image' &&
++            file.imageData &&
++            file.imageData.length > 0
++          ) {
++            if (file.imageData.length > 1) {
++              // ページ別画像モード: すべてのページを含むメッセージを作成
++              const imageMessage = {
++                role: 'user' as const,
++                content: [
++                  {
++                    type: 'text' as const,
++                    text: `Please extract topics from this document: ${file.name} (All ${file.imageData.length} pages)`,
++                  },
++                  // すべてのページ画像を含める
++                  ...file.imageData.map((imageData) => ({
++                    type: 'image' as const,
++                    image: imageData,
++                    mimeType: 'image/png',
++                  })),
++                ],
++              };
++              message = imageMessage;
++            } else {
++              // 統合画像モード: 単一メッセージ
++              const imageMessage = {
++                role: 'user' as const,
++                content: [
++                  {
++                    type: 'text' as const,
++                    text: `Please extract topics from this document: ${file.name}`,
++                  },
++                  {
++                    type: 'image' as const,
++                    image: file.imageData[0],
++                    mimeType: 'image/png',
++                  },
++                ],
++              };
++              message = imageMessage;
++            }
++          } else {
++            // テキスト抽出処理
++            const { content } = await FileExtractor.extractText(file.path);
++            message = content;
++            outputContent = content;
+           }
  
-@@ -307,7 +309,12 @@ const topicExtractionStep = createStep({
+-          // ファイル内容を抽出
+-          const { content } = await FileExtractor.extractText(source.path);
+-
+           const topicExtractionAgent = mastra.getAgent('topicExtractionAgent');
+           const outputSchema = z.object({
              topics: z
-               .array(
-                 z.object({
--                  title: z.string().describe('Topic title'),
-+                  topic: z.string().describe('Extracted topic'),
-+                  reason: z
-+                    .string()
-+                    .describe(
-+                      'The reason why that topic is necessary for creating checklist items',
-+                    ),
-                 }),
-               )
-               .describe('Extracted topics from the document'),
-@@ -326,9 +333,16 @@ const topicExtractionStep = createStep({
-             },
-           );
+@@ -324,7 +418,7 @@ const topicExtractionStep = createStep({
+           }
+ 
+           const extractionResult = await topicExtractionAgent.generate(
+-            content,
++            message,
+             {
+               output: outputSchema,
+               runtimeContext,
+@@ -334,14 +428,15 @@ const topicExtractionStep = createStep({
+           mastra
+             .getLogger()
+             .debug(
+-              `document(id:${sourceId}) extracted topics for creating checklist:`,
++              `document(${file.name}) extracted topics for creating checklist:`,
+               JSON.stringify(extractionResult.object.topics, null, 2),
+             );
  
-+          mastra
-+            .getLogger()
-+            .debug(
-+              `document(id:${sourceId}) extracted topics for creating checklist:`,
-+              JSON.stringify(extractionResult.object.topics, null, 2),
-+            );
-+
            allTopics.push(
--            ...extractionResult.object.topics.map((topic) => ({
--              ...topic,
-+            ...extractionResult.object.topics.map((t) => ({
-+              title: t.topic,
-               sourceId,
+             ...extractionResult.object.topics.map((t) => ({
+               title: t.topic,
+-              sourceId,
++              file,
++              content: outputContent,
              })),
            );
-@@ -352,9 +366,6 @@ const topicExtractionStep = createStep({
+         } catch (error) {
+@@ -351,15 +446,9 @@ const topicExtractionStep = createStep({
+           } else {
+             errorDetail = JSON.stringify(error);
+           }
+-          if (source) {
+-            errorMessages.push(
+-              `- ${path.basename(source.path)}のトピック抽出でエラー: ${errorDetail}`,
+-            );
+-          } else {
+-            errorMessages.push(
+-              `- トピック抽出処理でエラーが発生しました: ${errorDetail}`,
+-            );
+-          }
++          errorMessages.push(
++            `- ${file.name}のトピック抽出でエラー: ${errorDetail}`,
++          );
+         }
        });
  
-       await Promise.all(extractionPromises);
--      console.log(
--        'トピック抽出完了:\n' + allTopics.map((t) => `${t.title}`).join('\n'),
--      );
+@@ -408,27 +497,71 @@ const topicChecklistCreationStep = createStep({
+   description: 'トピックに基づいてチェックリスト項目を作成するステップ',
+   inputSchema: z.object({
+     title: z.string(),
+-    sourceId: z.number(),
++    file: triggerSchema.shape.files.element,
++    content: z.string().optional(),
+     reviewHistoryId: z.string(),
+     checklistRequirements: z.string().optional(),
+   }),
+   outputSchema: topicChecklistStepOutputSchema,
+   execute: async ({ inputData, mastra, bail }) => {
+-    const { title, sourceId, reviewHistoryId, checklistRequirements } =
++    const { title, file, content, reviewHistoryId, checklistRequirements } =
+       inputData;
+-    const sourceRepository = getSourceRepository();
+     const reviewRepository = getReviewRepository();
+     const errorMessages: string[] = [
+       'チェックリスト作成処理中にエラーが発生しました',
+     ];
  
-       // エラーがあれば失敗として返す
-       if (errorMessages.length > 1) {
-@@ -423,8 +434,19 @@ const topicChecklistCreationStep = createStep({
+     try {
+-      const source = await sourceRepository.getSourceById(sourceId);
+-      if (source === null) {
+-        throw new Error(`ドキュメントID ${sourceId} が見つかりません`);
++      let message;
++
++      // PDFで画像として処理する場合
++      if (
++        file.type === 'application/pdf' &&
++        file.pdfProcessMode === 'image' &&
++        file.imageData &&
++        file.imageData.length > 0
++      ) {
++        if (file.imageData.length > 1) {
++          // ページ別画像モードの場合、すべてのページを統合したメッセージを作成
++          // (このステップでは特定のトピックに基づいてチェックリスト作成するため、全ページを含める)
++          const imageMessage = {
++            role: 'user' as const,
++            content: [
++              {
++                type: 'text' as const,
++                text: `Please create checklist items from this document: ${file.name} (All ${file.imageData.length} pages) for topic: ${title}`,
++              },
++              // すべてのページ画像を含める
++              ...file.imageData.map((imageData) => ({
++                type: 'image' as const,
++                image: imageData,
++                mimeType: 'image/png',
++              })),
++            ],
++          };
++          message = imageMessage;
++        } else {
++          // 統合画像モード: 単一メッセージ
++          const imageMessage = {
++            role: 'user' as const,
++            content: [
++              {
++                type: 'text' as const,
++                text: `Please create checklist items from this document: ${file.name}`,
++              },
++              {
++                type: 'image' as const,
++                image: file.imageData[0],
++                mimeType: 'image/png',
++              },
++            ],
++          };
++          message = imageMessage;
++        }
++      } else {
++        // テキスト抽出処理
++        message = content!;
+       }
+-      // ファイル内容を抽出
+-      const { content } = await FileExtractor.extractText(source.path);
        const topicChecklistAgent = mastra.getAgent('topicChecklistAgent');
        const outputSchema = z.object({
          checklistItems: z
--          .array(z.string().describe('Checklist item'))
--          .describe('Generated checklist items for the topic'),
-+          .array(
-+            z.object({
-+              checklistItem: z.string().describe('Checklist item'),
-+              reason: z
-+                .string()
-+                .describe(
-+                  'The reason why the checklist items based on the document are valuable',
-+                ),
-+            }),
-+          )
-+          .describe(
-+            'Generated checklist items for the given topic from the document',
-+          ),
-       });
+@@ -454,14 +587,14 @@ const topicChecklistCreationStep = createStep({
+         runtimeContext.set('checklistRequirements', checklistRequirements);
+       }
  
-       const runtimeContext =
-@@ -438,6 +460,12 @@ const topicChecklistCreationStep = createStep({
+-      const result = await topicChecklistAgent.generate(content, {
++      const result = await topicChecklistAgent.generate(message, {
          output: outputSchema,
          runtimeContext,
        });
-+      mastra
-+        .getLogger()
-+        .debug(
-+          `document(id:${sourceId}) topic(${title}) generated checklist items:`,
-+          JSON.stringify(result.object.checklistItems, null, 2),
-+        );
+       mastra
+         .getLogger()
+         .debug(
+-          `document(id:${sourceId}) topic(${title}) generated checklist items:`,
++          `document(${file.name}) topic(${title}) generated checklist items:`,
+           JSON.stringify(result.object.checklistItems, null, 2),
+         );
+ 
+@@ -486,7 +619,9 @@ const topicChecklistCreationStep = createStep({
+ 
+       return {
+         status: 'success' as stepStatus,
+-        checklistItems: result.object.checklistItems,
++        checklistItems: result.object.checklistItems.map(
++          (item) => item.checklistItem,
++        ),
+       };
+     } catch (error) {
+       if (error instanceof Error && error.message) {
+@@ -600,6 +735,7 @@ export const checklistExtractionWorkflow = createWorkflow({
+           const topicResult = getStepResult(topicExtractionStep);
+           const initData = getInitData();
+ 
++          // 前ステップでエラーの場合はbailで早期終了させているため、ここに来るのは成功時のみの想定
+           if (topicResult?.status !== 'success' || !topicResult.topics) {
+             throw new Error(
+               topicResult?.errorMessage || 'トピック抽出に失敗しました',
+@@ -608,7 +744,8 @@ export const checklistExtractionWorkflow = createWorkflow({
+ 
+           return topicResult.topics.map((topic) => ({
+             title: topic.title,
+-            sourceId: topic.sourceId,
++            file: topic.file,
++            content: topic.content,
+             reviewHistoryId: initData.reviewHistoryId,
+             checklistRequirements: initData.checklistRequirements,
+           }));
+diff --git a/src/mastra/workflows/sourceReview/reviewExecution.ts b/src/mastra/workflows/sourceReview/reviewExecution.ts
+index 7cc87b9b6..ff8de03df 100644
+--- a/src/mastra/workflows/sourceReview/reviewExecution.ts
++++ b/src/mastra/workflows/sourceReview/reviewExecution.ts
+@@ -2,9 +2,7 @@ import { APICallError, NoObjectGeneratedError } from 'ai';
+ import { createWorkflow, createStep } from '@mastra/core/workflows';
+ import { MastraError } from '@mastra/core/error';
+ import { z } from 'zod';
+-import path from 'path';
+ import { getReviewRepository } from '../../../db/repository/reviewRepository';
+-import { getSourceRepository } from '../../../db/repository/sourceRepository';
+ import FileExtractor from '../../../main/utils/fileExtractor';
+ import type { ReviewEvaluation } from '../../../main/types';
+ import { baseStepOutputSchema } from '../schema';
+@@ -41,7 +39,19 @@ const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
+ // ワークフローの入力スキーマ
+ const triggerSchema = z.object({
+   reviewHistoryId: z.string().describe('レビュー履歴ID'),
+-  sourceIds: z.array(z.number()).describe('レビュー対象ソースのIDリスト'),
++  files: z
++    .array(
++      z.object({
++        id: z.string(),
++        name: z.string(),
++        path: z.string(),
++        type: z.string(),
++        pdfProcessMode: z.enum(['text', 'image']).optional(),
++        pdfImageMode: z.enum(['merged', 'pages']).optional(),
++        imageData: z.array(z.string()).optional(),
++      }),
++    )
++    .describe('アップロードファイルのリスト'),
+ });
+ 
+ // ステップ1: チェックリストをカテゴリごとに分類
+@@ -203,8 +213,8 @@ const reviewExecutionStep = createStep({
+   inputSchema: classifyChecklistsByCategoryOutputSchema,
+   outputSchema: baseStepOutputSchema,
+   execute: async ({ inputData, getInitData, mastra }) => {
+-    // レビュー対象のソースID
+-    const { sourceIds } = getInitData() as z.infer<typeof triggerSchema>;
++    // レビュー対象のファイル
++    const { files } = getInitData() as z.infer<typeof triggerSchema>;
+     // ステップ1からの入力を取得
+     const { categories } = inputData;
+ 
+@@ -218,7 +228,6 @@ const reviewExecutionStep = createStep({
+ 
+     // リポジトリを取得
+     const reviewRepository = getReviewRepository();
+-    const sourceRepository = getSourceRepository();
+ 
+     // チェックリストを全量チェックできなかったドキュメントを格納
+     // key: ファイル名, value: エラー内容
+@@ -227,15 +236,59 @@ const reviewExecutionStep = createStep({
+     try {
+       const reviewAgent = mastra.getAgent('reviewExecuteAgent');
+ 
+-      // 各カテゴリ、ソースごとにレビューを実行
++      // 各カテゴリ、ファイルごとにレビューを実行
+       for (const category of categories!) {
+-        for (const sourceId of sourceIds) {
+-          // ソースの内容を取得
+-          const source = await sourceRepository.getSourceById(sourceId);
+-          if (!source) {
+-            throw new Error(`ソースID ${sourceId} が見つかりません`);
++        for (const file of files) {
++          // ファイルの内容を取得（画像またはテキスト）
++          let message;
++
++          if (
++            file.type === 'application/pdf' &&
++            file.pdfProcessMode === 'image' &&
++            file.imageData &&
++            file.imageData.length > 0
++          ) {
++            if (file.imageData.length > 1) {
++              // ページ別画像モード: すべてのページを含むメッセージを作成
++              const imageMessage = {
++                role: 'user' as const,
++                content: [
++                  {
++                    type: 'text' as const,
++                    text: `Please review this document against the provided checklist items: ${file.name} (All ${file.imageData.length} pages)`,
++                  },
++                  // すべてのページ画像を含める
++                  ...file.imageData.map((imageData) => ({
++                    type: 'image' as const,
++                    image: imageData,
++                    mimeType: 'image/png',
++                  })),
++                ],
++              };
++              message = imageMessage;
++            } else {
++              // 統合画像モード: 単一メッセージ
++              const imageMessage = {
++                role: 'user' as const,
++                content: [
++                  {
++                    type: 'text' as const,
++                    text: `Please review this document against the provided checklist items: ${file.name}`,
++                  },
++                  {
++                    type: 'image' as const,
++                    image: file.imageData[0],
++                    mimeType: 'image/png',
++                  },
++                ],
++              };
++              message = imageMessage;
++            }
++          } else {
++            // テキスト抽出
++            const { content } = await FileExtractor.extractText(file.path);
++            message = content;
+           }
+-          const { content } = await FileExtractor.extractText(source.path);
+           // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
+           // レビュー結果に含まれなかったチェックリストは再度レビューを実行する（最大試行回数は3回）
+           const maxAttempts = 3;
+@@ -256,7 +309,7 @@ const reviewExecutionStep = createStep({
+                 createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
+               runtimeContext.set('checklistItems', reviewTargetChecklists);
+               // レビューエージェントを使用してレビューを実行
+-              const reviewResult = await reviewAgent.generate(content, {
++              const reviewResult = await reviewAgent.generate(message, {
+                 output: outputSchema,
+                 runtimeContext,
+               });
+@@ -267,17 +320,22 @@ const reviewExecutionStep = createStep({
+                 throw new Error(reason);
+               }
+               // レビュー結果をDBに保存
+-              await reviewRepository.upsertReviewResult(
+-                reviewResult.object.map((result) => ({
+-                  reviewChecklistId: result.checklistId,
+-                  sourceId,
+-                  evaluation: result.evaluation as ReviewEvaluation,
+-                  comment: result.comment,
+-                })),
+-              );
++              if (reviewResult.object && Array.isArray(reviewResult.object)) {
++                await reviewRepository.upsertReviewResult(
++                  reviewResult.object.map((result) => ({
++                    reviewChecklistId: result.checklistId,
++                    evaluation: result.evaluation as ReviewEvaluation,
++                    comment: result.comment,
++                    fileId: file.id,
++                    fileName: file.name,
++                  })),
++                );
++              }
+               // レビュー結果に含まれなかったチェックリストを抽出
+               const reviewedChecklistIds = new Set(
+-                reviewResult.object.map((result) => result.checklistId),
++                reviewResult.object && Array.isArray(reviewResult.object)
++                  ? reviewResult.object.map((result) => result.checklistId)
++                  : [],
+               );
+               reviewTargetChecklists = reviewTargetChecklists.filter(
+                 (checklist) => !reviewedChecklistIds.has(checklist.id),
+@@ -309,21 +367,21 @@ const reviewExecutionStep = createStep({
+                 errorDetail = JSON.stringify(error);
+               }
+               // レビューに失敗したチェックリストを記録
+-              if (!errorDocuments.has(path.basename(source.path))) {
+-                errorDocuments.set(path.basename(source.path), []);
++              if (!errorDocuments.has(file.name)) {
++                errorDocuments.set(file.name, []);
+               }
+-              errorDocuments.get(path.basename(source.path))!.push(errorDetail);
++              errorDocuments.get(file.name)!.push(errorDetail);
+             } finally {
+               attempt += 1;
+             }
+           }
+           if (attempt >= maxAttempts) {
+             // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
+-            if (!errorDocuments.has(path.basename(source.path))) {
+-              errorDocuments.set(path.basename(source.path), []);
++            if (!errorDocuments.has(file.name)) {
++              errorDocuments.set(file.name, []);
+             }
+             errorDocuments
+-              .get(path.basename(source.path))!
++              .get(file.name)!
+               .push(
+                 `全てのチェックリストに対してレビューを完了することができませんでした`,
+               );
+diff --git a/src/mastra/workflows/sourceReview/sourceReviewManager.ts b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
+index 79800bd46..36565d581 100644
+--- a/src/mastra/workflows/sourceReview/sourceReviewManager.ts
++++ b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
+@@ -9,7 +9,10 @@ import {
+ import { generateReviewTitle } from './lib';
+ import { ReviewHistory } from '../../../db/schema';
+ import { mastra } from '../..';
+-import { DocumentType } from '../../../renderer/components/review/types';
++import {
++  DocumentType,
++  UploadFile,
++} from '../../../renderer/components/review/types';
+ import { checkStatus } from '../libs';
+ 
+ /**
+@@ -21,8 +24,6 @@ export default class SourceReviewManager {
+ 
+   private reviewRepository = getReviewRepository();
+ 
+-  private sourceRepository = getSourceRepository();
+-
+   /**
+    * シングルトンインスタンスを取得
+    */
+@@ -34,14 +35,14 @@ export default class SourceReviewManager {
+   }
  
-       if (
-         !result.object.checklistItems ||
-@@ -450,10 +478,10 @@ const topicChecklistCreationStep = createStep({
+   /**
+-   * チェックリスト抽出処理を実行
++   * アップロードファイルからチェックリスト抽出処理を実行
+    * @param reviewHistoryId レビュー履歴ID（新規の場合は生成）
+-   * @param sourceIds ソースIDの配列
++   * @param files アップロードファイルの配列
+    * @returns 処理結果
+    */
+   public async extractChecklist(
+     reviewHistoryId: string,
+-    sourceIds: number[],
++    files: UploadFile[],
+     documentType: DocumentType = 'checklist',
+     checklistRequirements?: string,
+   ): Promise<{ success: boolean; error?: string }> {
+@@ -76,7 +77,7 @@ export default class SourceReviewManager {
+       const runResult = await run.start({
+         inputData: {
+           reviewHistoryId,
+-          sourceIds,
++          files,
+           documentType,
+           checklistRequirements,
+         },
+@@ -99,14 +100,14 @@ export default class SourceReviewManager {
+   }
+ 
+   /**
+-   * レビュー実行処理を実行
++   * アップロードファイルからレビュー実行処理を実行
+    * @param reviewHistoryId レビュー履歴ID
+-   * @param sourceIds ソースIDの配列
++   * @param files アップロードファイルの配列
+    * @returns 処理結果
+    */
+   public async executeReview(
+     reviewHistoryId: string,
+-    sourceIds: number[],
++    files: UploadFile[],
+   ): Promise<{ success: boolean; error?: string }> {
+     try {
+       // レビュー履歴の存在確認
+@@ -130,9 +131,8 @@ export default class SourceReviewManager {
        }
  
-       // 抽出されたチェックリストをDBに保存
--      for (const checklistItem of result.object.checklistItems) {
-+      for (const c of result.object.checklistItems) {
-         await reviewRepository.createChecklist(
+       // タイトルの変更
+-      // 全てのソースを取得
+-      const sources = await this.sourceRepository.getSourcesByIds(sourceIds);
+-      const reviewTitle = generateReviewTitle(sources.map((s) => s.title));
++      const fileNames = files.map((f) => f.name.replace(/\.[^/.]+$/, '')); // 拡張子を除いたファイル名
++      const reviewTitle = generateReviewTitle(fileNames);
+       // レビュー履歴のタイトルを更新
+       await this.reviewRepository.updateReviewHistoryTitle(
+         reviewHistory.id,
+@@ -143,7 +143,7 @@ export default class SourceReviewManager {
+       const result = await run.start({
+         inputData: {
            reviewHistoryId,
--          checklistItem,
-+          c.checklistItem,
-           'system',
+-          sourceIds,
++          files,
+         },
+       });
+       // 結果を確認
+@@ -170,13 +170,18 @@ export default class SourceReviewManager {
+    */
+   public extractChecklistWithNotification(
+     reviewHistoryId: string,
+-    sourceIds: number[],
++    files: UploadFile[],
+     event: IpcMainInvokeEvent,
+     documentType: DocumentType = 'checklist',
+     checklistRequirements?: string,
+   ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL] {
+     try {
+-      this.extractChecklist(reviewHistoryId, sourceIds, documentType, checklistRequirements)
++      this.extractChecklist(
++        reviewHistoryId,
++        files,
++        documentType,
++        checklistRequirements,
++      )
+         .then((res) => {
+           // 完了イベントを送信
+           event.sender.send(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
+@@ -225,11 +230,11 @@ export default class SourceReviewManager {
+    */
+   public executeReviewWithNotification(
+     reviewHistoryId: string,
+-    sourceIds: number[],
++    files: UploadFile[],
+     event: IpcMainInvokeEvent,
+   ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL] {
+     try {
+-      this.executeReview(reviewHistoryId, sourceIds)
++      this.executeReview(reviewHistoryId, files)
+         .then((res) => {
+           // 完了イベントを送信
+           event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, {
+diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
+index 56bf1fbde..c29e765f8 100644
+--- a/src/renderer/components/review/ReviewArea.tsx
++++ b/src/renderer/components/review/ReviewArea.tsx
+@@ -10,12 +10,12 @@ import {
+ import CheckBoxIcon from '@mui/icons-material/CheckBox';
+ import RateReviewIcon from '@mui/icons-material/RateReview';
+ import { v4 as uuid } from 'uuid';
+-import { ReviewAreaProps, ModalMode, DocumentType } from './types';
++import { ReviewAreaProps, ModalMode, DocumentType, UploadFile } from './types';
+ import ReviewChecklistSection from './ReviewChecklistSection';
+ import ReviewSourceModal from './ReviewSourceModal';
+ import {
+   ReviewChecklistEdit,
+-  ReviewChecklistResult,
++  ReviewChecklistResultDisplay,
+ } from '../../../main/types';
+ import AlertManager, { AlertMessage } from '../common/AlertMessage';
+ import { reviewService } from '../../services/reviewService';
+@@ -23,7 +23,7 @@ import { reviewService } from '../../services/reviewService';
+ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+   // 状態管理
+   const [checklistResults, setChecklistResults] = useState<
+-    ReviewChecklistResult[]
++    ReviewChecklistResultDisplay[]
+   >([]);
+   // チェックリスト更新処理中であるかどうか
+   const [isSaving, setIsSaving] = useState(false);
+@@ -78,7 +78,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+   // チェックリストの抽出処理
+   const handleExtractChecklist = useCallback(
+     async (
+-      sourceIds: number[],
++      files: UploadFile[],
+       documentType?: DocumentType,
+       checklistRequirements?: string,
+     ) => {
+@@ -91,7 +91,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+         // チェックリスト抽出処理を開始
+         const result = await window.electron.review.extractChecklist({
+           reviewHistoryId: selectedReviewHistoryId,
+-          sourceIds,
++          files,
+           documentType,
+           checklistRequirements,
+         });
+@@ -143,7 +143,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+ 
+   // レビュー実行処理
+   const handleExecuteReview = useCallback(
+-    async (sourceIds: number[]) => {
++    async (files: UploadFile[]) => {
+       if (!selectedReviewHistoryId) return;
+ 
+       try {
+@@ -153,7 +153,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+         // レビュー実行処理を開始
+         const result = await window.electron.review.execute({
+           reviewHistoryId: selectedReviewHistoryId,
+-          sourceIds,
++          files,
+         });
+ 
+         if (!result.success) {
+@@ -203,18 +203,18 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
+ 
+   const handleModalSubmit = useCallback(
+     async (
+-      sourceIds: number[],
++      files: UploadFile[],
+       documentType?: DocumentType,
+       checklistRequirements?: string,
+     ) => {
+       if (modalMode === 'extract') {
+         await handleExtractChecklist(
+-          sourceIds,
++          files,
+           documentType,
+           checklistRequirements,
+         );
+       } else if (modalMode === 'review') {
+-        await handleExecuteReview(sourceIds);
++        await handleExecuteReview(files);
+       }
+     },
+     [modalMode, handleExtractChecklist, handleExecuteReview],
+diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
+index ba9419ce3..2ce7748fb 100644
+--- a/src/renderer/components/review/ReviewChecklistSection.tsx
++++ b/src/renderer/components/review/ReviewChecklistSection.tsx
+@@ -42,7 +42,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+   const [editingContent, setEditingContent] = useState('');
+   const [isAddingNew, setIsAddingNew] = useState(false);
+   const [newContent, setNewContent] = useState('');
+-  const [sortBy, setSortBy] = useState<number | null>(null);
++  const [sortBy, setSortBy] = useState<string | null>(null);
+   const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
+ 
+   // --- ハンドラ ---
+@@ -72,24 +72,24 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+     setIsAddingNew(false);
+     setNewContent('');
+   };
+-  const handleSort = (sourceId: number) => {
+-    if (sortBy === sourceId) {
++  const handleSort = (fileId: string) => {
++    if (sortBy === fileId) {
+       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
+     } else {
+-      setSortBy(sourceId);
++      setSortBy(fileId);
+       setSortDirection('desc');
+     }
+   };
+ 
+-  // --- ユニークソース抽出 ---
++  // --- ユニークファイル抽出 ---
+   const uniqueSources = useMemo(() => {
+-    const map = new Map<number, { id: number; fileName: string }>();
++    const map = new Map<string, { id: string; fileName: string }>();
+     checklistResults.forEach((cl) => {
+       cl.sourceEvaluations?.forEach((ev) => {
+-        if (!map.has(ev.sourceId)) {
+-          map.set(ev.sourceId, {
+-            id: ev.sourceId,
+-            fileName: ev.sourceFileName,
++        if (!map.has(ev.fileId)) {
++          map.set(ev.fileId, {
++            id: ev.fileId,
++            fileName: ev.fileName,
+           });
+         }
+       });
+@@ -108,12 +108,12 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+     const order = sortDirection === 'desc' ? descOrder : ascOrder;
+ 
+     return [...checklistResults].sort((a, b) => {
+-      // 対象ソースの評価を取得。未評価は '-' 扱い
++      // 対象ファイルの評価を取得。未評価は '-' 扱い
+       const aEv =
+-        a.sourceEvaluations?.find((ev) => ev.sourceId === sortBy)?.evaluation ??
++        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
+         '-';
+       const bEv =
+-        b.sourceEvaluations?.find((ev) => ev.sourceId === sortBy)?.evaluation ??
++        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
+         '-';
+ 
+       // 配列のインデックスで比較
+@@ -186,7 +186,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
+       {/* 評価列 */}
+       {uniqueSources.map((src) => {
+         const ev = checklist.sourceEvaluations?.find(
+-          (x) => x.sourceId === src.id,
++          (x) => x.fileId === src.id,
          );
+         return (
+           <TableCell
+diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
+index a16143696..ee0f33fe6 100644
+--- a/src/renderer/components/review/ReviewSourceModal.tsx
++++ b/src/renderer/components/review/ReviewSourceModal.tsx
+@@ -5,35 +5,43 @@ import {
+   Box,
+   Typography,
+   Button,
+-  TableContainer,
+-  Table,
+-  TableHead,
+-  TableRow,
+-  TableCell,
+-  TableBody,
+   Paper,
+-  Tooltip,
+-  Chip,
+-  Checkbox,
+   FormControl,
+   RadioGroup,
+   FormControlLabel,
+   Radio,
+   FormLabel,
+   TextField,
++  List,
++  ListItem,
++  ListItemText,
++  IconButton,
++  Tooltip,
++  CircularProgress,
+ } from '@mui/material';
+ import {
+-  Check as CheckIcon,
+-  Error as ErrorIcon,
+-  Sync as SyncIcon,
+-  HourglassEmpty as ProcessingIcon,
+-  Help as UnknownIcon,
++  CloudUpload as UploadIcon,
++  Delete as DeleteIcon,
++  Image as ImageIcon,
++  Description as TextIcon,
++  Help as HelpIcon,
++  ViewAgenda as MergedIcon,
++  ViewStream as PagesIcon,
+ } from '@mui/icons-material';
++import { createHash } from 'crypto';
+ 
+-import { Source } from '../../../db/schema';
+-import { ReviewSourceModalProps, DocumentType } from './types';
++import {
++  ReviewSourceModalProps,
++  DocumentType,
++  UploadFile,
++  PdfProcessMode,
++  PdfImageMode,
++} from './types';
+ 
+-function SourceListModal({
++import { combineImages, convertPdfBytesToImages } from '../../utils/pdfUtils';
++import { file } from 'zod/v4';
++
++function ReviewSourceModal({
+   open,
+   onClose,
+   onSubmit,
+@@ -41,151 +49,208 @@ function SourceListModal({
+   disabled,
+   modalMode,
+ }: ReviewSourceModalProps): React.ReactElement {
+-  const [sources, setSources] = useState<Source[]>([]);
+-  const [checkedSources, setCheckedSources] = useState<{
+-    [key: number]: boolean;
+-  }>({});
+-  const [processing, setProcessing] = useState(true);
++  const [uploadedFiles, setUploadedFiles] = useState<UploadFile[]>([]);
++  const [processing, setProcessing] = useState(false); // ★ 送信処理やPDF変換の進行中フラグ
+   const [documentType, setDocumentType] = useState<DocumentType>('checklist');
+   const [checklistRequirements, setChecklistRequirements] = useState('');
++  const [error, setError] = useState<string | null>(null); // ★ エラー表示用
+ 
+-  // チェック状態の更新
+-  // ソースの更新状態が変わったときにチェック状態を更新する
+-  // 元のチェック状態とマージする
+-  useEffect(() => {
+-    const newCheckedSources: { [key: number]: boolean } = {};
+-    sources.forEach((source) => {
+-      newCheckedSources[source.id] =
+-        source.status === 'completed'
+-          ? checkedSources[source.id] || false
+-          : false;
+-    });
+-    setCheckedSources(newCheckedSources);
+-    // eslint-disable-next-line
+-  }, [sources]);
+-
+-  // modalMode, selectedReviewHistoryIdが変わったときにチェック状態を初期化する
+-  // checkedSourceを全てfalseにする
++  // modalMode, selectedReviewHistoryIdが変わったときに初期化
+   useEffect(() => {
+-    setCheckedSources((prev) => {
+-      Object.keys(prev).forEach((key) => {
+-        prev[+key] = false;
+-      });
+-      return { ...prev };
+-    });
+-    // ドキュメント種別もリセット
++    setUploadedFiles([]);
+     setDocumentType('checklist');
+-    // チェックリスト作成要件もリセット
+     setChecklistRequirements('');
++    setError(null);
+   }, [modalMode, selectedReviewHistoryId]);
+ 
+-  // チェックボックスの変更ハンドラ
+-  const handleSourceCheckChange = async (sourceId: number) => {
+-    setCheckedSources((prev) => ({
+-      ...prev,
+-      [sourceId]: !prev[sourceId],
+-    }));
++  const getMimeTypeFromExtension = (extension: string): string => {
++    const mimeTypes: { [key: string]: string } = {
++      pdf: 'application/pdf',
++      doc: 'application/msword',
++      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
++      xls: 'application/vnd.ms-excel',
++      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
++      ppt: 'application/vnd.ms-powerpoint',
++      pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
++      txt: 'text/plain',
++    };
++    return mimeTypes[extension] || 'application/octet-stream';
+   };
+ 
+-  // 全選択/全解除の切り替えハンドラ
+-  const handleSelectAllChange = () => {
+-    const targetSources = sources.filter(
+-      (source) => source.status === 'completed',
+-    );
+-    if (targetSources.length === 0) return;
+-    const targetCheckedSources = targetSources.reduce(
+-      (acc, source) => {
+-        acc[source.id] = checkedSources[source.id] || false;
+-        return acc;
+-      },
+-      {} as { [key: number]: boolean },
+-    );
+-    const someUnchecked = Object.values(targetCheckedSources).some(
+-      (checked) => !checked,
++  const handleFileUpload = async () => {
++    try {
++      const result = await window.electron.fs.showOpenDialog({
++        title: 'ドキュメントファイルを選択',
++        filters: [
++          {
++            name: 'ドキュメントファイル',
++            extensions: [
++              'pdf',
++              'doc',
++              'docx',
++              'xls',
++              'xlsx',
++              'ppt',
++              'pptx',
++              'txt',
++            ],
++          },
++        ],
++        properties: ['openFile', 'multiSelections'],
++      });
++
++      if (!result.canceled && result.filePaths.length > 0) {
++        const newFiles: UploadFile[] = result.filePaths.map(
++          (filePath: string) => {
++            const fileName = filePath.split('/').pop() || filePath;
++            const fileExtension =
++              fileName.split('.').pop()?.toLowerCase() || '';
++            const mimeType = getMimeTypeFromExtension(fileExtension);
++
++            return {
++              id: filePath,
++              name: fileName,
++              path: filePath,
++              type: mimeType,
++              // ★ 画像化は最終決定時だけ行うので、ここでは mode だけ持つ
++              pdfProcessMode:
++                mimeType === 'application/pdf' ? 'text' : undefined,
++              pdfImageMode: 'merged', // デフォルトは統合画像
++            };
++          },
++        );
++
++        setUploadedFiles((prev) => [...prev, ...newFiles]);
++      }
++    } catch (e) {
++      console.error('ファイル選択エラー:', e);
++      setError('ファイル選択に失敗しました。もう一度お試しください。');
++    }
++  };
++
++  const handleFileDelete = (fileId: string) => {
++    setUploadedFiles((prev) => prev.filter((file) => file.id !== fileId));
++  };
++
++  // ★ ここでは「モード切替」だけ。実際のPDF→画像変換は送信確定時にまとめて行う
++  const handlePdfProcessModeChange = (fileId: string, mode: PdfProcessMode) => {
++    setUploadedFiles((prev) =>
++      prev.map((file) =>
++        file.id === fileId
++          ? { ...file, pdfProcessMode: mode, imageData: undefined }
++          : file,
++      ),
+     );
+-    const newCheckedState = { ...checkedSources };
++  };
+ 
+-    // 一つでもチェックが外れているものがあれば全選択、すべてチェック済みなら全解除
+-    const newValue = someUnchecked;
++  // PDF画像化モードを変更するハンドラー
++  const handlePdfImageModeChange = (fileId: string, mode: PdfImageMode) => {
++    setUploadedFiles((prev) =>
++      prev.map((file) =>
++        file.id === fileId
++          ? { ...file, pdfImageMode: mode, imageData: undefined }
++          : file,
++      ),
++    );
++  };
+ 
+-    // すべてのソースのチェック状態を更新
+-    targetSources.forEach((source) => {
+-      newCheckedState[source.id] = newValue;
+-    });
+-    setCheckedSources(newCheckedState);
++  // デバッグ専用：DataURLを即ダウンロード
++  // 本番環境ではコメントアウトすること
++  const __dbgDownload = (dataUrl: string, name = 'converted.png') => {
++    const a = document.createElement('a');
++    a.href = dataUrl;
++    a.download = name;
++    a.click();
+   };
+ 
+-  // ソースデータの定期更新（processingステータスがある場合のみ）
+-  useEffect(() => {
+-    const fetchSources = async () => {
+-      try {
+-        const response = await window.electron.source.getSources();
+-        const responseSources: Source[] = response.sources || [];
+-        setSources(responseSources);
+-        const newProcessing = responseSources.some(
+-          (s: Source) => s.status === 'idle' || s.status === 'processing',
+-        );
+-        setProcessing(newProcessing);
+-      } catch (error) {
+-        console.error('ドキュメントデータの取得に失敗しました:', error);
+-      }
+-    };
++  // ★ 送信確定時にだけ、必要なPDFをMain経由で読み→Rendererで画像化→連結
++  const handleSubmit = async () => {
++    if (disabled || processing || uploadedFiles.length === 0) return;
+ 
+-    // 初回データ取得
+-    fetchSources();
++    setError(null);
++    setProcessing(true);
+ 
+-    const intervalId = setInterval(fetchSources, 5000);
++    try {
++      const filesReady = [];
++      for (const f of uploadedFiles) {
++        if (f.type === 'application/pdf' && f.pdfProcessMode === 'image') {
++          // Mainから安全にPDFバイト列を取得（file:// fetch を使わない）
++          const data = await window.electron.fs.readFile(f.path);
+ 
+-    return () => {
+-      if (intervalId) {
+-        clearInterval(intervalId);
++          // ブラウザ側で pdf.js にレンダリングさせて PNG を得る
++          const imagePages = await convertPdfBytesToImages(data, {
++            scale: 2.0,
++          });
++
++          if (f.pdfImageMode === 'pages') {
++            // ページ別画像モード: 各ページを個別に保存
++            // デバッグ用：各ページを個別にダウンロード
++            imagePages.forEach((pageImage, index) => {
++              // ←ここで即保存（デバッグ用）
++              // 本番はコメントアウトすること
++              __dbgDownload(
++                pageImage,
++                `${f.name.replace(/\.[^.]+$/, '')}_page_${index + 1}.png`,
++              );
++            });
++
++            filesReady.push({ ...f, imageData: imagePages });
++          } else {
++            // 統合画像モード（デフォルト）: 1つの縦長PNGに連結
++            const combined = await combineImages(imagePages);
++
++            // ←ここで即保存（デバッグ用）
++            // 本番はコメントアウトすること
++            __dbgDownload(
++              combined,
++              f.name.replace(/\.[^.]+$/, '') + '_combined.png',
++            );
++
++            filesReady.push({ ...f, imageData: [combined] });
++          }
++        } else {
++          filesReady.push(f);
++        }
        }
+-    };
+-  }, []);
+-
+-  const handleClick = () => {
+-    if (disabled) return;
+-    onSubmit(
+-      Object.keys(checkedSources)
+-        .filter((key) => {
+-          return checkedSources[+key];
+-        })
+-        .map((key) => +key),
+-      modalMode === 'extract' ? documentType : undefined,
+-      modalMode === 'extract' &&
+-        documentType === 'general' &&
+-        checklistRequirements.trim() !== ''
+-        ? checklistRequirements.trim()
+-        : undefined,
+-    );
++
++      // 呼び出し元に最終決定のファイルリストを渡す（必要ならこの先でMainに送る）
++      onSubmit(
++        filesReady,
++        modalMode === 'extract' ? documentType : undefined,
++        modalMode === 'extract' &&
++          documentType === 'general' &&
++          checklistRequirements.trim() !== ''
++          ? checklistRequirements.trim()
++          : undefined,
++      );
++    } catch (e) {
++      console.error('送信処理中に失敗:', e);
++      setError(
++        '送信時の処理に失敗しました。PDFが壊れていないか、またはPDFが非常に大きすぎないかをご確認ください。',
++      );
++    } finally {
++      setProcessing(false);
++    }
+   };
+ 
+   const getButtonText = () => {
+-    if (modalMode === 'review') {
+-      return 'ドキュメントレビュー実行';
+-    }
+-    if (modalMode === 'extract') {
+-      return 'チェックリスト抽出';
+-    }
++    if (modalMode === 'review') return 'ドキュメントレビュー実行';
++    if (modalMode === 'extract') return 'チェックリスト抽出';
+     return null;
+   };
+ 
+   const getTitle = () => {
+-    if (modalMode === 'review') {
+-      return 'ドキュメントレビュー対象ドキュメント選択';
+-    }
+-    if (modalMode === 'extract') {
+-      return 'チェックリスト抽出対象ドキュメント選択';
+-    }
+-    return 'ソース選択';
++    if (modalMode === 'review') return 'レビュー対象ファイルのアップロード';
++    if (modalMode === 'extract')
++      return 'チェックリスト抽出対象ファイルのアップロード';
++    return 'ファイルアップロード';
+   };
+ 
+-  // アラート表示の内容
+   const getAlertMessage = () => {
+     if (modalMode === 'extract') {
+-      const baseMessage = (
++      return (
+         <>
+-          設定されたフォルダ内のドキュメントを一覧表示しています
++          ファイルを選択してチェックリスト抽出を実行できます
+           <br />
+           {documentType === 'checklist'
+             ? '選択されたチェックリストドキュメントから、AIが既存のチェック項目を抽出できます'
+@@ -193,95 +258,24 @@ function SourceListModal({
+           <br />
+           ※
+           <br />
+-          フォルダの内容が更新された場合はドキュメント一覧画面（添付アイコン）からファイル同期を実行してください
+-          <br />
+           チェックリストは手動で編集・追加・削除が可能です
+           <br />
+           手動で追加・編集されたチェックリスト以外は、再度チェックリスト抽出を実行すると削除されます
+-          <br />
+-          フォルダのパスは設定画面（歯車アイコン）から変更可能です
+         </>
+       );
+-      return baseMessage;
+     }
+     if (modalMode === 'review') {
+       return (
+         <>
+-          設定されたフォルダ内のドキュメントを一覧表示しています
++          レビュー対象ファイルを選択してください
+           <br />
+           選択されたドキュメントに対して、AIがチェックリストに基づいてレビューを行います
+-          <br />
+-          ※
+-          <br />
+-          フォルダの内容が更新された場合はドキュメント一覧画面（添付アイコン）からファイル同期を実行してください
+-          <br />
+-          フォルダのパスは設定画面（歯車アイコン）から変更可能です
+         </>
+       );
+     }
+     return null;
+   };
+ 
+-  const getStatusIcon = (status: Source['status'], error?: Source['error']) => {
+-    switch (status) {
+-      case 'completed':
+-        return (
+-          <Chip
+-            icon={<CheckIcon />}
+-            label="完了"
+-            color="success"
+-            size="small"
+-            variant="outlined"
+-          />
+-        );
+-      case 'failed':
+-        return (
+-          <Tooltip
+-            data-testid="sourcelistmodal-error-tooltip"
+-            title={error ?? '不明なエラー'}
+-          >
+-            <Chip
+-              icon={<ErrorIcon />}
+-              label="エラー"
+-              color="error"
+-              size="small"
+-              variant="outlined"
+-            />
+-          </Tooltip>
+-        );
+-      case 'processing':
+-        return (
+-          <Chip
+-            icon={<ProcessingIcon />}
+-            label="処理中"
+-            color="primary"
+-            size="small"
+-            variant="outlined"
+-          />
+-        );
+-      case 'idle':
+-        return (
+-          <Chip
+-            icon={<SyncIcon />}
+-            label="待機中"
+-            color="default"
+-            size="small"
+-            variant="outlined"
+-          />
+-        );
+-      default:
+-        return (
+-          <Chip
+-            icon={<UnknownIcon />}
+-            label="不明"
+-            color="default"
+-            size="small"
+-            variant="outlined"
+-          />
+-        );
+-    }
+-  };
+-
+   return (
+     <Modal open={open} onClose={onClose}>
+       <Box
+@@ -303,10 +297,17 @@ function SourceListModal({
+         <Typography variant="h6" component="h2" gutterBottom>
+           {getTitle()}
+         </Typography>
++
+         <Alert severity="info" sx={{ whiteSpace: 'pre-line', mb: 2 }}>
+           {getAlertMessage()}
+         </Alert>
+ 
++        {error && (
++          <Alert severity="error" sx={{ mb: 2 }}>
++            {error}
++          </Alert>
++        )}
++
+         {modalMode === 'extract' && (
+           <>
+             <FormControl component="fieldset" sx={{ mb: 2 }}>
+@@ -350,78 +351,160 @@ function SourceListModal({
+           </>
+         )}
+ 
+-        <Box sx={{ mb: 2, display: 'flex', justifyContent: 'flex-end' }}>
+-          <Tooltip title="ソース登録ディレクトリ内のファイル内容と同期します">
+-            <Button
+-              variant="contained"
+-              onClick={handleClick}
+-              disabled={
+-                processing ||
+-                disabled ||
+-                Object.keys(checkedSources).length === 0
+-              }
+-              startIcon={<SyncIcon />}
+-            >
+-              {processing ? 'ドキュメント初期化処理中...' : getButtonText()}
+-            </Button>
+-          </Tooltip>
++        <Box sx={{ mb: 2 }}>
++          <Button
++            variant="contained"
++            onClick={handleFileUpload}
++            startIcon={<UploadIcon />}
++            disabled={processing}
++          >
++            ファイル選択ダイアログ
++          </Button>
+         </Box>
+ 
+-        <TableContainer component={Paper}>
+-          <Table>
+-            <TableHead>
+-              <TableRow>
+-                <TableCell padding="checkbox">
+-                  <Checkbox
+-                    indeterminate={
+-                      Object.values(checkedSources).some(
+-                        (checked) => checked,
+-                      ) &&
+-                      Object.values(checkedSources).some((checked) => !checked)
+-                    }
+-                    checked={
+-                      Object.values(checkedSources).length > 0 &&
+-                      Object.values(checkedSources).every((checked) => checked)
+-                    }
+-                    onChange={handleSelectAllChange}
+-                    disabled={processing}
+-                  />
+-                </TableCell>
+-                <TableCell>ファイルパス</TableCell>
+-                <TableCell>タイトル（生成）</TableCell>
+-                <TableCell>フォルダ同期処理ステータス</TableCell>
+-              </TableRow>
+-            </TableHead>
+-            <TableBody>
+-              {sources.map((source) => (
+-                <TableRow
+-                  key={source.id}
+-                  sx={{
+-                    '&:last-child td, &:last-child th': { border: 0 },
+-                    backgroundColor:
+-                      source.status === 'failed' ? 'error.lighter' : 'inherit',
+-                  }}
++        {uploadedFiles.length > 0 && (
++          <Paper sx={{ mb: 2, p: 2 }}>
++            <Typography variant="subtitle2" gutterBottom>
++              選択済みファイル ({uploadedFiles.length}件)
++            </Typography>
++            <List dense>
++              {uploadedFiles.map((file) => (
++                <ListItem
++                  key={file.id}
++                  secondaryAction={
++                    <IconButton
++                      edge="end"
++                      onClick={() => handleFileDelete(file.id)}
++                      disabled={processing}
++                    >
++                      <DeleteIcon />
++                    </IconButton>
++                  }
+                 >
+-                  <TableCell padding="checkbox">
+-                    <Checkbox
+-                      checked={checkedSources[source.id] || false}
+-                      onChange={() => handleSourceCheckChange(source.id)}
+-                      disabled={processing || source.status !== 'completed'}
+-                    />
+-                  </TableCell>
+-                  <TableCell>{source.path}</TableCell>
+-                  <TableCell>{source.title}</TableCell>
+-                  <TableCell>
+-                    {getStatusIcon(source.status, source.error)}
+-                  </TableCell>
+-                </TableRow>
++                  <ListItemText
++                    primary={file.name}
++                    secondary={file.type === 'application/pdf' ? 'PDF' : ''}
++                  />
++                  {file.type === 'application/pdf' && (
++                    <Box sx={{ mr: 2 }}>
++                      <FormControl size="small">
++                        <RadioGroup
++                          row
++                          value={file.pdfProcessMode}
++                          onChange={(e) =>
++                            handlePdfProcessModeChange(
++                              file.id,
++                              e.target.value as PdfProcessMode,
++                            )
++                          }
++                        >
++                          <FormControlLabel
++                            value="text"
++                            control={<Radio size="small" />}
++                            label={
++                              <Box
++                                sx={{ display: 'flex', alignItems: 'center' }}
++                              >
++                                <TextIcon fontSize="small" sx={{ mr: 0.5 }} />
++                                テキスト
++                              </Box>
++                            }
++                          />
++                          <FormControlLabel
++                            value="image"
++                            control={<Radio size="small" />}
++                            label={
++                              <Box
++                                sx={{ display: 'flex', alignItems: 'center' }}
++                              >
++                                <ImageIcon fontSize="small" sx={{ mr: 0.5 }} />
++                                画像
++                                <Tooltip title="図形オブジェクトが多いPDFは画像化で精度が上がる場合があります">
++                                  <HelpIcon
++                                    fontSize="small"
++                                    sx={{ ml: 0.5, color: 'text.secondary' }}
++                                  />
++                                </Tooltip>
++                              </Box>
++                            }
++                          />
++                        </RadioGroup>
++                      </FormControl>
++                      {file.pdfProcessMode === 'image' && (
++                        <FormControl size="small" sx={{ ml: 1 }}>
++                          <RadioGroup
++                            row
++                            value={file.pdfImageMode}
++                            onChange={(e) =>
++                              handlePdfImageModeChange(
++                                file.id,
++                                e.target.value as PdfImageMode,
++                              )
++                            }
++                          >
++                            <FormControlLabel
++                              value="merged"
++                              control={<Radio size="small" />}
++                              label={
++                                <Box
++                                  sx={{ display: 'flex', alignItems: 'center' }}
++                                >
++                                  <MergedIcon
++                                    fontSize="small"
++                                    sx={{ mr: 0.5 }}
++                                  />
++                                  統合画像
++                                </Box>
++                              }
++                            />
++                            <FormControlLabel
++                              value="pages"
++                              control={<Radio size="small" />}
++                              label={
++                                <Box
++                                  sx={{ display: 'flex', alignItems: 'center' }}
++                                >
++                                  <PagesIcon
++                                    fontSize="small"
++                                    sx={{ mr: 0.5 }}
++                                  />
++                                  ページ別画像
++                                  <Tooltip title="ページ数が多い場合はページごとに画像化することを検討してください">
++                                    <HelpIcon
++                                      fontSize="small"
++                                      sx={{ ml: 0.5, color: 'text.secondary' }}
++                                    />
++                                  </Tooltip>
++                                </Box>
++                              }
++                            />
++                          </RadioGroup>
++                        </FormControl>
++                      )}
++                    </Box>
++                  )}
++                </ListItem>
+               ))}
+-            </TableBody>
+-          </Table>
+-        </TableContainer>
++            </List>
++          </Paper>
++        )}
++
++        <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 2 }}>
++          <Button variant="outlined" onClick={onClose} disabled={processing}>
++            キャンセル
++          </Button>
++          <Button
++            variant="contained"
++            onClick={handleSubmit}
++            disabled={processing || disabled || uploadedFiles.length === 0}
++            startIcon={processing ? <CircularProgress size={20} /> : null}
++          >
++            {processing ? '処理中...' : getButtonText()}
++          </Button>
++        </Box>
+       </Box>
+     </Modal>
+   );
+ }
+ 
+-export default React.memo(SourceListModal);
++export default React.memo(ReviewSourceModal);
+diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
+index 55c81e159..e65954a5f 100644
+--- a/src/renderer/components/review/types.ts
++++ b/src/renderer/components/review/types.ts
+@@ -1,6 +1,6 @@
+ import {
+   ReviewChecklistEdit,
+-  ReviewChecklistResult,
++  ReviewChecklistResultDisplay,
+ } from '../../../main/types';
+ import { Source } from '../../../db/schema';
+ 
+@@ -11,7 +11,7 @@ export interface ReviewAreaProps {
+ 
+ // ReviewChecklistSectionのProps型
+ export interface ReviewChecklistSectionProps {
+-  checklistResults: ReviewChecklistResult[];
++  checklistResults: ReviewChecklistResultDisplay[];
+   isLoading: boolean;
+   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
+ }
+@@ -21,12 +21,29 @@ export type ModalMode = 'extract' | 'review';
+ // ドキュメント種別の定義
+ export type DocumentType = 'checklist' | 'general';
+ 
++// PDF処理方式の定義
++export type PdfProcessMode = 'text' | 'image';
++
++// PDF画像化方式の定義
++export type PdfImageMode = 'merged' | 'pages';
++
++// アップロードファイル情報の型定義
++export interface UploadFile {
++  id: string;
++  name: string;
++  path: string;
++  type: string;
++  pdfProcessMode?: PdfProcessMode; // PDFファイルの場合のみ
++  pdfImageMode?: PdfImageMode; // PDF画像化の場合のみ (merged: 統合画像, pages: ページ別画像)
++  imageData?: string[]; // PDF画像変換時のBase64データ配列 (merged: 長さ1, pages: 各ページ)
++}
++
+ // ReviewSourceModalのProps型
+ export interface ReviewSourceModalProps {
+   open: boolean;
+   onClose: () => void;
+   onSubmit: (
+-    sourceIds: number[],
++    files: UploadFile[],
+     documentType?: DocumentType,
+     checklistRequirements?: string,
+   ) => void;
+diff --git a/src/renderer/services/reviewService.ts b/src/renderer/services/reviewService.ts
+index fd5edd165..5655e2270 100644
+--- a/src/renderer/services/reviewService.ts
++++ b/src/renderer/services/reviewService.ts
+@@ -1,5 +1,6 @@
+ import { ReviewHistory } from '../../db/schema';
+ import { IpcChannels, IpcEventPayload } from '../../main/types/ipc';
++import { UploadFile } from '../components/review/types';
+ 
+ // IPC通信を使用してメインプロセスとやり取りするレビュー機能用のサービス
+ export const reviewService = {
+@@ -67,12 +68,12 @@ export const reviewService = {
+    */
+   callChecklistExtraction: async (
+     reviewHistoryId: string,
+-    sourceIds: number[],
++    files: UploadFile[],
+   ) => {
+     try {
+       const result = await window.electron.review.extractChecklist({
+         reviewHistoryId,
+-        sourceIds,
++        files,
+       });
+       if (!result.success) {
+         throw new Error(result.error || '不明なエラー');
+@@ -85,7 +86,11 @@ export const reviewService = {
+   },
+ 
+   subscribeChecklistExtractionFinished: (
+-    callback: (payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED>) => void,
++    callback: (
++      payload: IpcEventPayload<
++        typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
++      >,
++    ) => void,
+   ) => {
+     return window.electron.review.onExtractChecklistFinished((payload) => {
+       callback(payload);
+@@ -93,7 +98,9 @@ export const reviewService = {
+   },
+ 
+   subscribeReviewExecutionFinished: (
+-    callback: (payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>) => void,
++    callback: (
++      payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
++    ) => void,
+   ) => {
+     return window.electron.review.onExecuteReviewFinished((payload) => {
+       callback(payload);
+diff --git a/src/renderer/utils/pdfUtils.ts b/src/renderer/utils/pdfUtils.ts
+new file mode 100644
+index 000000000..1f7c41657
+--- /dev/null
++++ b/src/renderer/utils/pdfUtils.ts
+@@ -0,0 +1,84 @@
++import * as pdfjsLib from 'pdfjs-dist';
++
++// PDF.jsのワーカーを設定
++const workerUrl = new URL('pdf.worker.mjs', window.location.href).toString();
++const worker = new Worker(workerUrl, { type: 'module' });
++pdfjsLib.GlobalWorkerOptions.workerPort = worker;
++
++/**
++ * PDF を PNG(Base64 DataURL) の配列に変換
++ * @param arrayBuffer Main 経由で取得した PDF の ArrayBuffer
++ * @param opts.scale レンダリング解像度（デフォルト 2.0）
++ */
++export const convertPdfBytesToImages = async (
++  data: Uint8Array | ArrayBufferLike,
++  opts: { scale?: number } = {},
++): Promise<string[]> => {
++  const scale = opts.scale ?? 2.0;
++
++  // data が Uint8Array でなければ Uint8Array に包む
++  const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
++
++  const loadingTask = pdfjsLib.getDocument({ data: bytes });
++  const pdf = await loadingTask.promise;
++
++  const images: string[] = [];
++  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
++    const page = await pdf.getPage(pageNum);
++    const viewport = page.getViewport({ scale });
++
++    const canvas = document.createElement('canvas');
++    const ctx = canvas.getContext('2d');
++    if (!ctx) throw new Error('Canvas context could not be created');
++
++    canvas.width = viewport.width;
++    canvas.height = viewport.height;
++
++    await page.render({ canvasContext: ctx, viewport }).promise;
++    images.push(canvas.toDataURL('image/png'));
++  }
++  return images;
++};
++
++/**
++ * 画像データURL配列を縦に結合して1枚のPNGにする
++ */
++export const combineImages = async (
++  imageDataArray: string[],
++): Promise<string> => {
++  if (imageDataArray.length === 0) throw new Error('画像データが空です');
++  if (imageDataArray.length === 1) return imageDataArray[0];
++
++  const images = await Promise.all(
++    imageDataArray.map(
++      (data) =>
++        new Promise<HTMLImageElement>((resolve, reject) => {
++          const img = new Image();
++          img.onload = () => resolve(img);
++          img.onerror = reject;
++          img.src = data;
++        }),
++    ),
++  );
++
++  const maxWidth = Math.max(...images.map((img) => img.width));
++  const totalHeight = images.reduce((sum, img) => sum + img.height, 0);
++
++  const canvas = document.createElement('canvas');
++  const context = canvas.getContext('2d');
++  if (!context) throw new Error('Canvas context could not be created');
++
++  canvas.width = maxWidth;
++  canvas.height = totalHeight;
++
++  context.fillStyle = '#FFFFFF';
++  context.fillRect(0, 0, maxWidth, totalHeight);
++
++  let currentY = 0;
++  for (const img of images) {
++    context.drawImage(img, 0, currentY);
++    currentY += img.height;
++  }
++
++  return canvas.toDataURL('image/png');
++};
diff --git a/drizzle/migrations/0004_adorable_abomination.sql b/drizzle/migrations/0004_adorable_abomination.sql
new file mode 100644
index 000000000..847a9f90c
--- /dev/null
+++ b/drizzle/migrations/0004_adorable_abomination.sql
@@ -0,0 +1,13 @@
+CREATE TABLE `review_checklist_results` (
+	`review_checklist_id` integer NOT NULL,
+	`file_id` text NOT NULL,
+	`file_name` text NOT NULL,
+	`evaluation` text NOT NULL,
+	`comment` text,
+	`created_at` text DEFAULT (current_timestamp) NOT NULL,
+	`updated_at` text DEFAULT (current_timestamp) NOT NULL,
+	PRIMARY KEY(`review_checklist_id`, `file_id`),
+	FOREIGN KEY (`review_checklist_id`) REFERENCES `review_checklists`(`id`) ON UPDATE no action ON DELETE cascade
+);
+--> statement-breakpoint
+DROP TABLE `review_checklist_sources`;
\ No newline at end of file
diff --git a/drizzle/migrations/meta/0004_snapshot.json b/drizzle/migrations/meta/0004_snapshot.json
new file mode 100644
index 000000000..403c6cf39
--- /dev/null
+++ b/drizzle/migrations/meta/0004_snapshot.json
@@ -0,0 +1,362 @@
+{
+  "version": "6",
+  "dialect": "sqlite",
+  "id": "362051e0-23e2-46a5-88e8-952bfb3e5be4",
+  "prevId": "e4779464-5d36-4a28-a701-899c1b816205",
+  "tables": {
+    "review_checklist_results": {
+      "name": "review_checklist_results",
+      "columns": {
+        "review_checklist_id": {
+          "name": "review_checklist_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "file_id": {
+          "name": "file_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "file_name": {
+          "name": "file_name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "evaluation": {
+          "name": "evaluation",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "comment": {
+          "name": "comment",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklist_results_review_checklist_id_review_checklists_id_fk": {
+          "name": "review_checklist_results_review_checklist_id_review_checklists_id_fk",
+          "tableFrom": "review_checklist_results",
+          "tableTo": "review_checklists",
+          "columnsFrom": [
+            "review_checklist_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {
+        "review_checklist_results_review_checklist_id_file_id_pk": {
+          "columns": [
+            "review_checklist_id",
+            "file_id"
+          ],
+          "name": "review_checklist_results_review_checklist_id_file_id_pk"
+        }
+      },
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_checklists": {
+      "name": "review_checklists",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "review_history_id": {
+          "name": "review_history_id",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "content": {
+          "name": "content",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_by": {
+          "name": "created_by",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "review_checklists_review_history_id_review_histories_id_fk": {
+          "name": "review_checklists_review_history_id_review_histories_id_fk",
+          "tableFrom": "review_checklists",
+          "tableTo": "review_histories",
+          "columnsFrom": [
+            "review_history_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "review_histories": {
+      "name": "review_histories",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "text",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "sources": {
+      "name": "sources",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "path": {
+          "name": "path",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "title": {
+          "name": "title",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "status": {
+          "name": "status",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "'idle'"
+        },
+        "error": {
+          "name": "error",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": false,
+          "autoincrement": false
+        },
+        "is_enabled": {
+          "name": "is_enabled",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": 1
+        }
+      },
+      "indexes": {
+        "sources_path_unique": {
+          "name": "sources_path_unique",
+          "columns": [
+            "path"
+          ],
+          "isUnique": true
+        }
+      },
+      "foreignKeys": {},
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    },
+    "topics": {
+      "name": "topics",
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "integer",
+          "primaryKey": true,
+          "notNull": true,
+          "autoincrement": true
+        },
+        "source_id": {
+          "name": "source_id",
+          "type": "integer",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "name": {
+          "name": "name",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "summary": {
+          "name": "summary",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false
+        },
+        "created_at": {
+          "name": "created_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        },
+        "updated_at": {
+          "name": "updated_at",
+          "type": "text",
+          "primaryKey": false,
+          "notNull": true,
+          "autoincrement": false,
+          "default": "(current_timestamp)"
+        }
+      },
+      "indexes": {},
+      "foreignKeys": {
+        "topics_source_id_sources_id_fk": {
+          "name": "topics_source_id_sources_id_fk",
+          "tableFrom": "topics",
+          "tableTo": "sources",
+          "columnsFrom": [
+            "source_id"
+          ],
+          "columnsTo": [
+            "id"
+          ],
+          "onDelete": "cascade",
+          "onUpdate": "no action"
+        }
+      },
+      "compositePrimaryKeys": {},
+      "uniqueConstraints": {},
+      "checkConstraints": {}
+    }
+  },
+  "views": {},
+  "enums": {},
+  "_meta": {
+    "schemas": {},
+    "tables": {},
+    "columns": {}
+  },
+  "internal": {
+    "indexes": {}
+  }
+}
\ No newline at end of file
diff --git a/drizzle/migrations/meta/_journal.json b/drizzle/migrations/meta/_journal.json
index 6313c7bd6..1315c768b 100644
--- a/drizzle/migrations/meta/_journal.json
+++ b/drizzle/migrations/meta/_journal.json
@@ -29,6 +29,13 @@
       "when": 1749952232695,
       "tag": "0003_outgoing_cobalt_man",
       "breakpoints": true
+    },
+    {
+      "idx": 4,
+      "version": "6",
+      "when": 1756909323206,
+      "tag": "0004_adorable_abomination",
+      "breakpoints": true
     }
   ]
 }
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index ba32ee2b8..46bcccd6f 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -5105,6 +5105,207 @@
         "node": ">=10"
       }
     },
+    "node_modules/@mapbox/node-pre-gyp": {
+      "version": "1.0.11",
+      "resolved": "https://registry.npmjs.org/@mapbox/node-pre-gyp/-/node-pre-gyp-1.0.11.tgz",
+      "integrity": "sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "detect-libc": "^2.0.0",
+        "https-proxy-agent": "^5.0.0",
+        "make-dir": "^3.1.0",
+        "node-fetch": "^2.6.7",
+        "nopt": "^5.0.0",
+        "npmlog": "^5.0.1",
+        "rimraf": "^3.0.2",
+        "semver": "^7.3.5",
+        "tar": "^6.1.11"
+      },
+      "bin": {
+        "node-pre-gyp": "bin/node-pre-gyp"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/are-we-there-yet": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-2.0.0.tgz",
+      "integrity": "sha512-Ci/qENmwHnsYo9xKIcUJN5LeDKdJ6R1Z1j9V/J5wyq8nh/mYPEpIKJbBZXtZjG04HiK7zV/p6Vs9952MrMeUIw==",
+      "deprecated": "This package is no longer supported.",
+      "dev": true,
+      "license": "ISC",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "delegates": "^1.0.0",
+        "readable-stream": "^3.6.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/gauge": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/gauge/-/gauge-3.0.2.tgz",
+      "integrity": "sha512-+5J6MS/5XksCuXq++uFRsnUd7Ovu1XenbeuIuNRJxYWjgQbPuFhT14lAvsWfqfAmnwluf1OwMjz39HjfLPci0Q==",
+      "deprecated": "This package is no longer supported.",
+      "dev": true,
+      "license": "ISC",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "aproba": "^1.0.3 || ^2.0.0",
+        "color-support": "^1.1.2",
+        "console-control-strings": "^1.0.0",
+        "has-unicode": "^2.0.1",
+        "object-assign": "^4.1.1",
+        "signal-exit": "^3.0.0",
+        "string-width": "^4.2.3",
+        "strip-ansi": "^6.0.1",
+        "wide-align": "^1.1.2"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/make-dir": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
+      "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "semver": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/make-dir/node_modules/semver": {
+      "version": "6.3.1",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
+      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
+      "dev": true,
+      "license": "ISC",
+      "optional": true,
+      "peer": true,
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/node-fetch": {
+      "version": "2.7.0",
+      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
+      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "whatwg-url": "^5.0.0"
+      },
+      "engines": {
+        "node": "4.x || >=6.0.0"
+      },
+      "peerDependencies": {
+        "encoding": "^0.1.0"
+      },
+      "peerDependenciesMeta": {
+        "encoding": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/nopt": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/nopt/-/nopt-5.0.0.tgz",
+      "integrity": "sha512-Tbj67rffqceeLpcRXrT7vKAN8CwfPeIBgM7E6iBkmKLV7bEMwpGgYLGv0jACUsECaa/vuxP0IjEont6umdMgtQ==",
+      "dev": true,
+      "license": "ISC",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "abbrev": "1"
+      },
+      "bin": {
+        "nopt": "bin/nopt.js"
+      },
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/npmlog": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-5.0.1.tgz",
+      "integrity": "sha512-AqZtDUWOMKs1G/8lwylVjrdYgqA4d9nu8hc+0gzRxlDb1I10+FHBGMXs6aiQHFdCUUlqH99MUMuLfzWDNDtfxw==",
+      "deprecated": "This package is no longer supported.",
+      "dev": true,
+      "license": "ISC",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "are-we-there-yet": "^2.0.0",
+        "console-control-strings": "^1.1.0",
+        "gauge": "^3.0.0",
+        "set-blocking": "^2.0.0"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/rimraf": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
+      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
+      "deprecated": "Rimraf versions prior to v4 are no longer supported",
+      "dev": true,
+      "license": "ISC",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "glob": "^7.1.3"
+      },
+      "bin": {
+        "rimraf": "bin.js"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/tr46": {
+      "version": "0.0.3",
+      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
+      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/webidl-conversions": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
+      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==",
+      "dev": true,
+      "license": "BSD-2-Clause",
+      "optional": true,
+      "peer": true
+    },
+    "node_modules/@mapbox/node-pre-gyp/node_modules/whatwg-url": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
+      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "tr46": "~0.0.3",
+        "webidl-conversions": "^3.0.0"
+      }
+    },
     "node_modules/@mastra/core": {
       "version": "0.14.1",
       "resolved": "https://registry.npmjs.org/@mastra/core/-/core-0.14.1.tgz",
@@ -13329,6 +13530,24 @@
       ],
       "license": "CC-BY-4.0"
     },
+    "node_modules/canvas": {
+      "version": "2.11.2",
+      "resolved": "https://registry.npmjs.org/canvas/-/canvas-2.11.2.tgz",
+      "integrity": "sha512-ItanGBMrmRV7Py2Z+Xhs7cT+FNt5K0vPL4p9EZ/UX/Mu7hFbkxSjKF2KVtPwX7UYWp7dRKnrTvReflgrItJbdw==",
+      "dev": true,
+      "hasInstallScript": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "@mapbox/node-pre-gyp": "^1.0.0",
+        "nan": "^2.17.0",
+        "simple-get": "^3.0.3"
+      },
+      "engines": {
+        "node": ">=6"
+      }
+    },
     "node_modules/ccount": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/ccount/-/ccount-2.0.1.tgz",
@@ -25232,6 +25451,15 @@
         "url": "https://github.com/sponsors/raouldeheer"
       }
     },
+    "node_modules/nan": {
+      "version": "2.23.0",
+      "resolved": "https://registry.npmjs.org/nan/-/nan-2.23.0.tgz",
+      "integrity": "sha512-1UxuyYGdoQHcGg87Lkqm3FzefucTa0NAiOcuRsDmysep3c1LVCRK2krrUDafMWtjSG04htvAmvg96+SDknOmgQ==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true
+    },
     "node_modules/nanoid": {
       "version": "3.3.11",
       "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
@@ -29808,6 +30036,73 @@
       "dev": true,
       "license": "ISC"
     },
+    "node_modules/simple-concat": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
+      "integrity": "sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "license": "MIT",
+      "optional": true,
+      "peer": true
+    },
+    "node_modules/simple-get": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/simple-get/-/simple-get-3.1.1.tgz",
+      "integrity": "sha512-CQ5LTKGfCpvE1K0n2us+kuMPbk/q0EKl82s4aheV9oXjFEz6W/Y7oQFVJuU6QG77hRT4Ghb5RURteF5vnWjupA==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "decompress-response": "^4.2.0",
+        "once": "^1.3.1",
+        "simple-concat": "^1.0.0"
+      }
+    },
+    "node_modules/simple-get/node_modules/decompress-response": {
+      "version": "4.2.1",
+      "resolved": "https://registry.npmjs.org/decompress-response/-/decompress-response-4.2.1.tgz",
+      "integrity": "sha512-jOSne2qbyE+/r8G1VU+G/82LBs2Fs4LAsTiLSHOCOMZQl2OKZ6i8i4IyHemTe+/yIXOtTcRQMzPcgyhoFlqPkw==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "dependencies": {
+        "mimic-response": "^2.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/simple-get/node_modules/mimic-response": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/mimic-response/-/mimic-response-2.1.0.tgz",
+      "integrity": "sha512-wXqjST+SLt7R009ySCglWBCFpjUygmCIfD790/kVbiGmUgfYGuB14PiTd5DwVxSV4NcYHjzMkoj5LjQZwTQLEA==",
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "peer": true,
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/simple-update-notifier": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
diff --git a/src/db/repository/reviewRepository.ts b/src/db/repository/reviewRepository.ts
index d113164f4..aacc552bf 100644
--- a/src/db/repository/reviewRepository.ts
+++ b/src/db/repository/reviewRepository.ts
@@ -3,17 +3,16 @@ import path from 'path';
 import type {
   ReviewHistory,
   ReviewChecklist,
-  ReviewChecklistSource,
+  ReviewChecklistResult as DBReviewChecklistResult,
 } from '../schema';
 import {
   reviewHistories,
   reviewChecklists,
-  reviewChecklistSources,
-  sources,
+  reviewChecklistResults,
 } from '../schema';
 import getDb from '..';
 import type {
-  ReviewChecklistResult,
+  ReviewChecklistResultDisplay,
   ReviewEvaluation,
   ReviewChecklistCreatedBy,
 } from '../../main/types';
@@ -45,19 +44,22 @@ export interface ReviewRepository {
   upsertReviewResult(
     results: {
       reviewChecklistId: number;
-      sourceId: number;
       evaluation: ReviewEvaluation;
       comment: string;
+      fileId: string;
+      fileName: string;
     }[],
-  ): Promise<ReviewChecklistSource[]>;
-  getReviewResults(reviewChecklistId: number): Promise<ReviewChecklistSource[]>;
+  ): Promise<DBReviewChecklistResult[]>;
+  getReviewResults(
+    reviewChecklistId: number,
+  ): Promise<DBReviewChecklistResult[]>;
   deleteReviewResults(
     reviewChecklistId: number,
     sourceId: number,
   ): Promise<void>;
   getReviewChecklistResults(
     reviewHistoryId: string,
-  ): Promise<ReviewChecklistResult[]>;
+  ): Promise<ReviewChecklistResultDisplay[]>;
   deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
 }
 
@@ -246,22 +248,23 @@ class DrizzleReviewRepository implements ReviewRepository {
   async upsertReviewResult(
     results: {
       reviewChecklistId: number;
-      sourceId: number;
       evaluation: ReviewEvaluation;
       comment: string;
+      fileId: string;
+      fileName: string;
     }[],
-  ): Promise<ReviewChecklistSource[]> {
+  ): Promise<DBReviewChecklistResult[]> {
     try {
       const db = await getDb();
-      const upsertedResults: ReviewChecklistSource[] = [];
+      const upsertedResults: DBReviewChecklistResult[] = [];
       for (const result of results) {
         const [upserted] = await db
-          .insert(reviewChecklistSources)
+          .insert(reviewChecklistResults)
           .values(result)
           .onConflictDoUpdate({
             target: [
-              reviewChecklistSources.reviewChecklistId,
-              reviewChecklistSources.sourceId,
+              reviewChecklistResults.reviewChecklistId,
+              reviewChecklistResults.fileId,
             ],
             set: {
               evaluation: result.evaluation,
@@ -283,13 +286,13 @@ class DrizzleReviewRepository implements ReviewRepository {
   /** レビュー結果一覧を取得 */
   async getReviewResults(
     reviewChecklistId: number,
-  ): Promise<ReviewChecklistSource[]> {
+  ): Promise<DBReviewChecklistResult[]> {
     try {
       const db = await getDb();
       return await db
         .select()
-        .from(reviewChecklistSources)
-        .where(eq(reviewChecklistSources.reviewChecklistId, reviewChecklistId));
+        .from(reviewChecklistResults)
+        .where(eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId));
     } catch (err) {
       throw new RepositoryError(
         `レビュー結果の取得に失敗しました: ${(err as Error).message}`,
@@ -306,11 +309,11 @@ class DrizzleReviewRepository implements ReviewRepository {
     try {
       const db = await getDb();
       await db
-        .delete(reviewChecklistSources)
+        .delete(reviewChecklistResults)
         .where(
           and(
-            eq(reviewChecklistSources.reviewChecklistId, reviewChecklistId),
-            eq(reviewChecklistSources.sourceId, sourceId),
+            eq(reviewChecklistResults.reviewChecklistId, reviewChecklistId),
+            eq(reviewChecklistResults.fileId, sourceId.toString()),
           ),
         );
     } catch (err) {
@@ -324,28 +327,27 @@ class DrizzleReviewRepository implements ReviewRepository {
   /** チェックリスト結果を取得してグルーピング */
   async getReviewChecklistResults(
     reviewHistoryId: string,
-  ): Promise<ReviewChecklistResult[]> {
+  ): Promise<ReviewChecklistResultDisplay[]> {
     try {
       const db = await getDb();
       const rows = await db
         .select({
           checklistId: reviewChecklists.id,
           content: reviewChecklists.content,
-          sourceId: reviewChecklistSources.sourceId,
-          sourcePath: sources.path,
-          evaluation: reviewChecklistSources.evaluation,
-          comment: reviewChecklistSources.comment,
+          fileId: reviewChecklistResults.fileId,
+          fileName: reviewChecklistResults.fileName,
+          evaluation: reviewChecklistResults.evaluation,
+          comment: reviewChecklistResults.comment,
         })
         .from(reviewChecklists)
         .leftJoin(
-          reviewChecklistSources,
-          eq(reviewChecklistSources.reviewChecklistId, reviewChecklists.id),
+          reviewChecklistResults,
+          eq(reviewChecklistResults.reviewChecklistId, reviewChecklists.id),
         )
-        .leftJoin(sources, eq(reviewChecklistSources.sourceId, sources.id))
         .where(eq(reviewChecklists.reviewHistoryId, reviewHistoryId))
         .orderBy(reviewChecklists.createdAt);
 
-      const map = new Map<number, ReviewChecklistResult>();
+      const map = new Map<number, ReviewChecklistResultDisplay>();
       for (const row of rows) {
         let group = map.get(row.checklistId);
         if (!group) {
@@ -356,10 +358,10 @@ class DrizzleReviewRepository implements ReviewRepository {
           };
           map.set(row.checklistId, group);
         }
-        if (row.sourceId !== null) {
+        if (row.fileId !== null && row.fileName !== null) {
           group.sourceEvaluations!.push({
-            sourceId: row.sourceId,
-            sourceFileName: row.sourcePath ? path.basename(row.sourcePath) : '',
+            fileId: row.fileId,
+            fileName: row.fileName,
             evaluation: row.evaluation as ReviewEvaluation,
             comment: row.comment ?? undefined,
           });
@@ -388,8 +390,8 @@ class DrizzleReviewRepository implements ReviewRepository {
 
       for (const { id } of checklists) {
         await db
-          .delete(reviewChecklistSources)
-          .where(eq(reviewChecklistSources.reviewChecklistId, id));
+          .delete(reviewChecklistResults)
+          .where(eq(reviewChecklistResults.reviewChecklistId, id));
       }
     } catch (err) {
       throw new RepositoryError(
diff --git a/src/db/schema.ts b/src/db/schema.ts
index 8a11a9a77..62d70bd5f 100644
--- a/src/db/schema.ts
+++ b/src/db/schema.ts
@@ -85,17 +85,16 @@ export const reviewChecklists = sqliteTable('review_checklists', {
     .$onUpdate(() => sql`(current_timestamp)`),
 });
 
-// レビューチェックリストとソースの中間テーブル
-export const reviewChecklistSources = sqliteTable(
-  'review_checklist_sources',
+// レビューチェックリスト結果テーブル（1つのチェックリストに対して複数のファイル結果を保存）
+export const reviewChecklistResults = sqliteTable(
+  'review_checklist_results',
   {
     reviewChecklistId: integer('review_checklist_id')
       .notNull()
       .references(() => reviewChecklists.id, { onDelete: 'cascade' }),
-    sourceId: integer('source_id')
-      .notNull()
-      .references(() => sources.id, { onDelete: 'cascade' }),
-    evaluation: text('evaluation'), // A, B, C評価
+    fileId: text('file_id').notNull(), // アップロードファイルのID
+    fileName: text('file_name').notNull(), // ファイル名
+    evaluation: text('evaluation').notNull(), // A, B, C, - 評価
     comment: text('comment'), // レビューコメント
     createdAt: text('created_at')
       .notNull()
@@ -105,7 +104,7 @@ export const reviewChecklistSources = sqliteTable(
       .default(sql`(current_timestamp)`)
       .$onUpdate(() => sql`(current_timestamp)`),
   },
-  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.sourceId] })],
+  (t) => [primaryKey({ columns: [t.reviewChecklistId, t.fileId] })],
 );
 
 // 型定義
@@ -117,6 +116,6 @@ export type ReviewHistory = typeof reviewHistories.$inferSelect;
 export type InsertReviewHistory = typeof reviewHistories.$inferInsert;
 export type ReviewChecklist = typeof reviewChecklists.$inferSelect;
 export type InsertReviewChecklist = typeof reviewChecklists.$inferInsert;
-export type ReviewChecklistSource = typeof reviewChecklistSources.$inferSelect;
-export type InsertReviewChecklistSource =
-  typeof reviewChecklistSources.$inferInsert;
+export type ReviewChecklistResult = typeof reviewChecklistResults.$inferSelect;
+export type InsertReviewChecklistResult =
+  typeof reviewChecklistResults.$inferInsert;
diff --git a/src/main/main.ts b/src/main/main.ts
index 5c5b21191..c53dd98e2 100644
--- a/src/main/main.ts
+++ b/src/main/main.ts
@@ -10,7 +10,14 @@
  */
 import path from 'path';
 import fs from 'fs/promises';
-import { app, BrowserWindow, shell, ipcMain, crashReporter } from 'electron';
+import {
+  app,
+  BrowserWindow,
+  shell,
+  ipcMain,
+  crashReporter,
+  dialog,
+} from 'electron';
 import { autoUpdater } from 'electron-updater';
 import log from 'electron-log';
 import { createDataStream, APICallError } from 'ai';
@@ -450,6 +457,43 @@ const setupFsHandlers = () => {
       }
     },
   );
+
+  ipcMain.handle(
+    IpcChannels.FS_SHOW_OPEN_DIALOG,
+    async (
+      _,
+      options: {
+        title: string;
+        filters?: { name: string; extensions: string[] }[];
+        properties?: (
+          | 'openFile'
+          | 'openDirectory'
+          | 'multiSelections'
+          | 'showHiddenFiles'
+          | 'createDirectory'
+          | 'promptToCreate'
+          | 'noResolveAliases'
+          | 'treatPackageAsDirectory'
+          | 'dontAddToRecent'
+        )[];
+      },
+    ) => {
+      const result = await dialog.showOpenDialog(options);
+      return result;
+    },
+  );
+  ipcMain.handle(
+    IpcChannels.FS_READ_FILE,
+    async (_, filePath: string): Promise<Uint8Array> => {
+      try {
+        const data = await fs.readFile(filePath);
+        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
+      } catch (error) {
+        console.error('ファイルの読み込み中にエラーが発生:', error);
+        throw error;
+      }
+    },
+  );
 };
 
 const setupSourceHandlers = () => {
@@ -610,7 +654,7 @@ const setupReviewHandlers = () => {
       event,
       {
         reviewHistoryId,
-        sourceIds,
+        files,
         documentType,
         checklistRequirements,
       }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL],
@@ -623,7 +667,7 @@ const setupReviewHandlers = () => {
         // 非同期でチェックリスト抽出処理を実行
         const result = manager.extractChecklistWithNotification(
           reviewHistoryId,
-          sourceIds,
+          files,
           event,
           documentType,
           checklistRequirements,
@@ -676,7 +720,7 @@ const setupReviewHandlers = () => {
       event,
       {
         reviewHistoryId,
-        sourceIds,
+        files,
       }: IpcRequestPayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL],
     ): Promise<
       IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL]
@@ -685,11 +729,7 @@ const setupReviewHandlers = () => {
         const manager = SourceReviewManager.getInstance();
 
         // 非同期でレビュー実行処理を実行
-        manager.executeReviewWithNotification(
-          reviewHistoryId,
-          sourceIds,
-          event,
-        );
+        manager.executeReviewWithNotification(reviewHistoryId, files, event);
 
         return { success: true };
       } catch (error) {
diff --git a/src/main/preload.ts b/src/main/preload.ts
index 19b3eef1f..07577d2d7 100644
--- a/src/main/preload.ts
+++ b/src/main/preload.ts
@@ -37,6 +37,16 @@ const electronHandler = {
     access: async (path: string): Promise<boolean> => {
       return ipcRenderer.invoke(IpcChannels.FS_CHECK_PATH_EXISTS, path);
     },
+    showOpenDialog: async (options: {
+      title: string;
+      filters?: { name: string; extensions: string[] }[];
+      properties?: string[];
+    }) => {
+      return ipcRenderer.invoke(IpcChannels.FS_SHOW_OPEN_DIALOG, options);
+    },
+    readFile: async (filePath: string): Promise<Uint8Array> => {
+      return ipcRenderer.invoke(IpcChannels.FS_READ_FILE, filePath);
+    },
   },
   store: {
     get: async (
diff --git a/src/main/types/index.ts b/src/main/types/index.ts
index a8fd2fc07..f80cd09de 100644
--- a/src/main/types/index.ts
+++ b/src/main/types/index.ts
@@ -55,12 +55,12 @@ export type ReviewEvaluation = 'A' | 'B' | 'C' | '-';
 export type ReviewChecklistCreatedBy = 'user' | 'system';
 
 // 最終的に画面に表示するチェックリストの型
-export type ReviewChecklistResult = {
+export type ReviewChecklistResultDisplay = {
   id: number; // チェックリストのID
   content: string;
   sourceEvaluations?: {
-    sourceId: number;
-    sourceFileName: string;
+    fileId: string;
+    fileName: string;
     evaluation?: ReviewEvaluation;
     comment?: string;
   }[];
diff --git a/src/main/types/ipc.ts b/src/main/types/ipc.ts
index b85808772..b1d631fc5 100644
--- a/src/main/types/ipc.ts
+++ b/src/main/types/ipc.ts
@@ -2,11 +2,14 @@ import type {
   ChatMessage,
   ChatRoom,
   SettingsSavingStatus,
-  ReviewChecklistResult,
+  ReviewChecklistResultDisplay,
   ReviewChecklistEdit,
 } from '.';
 import type { Source, ReviewHistory } from '../../db/schema';
-import type { DocumentType } from '../../renderer/components/review/types';
+import type {
+  DocumentType,
+  UploadFile,
+} from '../../renderer/components/review/types';
 
 /**
  * IPC通信で使用するチャネル名の定義
@@ -43,6 +46,8 @@ export const IpcChannels = {
 
   // ファイルシステム関連
   FS_CHECK_PATH_EXISTS: 'fs-check-path-exists',
+  FS_SHOW_OPEN_DIALOG: 'fs-show-open-dialog',
+  FS_READ_FILE: 'fs-read-file',
 
   // ドキュメントレビュー関連
   REVIEW_GET_HISTORIES: 'review-get-histories', // ドキュメント履歴切り替え時やチェックリスト抽出・ドキュメントレビュー時のポーリング処理にて呼び出される
@@ -68,6 +73,12 @@ export type IpcRequestPayloadMap = {
 
   // ファイルシステム関連
   [IpcChannels.FS_CHECK_PATH_EXISTS]: string;
+  [IpcChannels.FS_SHOW_OPEN_DIALOG]: {
+    title: string;
+    filters?: { name: string; extensions: string[] }[];
+    properties?: string[];
+  };
+  [IpcChannels.FS_READ_FILE]: string; // file path
 
   // ストア関連
   [IpcChannels.GET_STORE_VALUE]: string;
@@ -99,7 +110,7 @@ export type IpcRequestPayloadMap = {
   [IpcChannels.REVIEW_DELETE_HISTORY]: string; // review history id
   [IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]: {
     reviewHistoryId: string;
-    sourceIds: number[];
+    files: UploadFile[];
     documentType?: DocumentType;
     checklistRequirements?: string;
   };
@@ -109,7 +120,7 @@ export type IpcRequestPayloadMap = {
   };
   [IpcChannels.REVIEW_EXECUTE_CALL]: {
     reviewHistoryId: string;
-    sourceIds: number[];
+    files: UploadFile[];
   };
 };
 
@@ -121,6 +132,11 @@ export type IpcResponsePayloadMap = {
 
   // ファイルシステム関連
   [IpcChannels.FS_CHECK_PATH_EXISTS]: boolean;
+  [IpcChannels.FS_SHOW_OPEN_DIALOG]: {
+    filePaths: string[];
+    canceled: boolean;
+  };
+  [IpcChannels.FS_READ_FILE]: Uint8Array; // ファイルのバイナリデータ
 
   // ストア関連
   [IpcChannels.GET_STORE_VALUE]: unknown;
@@ -155,7 +171,7 @@ export type IpcResponsePayloadMap = {
   };
   [IpcChannels.REVIEW_GET_HISTORY_DETAIL]: {
     success: boolean;
-    checklistResults?: ReviewChecklistResult[];
+    checklistResults?: ReviewChecklistResultDisplay[];
     error?: string;
   };
   [IpcChannels.REVIEW_DELETE_HISTORY]: { success: boolean; error?: string };
diff --git a/src/mastra/workflows/libs.ts b/src/mastra/workflows/libs.ts
index fd9bcbc23..f7d235093 100644
--- a/src/mastra/workflows/libs.ts
+++ b/src/mastra/workflows/libs.ts
@@ -21,6 +21,13 @@ export function checkStatus(result: WorkflowResult<any, any>): {
     };
   }
 
+  // ネストワークフロー使ってない場合
+  if (!result.result || !Array.isArray(result.result)) {
+    const value = result.result as z.infer<typeof baseStepOutputSchema>;
+    return value;
+  }
+
+  // ネストワークフローを使っている場合
   // Object.valuesでオブジェクトの値だけを配列として取り出す
   const values = Object.values(result.result);
 
diff --git a/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts b/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
index ec5215f71..7144a779a 100644
--- a/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
+++ b/src/mastra/workflows/sourceRegistration/sourceRegistrationManager.ts
@@ -164,6 +164,7 @@ export default class SourceRegistrationManager {
               });
 
               // 結果を確認
+              console.log('apply checkStatus', JSON.stringify(result));
               const checkResult = checkStatus(result);
 
               resultList.push({
diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
index 064a45609..037a84b77 100644
--- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
@@ -3,10 +3,8 @@ import { APICallError, NoObjectGeneratedError } from 'ai';
 import { createStep, createWorkflow } from '@mastra/core/workflows';
 import { MastraError } from '@mastra/core/error';
 import { z } from 'zod';
-import path from 'path';
 import { getReviewRepository } from '../../../db/repository/reviewRepository';
 import { getSourceRepository } from '../../../db/repository/sourceRepository';
-import { Source } from '../../../db/schema';
 import FileExtractor from '../../../main/utils/fileExtractor';
 import { baseStepOutputSchema } from '../schema';
 import { stepStatus } from '../types';
@@ -16,13 +14,24 @@ import {
   TopicChecklistAgentRuntimeContext,
 } from '../../agents/workflowAgents';
 import { createRuntimeContext } from '../../agents/lib';
+import { UploadFile } from '../../../renderer/components/review/types';
 
 // ワークフローの入力スキーマ
 const triggerSchema = z.object({
   reviewHistoryId: z.string().describe('レビュー履歴ID'),
-  sourceIds: z
-    .array(z.number())
-    .describe('チェックリストを抽出するソースのIDリスト'),
+  files: z
+    .array(
+      z.object({
+        id: z.string(),
+        name: z.string(),
+        path: z.string(),
+        type: z.string(),
+        pdfProcessMode: z.enum(['text', 'image']).optional(),
+        pdfImageMode: z.enum(['merged', 'pages']).optional(),
+        imageData: z.array(z.string()).optional(),
+      }),
+    )
+    .describe('アップロードファイルのリスト'),
   documentType: z
     .enum(['checklist', 'general'])
     .default('checklist')
@@ -46,7 +55,8 @@ const topicExtractionStepOutputSchema = baseStepOutputSchema.extend({
     .array(
       z.object({
         title: z.string(),
-        sourceId: z.number(),
+        file: triggerSchema.shape.files.element,
+        content: z.string().optional(),
       }),
     )
     .optional(),
@@ -72,7 +82,7 @@ const checklistDocumentExtractionStep = createStep({
     const reviewRepository = getReviewRepository();
     const sourceRepository = getSourceRepository();
     // トリガーから入力を取得
-    const { reviewHistoryId, sourceIds, documentType } = inputData;
+    const { reviewHistoryId, files } = inputData;
     const errorMessages: string[] = [
       'チェックリスト抽出処理中に以下エラーが発生しました',
     ];
@@ -81,19 +91,9 @@ const checklistDocumentExtractionStep = createStep({
       // 既存のシステム作成チェックリストを削除
       await reviewRepository.deleteSystemCreatedChecklists(reviewHistoryId);
 
-      // 各ソースを並行して処理
-      const extractionPromises = sourceIds.map(async (sourceId) => {
-        let source: Source | null = null;
+      // 各ファイルを並行して処理
+      const extractionPromises = files.map(async (file: UploadFile) => {
         try {
-          source = await sourceRepository.getSourceById(sourceId);
-
-          if (source === null) {
-            throw new Error(`ドキュメントID ${sourceId} が見つかりません`);
-          }
-
-          // ファイル内容を抽出
-          const { content } = await FileExtractor.extractText(source.path);
-
           const checklistExtractionAgent = mastra.getAgent(
             'checklistExtractionAgent',
           );
@@ -109,6 +109,60 @@ const checklistDocumentExtractionStep = createStep({
           // これまでに抽出したチェックリスト項目を蓄積する配列
           const accumulated: string[] = [];
 
+          let message;
+
+          // PDFで画像として処理する場合
+          if (
+            file.type === 'application/pdf' &&
+            file.pdfProcessMode === 'image' &&
+            file.imageData &&
+            file.imageData.length > 0
+          ) {
+            if (file.imageData.length > 1) {
+              // ページ別画像モード: すべてのページを含むメッセージを作成
+              const imageMessage = {
+                role: 'user' as const,
+                content: [
+                  {
+                    type: 'text' as const,
+                    text: `Please extract checklist items from this document: ${file.name} (All ${file.imageData.length} pages)`,
+                  },
+                  // すべてのページ画像を含める
+                  ...file.imageData.map((imageData) => ({
+                    type: 'image' as const,
+                    image: imageData,
+                    mimeType: 'image/png',
+                  })),
+                ],
+              };
+
+              message = imageMessage;
+            } else {
+              // 統合画像モード: 単一メッセージ
+              const imageMessage = {
+                role: 'user' as const,
+                content: [
+                  {
+                    type: 'text' as const,
+                    text: `Please extract checklist items from this document: ${file.name}`,
+                  },
+                  {
+                    type: 'image' as const,
+                    image: file.imageData[0],
+                    mimeType: 'image/png',
+                  },
+                ],
+              };
+
+              message = imageMessage;
+            }
+            // 画像化PDF以外はテキスト抽出処理
+          } else {
+            // テキスト抽出処理
+            const { content } = await FileExtractor.extractText(file.path);
+            message = content;
+          }
+
           // 最大試行回数
           const MAX_ATTEMPTS = 5;
           let attempts = 0;
@@ -120,7 +174,7 @@ const checklistDocumentExtractionStep = createStep({
             // これまでに抽出したチェックリスト項目
             runtimeContext.set('extractedItems', accumulated);
             const extractionResult = await checklistExtractionAgent.generate(
-              content,
+              message,
               {
                 output: outputSchema,
                 runtimeContext,
@@ -182,9 +236,10 @@ const checklistDocumentExtractionStep = createStep({
             }
 
             // 抽出されたチェックリストから新規のものを蓄積
-            const newChecklists = extractionResult.object.newChecklists.filter(
-              (item) => !accumulated.includes(item),
-            );
+            const newChecklists =
+              extractionResult.object.newChecklists?.filter(
+                (item: string) => !accumulated.includes(item),
+              ) || [];
             accumulated.push(...newChecklists);
 
             // 抽出されたチェックリストをDBに保存
@@ -229,11 +284,7 @@ const checklistDocumentExtractionStep = createStep({
           } else {
             errorDetail = JSON.stringify(error);
           }
-          if (source) {
-            errorMessage += `- ${path.basename(source.path)}のチェックリスト抽出でエラー: ${errorDetail}`;
-          } else {
-            errorMessage += `- チェックリスト抽出処理でエラーが発生しました: ${errorDetail}`;
-          }
+          errorMessage += `- ${file.name}のチェックリスト抽出でエラー: ${errorDetail}`;
           errorMessages.push(errorMessage);
         }
       });
@@ -276,9 +327,8 @@ const topicExtractionStep = createStep({
   inputSchema: triggerSchema,
   outputSchema: topicExtractionStepOutputSchema,
   execute: async ({ inputData, mastra, bail }) => {
-    const sourceRepository = getSourceRepository();
     const reviewRepository = getReviewRepository();
-    const { sourceIds, reviewHistoryId, checklistRequirements } = inputData;
+    const { files, reviewHistoryId, checklistRequirements } = inputData;
     const errorMessages: string[] = [
       'チェックリスト作成処理中にエラーが発生しました',
     ];
@@ -286,22 +336,66 @@ const topicExtractionStep = createStep({
     try {
       const allTopics: Array<{
         title: string;
-        sourceId: number;
+        file: z.infer<typeof triggerSchema.shape.files.element>;
+        content?: string;
       }> = [];
 
-      // 各ソースからトピックを抽出
-      const extractionPromises = sourceIds.map(async (sourceId) => {
-        let source: Source | null = null;
+      // 各ファイルからトピックを抽出
+      const extractionPromises = files.map(async (file: UploadFile) => {
         try {
-          source = await sourceRepository.getSourceById(sourceId);
+          let message;
+          let outputContent: string | undefined = undefined;
 
-          if (source === null) {
-            throw new Error(`ソースID ${sourceId} が見つかりません`);
+          // PDFで画像として処理する場合
+          if (
+            file.type === 'application/pdf' &&
+            file.pdfProcessMode === 'image' &&
+            file.imageData &&
+            file.imageData.length > 0
+          ) {
+            if (file.imageData.length > 1) {
+              // ページ別画像モード: すべてのページを含むメッセージを作成
+              const imageMessage = {
+                role: 'user' as const,
+                content: [
+                  {
+                    type: 'text' as const,
+                    text: `Please extract topics from this document: ${file.name} (All ${file.imageData.length} pages)`,
+                  },
+                  // すべてのページ画像を含める
+                  ...file.imageData.map((imageData) => ({
+                    type: 'image' as const,
+                    image: imageData,
+                    mimeType: 'image/png',
+                  })),
+                ],
+              };
+              message = imageMessage;
+            } else {
+              // 統合画像モード: 単一メッセージ
+              const imageMessage = {
+                role: 'user' as const,
+                content: [
+                  {
+                    type: 'text' as const,
+                    text: `Please extract topics from this document: ${file.name}`,
+                  },
+                  {
+                    type: 'image' as const,
+                    image: file.imageData[0],
+                    mimeType: 'image/png',
+                  },
+                ],
+              };
+              message = imageMessage;
+            }
+          } else {
+            // テキスト抽出処理
+            const { content } = await FileExtractor.extractText(file.path);
+            message = content;
+            outputContent = content;
           }
 
-          // ファイル内容を抽出
-          const { content } = await FileExtractor.extractText(source.path);
-
           const topicExtractionAgent = mastra.getAgent('topicExtractionAgent');
           const outputSchema = z.object({
             topics: z
@@ -324,7 +418,7 @@ const topicExtractionStep = createStep({
           }
 
           const extractionResult = await topicExtractionAgent.generate(
-            content,
+            message,
             {
               output: outputSchema,
               runtimeContext,
@@ -334,14 +428,15 @@ const topicExtractionStep = createStep({
           mastra
             .getLogger()
             .debug(
-              `document(id:${sourceId}) extracted topics for creating checklist:`,
+              `document(${file.name}) extracted topics for creating checklist:`,
               JSON.stringify(extractionResult.object.topics, null, 2),
             );
 
           allTopics.push(
             ...extractionResult.object.topics.map((t) => ({
               title: t.topic,
-              sourceId,
+              file,
+              content: outputContent,
             })),
           );
         } catch (error) {
@@ -351,15 +446,9 @@ const topicExtractionStep = createStep({
           } else {
             errorDetail = JSON.stringify(error);
           }
-          if (source) {
-            errorMessages.push(
-              `- ${path.basename(source.path)}のトピック抽出でエラー: ${errorDetail}`,
-            );
-          } else {
-            errorMessages.push(
-              `- トピック抽出処理でエラーが発生しました: ${errorDetail}`,
-            );
-          }
+          errorMessages.push(
+            `- ${file.name}のトピック抽出でエラー: ${errorDetail}`,
+          );
         }
       });
 
@@ -408,27 +497,71 @@ const topicChecklistCreationStep = createStep({
   description: 'トピックに基づいてチェックリスト項目を作成するステップ',
   inputSchema: z.object({
     title: z.string(),
-    sourceId: z.number(),
+    file: triggerSchema.shape.files.element,
+    content: z.string().optional(),
     reviewHistoryId: z.string(),
     checklistRequirements: z.string().optional(),
   }),
   outputSchema: topicChecklistStepOutputSchema,
   execute: async ({ inputData, mastra, bail }) => {
-    const { title, sourceId, reviewHistoryId, checklistRequirements } =
+    const { title, file, content, reviewHistoryId, checklistRequirements } =
       inputData;
-    const sourceRepository = getSourceRepository();
     const reviewRepository = getReviewRepository();
     const errorMessages: string[] = [
       'チェックリスト作成処理中にエラーが発生しました',
     ];
 
     try {
-      const source = await sourceRepository.getSourceById(sourceId);
-      if (source === null) {
-        throw new Error(`ドキュメントID ${sourceId} が見つかりません`);
+      let message;
+
+      // PDFで画像として処理する場合
+      if (
+        file.type === 'application/pdf' &&
+        file.pdfProcessMode === 'image' &&
+        file.imageData &&
+        file.imageData.length > 0
+      ) {
+        if (file.imageData.length > 1) {
+          // ページ別画像モードの場合、すべてのページを統合したメッセージを作成
+          // (このステップでは特定のトピックに基づいてチェックリスト作成するため、全ページを含める)
+          const imageMessage = {
+            role: 'user' as const,
+            content: [
+              {
+                type: 'text' as const,
+                text: `Please create checklist items from this document: ${file.name} (All ${file.imageData.length} pages) for topic: ${title}`,
+              },
+              // すべてのページ画像を含める
+              ...file.imageData.map((imageData) => ({
+                type: 'image' as const,
+                image: imageData,
+                mimeType: 'image/png',
+              })),
+            ],
+          };
+          message = imageMessage;
+        } else {
+          // 統合画像モード: 単一メッセージ
+          const imageMessage = {
+            role: 'user' as const,
+            content: [
+              {
+                type: 'text' as const,
+                text: `Please create checklist items from this document: ${file.name}`,
+              },
+              {
+                type: 'image' as const,
+                image: file.imageData[0],
+                mimeType: 'image/png',
+              },
+            ],
+          };
+          message = imageMessage;
+        }
+      } else {
+        // テキスト抽出処理
+        message = content!;
       }
-      // ファイル内容を抽出
-      const { content } = await FileExtractor.extractText(source.path);
       const topicChecklistAgent = mastra.getAgent('topicChecklistAgent');
       const outputSchema = z.object({
         checklistItems: z
@@ -454,14 +587,14 @@ const topicChecklistCreationStep = createStep({
         runtimeContext.set('checklistRequirements', checklistRequirements);
       }
 
-      const result = await topicChecklistAgent.generate(content, {
+      const result = await topicChecklistAgent.generate(message, {
         output: outputSchema,
         runtimeContext,
       });
       mastra
         .getLogger()
         .debug(
-          `document(id:${sourceId}) topic(${title}) generated checklist items:`,
+          `document(${file.name}) topic(${title}) generated checklist items:`,
           JSON.stringify(result.object.checklistItems, null, 2),
         );
 
@@ -486,7 +619,9 @@ const topicChecklistCreationStep = createStep({
 
       return {
         status: 'success' as stepStatus,
-        checklistItems: result.object.checklistItems,
+        checklistItems: result.object.checklistItems.map(
+          (item) => item.checklistItem,
+        ),
       };
     } catch (error) {
       if (error instanceof Error && error.message) {
@@ -600,6 +735,7 @@ export const checklistExtractionWorkflow = createWorkflow({
           const topicResult = getStepResult(topicExtractionStep);
           const initData = getInitData();
 
+          // 前ステップでエラーの場合はbailで早期終了させているため、ここに来るのは成功時のみの想定
           if (topicResult?.status !== 'success' || !topicResult.topics) {
             throw new Error(
               topicResult?.errorMessage || 'トピック抽出に失敗しました',
@@ -608,7 +744,8 @@ export const checklistExtractionWorkflow = createWorkflow({
 
           return topicResult.topics.map((topic) => ({
             title: topic.title,
-            sourceId: topic.sourceId,
+            file: topic.file,
+            content: topic.content,
             reviewHistoryId: initData.reviewHistoryId,
             checklistRequirements: initData.checklistRequirements,
           }));
diff --git a/src/mastra/workflows/sourceReview/reviewExecution.ts b/src/mastra/workflows/sourceReview/reviewExecution.ts
index 7cc87b9b6..5391c525a 100644
--- a/src/mastra/workflows/sourceReview/reviewExecution.ts
+++ b/src/mastra/workflows/sourceReview/reviewExecution.ts
@@ -2,9 +2,7 @@ import { APICallError, NoObjectGeneratedError } from 'ai';
 import { createWorkflow, createStep } from '@mastra/core/workflows';
 import { MastraError } from '@mastra/core/error';
 import { z } from 'zod';
-import path from 'path';
 import { getReviewRepository } from '../../../db/repository/reviewRepository';
-import { getSourceRepository } from '../../../db/repository/sourceRepository';
 import FileExtractor from '../../../main/utils/fileExtractor';
 import type { ReviewEvaluation } from '../../../main/types';
 import { baseStepOutputSchema } from '../schema';
@@ -17,9 +15,9 @@ import {
 import { createRuntimeContext, judgeFinishReason } from '../../agents/lib';
 
 // 一つのカテゴリに含めるチェックリストの最大数
-const MAX_CHECKLISTS_PER_CATEGORY = 7;
+const MAX_CHECKLISTS_PER_CATEGORY = 3;
 // 分割カテゴリの最大数
-const MAX_CATEGORIES = 10;
+const MAX_CATEGORIES = 20;
 
 // カテゴリ分類ステップの出力スキーマ
 const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
@@ -41,7 +39,19 @@ const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
 // ワークフローの入力スキーマ
 const triggerSchema = z.object({
   reviewHistoryId: z.string().describe('レビュー履歴ID'),
-  sourceIds: z.array(z.number()).describe('レビュー対象ソースのIDリスト'),
+  files: z
+    .array(
+      z.object({
+        id: z.string(),
+        name: z.string(),
+        path: z.string(),
+        type: z.string(),
+        pdfProcessMode: z.enum(['text', 'image']).optional(),
+        pdfImageMode: z.enum(['merged', 'pages']).optional(),
+        imageData: z.array(z.string()).optional(),
+      }),
+    )
+    .describe('アップロードファイルのリスト'),
 });
 
 // ステップ1: チェックリストをカテゴリごとに分類
@@ -203,8 +213,8 @@ const reviewExecutionStep = createStep({
   inputSchema: classifyChecklistsByCategoryOutputSchema,
   outputSchema: baseStepOutputSchema,
   execute: async ({ inputData, getInitData, mastra }) => {
-    // レビュー対象のソースID
-    const { sourceIds } = getInitData() as z.infer<typeof triggerSchema>;
+    // レビュー対象のファイル
+    const { files } = getInitData() as z.infer<typeof triggerSchema>;
     // ステップ1からの入力を取得
     const { categories } = inputData;
 
@@ -218,7 +228,6 @@ const reviewExecutionStep = createStep({
 
     // リポジトリを取得
     const reviewRepository = getReviewRepository();
-    const sourceRepository = getSourceRepository();
 
     // チェックリストを全量チェックできなかったドキュメントを格納
     // key: ファイル名, value: エラー内容
@@ -227,15 +236,59 @@ const reviewExecutionStep = createStep({
     try {
       const reviewAgent = mastra.getAgent('reviewExecuteAgent');
 
-      // 各カテゴリ、ソースごとにレビューを実行
+      // 各カテゴリ、ファイルごとにレビューを実行
       for (const category of categories!) {
-        for (const sourceId of sourceIds) {
-          // ソースの内容を取得
-          const source = await sourceRepository.getSourceById(sourceId);
-          if (!source) {
-            throw new Error(`ソースID ${sourceId} が見つかりません`);
+        for (const file of files) {
+          // ファイルの内容を取得（画像またはテキスト）
+          let message;
+
+          if (
+            file.type === 'application/pdf' &&
+            file.pdfProcessMode === 'image' &&
+            file.imageData &&
+            file.imageData.length > 0
+          ) {
+            if (file.imageData.length > 1) {
+              // ページ別画像モード: すべてのページを含むメッセージを作成
+              const imageMessage = {
+                role: 'user' as const,
+                content: [
+                  {
+                    type: 'text' as const,
+                    text: `Please review this document against the provided checklist items: ${file.name} (All ${file.imageData.length} pages)`,
+                  },
+                  // すべてのページ画像を含める
+                  ...file.imageData.map((imageData) => ({
+                    type: 'image' as const,
+                    image: imageData,
+                    mimeType: 'image/png',
+                  })),
+                ],
+              };
+              message = imageMessage;
+            } else {
+              // 統合画像モード: 単一メッセージ
+              const imageMessage = {
+                role: 'user' as const,
+                content: [
+                  {
+                    type: 'text' as const,
+                    text: `Please review this document against the provided checklist items: ${file.name}`,
+                  },
+                  {
+                    type: 'image' as const,
+                    image: file.imageData[0],
+                    mimeType: 'image/png',
+                  },
+                ],
+              };
+              message = imageMessage;
+            }
+          } else {
+            // テキスト抽出
+            const { content } = await FileExtractor.extractText(file.path);
+            message = content;
           }
-          const { content } = await FileExtractor.extractText(source.path);
           // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
           // レビュー結果に含まれなかったチェックリストは再度レビューを実行する（最大試行回数は3回）
           const maxAttempts = 3;
@@ -246,17 +299,17 @@ const reviewExecutionStep = createStep({
               const outputSchema = z.array(
                 z.object({
                   checklistId: z.number(),
+                  comment: z.string().describe('evaluation comment'),
                   evaluation: z
                     .enum(['A', 'B', 'C', '-'])
                     .describe('evaluation'),
-                  comment: z.string().describe('evaluation comment'),
                 }),
               );
               const runtimeContext =
                 createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
               runtimeContext.set('checklistItems', reviewTargetChecklists);
               // レビューエージェントを使用してレビューを実行
-              const reviewResult = await reviewAgent.generate(content, {
+              const reviewResult = await reviewAgent.generate(message, {
                 output: outputSchema,
                 runtimeContext,
               });
@@ -267,17 +320,22 @@ const reviewExecutionStep = createStep({
                 throw new Error(reason);
               }
               // レビュー結果をDBに保存
-              await reviewRepository.upsertReviewResult(
-                reviewResult.object.map((result) => ({
-                  reviewChecklistId: result.checklistId,
-                  sourceId,
-                  evaluation: result.evaluation as ReviewEvaluation,
-                  comment: result.comment,
-                })),
-              );
+              if (reviewResult.object && Array.isArray(reviewResult.object)) {
+                await reviewRepository.upsertReviewResult(
+                  reviewResult.object.map((result) => ({
+                    reviewChecklistId: result.checklistId,
+                    evaluation: result.evaluation as ReviewEvaluation,
+                    comment: result.comment,
+                    fileId: file.id,
+                    fileName: file.name,
+                  })),
+                );
+              }
               // レビュー結果に含まれなかったチェックリストを抽出
               const reviewedChecklistIds = new Set(
-                reviewResult.object.map((result) => result.checklistId),
+                reviewResult.object && Array.isArray(reviewResult.object)
+                  ? reviewResult.object.map((result) => result.checklistId)
+                  : [],
               );
               reviewTargetChecklists = reviewTargetChecklists.filter(
                 (checklist) => !reviewedChecklistIds.has(checklist.id),
@@ -309,21 +367,21 @@ const reviewExecutionStep = createStep({
                 errorDetail = JSON.stringify(error);
               }
               // レビューに失敗したチェックリストを記録
-              if (!errorDocuments.has(path.basename(source.path))) {
-                errorDocuments.set(path.basename(source.path), []);
+              if (!errorDocuments.has(file.name)) {
+                errorDocuments.set(file.name, []);
               }
-              errorDocuments.get(path.basename(source.path))!.push(errorDetail);
+              errorDocuments.get(file.name)!.push(errorDetail);
             } finally {
               attempt += 1;
             }
           }
           if (attempt >= maxAttempts) {
             // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
-            if (!errorDocuments.has(path.basename(source.path))) {
-              errorDocuments.set(path.basename(source.path), []);
+            if (!errorDocuments.has(file.name)) {
+              errorDocuments.set(file.name, []);
             }
             errorDocuments
-              .get(path.basename(source.path))!
+              .get(file.name)!
               .push(
                 `全てのチェックリストに対してレビューを完了することができませんでした`,
               );
diff --git a/src/mastra/workflows/sourceReview/sourceReviewManager.ts b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
index 79800bd46..36565d581 100644
--- a/src/mastra/workflows/sourceReview/sourceReviewManager.ts
+++ b/src/mastra/workflows/sourceReview/sourceReviewManager.ts
@@ -9,7 +9,10 @@ import {
 import { generateReviewTitle } from './lib';
 import { ReviewHistory } from '../../../db/schema';
 import { mastra } from '../..';
-import { DocumentType } from '../../../renderer/components/review/types';
+import {
+  DocumentType,
+  UploadFile,
+} from '../../../renderer/components/review/types';
 import { checkStatus } from '../libs';
 
 /**
@@ -21,8 +24,6 @@ export default class SourceReviewManager {
 
   private reviewRepository = getReviewRepository();
 
-  private sourceRepository = getSourceRepository();
-
   /**
    * シングルトンインスタンスを取得
    */
@@ -34,14 +35,14 @@ export default class SourceReviewManager {
   }
 
   /**
-   * チェックリスト抽出処理を実行
+   * アップロードファイルからチェックリスト抽出処理を実行
    * @param reviewHistoryId レビュー履歴ID（新規の場合は生成）
-   * @param sourceIds ソースIDの配列
+   * @param files アップロードファイルの配列
    * @returns 処理結果
    */
   public async extractChecklist(
     reviewHistoryId: string,
-    sourceIds: number[],
+    files: UploadFile[],
     documentType: DocumentType = 'checklist',
     checklistRequirements?: string,
   ): Promise<{ success: boolean; error?: string }> {
@@ -76,7 +77,7 @@ export default class SourceReviewManager {
       const runResult = await run.start({
         inputData: {
           reviewHistoryId,
-          sourceIds,
+          files,
           documentType,
           checklistRequirements,
         },
@@ -99,14 +100,14 @@ export default class SourceReviewManager {
   }
 
   /**
-   * レビュー実行処理を実行
+   * アップロードファイルからレビュー実行処理を実行
    * @param reviewHistoryId レビュー履歴ID
-   * @param sourceIds ソースIDの配列
+   * @param files アップロードファイルの配列
    * @returns 処理結果
    */
   public async executeReview(
     reviewHistoryId: string,
-    sourceIds: number[],
+    files: UploadFile[],
   ): Promise<{ success: boolean; error?: string }> {
     try {
       // レビュー履歴の存在確認
@@ -130,9 +131,8 @@ export default class SourceReviewManager {
       }
 
       // タイトルの変更
-      // 全てのソースを取得
-      const sources = await this.sourceRepository.getSourcesByIds(sourceIds);
-      const reviewTitle = generateReviewTitle(sources.map((s) => s.title));
+      const fileNames = files.map((f) => f.name.replace(/\.[^/.]+$/, '')); // 拡張子を除いたファイル名
+      const reviewTitle = generateReviewTitle(fileNames);
       // レビュー履歴のタイトルを更新
       await this.reviewRepository.updateReviewHistoryTitle(
         reviewHistory.id,
@@ -143,7 +143,7 @@ export default class SourceReviewManager {
       const result = await run.start({
         inputData: {
           reviewHistoryId,
-          sourceIds,
+          files,
         },
       });
       // 結果を確認
@@ -170,13 +170,18 @@ export default class SourceReviewManager {
    */
   public extractChecklistWithNotification(
     reviewHistoryId: string,
-    sourceIds: number[],
+    files: UploadFile[],
     event: IpcMainInvokeEvent,
     documentType: DocumentType = 'checklist',
     checklistRequirements?: string,
   ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL] {
     try {
-      this.extractChecklist(reviewHistoryId, sourceIds, documentType, checklistRequirements)
+      this.extractChecklist(
+        reviewHistoryId,
+        files,
+        documentType,
+        checklistRequirements,
+      )
         .then((res) => {
           // 完了イベントを送信
           event.sender.send(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
@@ -225,11 +230,11 @@ export default class SourceReviewManager {
    */
   public executeReviewWithNotification(
     reviewHistoryId: string,
-    sourceIds: number[],
+    files: UploadFile[],
     event: IpcMainInvokeEvent,
   ): IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL] {
     try {
-      this.executeReview(reviewHistoryId, sourceIds)
+      this.executeReview(reviewHistoryId, files)
         .then((res) => {
           // 完了イベントを送信
           event.sender.send(IpcChannels.REVIEW_EXECUTE_FINISHED, {
diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
index 56bf1fbde..c29e765f8 100644
--- a/src/renderer/components/review/ReviewArea.tsx
+++ b/src/renderer/components/review/ReviewArea.tsx
@@ -10,12 +10,12 @@ import {
 import CheckBoxIcon from '@mui/icons-material/CheckBox';
 import RateReviewIcon from '@mui/icons-material/RateReview';
 import { v4 as uuid } from 'uuid';
-import { ReviewAreaProps, ModalMode, DocumentType } from './types';
+import { ReviewAreaProps, ModalMode, DocumentType, UploadFile } from './types';
 import ReviewChecklistSection from './ReviewChecklistSection';
 import ReviewSourceModal from './ReviewSourceModal';
 import {
   ReviewChecklistEdit,
-  ReviewChecklistResult,
+  ReviewChecklistResultDisplay,
 } from '../../../main/types';
 import AlertManager, { AlertMessage } from '../common/AlertMessage';
 import { reviewService } from '../../services/reviewService';
@@ -23,7 +23,7 @@ import { reviewService } from '../../services/reviewService';
 const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   // 状態管理
   const [checklistResults, setChecklistResults] = useState<
-    ReviewChecklistResult[]
+    ReviewChecklistResultDisplay[]
   >([]);
   // チェックリスト更新処理中であるかどうか
   const [isSaving, setIsSaving] = useState(false);
@@ -78,7 +78,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
   // チェックリストの抽出処理
   const handleExtractChecklist = useCallback(
     async (
-      sourceIds: number[],
+      files: UploadFile[],
       documentType?: DocumentType,
       checklistRequirements?: string,
     ) => {
@@ -91,7 +91,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
         // チェックリスト抽出処理を開始
         const result = await window.electron.review.extractChecklist({
           reviewHistoryId: selectedReviewHistoryId,
-          sourceIds,
+          files,
           documentType,
           checklistRequirements,
         });
@@ -143,7 +143,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
 
   // レビュー実行処理
   const handleExecuteReview = useCallback(
-    async (sourceIds: number[]) => {
+    async (files: UploadFile[]) => {
       if (!selectedReviewHistoryId) return;
 
       try {
@@ -153,7 +153,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
         // レビュー実行処理を開始
         const result = await window.electron.review.execute({
           reviewHistoryId: selectedReviewHistoryId,
-          sourceIds,
+          files,
         });
 
         if (!result.success) {
@@ -203,18 +203,18 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
 
   const handleModalSubmit = useCallback(
     async (
-      sourceIds: number[],
+      files: UploadFile[],
       documentType?: DocumentType,
       checklistRequirements?: string,
     ) => {
       if (modalMode === 'extract') {
         await handleExtractChecklist(
-          sourceIds,
+          files,
           documentType,
           checklistRequirements,
         );
       } else if (modalMode === 'review') {
-        await handleExecuteReview(sourceIds);
+        await handleExecuteReview(files);
       }
     },
     [modalMode, handleExtractChecklist, handleExecuteReview],
diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
index ba9419ce3..2ce7748fb 100644
--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++ b/src/renderer/components/review/ReviewChecklistSection.tsx
@@ -42,7 +42,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
   const [editingContent, setEditingContent] = useState('');
   const [isAddingNew, setIsAddingNew] = useState(false);
   const [newContent, setNewContent] = useState('');
-  const [sortBy, setSortBy] = useState<number | null>(null);
+  const [sortBy, setSortBy] = useState<string | null>(null);
   const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
 
   // --- ハンドラ ---
@@ -72,24 +72,24 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
     setIsAddingNew(false);
     setNewContent('');
   };
-  const handleSort = (sourceId: number) => {
-    if (sortBy === sourceId) {
+  const handleSort = (fileId: string) => {
+    if (sortBy === fileId) {
       setSortDirection((prev) => (prev === 'desc' ? 'asc' : 'desc'));
     } else {
-      setSortBy(sourceId);
+      setSortBy(fileId);
       setSortDirection('desc');
     }
   };
 
-  // --- ユニークソース抽出 ---
+  // --- ユニークファイル抽出 ---
   const uniqueSources = useMemo(() => {
-    const map = new Map<number, { id: number; fileName: string }>();
+    const map = new Map<string, { id: string; fileName: string }>();
     checklistResults.forEach((cl) => {
       cl.sourceEvaluations?.forEach((ev) => {
-        if (!map.has(ev.sourceId)) {
-          map.set(ev.sourceId, {
-            id: ev.sourceId,
-            fileName: ev.sourceFileName,
+        if (!map.has(ev.fileId)) {
+          map.set(ev.fileId, {
+            id: ev.fileId,
+            fileName: ev.fileName,
           });
         }
       });
@@ -108,12 +108,12 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
     const order = sortDirection === 'desc' ? descOrder : ascOrder;
 
     return [...checklistResults].sort((a, b) => {
-      // 対象ソースの評価を取得。未評価は '-' 扱い
+      // 対象ファイルの評価を取得。未評価は '-' 扱い
       const aEv =
-        a.sourceEvaluations?.find((ev) => ev.sourceId === sortBy)?.evaluation ??
+        a.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
         '-';
       const bEv =
-        b.sourceEvaluations?.find((ev) => ev.sourceId === sortBy)?.evaluation ??
+        b.sourceEvaluations?.find((ev) => ev.fileId === sortBy)?.evaluation ??
         '-';
 
       // 配列のインデックスで比較
@@ -186,7 +186,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
       {/* 評価列 */}
       {uniqueSources.map((src) => {
         const ev = checklist.sourceEvaluations?.find(
-          (x) => x.sourceId === src.id,
+          (x) => x.fileId === src.id,
         );
         return (
           <TableCell
diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
index a16143696..ee0f33fe6 100644
--- a/src/renderer/components/review/ReviewSourceModal.tsx
+++ b/src/renderer/components/review/ReviewSourceModal.tsx
@@ -5,35 +5,43 @@ import {
   Box,
   Typography,
   Button,
-  TableContainer,
-  Table,
-  TableHead,
-  TableRow,
-  TableCell,
-  TableBody,
   Paper,
-  Tooltip,
-  Chip,
-  Checkbox,
   FormControl,
   RadioGroup,
   FormControlLabel,
   Radio,
   FormLabel,
   TextField,
+  List,
+  ListItem,
+  ListItemText,
+  IconButton,
+  Tooltip,
+  CircularProgress,
 } from '@mui/material';
 import {
-  Check as CheckIcon,
-  Error as ErrorIcon,
-  Sync as SyncIcon,
-  HourglassEmpty as ProcessingIcon,
-  Help as UnknownIcon,
+  CloudUpload as UploadIcon,
+  Delete as DeleteIcon,
+  Image as ImageIcon,
+  Description as TextIcon,
+  Help as HelpIcon,
+  ViewAgenda as MergedIcon,
+  ViewStream as PagesIcon,
 } from '@mui/icons-material';
+import { createHash } from 'crypto';
 
-import { Source } from '../../../db/schema';
-import { ReviewSourceModalProps, DocumentType } from './types';
+import {
+  ReviewSourceModalProps,
+  DocumentType,
+  UploadFile,
+  PdfProcessMode,
+  PdfImageMode,
+} from './types';
 
-function SourceListModal({
+import { combineImages, convertPdfBytesToImages } from '../../utils/pdfUtils';
+import { file } from 'zod/v4';
+
+function ReviewSourceModal({
   open,
   onClose,
   onSubmit,
@@ -41,151 +49,208 @@ function SourceListModal({
   disabled,
   modalMode,
 }: ReviewSourceModalProps): React.ReactElement {
-  const [sources, setSources] = useState<Source[]>([]);
-  const [checkedSources, setCheckedSources] = useState<{
-    [key: number]: boolean;
-  }>({});
-  const [processing, setProcessing] = useState(true);
+  const [uploadedFiles, setUploadedFiles] = useState<UploadFile[]>([]);
+  const [processing, setProcessing] = useState(false); // ★ 送信処理やPDF変換の進行中フラグ
   const [documentType, setDocumentType] = useState<DocumentType>('checklist');
   const [checklistRequirements, setChecklistRequirements] = useState('');
+  const [error, setError] = useState<string | null>(null); // ★ エラー表示用
 
-  // チェック状態の更新
-  // ソースの更新状態が変わったときにチェック状態を更新する
-  // 元のチェック状態とマージする
-  useEffect(() => {
-    const newCheckedSources: { [key: number]: boolean } = {};
-    sources.forEach((source) => {
-      newCheckedSources[source.id] =
-        source.status === 'completed'
-          ? checkedSources[source.id] || false
-          : false;
-    });
-    setCheckedSources(newCheckedSources);
-    // eslint-disable-next-line
-  }, [sources]);
-
-  // modalMode, selectedReviewHistoryIdが変わったときにチェック状態を初期化する
-  // checkedSourceを全てfalseにする
+  // modalMode, selectedReviewHistoryIdが変わったときに初期化
   useEffect(() => {
-    setCheckedSources((prev) => {
-      Object.keys(prev).forEach((key) => {
-        prev[+key] = false;
-      });
-      return { ...prev };
-    });
-    // ドキュメント種別もリセット
+    setUploadedFiles([]);
     setDocumentType('checklist');
-    // チェックリスト作成要件もリセット
     setChecklistRequirements('');
+    setError(null);
   }, [modalMode, selectedReviewHistoryId]);
 
-  // チェックボックスの変更ハンドラ
-  const handleSourceCheckChange = async (sourceId: number) => {
-    setCheckedSources((prev) => ({
-      ...prev,
-      [sourceId]: !prev[sourceId],
-    }));
+  const getMimeTypeFromExtension = (extension: string): string => {
+    const mimeTypes: { [key: string]: string } = {
+      pdf: 'application/pdf',
+      doc: 'application/msword',
+      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
+      xls: 'application/vnd.ms-excel',
+      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
+      ppt: 'application/vnd.ms-powerpoint',
+      pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
+      txt: 'text/plain',
+    };
+    return mimeTypes[extension] || 'application/octet-stream';
   };
 
-  // 全選択/全解除の切り替えハンドラ
-  const handleSelectAllChange = () => {
-    const targetSources = sources.filter(
-      (source) => source.status === 'completed',
-    );
-    if (targetSources.length === 0) return;
-    const targetCheckedSources = targetSources.reduce(
-      (acc, source) => {
-        acc[source.id] = checkedSources[source.id] || false;
-        return acc;
-      },
-      {} as { [key: number]: boolean },
-    );
-    const someUnchecked = Object.values(targetCheckedSources).some(
-      (checked) => !checked,
+  const handleFileUpload = async () => {
+    try {
+      const result = await window.electron.fs.showOpenDialog({
+        title: 'ドキュメントファイルを選択',
+        filters: [
+          {
+            name: 'ドキュメントファイル',
+            extensions: [
+              'pdf',
+              'doc',
+              'docx',
+              'xls',
+              'xlsx',
+              'ppt',
+              'pptx',
+              'txt',
+            ],
+          },
+        ],
+        properties: ['openFile', 'multiSelections'],
+      });
+
+      if (!result.canceled && result.filePaths.length > 0) {
+        const newFiles: UploadFile[] = result.filePaths.map(
+          (filePath: string) => {
+            const fileName = filePath.split('/').pop() || filePath;
+            const fileExtension =
+              fileName.split('.').pop()?.toLowerCase() || '';
+            const mimeType = getMimeTypeFromExtension(fileExtension);
+
+            return {
+              id: filePath,
+              name: fileName,
+              path: filePath,
+              type: mimeType,
+              // ★ 画像化は最終決定時だけ行うので、ここでは mode だけ持つ
+              pdfProcessMode:
+                mimeType === 'application/pdf' ? 'text' : undefined,
+              pdfImageMode: 'merged', // デフォルトは統合画像
+            };
+          },
+        );
+
+        setUploadedFiles((prev) => [...prev, ...newFiles]);
+      }
+    } catch (e) {
+      console.error('ファイル選択エラー:', e);
+      setError('ファイル選択に失敗しました。もう一度お試しください。');
+    }
+  };
+
+  const handleFileDelete = (fileId: string) => {
+    setUploadedFiles((prev) => prev.filter((file) => file.id !== fileId));
+  };
+
+  // ★ ここでは「モード切替」だけ。実際のPDF→画像変換は送信確定時にまとめて行う
+  const handlePdfProcessModeChange = (fileId: string, mode: PdfProcessMode) => {
+    setUploadedFiles((prev) =>
+      prev.map((file) =>
+        file.id === fileId
+          ? { ...file, pdfProcessMode: mode, imageData: undefined }
+          : file,
+      ),
     );
-    const newCheckedState = { ...checkedSources };
+  };
 
-    // 一つでもチェックが外れているものがあれば全選択、すべてチェック済みなら全解除
-    const newValue = someUnchecked;
+  // PDF画像化モードを変更するハンドラー
+  const handlePdfImageModeChange = (fileId: string, mode: PdfImageMode) => {
+    setUploadedFiles((prev) =>
+      prev.map((file) =>
+        file.id === fileId
+          ? { ...file, pdfImageMode: mode, imageData: undefined }
+          : file,
+      ),
+    );
+  };
 
-    // すべてのソースのチェック状態を更新
-    targetSources.forEach((source) => {
-      newCheckedState[source.id] = newValue;
-    });
-    setCheckedSources(newCheckedState);
+  // デバッグ専用：DataURLを即ダウンロード
+  // 本番環境ではコメントアウトすること
+  const __dbgDownload = (dataUrl: string, name = 'converted.png') => {
+    const a = document.createElement('a');
+    a.href = dataUrl;
+    a.download = name;
+    a.click();
   };
 
-  // ソースデータの定期更新（processingステータスがある場合のみ）
-  useEffect(() => {
-    const fetchSources = async () => {
-      try {
-        const response = await window.electron.source.getSources();
-        const responseSources: Source[] = response.sources || [];
-        setSources(responseSources);
-        const newProcessing = responseSources.some(
-          (s: Source) => s.status === 'idle' || s.status === 'processing',
-        );
-        setProcessing(newProcessing);
-      } catch (error) {
-        console.error('ドキュメントデータの取得に失敗しました:', error);
-      }
-    };
+  // ★ 送信確定時にだけ、必要なPDFをMain経由で読み→Rendererで画像化→連結
+  const handleSubmit = async () => {
+    if (disabled || processing || uploadedFiles.length === 0) return;
 
-    // 初回データ取得
-    fetchSources();
+    setError(null);
+    setProcessing(true);
 
-    const intervalId = setInterval(fetchSources, 5000);
+    try {
+      const filesReady = [];
+      for (const f of uploadedFiles) {
+        if (f.type === 'application/pdf' && f.pdfProcessMode === 'image') {
+          // Mainから安全にPDFバイト列を取得（file:// fetch を使わない）
+          const data = await window.electron.fs.readFile(f.path);
 
-    return () => {
-      if (intervalId) {
-        clearInterval(intervalId);
+          // ブラウザ側で pdf.js にレンダリングさせて PNG を得る
+          const imagePages = await convertPdfBytesToImages(data, {
+            scale: 2.0,
+          });
+
+          if (f.pdfImageMode === 'pages') {
+            // ページ別画像モード: 各ページを個別に保存
+            // デバッグ用：各ページを個別にダウンロード
+            imagePages.forEach((pageImage, index) => {
+              // ←ここで即保存（デバッグ用）
+              // 本番はコメントアウトすること
+              __dbgDownload(
+                pageImage,
+                `${f.name.replace(/\.[^.]+$/, '')}_page_${index + 1}.png`,
+              );
+            });
+
+            filesReady.push({ ...f, imageData: imagePages });
+          } else {
+            // 統合画像モード（デフォルト）: 1つの縦長PNGに連結
+            const combined = await combineImages(imagePages);
+
+            // ←ここで即保存（デバッグ用）
+            // 本番はコメントアウトすること
+            __dbgDownload(
+              combined,
+              f.name.replace(/\.[^.]+$/, '') + '_combined.png',
+            );
+
+            filesReady.push({ ...f, imageData: [combined] });
+          }
+        } else {
+          filesReady.push(f);
+        }
       }
-    };
-  }, []);
-
-  const handleClick = () => {
-    if (disabled) return;
-    onSubmit(
-      Object.keys(checkedSources)
-        .filter((key) => {
-          return checkedSources[+key];
-        })
-        .map((key) => +key),
-      modalMode === 'extract' ? documentType : undefined,
-      modalMode === 'extract' &&
-        documentType === 'general' &&
-        checklistRequirements.trim() !== ''
-        ? checklistRequirements.trim()
-        : undefined,
-    );
+
+      // 呼び出し元に最終決定のファイルリストを渡す（必要ならこの先でMainに送る）
+      onSubmit(
+        filesReady,
+        modalMode === 'extract' ? documentType : undefined,
+        modalMode === 'extract' &&
+          documentType === 'general' &&
+          checklistRequirements.trim() !== ''
+          ? checklistRequirements.trim()
+          : undefined,
+      );
+    } catch (e) {
+      console.error('送信処理中に失敗:', e);
+      setError(
+        '送信時の処理に失敗しました。PDFが壊れていないか、またはPDFが非常に大きすぎないかをご確認ください。',
+      );
+    } finally {
+      setProcessing(false);
+    }
   };
 
   const getButtonText = () => {
-    if (modalMode === 'review') {
-      return 'ドキュメントレビュー実行';
-    }
-    if (modalMode === 'extract') {
-      return 'チェックリスト抽出';
-    }
+    if (modalMode === 'review') return 'ドキュメントレビュー実行';
+    if (modalMode === 'extract') return 'チェックリスト抽出';
     return null;
   };
 
   const getTitle = () => {
-    if (modalMode === 'review') {
-      return 'ドキュメントレビュー対象ドキュメント選択';
-    }
-    if (modalMode === 'extract') {
-      return 'チェックリスト抽出対象ドキュメント選択';
-    }
-    return 'ソース選択';
+    if (modalMode === 'review') return 'レビュー対象ファイルのアップロード';
+    if (modalMode === 'extract')
+      return 'チェックリスト抽出対象ファイルのアップロード';
+    return 'ファイルアップロード';
   };
 
-  // アラート表示の内容
   const getAlertMessage = () => {
     if (modalMode === 'extract') {
-      const baseMessage = (
+      return (
         <>
-          設定されたフォルダ内のドキュメントを一覧表示しています
+          ファイルを選択してチェックリスト抽出を実行できます
           <br />
           {documentType === 'checklist'
             ? '選択されたチェックリストドキュメントから、AIが既存のチェック項目を抽出できます'
@@ -193,95 +258,24 @@ function SourceListModal({
           <br />
           ※
           <br />
-          フォルダの内容が更新された場合はドキュメント一覧画面（添付アイコン）からファイル同期を実行してください
-          <br />
           チェックリストは手動で編集・追加・削除が可能です
           <br />
           手動で追加・編集されたチェックリスト以外は、再度チェックリスト抽出を実行すると削除されます
-          <br />
-          フォルダのパスは設定画面（歯車アイコン）から変更可能です
         </>
       );
-      return baseMessage;
     }
     if (modalMode === 'review') {
       return (
         <>
-          設定されたフォルダ内のドキュメントを一覧表示しています
+          レビュー対象ファイルを選択してください
           <br />
           選択されたドキュメントに対して、AIがチェックリストに基づいてレビューを行います
-          <br />
-          ※
-          <br />
-          フォルダの内容が更新された場合はドキュメント一覧画面（添付アイコン）からファイル同期を実行してください
-          <br />
-          フォルダのパスは設定画面（歯車アイコン）から変更可能です
         </>
       );
     }
     return null;
   };
 
-  const getStatusIcon = (status: Source['status'], error?: Source['error']) => {
-    switch (status) {
-      case 'completed':
-        return (
-          <Chip
-            icon={<CheckIcon />}
-            label="完了"
-            color="success"
-            size="small"
-            variant="outlined"
-          />
-        );
-      case 'failed':
-        return (
-          <Tooltip
-            data-testid="sourcelistmodal-error-tooltip"
-            title={error ?? '不明なエラー'}
-          >
-            <Chip
-              icon={<ErrorIcon />}
-              label="エラー"
-              color="error"
-              size="small"
-              variant="outlined"
-            />
-          </Tooltip>
-        );
-      case 'processing':
-        return (
-          <Chip
-            icon={<ProcessingIcon />}
-            label="処理中"
-            color="primary"
-            size="small"
-            variant="outlined"
-          />
-        );
-      case 'idle':
-        return (
-          <Chip
-            icon={<SyncIcon />}
-            label="待機中"
-            color="default"
-            size="small"
-            variant="outlined"
-          />
-        );
-      default:
-        return (
-          <Chip
-            icon={<UnknownIcon />}
-            label="不明"
-            color="default"
-            size="small"
-            variant="outlined"
-          />
-        );
-    }
-  };
-
   return (
     <Modal open={open} onClose={onClose}>
       <Box
@@ -303,10 +297,17 @@ function SourceListModal({
         <Typography variant="h6" component="h2" gutterBottom>
           {getTitle()}
         </Typography>
+
         <Alert severity="info" sx={{ whiteSpace: 'pre-line', mb: 2 }}>
           {getAlertMessage()}
         </Alert>
 
+        {error && (
+          <Alert severity="error" sx={{ mb: 2 }}>
+            {error}
+          </Alert>
+        )}
+
         {modalMode === 'extract' && (
           <>
             <FormControl component="fieldset" sx={{ mb: 2 }}>
@@ -350,78 +351,160 @@ function SourceListModal({
           </>
         )}
 
-        <Box sx={{ mb: 2, display: 'flex', justifyContent: 'flex-end' }}>
-          <Tooltip title="ソース登録ディレクトリ内のファイル内容と同期します">
-            <Button
-              variant="contained"
-              onClick={handleClick}
-              disabled={
-                processing ||
-                disabled ||
-                Object.keys(checkedSources).length === 0
-              }
-              startIcon={<SyncIcon />}
-            >
-              {processing ? 'ドキュメント初期化処理中...' : getButtonText()}
-            </Button>
-          </Tooltip>
+        <Box sx={{ mb: 2 }}>
+          <Button
+            variant="contained"
+            onClick={handleFileUpload}
+            startIcon={<UploadIcon />}
+            disabled={processing}
+          >
+            ファイル選択ダイアログ
+          </Button>
         </Box>
 
-        <TableContainer component={Paper}>
-          <Table>
-            <TableHead>
-              <TableRow>
-                <TableCell padding="checkbox">
-                  <Checkbox
-                    indeterminate={
-                      Object.values(checkedSources).some(
-                        (checked) => checked,
-                      ) &&
-                      Object.values(checkedSources).some((checked) => !checked)
-                    }
-                    checked={
-                      Object.values(checkedSources).length > 0 &&
-                      Object.values(checkedSources).every((checked) => checked)
-                    }
-                    onChange={handleSelectAllChange}
-                    disabled={processing}
-                  />
-                </TableCell>
-                <TableCell>ファイルパス</TableCell>
-                <TableCell>タイトル（生成）</TableCell>
-                <TableCell>フォルダ同期処理ステータス</TableCell>
-              </TableRow>
-            </TableHead>
-            <TableBody>
-              {sources.map((source) => (
-                <TableRow
-                  key={source.id}
-                  sx={{
-                    '&:last-child td, &:last-child th': { border: 0 },
-                    backgroundColor:
-                      source.status === 'failed' ? 'error.lighter' : 'inherit',
-                  }}
+        {uploadedFiles.length > 0 && (
+          <Paper sx={{ mb: 2, p: 2 }}>
+            <Typography variant="subtitle2" gutterBottom>
+              選択済みファイル ({uploadedFiles.length}件)
+            </Typography>
+            <List dense>
+              {uploadedFiles.map((file) => (
+                <ListItem
+                  key={file.id}
+                  secondaryAction={
+                    <IconButton
+                      edge="end"
+                      onClick={() => handleFileDelete(file.id)}
+                      disabled={processing}
+                    >
+                      <DeleteIcon />
+                    </IconButton>
+                  }
                 >
-                  <TableCell padding="checkbox">
-                    <Checkbox
-                      checked={checkedSources[source.id] || false}
-                      onChange={() => handleSourceCheckChange(source.id)}
-                      disabled={processing || source.status !== 'completed'}
-                    />
-                  </TableCell>
-                  <TableCell>{source.path}</TableCell>
-                  <TableCell>{source.title}</TableCell>
-                  <TableCell>
-                    {getStatusIcon(source.status, source.error)}
-                  </TableCell>
-                </TableRow>
+                  <ListItemText
+                    primary={file.name}
+                    secondary={file.type === 'application/pdf' ? 'PDF' : ''}
+                  />
+                  {file.type === 'application/pdf' && (
+                    <Box sx={{ mr: 2 }}>
+                      <FormControl size="small">
+                        <RadioGroup
+                          row
+                          value={file.pdfProcessMode}
+                          onChange={(e) =>
+                            handlePdfProcessModeChange(
+                              file.id,
+                              e.target.value as PdfProcessMode,
+                            )
+                          }
+                        >
+                          <FormControlLabel
+                            value="text"
+                            control={<Radio size="small" />}
+                            label={
+                              <Box
+                                sx={{ display: 'flex', alignItems: 'center' }}
+                              >
+                                <TextIcon fontSize="small" sx={{ mr: 0.5 }} />
+                                テキスト
+                              </Box>
+                            }
+                          />
+                          <FormControlLabel
+                            value="image"
+                            control={<Radio size="small" />}
+                            label={
+                              <Box
+                                sx={{ display: 'flex', alignItems: 'center' }}
+                              >
+                                <ImageIcon fontSize="small" sx={{ mr: 0.5 }} />
+                                画像
+                                <Tooltip title="図形オブジェクトが多いPDFは画像化で精度が上がる場合があります">
+                                  <HelpIcon
+                                    fontSize="small"
+                                    sx={{ ml: 0.5, color: 'text.secondary' }}
+                                  />
+                                </Tooltip>
+                              </Box>
+                            }
+                          />
+                        </RadioGroup>
+                      </FormControl>
+                      {file.pdfProcessMode === 'image' && (
+                        <FormControl size="small" sx={{ ml: 1 }}>
+                          <RadioGroup
+                            row
+                            value={file.pdfImageMode}
+                            onChange={(e) =>
+                              handlePdfImageModeChange(
+                                file.id,
+                                e.target.value as PdfImageMode,
+                              )
+                            }
+                          >
+                            <FormControlLabel
+                              value="merged"
+                              control={<Radio size="small" />}
+                              label={
+                                <Box
+                                  sx={{ display: 'flex', alignItems: 'center' }}
+                                >
+                                  <MergedIcon
+                                    fontSize="small"
+                                    sx={{ mr: 0.5 }}
+                                  />
+                                  統合画像
+                                </Box>
+                              }
+                            />
+                            <FormControlLabel
+                              value="pages"
+                              control={<Radio size="small" />}
+                              label={
+                                <Box
+                                  sx={{ display: 'flex', alignItems: 'center' }}
+                                >
+                                  <PagesIcon
+                                    fontSize="small"
+                                    sx={{ mr: 0.5 }}
+                                  />
+                                  ページ別画像
+                                  <Tooltip title="ページ数が多い場合はページごとに画像化することを検討してください">
+                                    <HelpIcon
+                                      fontSize="small"
+                                      sx={{ ml: 0.5, color: 'text.secondary' }}
+                                    />
+                                  </Tooltip>
+                                </Box>
+                              }
+                            />
+                          </RadioGroup>
+                        </FormControl>
+                      )}
+                    </Box>
+                  )}
+                </ListItem>
               ))}
-            </TableBody>
-          </Table>
-        </TableContainer>
+            </List>
+          </Paper>
+        )}
+
+        <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 2 }}>
+          <Button variant="outlined" onClick={onClose} disabled={processing}>
+            キャンセル
+          </Button>
+          <Button
+            variant="contained"
+            onClick={handleSubmit}
+            disabled={processing || disabled || uploadedFiles.length === 0}
+            startIcon={processing ? <CircularProgress size={20} /> : null}
+          >
+            {processing ? '処理中...' : getButtonText()}
+          </Button>
+        </Box>
       </Box>
     </Modal>
   );
 }
 
-export default React.memo(SourceListModal);
+export default React.memo(ReviewSourceModal);
diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
index 55c81e159..e65954a5f 100644
--- a/src/renderer/components/review/types.ts
+++ b/src/renderer/components/review/types.ts
@@ -1,6 +1,6 @@
 import {
   ReviewChecklistEdit,
-  ReviewChecklistResult,
+  ReviewChecklistResultDisplay,
 } from '../../../main/types';
 import { Source } from '../../../db/schema';
 
@@ -11,7 +11,7 @@ export interface ReviewAreaProps {
 
 // ReviewChecklistSectionのProps型
 export interface ReviewChecklistSectionProps {
-  checklistResults: ReviewChecklistResult[];
+  checklistResults: ReviewChecklistResultDisplay[];
   isLoading: boolean;
   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
 }
@@ -21,12 +21,29 @@ export type ModalMode = 'extract' | 'review';
 // ドキュメント種別の定義
 export type DocumentType = 'checklist' | 'general';
 
+// PDF処理方式の定義
+export type PdfProcessMode = 'text' | 'image';
+
+// PDF画像化方式の定義
+export type PdfImageMode = 'merged' | 'pages';
+
+// アップロードファイル情報の型定義
+export interface UploadFile {
+  id: string;
+  name: string;
+  path: string;
+  type: string;
+  pdfProcessMode?: PdfProcessMode; // PDFファイルの場合のみ
+  pdfImageMode?: PdfImageMode; // PDF画像化の場合のみ (merged: 統合画像, pages: ページ別画像)
+  imageData?: string[]; // PDF画像変換時のBase64データ配列 (merged: 長さ1, pages: 各ページ)
+}
+
 // ReviewSourceModalのProps型
 export interface ReviewSourceModalProps {
   open: boolean;
   onClose: () => void;
   onSubmit: (
-    sourceIds: number[],
+    files: UploadFile[],
     documentType?: DocumentType,
     checklistRequirements?: string,
   ) => void;
diff --git a/src/renderer/services/reviewService.ts b/src/renderer/services/reviewService.ts
index fd5edd165..5655e2270 100644
--- a/src/renderer/services/reviewService.ts
+++ b/src/renderer/services/reviewService.ts
@@ -1,5 +1,6 @@
 import { ReviewHistory } from '../../db/schema';
 import { IpcChannels, IpcEventPayload } from '../../main/types/ipc';
+import { UploadFile } from '../components/review/types';
 
 // IPC通信を使用してメインプロセスとやり取りするレビュー機能用のサービス
 export const reviewService = {
@@ -67,12 +68,12 @@ export const reviewService = {
    */
   callChecklistExtraction: async (
     reviewHistoryId: string,
-    sourceIds: number[],
+    files: UploadFile[],
   ) => {
     try {
       const result = await window.electron.review.extractChecklist({
         reviewHistoryId,
-        sourceIds,
+        files,
       });
       if (!result.success) {
         throw new Error(result.error || '不明なエラー');
@@ -85,7 +86,11 @@ export const reviewService = {
   },
 
   subscribeChecklistExtractionFinished: (
-    callback: (payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED>) => void,
+    callback: (
+      payload: IpcEventPayload<
+        typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED
+      >,
+    ) => void,
   ) => {
     return window.electron.review.onExtractChecklistFinished((payload) => {
       callback(payload);
@@ -93,7 +98,9 @@ export const reviewService = {
   },
 
   subscribeReviewExecutionFinished: (
-    callback: (payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>) => void,
+    callback: (
+      payload: IpcEventPayload<typeof IpcChannels.REVIEW_EXECUTE_FINISHED>,
+    ) => void,
   ) => {
     return window.electron.review.onExecuteReviewFinished((payload) => {
       callback(payload);
diff --git a/src/renderer/utils/pdfUtils.ts b/src/renderer/utils/pdfUtils.ts
new file mode 100644
index 000000000..1f7c41657
--- /dev/null
+++ b/src/renderer/utils/pdfUtils.ts
@@ -0,0 +1,84 @@
+import * as pdfjsLib from 'pdfjs-dist';
+
+// PDF.jsのワーカーを設定
+const workerUrl = new URL('pdf.worker.mjs', window.location.href).toString();
+const worker = new Worker(workerUrl, { type: 'module' });
+pdfjsLib.GlobalWorkerOptions.workerPort = worker;
+
+/**
+ * PDF を PNG(Base64 DataURL) の配列に変換
+ * @param arrayBuffer Main 経由で取得した PDF の ArrayBuffer
+ * @param opts.scale レンダリング解像度（デフォルト 2.0）
+ */
+export const convertPdfBytesToImages = async (
+  data: Uint8Array | ArrayBufferLike,
+  opts: { scale?: number } = {},
+): Promise<string[]> => {
+  const scale = opts.scale ?? 2.0;
+
+  // data が Uint8Array でなければ Uint8Array に包む
+  const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
+
+  const loadingTask = pdfjsLib.getDocument({ data: bytes });
+  const pdf = await loadingTask.promise;
+
+  const images: string[] = [];
+  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
+    const page = await pdf.getPage(pageNum);
+    const viewport = page.getViewport({ scale });
+
+    const canvas = document.createElement('canvas');
+    const ctx = canvas.getContext('2d');
+    if (!ctx) throw new Error('Canvas context could not be created');
+
+    canvas.width = viewport.width;
+    canvas.height = viewport.height;
+
+    await page.render({ canvasContext: ctx, viewport }).promise;
+    images.push(canvas.toDataURL('image/png'));
+  }
+  return images;
+};
+
+/**
+ * 画像データURL配列を縦に結合して1枚のPNGにする
+ */
+export const combineImages = async (
+  imageDataArray: string[],
+): Promise<string> => {
+  if (imageDataArray.length === 0) throw new Error('画像データが空です');
+  if (imageDataArray.length === 1) return imageDataArray[0];
+
+  const images = await Promise.all(
+    imageDataArray.map(
+      (data) =>
+        new Promise<HTMLImageElement>((resolve, reject) => {
+          const img = new Image();
+          img.onload = () => resolve(img);
+          img.onerror = reject;
+          img.src = data;
+        }),
+    ),
+  );
+
+  const maxWidth = Math.max(...images.map((img) => img.width));
+  const totalHeight = images.reduce((sum, img) => sum + img.height, 0);
+
+  const canvas = document.createElement('canvas');
+  const context = canvas.getContext('2d');
+  if (!context) throw new Error('Canvas context could not be created');
+
+  canvas.width = maxWidth;
+  canvas.height = totalHeight;
+
+  context.fillStyle = '#FFFFFF';
+  context.fillRect(0, 0, maxWidth, totalHeight);
+
+  let currentY = 0;
+  for (const img of images) {
+    context.drawImage(img, 0, currentY);
+    currentY += img.height;
+  }
+
+  return canvas.toDataURL('image/png');
+};
