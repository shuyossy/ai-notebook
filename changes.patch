diff --git a/src/__tests__/renderer/reviewChecklistExtract.test.tsx b/src/__tests__/renderer/reviewChecklistExtract.test.tsx
index f07b07190..d897660d8 100644
--- a/src/__tests__/renderer/reviewChecklistExtract.test.tsx
+++ b/src/__tests__/renderer/reviewChecklistExtract.test.tsx
@@ -777,6 +777,277 @@ describe('ReviewArea - チェックリスト抽出', () => {
       jest.useRealTimers();
     }, 15000);
 
+    it('ファイルインポート成功時にチェックリストが更新されること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-extract-checklist-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      // 更新されたチェックリストデータ
+      const updatedChecklistResults: ReviewChecklistResult[] = [
+        { id: 1, content: 'インポートされたチェック項目1' },
+        { id: 2, content: 'インポートされたチェック項目2' },
+      ];
+
+      let getHistoryDetailCallCount = 0;
+      const mockGetHistoryDetail = jest.fn(() => {
+        getHistoryDetailCallCount++;
+        // 初回は空、イベント後は更新されたデータを返す
+        if (getHistoryDetailCallCount === 1) {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: [],
+              targetDocumentName: null,
+            },
+          });
+        }
+        return Promise.resolve({
+          success: true as const,
+          data: {
+            checklistResults: updatedChecklistResults,
+            targetDocumentName: 'imported-checklist.xlsx',
+          },
+        });
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されていることを確認
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      const callCountBeforeEvent = mockGetHistoryDetail.mock.calls.length;
+
+      // ファイルインポート完了イベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'success',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // getHistoryDetailが再度呼ばれることを確認
+      expect(mockGetHistoryDetail.mock.calls.length).toBeGreaterThan(
+        callCountBeforeEvent,
+      );
+
+      // 更新されたチェックリストが画面に表示されることを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('インポートされたチェック項目1'),
+        ).toBeInTheDocument();
+        expect(
+          screen.getByText('インポートされたチェック項目2'),
+        ).toBeInTheDocument();
+      });
+
+      // 成功メッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasSuccess = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('チェックリストの抽出が完了しました'),
+        );
+        expect(hasSuccess).toBe(true);
+      });
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('ファイルインポート成功時にレビュー設定が更新されること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-extract-checklist-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: [
+            { id: 1, content: 'インポートされたチェック項目1' },
+          ],
+          targetDocumentName: 'imported-checklist.xlsx',
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+      });
+
+      // レビュー設定のモック - 呼び出し回数に応じて異なるデータを返す
+      let getInstructionCallCount = 0;
+      const mockGetHistoryInstruction = jest.fn(() => {
+        getInstructionCallCount++;
+        // 初回はデフォルト設定
+        if (getInstructionCallCount === 1) {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              additionalInstructions: '',
+              commentFormat:
+                '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+              evaluationSettings: {
+                items: [
+                  { label: 'A', description: '基準を完全に満たしている' },
+                  { label: 'B', description: '基準をある程度満たしている' },
+                  { label: 'C', description: '基準を満たしていない' },
+                  { label: '–', description: '評価の対象外、または評価できない' },
+                ],
+              },
+            },
+          });
+        }
+        // イベント後はCSVからインポートされた設定
+        return Promise.resolve({
+          success: true as const,
+          data: {
+            additionalInstructions: 'CSVからインポートされた追加指示',
+            commentFormat: '【インポート後】\n新しいコメントフォーマット',
+            evaluationSettings: {
+              items: [
+                { label: '優秀', description: '非常に優れている' },
+                { label: '良好', description: '基準を満たしている' },
+                { label: '要改善', description: '改善が必要' },
+                { label: '不可', description: '基準を満たしていない' },
+                { label: '対象外', description: '評価の対象外' },
+              ],
+            },
+          },
+        });
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されていることを確認
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      // 初回の呼び出し回数を記録
+      const instructionCallCountBeforeEvent =
+        mockGetHistoryInstruction.mock.calls.length;
+      expect(instructionCallCountBeforeEvent).toBe(1);
+
+      // ファイルインポート完了イベント（成功）を発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'success',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // getHistoryInstructionが再度呼ばれることを確認（設定が再取得される）
+      await waitFor(() => {
+        expect(mockGetHistoryInstruction.mock.calls.length).toBeGreaterThan(
+          instructionCallCountBeforeEvent,
+        );
+      });
+
+      // 最終的に2回呼ばれていることを確認（初回 + イベント後の再取得）
+      expect(mockGetHistoryInstruction.mock.calls.length).toBe(2);
+
+      // 成功メッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasSuccess = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('チェックリストの抽出が完了しました'),
+        );
+        expect(hasSuccess).toBe(true);
+      });
+
+      jest.useRealTimers();
+    }, 15000);
+
     it('チェックリスト抽出完了イベント（失敗）を受信したら、エラーメッセージを表示してポーリングを停止すること', async () => {
       jest.useFakeTimers();
 
@@ -1498,7 +1769,7 @@ describe('ReviewArea - チェックリスト抽出', () => {
           expect(radio).toBeChecked();
         });
       });
-    });
+    }, 20000);
 
     it('一括設定で全ファイルの処理モードを画像化（統合）に変更できること', async () => {
       const mockShowOpenDialog = jest.fn().mockResolvedValue({
@@ -1586,7 +1857,7 @@ describe('ReviewArea - チェックリスト抽出', () => {
           expect(radio).toBeChecked();
         });
       });
-    });
+    }, 20000);
 
     it('Officeファイルを画像化する際にOffice→PDF変換が実行されること', async () => {
       // PDF→画像変換のモックを準備（jest.spyOnを使用）
