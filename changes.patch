diff --git a/.gitignore b/.gitignore
index 19003f9b1..458394a06 100644
--- a/.gitignore
+++ b/.gitignore
@@ -47,3 +47,4 @@ electron-store
 .erb/chrome.exe
 /release/app/drizzle
 dev_appdata
+.serena
diff --git a/.mcp.json b/.mcp.json
index 8be50ce70..b25d0b2fc 100644
--- a/.mcp.json
+++ b/.mcp.json
@@ -32,6 +32,11 @@
         "@upstash/context7-mcp"
       ],
       "env": {}
+    },
+    "codex": {
+      "type": "stdio",
+      "command": "codex",
+      "args": ["mcp"]
     }
   }
 }
diff --git a/.serena/.gitignore b/.serena/.gitignore
deleted file mode 100644
index 14d86ad62..000000000
--- a/.serena/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/cache
diff --git a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl b/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl
deleted file mode 100644
index 48bb5b276..000000000
Binary files a/.serena/cache/typescript/document_symbols_cache_v23-06-25.pkl and /dev/null differ
diff --git a/.serena/memories/architecture_details.md b/.serena/memories/architecture_details.md
deleted file mode 100644
index ff65addf2..000000000
--- a/.serena/memories/architecture_details.md
+++ /dev/null
@@ -1,76 +0,0 @@
-# アーキテクチャ詳細
-
-## レイヤー構成
-
-### 1. Electronプロセス層
-- **メインプロセス** (`src/main/main.ts`): アプリケーションエントリーポイント、IPC通信管理
-- **レンダラープロセス** (`src/renderer/`): Reactベースフロントエンド
-- **プリロードスクリプト** (`src/main/preload/`): セキュアなIPC API公開
-
-### 2. フロントエンド層（React）
-```
-src/renderer/
-├── components/          # UIコンポーネント
-│   ├── sidebar/        # サイドバー（機能切り替え）
-│   ├── chat/           # チャット機能UI
-│   ├── review/         # レビュー機能UI
-│   └── common/         # 共通コンポーネント
-├── hooks/              # カスタムフック
-├── service/            # フロントエンドサービス
-└── stores/            # Zustand状態管理
-```
-
-### 3. Mastraフレームワーク統合層
-```
-src/mastra/
-├── agents/             # AIエージェント定義
-│   ├── orchestrator.ts # 汎用チャットエージェント
-│   └── prompts.ts      # プロンプト定義集約
-├── tools/              # 外部システム統合
-│   ├── gitlab/         # GitLab API統合
-│   ├── redmine/        # Redmine API統合
-│   ├── mcp/            # MCP連携
-│   └── sourcesTools.ts # ドキュメント検索
-├── workflows/          # 複雑タスク自動化
-│   ├── sourceRegistration/ # ドキュメント登録WF
-│   └── sourceReview/       # レビュー実行WF
-└── memory/            # メモリ・フィルタリング
-```
-
-### 4. データベース層
-```
-src/db/
-├── schema.ts          # Drizzleテーブル定義
-└── repository/        # データアクセス層
-```
-
-### 5. サービス層
-```
-src/main/service/
-├── ChatService        # チャット機能ビジネスロジック
-├── ReviewService      # レビュー機能ビジネスロジック
-└── SettingsService    # 設定管理
-```
-
-## IPC通信アーキテクチャ
-- **チャネル定義**: `src/main/types/ipc.ts`で型安全管理
-- **ハンドラー**: `src/main/main.ts`で集約定義
-- **プリロード**: セキュアなAPI公開層
-
-## データフロー
-
-### チャット機能
-1. UI → IPC → ChatService → Mastra Agent → 外部API/Tools → レスポンス
-2. リアルタイム更新: IPC eventを使用
-
-### レビュー機能  
-1. UI → IPC → ReviewService → Mastra Workflow → チェックリスト抽出/レビュー実行
-2. 段階的処理: Workflowのステップ管理
-
-### ドキュメント管理
-1. ファイル登録 → テキスト抽出（fileExtractor） → DBキャッシュ → 検索可能化
-
-## 設定管理
-- **electron-store**: 永続化設定ストレージ
-- **環境分離**: 開発/本番環境の設定分離
-- **リアクティブ**: 設定変更の即座反映
\ No newline at end of file
diff --git a/.serena/memories/code_style_conventions.md b/.serena/memories/code_style_conventions.md
deleted file mode 100644
index 5e306c0ee..000000000
--- a/.serena/memories/code_style_conventions.md
+++ /dev/null
@@ -1,52 +0,0 @@
-# コードスタイル・規約
-
-## TypeScript設定
-- **厳密設定**: `strict: true`
-- **ターゲット**: ES2022
-- **モジュール**: Node16
-- **JSX**: react-jsx（React 17+の新JSX変換）
-- **パスエイリアス**: `@/*` -> `./src/*`
-
-## ESLint規約
-- **ベース**: 'erb' configuration
-- **重要なルール**:
-  - `react/react-in-jsx-scope`: 'off' （React 17+のため）
-  - `@typescript-eslint/no-shadow`: 'error' （TypeScript版を使用）
-  - `@typescript-eslint/no-unused-vars`: 'off' （開発中は無効）
-  - `no-console`: 'off' （コンソール使用許可）
-  - `react/require-default-props`: 'off' （デストラクチャリングでデフォルト値設定を許可）
-  - `react/function-component-definition`: arrow-functionを許可
-
-## Prettier設定
-- **シングルクォート**: 有効
-- **JSON設定**: 特別パース設定
-
-## 命名規約
-### React コンポーネント
-- **ファイル名**: PascalCase（例：`SidebarHeader.tsx`）
-- **コンポーネント名**: PascalCase
-- **プロップス型**: ComponentNameProps（例：`SidebarHeaderProps`）
-
-### 関数・変数
-- **関数**: camelCase（例：`handleFeatureChange`）
-- **定数**: UPPER_SNAKE_CASE（例：`FEATURES`）
-- **変数**: camelCase
-
-### ファイル構造
-- **コンポーネントディレクトリ**: 機能別（chat/, sidebar/, common/, review/）
-- **型定義**: `types.ts`または同一ファイル内でinterface定義
-
-## コメント規約
-- **コードコメント**: 日本語で記載
-- **プロンプト**: 英語で記載（Mastra AIエージェント用）
-- **TSDocコメント**: 必要に応じて英語
-
-## インポート規約
-- **外部ライブラリ**: 最初にグループ化
-- **内部モジュール**: @/から始まるパスエイリアス使用
-- **相対パス**: ./または../で明示
-
-## 制約事項
-- **async iterator**: 使用非推奨（パフォーマンス理由）
-- **for-await-of**: ESLintで禁止設定
-- **非同期処理**: Promise chainまたはasync/await推奨
\ No newline at end of file
diff --git a/.serena/memories/development_guidelines.md b/.serena/memories/development_guidelines.md
deleted file mode 100644
index 7f036e6bf..000000000
--- a/.serena/memories/development_guidelines.md
+++ /dev/null
@@ -1,68 +0,0 @@
-# 開発ガイドライン
-
-## 実装アプローチ
-
-### プロジェクト理解
-1. **全体把握**: プロジェクト全体を理解してから必要箇所を洗い出し
-2. **既存資源活用**: 型情報、コンポーネントなど既存コードを積極活用
-3. **修正最小化**: 既存コードの修正は真に必要な場合に限定
-
-### Mastra実装
-1. **ドキュメント参照**: MCPでMastraドキュメント・実装例を必ず確認
-2. **ベストプラクティス**: 正確な情報に基づいて実装
-3. **プロンプト品質**: 経験豊富なプロンプトエンジニアレベルで英語作成
-
-### UI実装
-1. **品質基準**: 市場投入可能レベルのUI
-2. **ライブラリ優先順位**: MUI第一優先 → shadcn/ui → カスタム実装
-3. **ライブラリ選定**: 安定稼働バージョンを採用
-
-## アーキテクチャ設計原則
-
-### 状態管理パターン
-- **ユーザー別状態**: クラス利用（将来のWebアプリ対応）
-- **アプリ全体状態**: シングルトン変数・関数
-
-### 型安全性
-- **TypeScript厳密**: 型安全なコード必須
-- **外部API**: zodスキーマでバリデーション必須
-- **IPC通信**: 型定義による安全性確保
-
-### コンポーネント設計
-- **関数コンポーネント**: Arrow function推奨
-- **プロップス**: デストラクチャリングでデフォルト値設定
-- **再利用性**: common/ディレクトリで共通コンポーネント管理
-
-## 品質基準
-
-### コード品質
-- **ESLint**: 単純フォーマットエラー無視、重要エラーは修正必須
-- **TypeScript**: 型エラーゼロ必須
-- **コメント**: 日本語でコード説明、英語でプロンプト
-
-### テスト方針
-- **基本方針**: 明確指示なしではテスト作成不要
-- **テスト実行**: 指示されない限り実行・修正不要
-- **テストスタイル**: 古典派（振る舞い単位）、日本語説明
-
-### セキュリティ
-- **秘匿情報**: シークレット・キーの露出・ログ出力禁止
-- **コミット**: シークレット・キーのコミット禁止
-
-## 開発効率化
-
-### ファイル作成方針
-- **新ファイル**: 絶対必要な場合のみ作成
-- **既存ファイル編集**: 優先
-- **ドキュメント**: 明確指示なしでは作成禁止
-
-### ライブラリ利用
-- **React**: 積極的にライブラリ活用
-- **安定性**: stable版採用
-- **依存関係**: package.jsonで事前確認
-
-## 言語使用方針
-- **プロンプト**: 英語（自然で一般的な表現）
-- **コメント**: 日本語
-- **UI文言**: 日本語（ユーザー向け）
-- **ログメッセージ**: 英語または日本語
\ No newline at end of file
diff --git a/.serena/memories/project_overview.md b/.serena/memories/project_overview.md
deleted file mode 100644
index 2f3a0b270..000000000
--- a/.serena/memories/project_overview.md
+++ /dev/null
@@ -1,34 +0,0 @@
-# AIKATA プロジェクト概要
-
-## プロジェクトの目的
-AIKATAは、AIデスクトップアプリケーションで以下の機能を提供する：
-
-- **アプリケーション設定機能**: AI APIのURL・キー、チャット機能のユーザーカスタムシステムプロンプト、MCPサーバー設定、DB（SQLite）のパス、Redmine・GitLabのAPI・アクセストークン、ドキュメント登録用ディレクトリの設定
-- **ドキュメント登録機能**: word、excel、pdf、txtのようなファイルからテキストを抽出し、AI機能で利用できるようにする
-- **チャット機能**: AIエージェントがドキュメント検索、GitLab操作、Redmine操作、MCP連携ツールを使ってユーザーの指示に対応
-- **ドキュメントレビュー機能**: チェックリストをドキュメントから抽出し、そのリストでレビュー実行
-
-## 技術スタック
-
-### コアテクノロジー
-- **フレームワーク**: Electron（electron-react-boilerplate） + React + TypeScript
-- **UI**: Material-UI (MUI) + shadcn/ui
-- **データベース**: SQLite（Drizzle ORM）
-- **AIフレームワーク**: Mastra（エージェント・ワークフロー管理）
-- **バンドラー**: Webpack
-- **テスト**: Jest + Testing Library
-
-### 開発ツール
-- **ESLint**: 'erb' config基盤、TypeScript対応
-- **Prettier**: シングルクォート設定
-- **TypeScript**: 厳密設定（strict: true）
-
-## プロジェクト構造
-```
-src/
-├── main/           # Electronメインプロセス
-├── renderer/       # Reactフロントエンド
-├── mastra/         # Mastra AI統合
-├── db/            # データベース層
-└── __tests__/     # テストファイル
-```
\ No newline at end of file
diff --git a/.serena/memories/suggested_commands.md b/.serena/memories/suggested_commands.md
deleted file mode 100644
index 73151a2ce..000000000
--- a/.serena/memories/suggested_commands.md
+++ /dev/null
@@ -1,81 +0,0 @@
-# 推奨コマンド
-
-## 開発環境
-```bash
-# 開発サーバー起動
-npm start
-
-# Mastra開発モード
-npm run mastra:dev
-```
-
-## 品質管理
-```bash
-# TypeScript型チェック
-npm run check
-
-# ESLint実行（全体）
-npm run lint
-
-# ESLint修正（全体）
-npm run lint:fix
-
-# ESLintバックエンドのみ
-npm run lint:backend
-
-# ESLintバックエンド修正
-npm run lint:backend:fix
-
-# Prettier実行
-npm run format
-
-# テスト実行
-npm test
-```
-
-## データベース関連
-```bash
-# スキーマ生成
-npm run db:generate
-
-# DBプッシュ
-npm run db:push
-
-# マイグレーション（生成+プッシュ）
-npm run db:migrate
-
-# DBセットアップ
-npm run db:prepare
-
-# Drizzle Studio起動
-npm run db:studio
-```
-
-## ビルド・デプロイ
-```bash
-# プロダクションビルド
-npm run build
-
-# Electronパッケージ作成
-npm run package
-```
-
-## システムユーティリティ（macOS）
-```bash
-# ファイル一覧表示
-ls -la
-
-# ディレクトリ移動
-cd [path]
-
-# ファイル検索
-find . -name "*.ts" -type f
-
-# テキスト検索
-grep -r "search_term" src/
-
-# Git操作
-git status
-git add .
-git commit -m "message"
-```
\ No newline at end of file
diff --git a/.serena/memories/task_completion_workflow.md b/.serena/memories/task_completion_workflow.md
deleted file mode 100644
index bb960720f..000000000
--- a/.serena/memories/task_completion_workflow.md
+++ /dev/null
@@ -1,70 +0,0 @@
-# タスク完了時のワークフロー
-
-## 必須チェック項目
-
-### 1. コード品質チェック
-```bash
-# TypeScript型チェック実行
-npm run check
-
-# ESLint実行・修正
-npm run lint
-npm run lint:fix  # エラーがある場合
-```
-
-### 2. テスト実行
-```bash
-# テストスイート実行
-npm test
-```
-
-### 3. データベースマイグレーション（必要な場合）
-```bash
-# スキーマ変更がある場合
-npm run db:migrate
-```
-
-### 4. ビルド確認
-```bash
-# プロダクションビルドが通るか確認
-npm run build
-```
-
-## コード品質基準
-
-### TypeScript
-- **型エラーゼロ**: `npm run check`でエラーなし
-- **厳密な型定義**: `any`の使用を避ける
-- **型安全**: 全ての外部APIレスポンスはzodでバリデーション
-
-### ESLint
-- **単純フォーマットエラー**: 対応不要
-- **重要なエラー**: 必ず修正（型安全性、セキュリティ関連）
-
-### テスト
-- **新機能**: 明確な指示がない限りテスト作成不要
-- **既存テスト**: 修正・実行不要（指示されない限り）
-- **カバレッジ**: 100%目標（テスト作成時のみ）
-
-## 実装完了基準
-
-### フロントエンド
-- **UI品質**: 市場投入可能レベル
-- **レスポンシブ**: MUIのGrid/Flexboxを活用
-- **アクセシビリティ**: 基本的なaria属性設定
-
-### バックエンド・統合
-- **エラーハンドリング**: 適切な例外処理
-- **ログ出力**: electron-log使用
-- **IPC通信**: 型安全な通信確保
-
-### Mastra統合
-- **プロンプト**: 英語でベストプラクティス準拠
-- **ツール定義**: 型安全な入出力スキーマ
-- **エージェント**: 適切なシステムプロンプト設定
-
-## 注意事項
-- **テスト**: 指示されない限り実行・修正不要
-- **ドキュメント**: 明確な指示がない限り作成不要
-- **既存コード修正**: 真に必要な場合に限定
-- **ライブラリ追加**: 安定版を採用
\ No newline at end of file
diff --git a/.serena/project.yml b/.serena/project.yml
deleted file mode 100644
index 6df9d2f23..000000000
--- a/.serena/project.yml
+++ /dev/null
@@ -1,47 +0,0 @@
-project_name: "my-awesome-project"
-language: typescript  # python, rust, go, java など
-entry_points:
-  - src/index.ts
-  - src/app.ts
-ignored_dirs:
-  - .claude
-  - .github
-  - .serena
-  - .vscode
-  - assets
-  - db
-  - source
-  - dowonloads
-  - local_docker
-  - release/app/node_modules
-  - release/app/dist
-  - release/build
-  - release/db
-  - src/node_modules
-  - node_modules
-  - .erb/node_modules
-  - .erb/dll
-  - .git
-  - dist
-  - coverage
-  - __pycache__
-  - public/images  # 画像ディレクトリを除外
-  - docs/pdfs      # PDFドキュメントを除外
-ignored_files:
-  - "*.log"
-  - "*.tmp"
-  - ".env*"
-  - "*.jpg"
-  - "*.png"
-  - "*.pdf"
-  - "*.zip"
-max_file_size: 1048576  # 1MB（バイナリも含む総バイト数）
-show_logs: true
-use_lsp: true
-# セキュリティ設定
-security:
-  exclude_sensitive:
-    - "**/*.key"
-    - "**/*.pem"
-    - "**/secrets/**"
-  sanitize_logs: true
diff --git a/AGENTS.md b/AGENTS.md
new file mode 100644
index 000000000..34799f515
--- /dev/null
+++ b/AGENTS.md
@@ -0,0 +1,234 @@
+# CLAUDE.md
+
+このファイルは、Claude Code (claude.ai/code) がこのリポジトリでコードを作業する際のガイダンスを提供します。
+
+## 共通コマンド
+
+### 開発環境
+```bash
+npm start
+```
+
+### リント・フォーマット
+```bash
+npm run check # TypeScriptの型チェック
+```
+加えて、IDEからのエラー情報も読み取るようにしてください
+
+### テスト
+```bash
+npm test
+```
+
+## アーキテクチャ概要
+
+### プロジェクト構成
+本プロジェクト「AIKATA」は、Electron製のAIデスクトップアプリケーションで、以下の機能を提供する
+- アプリケーション設定機能
+  - 以下を設定できる
+  - アプリ内で利用するAI APIのURL・キー
+  - 後述のチャット機能のユーザカスタムシステムプロンプト
+  - MCPサーバ設定
+   - チャット機能で利用可能なMCPサーバを指定する
+  - アプリが利用するDB（ローカルにSQLiteとして保存）のパス
+    - DBにはチャット履歴やドキュメントの要約情報（チャット機能でシステムプロンプトに検索可能なドキュメントを提示するために利用する）を保存する
+  - Redmine・GitLabのAPI・アクセストークン
+    - チャット機能で利用
+  - ドキュメント登録用ディレクトリ
+    - チャット機能でAIが参照できるファイルが格納されてあるディレクトリを指定
+- ドキュメント登録機能
+  - チャット機能でユーザが登録したドキュメントから抽出したテキスト情報にアクセスできるようにする
+  - 抽出したテキストはアプリのUserDataディレクトリにファイルキャッシュとして保存
+- チャット機能
+  - AIエージェントが以下のツールを利用しながらユーザの指示に対応する
+    - ドキュメント検索ツール
+      - 指定したドキュメント登録用ディレクトリ内にあるファイルをAIが参照することができる
+        - 厳密には、ドキュメント検索ツール(該当ディレクトリ内ファイルを読み込んだ別のAIエージェントに質問することができるツール)をチャット用AIエージェントに使わせることができる
+    - GitLab操作ツール
+    - Redmine操作ツール
+    - MCP連携
+- ドキュメントレビュー機能
+  - チェックリストをあるドキュメントから抽出して、そのリストを元に別のドキュメントのレビューを実行する機能
+    - サブ機能は以下（Mastraのworkflowを利用して実装）
+      - チェックリスト抽出機能
+        - チェックリストドキュメントからのチェックリスト項目抽出機能
+        - 一般ドキュメントからのチェックリスト項目作成機能
+      - （上記で抽出したチェックリスト項目に対して）ドキュメントレビュー実行機能
+    - ユーザは対象ドキュメントをファイルアップロード形式で指定する
+       - 基本的にはアップロードされたファイルはテキスト抽出処理が実行され、後続のworkflow処理で利用される
+         - ただし、PDFファイルについてはテキスト抽出か画像として処理するか選択することができる
+           - 画像にした場合は図なども認識させることができるため
+### 技術スタック
+- **フレームワーク**: Electron(electron-react-boilerplate) + React + TypeScript
+- **UI**: Material-UI (MUI)
+- **データベース**: SQLite (Drizzle ORM)  
+- **AIフレームワーク**: Mastra（エージェント・ワークフロー管理）
+- **バンドラー**: Webpack
+- **テスト**: Jest + Testing Library
+
+### アーキテクチャ階層
+
+#### 1. Electronプロセス
+- **メインプロセス** (`src/main/main.ts`): アプリケーションのエントリーポイント、IPC通信管理
+- **レンダラープロセス** (`src/renderer/`): Reactベースのフロントエンド UI
+  - レイアウトは`src/renderer/App.tsx`で定義しており、各機能はsrc/renderer/components/sidebar/SidebarHeader.tsxで切り替え
+
+#### 2. Mastraフレームワーク統合 (`src/mastra/`)
+- **エージェント**（`src/mastra/agents`）: 特定のタスクを実行するAgent
+- **ツール**（`src/mastra/tools`）: 外部システム（GitLab、Redmine、MCP）との統合
+- **ワークフロー**（`src/mastra/workflows`）: 複雑なタスクの自動化フロー
+
+#### 3. データベース層 (`src/db/`)
+- **スキーマ**（`src/db/schema.ts`）: Drizzleで定義されたテーブル構造
+- **リポジトリ**（`src/db/repository`）: データアクセス層
+- SQLiteベースの軽量データベース
+
+#### 4. サービス層 (`src/main/service/`)
+- **ChatService**: チャット機能のビジネスロジック
+- **ReviewService**: レビュー機能のビジネスロジック  
+- **SettingsService**: アプリケーション設定管理
+
+### IPC通信パターン
+ElectronのIPCを使用してフロントエンド・バックエンド間の通信を実装。チャネル定義は`src/main/types/ipc.ts`で管理。
+
+### 設定管理
+- Electron-storeを使用したアプリケーション設定の永続化
+- 環境変数とランタイム設定の分離
+
+### その他代表的なフォルダ・ファイル
+- `src/types`：アプリで利用する型・zodスキーマの定義
+  - `src/types/index.ts`：アプリ全体で利用する型定義のエントリーポイント（ただし、個別の機能等で型を定義する場合は各機能ディレクトリに作成しているので別途参照が必要）
+  - `src/types/ipc.ts`：Electron IPC通信で利用する型定義
+  - `src/types/eventPush.ts`: Main側からのイベントプッシュで利用する型定義
+- `src/adapters`: portの実装
+  - `src/adapters/db/drizzle`: drizzleのスキーマ定義、repository実装
+- `src/main`: Electronのメインプロセス関連のコード
+  - `src/main.ts`: Electronのメインプロセスのエントリポイント、IPC通信のハンドラの具体的な処理の定義やアプリケーションの初期化処理などを含む
+  - `src/main/preload.ts`: ElectronのPreloadスクリプト、レンダラープロセスに公開するハンドラを定義(rendererとの境界にあたるため、ここで一元的にエラーハンドリングを実施している)
+  - `src/main/store.ts`: electron-storeを利用してアプリケーションの設定や状態の保存・取得を行う、ここではstoreの初期化や設定の定義を行う
+  - `src/main/service`: サービス（コア）ロジック
+  - `src/mian/service/port`: 外部通信の抽象
+    - `src/mian/service/port/repository`: 外部DB通信（リポジトリ）の抽象
+  - `src/main/push`: Main側からのイベントプッシュ関連コード
+    - `src/main/push/InProcBroker.ts`: イベントを蓄積するBroker
+    - `src/main/push/electronPushBroker.ts`: イベント購読についてelectron固有の差異を吸収するBroker
+  - `src/main/lib`: メインプロセスで利用するライブラリ群
+    - `src/main/lib/eventPayloadHelper.ts`: イベントをpushする際のヘルパーを提供
+    - `src/main/lib/logger.ts`: アプリ内で利用するロガーを提供
+    - `src/mian/lib/error.ts`: アプリで利用するエラー定義
+    - `src/main/lib/message.ts`: アプリ内で利用するメッセージテンプレートを解決し、メッセージを提供する関数を提供（メッセージテンプレートはこちら`src/messages/ja/template.ts`）
+    - `src/main/lib/utils/fileExtractor.ts`: 登録されたソースのテキスト情報を抽出する関数
+- `src/renderer/components`：Reactコンポーネント
+  - `src/renderer/components/chat`: チャット機能のコンポーネント
+  - `src/renderer/components/review`: レビュー機能のコンポーネント
+  - `src/renderer/components/chat`: チャット機能のコンポーネント
+  - `src/renderer/components/common`: アプリ共通のコンポーネント
+  - `src/renderer/components/sidebar`: サイドバー共通のコンポーネント
+  - `src/renderer/hooks`: フック定義をまとめたディレクトリ
+    - `src/renderer/hooks/usePushChannel.ts`: イベント購読をする際に利用するフック（コンポーネントが常時通信をSSEでデータを受け取れるようにしたい場合に利用）
+    - `src/renderer/hooks/useSettings.ts`: 設定情報を利用したい場合に利用するフック
+  - `src/renderer/service`: フロントエンドから利用するサービス層で、外部アクセスロジックもここで管理する(~Api.ts)
+  - `src/renderer/stores`: zustandで管理するstate定義
+    - `src/renderer/stores/alertStore.ts`: renderer側のユーザに表示するアラートメッセージを一元管理する、addAlertを公開しており、これを利用してalertを追加するとエラーを表示できる
+  - `src/renderer/lib/ElectronPushClient.ts`: 直接イベント購読したい際に利用するクライアントクラス（`usePushChannel.ts`についても内部でこのクラスを利用している、一度だけSSEでデータを受信したい場合などにも利用）
+  - `src/renderer/lib/error.ts`: Renderer側で利用するエラーの定義
+- `src/mastra`: Mastraを利用したAI関連のコード
+  - `src/mastra/agents/prompt.ts`: Mastraのエージェントのプロンプト定義を一箇所に集約（エージェントやワークフロー内で利用するプロンプトを定義）
+  - `src/mastra/agents/orchestrator.ts`: 汎用チャット機能で利用するAIエージェントの定義
+  - `src/mastra/workflows`: Mastraのワークフロー定義
+    - `src/mastra/workflows/sourceRegistration`: ドキュメントのテキスト抽出用のワークフロー定義
+    - `src/mastra/workflows/sourceReview`: ドキュメントレビュー用のワークフロー定義
+    - `src/mastra/workflows/types.ts`: ワークフローで利用する型定義
+    - `src/mastra/workflows/schema.ts`: ワークフローで利用するzodスキーマ定義（ワークフローを作成する際は、各Stepのoutputschemaは必ず本ファイル内に定義されているbaseStepOutputSchemaを継承するようにしてください）
+
+## テスト作成時の注意
+- 明確な指示がある場合以外はテストコードを作成しないこと
+- 外部ライブラリとの結合をテストする場合はできるだけ実際のライブラリを使用すること
+  - 実際のライブラリの利用が難しい場合はモックを利用すること
+  - Electron IPCはモックを利用すること
+    - モックの実装はsrc/__tests__/test-utils/mockElectronHandler.tsに集約させること
+- 下記の観点からテストを作成すること
+  - ビジネス的な観点
+    - 正常系
+    - 異常系
+  - 技術的な観点
+    - 正常系
+    - 異常系
+- テストに関連するプロダクトコードのカバレッジを100%にすること
+- テスト関連コードはsrc/__test__に配置すること
+- テストは古典派的なスタイルで記述すること
+  - つまり、単体テストはクラス単位ではなく、一つの振る舞い単位で記述すること
+- テストの説明は日本語で記述すること
+  - テストの説明は、何をテストしているのか、どのような条件でテストが行われるのかを明確に記述すること
+- テストの書き方で不明点があれば次のディレクトリ配下のテストコードを参考にすること
+  - src/__tests__/integration
+
+## 実装上の注意
+- Mastraについては実装する際はまずMCPでドキュメントや実装例を参考にしてから正確な情報やベストプラクティスに基づいてコーディングすること
+- Mastra workflowの各Stepの処理について既存のスタイルを踏襲すること
+- プロジェクト全体を把握して、全ての実装が必要箇所を正しく洗い出してから実装すること
+- 既存資源（型情報やコンポーネントなど）を積極的に活用して効率的に実装すること
+  - 既存のコードの修正は真に必要な場合に限ること
+- UIは実際に市場に投入できるくらいレベルの高いUIにすること
+- TypeScriptを利用して型安全なコードにすること
+- プロンプトは英語で記載すること
+  - プロンプトの内容は経験豊富なプロンプトエンジニアとしてベストプラクティスに基づいて実装すること
+  - 一般的で自然な英語表現にすること
+- コードのコメントは日本語で記載すること
+- Reactライブラリが使えるのであれば積極的に利用すること
+    - 特にUIについてはMUIを第一優先に使い、カスタマイズしたい場合はshadcn/uiを利用すること
+    - ライブラリを追加する際は安定稼働バージョンを採用すること
+- eslintについては単純なフォーマットエラーの場合は対応する必要はない
+- IDEからエラー内容を読み取り、必要があれば確り対応すること
+- MainプロセスでのIPC処理について、`src/main.ts`のhandleIpcにてエラーを一元管理しているため、IPCハンドラ内のサービスロジックにおいては基本的にはエラーをtry-catchしてハンドリングする必要はない
+  - ただし、ユーザにエラーメッセージを通知する必要がある場合は適切なエラーハンドリングの下、`src/mian/lib/error.ts`にて提供されているAppErrorをthrowすること
+- フロントエンドから外部（IPC）通信する場合は`src/renderer/service/~Api.ts`を経由すること
+  - 新規にサービスクラスを作成する場合は既存ロジックを参考にして作成すること
+- サーバからイベントをpushする際は`src/main/lib/eventPayloadHelper.ts`を利用すること
+- フロントエンドでイベントを購読する際は`usePushChannel`もしくは`ElectronPushClient`を利用すること
+  - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
+- フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
+- このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
+- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+- テストについては指示されない限り、実行も修正もしなくてよい
+
+## 依頼タスク
+### 前提知識
+- レビュー実行では、レビュー対象ドキュメントを同時に複数選択できる
+  - この場合、個々の選択ドキュメントは選択順に結合され（以下、結合ドキュメントと呼ぶ）AIに渡される(`src/mastra/lib/util.ts`)
+
+### 要件
+ - レビュー実行時に「少量ドキュメント」か「大量ドキュメント」か選択できるようにする 
+   - 目的
+     - レビュー実行の際に、結合ドキュメントがAIのコンテキスト長を超えてしまっていてもレビュー可能にする
+   - 機能
+     - 少量ドキュメント
+       - 現状通り、結合ドキュメントをそのままレビュー用AIの入力コンテキストに与える
+     - 大量ドキュメント
+       - まず、個々のドキュメントに対してトピックとそのトピックの要約を生成する
+       - これらトピックと要約を全てのドキュメント合わせて結合させたものをレビュー用AIの入力コンテキストに与える
+       - レビュー用AIについては、個々のドキュメントのトピックと要約しか知ることができないのので、チェックリストに対する質問ができるように質問用のtoolを利用できるようにする
+         - 質問用toolは対象のチェックリストとドキュメントID(workflow用に一時的に付与)と質問文を引数として与えると質問回答用のAIが対象ドキュメントを基に回答を生成してくれるというものである(似たような仕組みをチャット機能の`src/mastra/tools/sourcesTools.ts`で利用しているので参考にすること)     
+
+### 実装方針
+以下のようなworkflowを構築する
+1. レビュー対象のドキュメントのテキスト抽出を実行するstepを実行
+  - imageDataはもともとbase64が入るのでそのまま
+2. チェックリストをカテゴリ分割するstepを実行(現在の`classifyChecklistsByCategoryStep`)
+3. 次に少量ドキュメントか大量ドキュメントかで処理を分岐
+  3-a. 少量ドキュメントの場合
+    3-a-1. 現状通り結合ドキュメントをそのままレビュー用AIの入力コンテキストに与えて、カテゴリごとにレビューさせる
+  3-b. 大量ドキュメントの場合
+    3-b-1. 個々のドキュメントの要約とトピック抽出
+    3-b-2. レビュー用AIの組み立て(step内での動的なtool作成)を実施、個々のドキュメントの要約とトピックを組み合わせたものを初期の入力コンテキストとして与えてレビューさせる
+
+### 実装時の注意点
+- 次のようなフォルダ構成にする
+src/mastra/workflows/
+├── sourceReview/
+│   ├── index.ts  # 各Stepのimportとワークフローの組み立て
+│   ├── ~Step.ts  # workflowのstep定義
+│   ├── ~Step.ts. # workflowのstep定義
+│   └── ...
+- 今回のように初期の入力コンテキストには質問可能なドキュメントの要約を与えて、そのドキュメントに対する質問をtoolで実行させる例につちえはチャット機能のドキュメント検索toolを参考にすること
+- mastraのAIエージェントに関する実装スタイルは既存のコードを参考にすること
diff --git a/CLAUDE.md b/CLAUDE.md
index 3bd0f2205..ddfa22d20 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -20,15 +20,6 @@ npm run check # TypeScriptの型チェック
 npm test
 ```
 
-### データベース関連
-```bash
-npm run db:generate
-npm run db:push
-npm run db:migrate
-npm run db:prepare
-npm run db:studio
-```
-
 ## アーキテクチャ概要
 
 ### プロジェクト構成
@@ -63,6 +54,14 @@ npm run db:studio
         - チェックリストドキュメントからのチェックリスト項目抽出機能
         - 一般ドキュメントからのチェックリスト項目作成機能
       - （上記で抽出したチェックリスト項目に対して）ドキュメントレビュー実行機能
+        - 少量ドキュメントのレビュー機能
+          - 与えられたドキュメントを全てレビュー用AIのコンテキストに与える
+        - 大量ドキュメントレビュー機能
+          - 以下のようなworkflowでレビューを実行
+            - まず、個々のドキュメントに対してトピックとそのトピックの要約を生成する
+            - チェックリストをレビューするために、個々のドキュメントに対する質問とその応答をそれぞれ十分だと判断されるまで生成させる
+            - 最終的にトピック・要約、質問・応答を全てレビュー用AIの入力コンテキストに与えてレビューさせる
+      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つのドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
     - ユーザは対象ドキュメントをファイルアップロード形式で指定する
        - 基本的にはアップロードされたファイルはテキスト抽出処理が実行され、後続のworkflow処理で利用される
          - ただし、PDFファイルについてはテキスト抽出か画像として処理するか選択することができる
@@ -109,12 +108,15 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
   - `src/types/index.ts`：アプリ全体で利用する型定義のエントリーポイント（ただし、個別の機能等で型を定義する場合は各機能ディレクトリに作成しているので別途参照が必要）
   - `src/types/ipc.ts`：Electron IPC通信で利用する型定義
   - `src/types/eventPush.ts`: Main側からのイベントプッシュで利用する型定義
-- `src/db`: データベース定義（スキーマやDB接続情報）
-- `src/repository`: データアクセス層
+- `src/adapters`: portの実装
+  - `src/adapters/db/drizzle`: drizzleのスキーマ定義、repository実装
 - `src/main`: Electronのメインプロセス関連のコード
   - `src/main.ts`: Electronのメインプロセスのエントリポイント、IPC通信のハンドラの具体的な処理の定義やアプリケーションの初期化処理などを含む
   - `src/main/preload.ts`: ElectronのPreloadスクリプト、レンダラープロセスに公開するハンドラを定義(rendererとの境界にあたるため、ここで一元的にエラーハンドリングを実施している)
   - `src/main/store.ts`: electron-storeを利用してアプリケーションの設定や状態の保存・取得を行う、ここではstoreの初期化や設定の定義を行う
+  - `src/main/service`: サービス（コア）ロジック
+  - `src/mian/service/port`: 外部通信の抽象
+    - `src/mian/service/port/repository`: 外部DB通信（リポジトリ）の抽象
   - `src/main/push`: Main側からのイベントプッシュ関連コード
     - `src/main/push/InProcBroker.ts`: イベントを蓄積するBroker
     - `src/main/push/electronPushBroker.ts`: イベント購読についてelectron固有の差異を吸収するBroker
@@ -171,7 +173,7 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
 
 ## 実装上の注意
 - Mastraについては実装する際はまずMCPでドキュメントや実装例を参考にしてから正確な情報やベストプラクティスに基づいてコーディングすること
-- Mastra workflowの作成時は既存のスタイルを踏襲すること
+- Mastra workflowの各Stepの処理について既存のスタイルを踏襲すること
 - プロジェクト全体を把握して、全ての実装が必要箇所を正しく洗い出してから実装すること
 - 既存資源（型情報やコンポーネントなど）を積極的に活用して効率的に実装すること
   - 既存のコードの修正は真に必要な場合に限ること
@@ -195,16 +197,15 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
   - コンポーネントで常にSSEの通信を張ってデータを取得したい場合は`usePushChannel`を、一時的にSSEの通信を貼りたい場合は`ElectronPushClient`を利用
 - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
 - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
-- DB用の型(`src/db/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
+- DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
 - テストについては指示されない限り、実行も修正もしなくてよい
+- 適宜調査や実装の際に必要あればcodex mcpを活用すること
+
 
 ## 依頼タスク
-### 要件
-- テキスト抽出処理(`src/main/lib/fileExtractor.ts`)、キャッシュ有無のオプションを廃止、デフォルトでキャッシュするように変更
-  - キャッシュはJsonオブジェクトに変更
-    - オブジェクトにはメタデータ（ファイルパス、ファイルの最終更新日時）を付与する
-    - ファイル名は現在と同様にファイルパスのハッシュ値をもとに生成した文字列とする
-  - ファイルの最終更新日時が変更されていた場合はキャッシュを破棄し、再度テキスト抽出処理を実行する
-  - 起動時のmain.tsでキャッシュディレクトリのクリーニング処理を実施
-    - 抽出元のファイルが削除された場合、最新版と最終更新日時がずれているキャッシュについては削除
-    - ただし、キャッシュディレクトリのパスは`src/main/lib/fileExtractor.ts`で一元管理すること
+- チェックリスト結果の表のヘッダーは、複数ファイルがレビュー対象として選択された場合は、それぞれのファイル名を`/`で結合した文字列となるが、大量ファイルが選択された場合、ヘッダが巨大にならないようにする
+  - 適切にスクロール表示されるようにする(最大3行くらいかな)
+
+### タスク実装時の注意点
+- 該当コンポーネント：`src/renderer/components/review/ReviewChecklistSection.tsx`
+- 複雑な処理なので、十分に思考して実装すること
diff --git a/src/db/index.ts b/src/adapter/db/drizzle/index.ts
similarity index 94%
rename from src/db/index.ts
rename to src/adapter/db/drizzle/index.ts
index 90d993f1e..bf2e952ff 100644
--- a/src/db/index.ts
+++ b/src/adapter/db/drizzle/index.ts
@@ -3,8 +3,8 @@ import { join } from 'path';
 import { drizzle, type LibSQLDatabase } from 'drizzle-orm/libsql';
 import { migrate } from 'drizzle-orm/libsql/migrator';
 import * as schema from './schema';
-import { getStore } from '../main/store';
-import { toAbsoluteFileURL } from '../main/lib/util';
+import { getStore } from '@/main/store';
+import { toAbsoluteFileURL } from '@/main/lib/util';
 
 // データベースの型定義
 type Database = LibSQLDatabase<typeof schema>;
diff --git a/src/adapter/db/drizzle/repository/index.ts b/src/adapter/db/drizzle/repository/index.ts
new file mode 100644
index 000000000..b908a5531
--- /dev/null
+++ b/src/adapter/db/drizzle/repository/index.ts
@@ -0,0 +1,3 @@
+export * from './sourceRepository';
+export * from './reviewRepository';
+export * from './settingsRepository';
diff --git a/src/main/repository/reviewRepository.ts b/src/adapter/db/drizzle/repository/reviewRepository.ts
similarity index 83%
rename from src/main/repository/reviewRepository.ts
rename to src/adapter/db/drizzle/repository/reviewRepository.ts
index a83432598..572c1e214 100644
--- a/src/main/repository/reviewRepository.ts
+++ b/src/adapter/db/drizzle/repository/reviewRepository.ts
@@ -5,8 +5,8 @@ import {
   reviewChecklistResults,
   ReviewChecklistEntity,
   ReviewHistoryEntity,
-} from '../../db/schema';
-import getDb from '../../db';
+} from '../schema';
+import getDb from '..';
 import type {
   RevieHistory,
   ReviewChecklist,
@@ -17,69 +17,13 @@ import type {
   ProcessingStatus,
 } from '@/types';
 import { AppError } from '@/main/lib/error';
-import { repositoryError } from './error';
-
-/**
- * ドキュメントレビューで利用するDBアクセス用のインターフェース
- */
-export interface IReviewRepository {
-  // レビュー履歴
-  createReviewHistory(title: string, id?: string): Promise<RevieHistory>;
-  getReviewHistory(id: string): Promise<RevieHistory | null>;
-  getAllReviewHistories(): Promise<RevieHistory[]>;
-  updateReviewHistoryTitle(id: string, title: string): Promise<void>;
-  updateReviewHistoryAdditionalInstructionsAndCommentFormat(
-    id: string,
-    additionalInstructions?: string,
-    commentFormat?: string,
-  ): Promise<void>;
-  updateReviewHistoryEvaluationSettings(
-    id: string,
-    evaluationSettings?: CustomEvaluationSettings,
-  ): Promise<void>;
-  updateReviewHistoryProcessingStatus(
-    id: string,
-    processingStatus: ProcessingStatus,
-  ): Promise<void>;
-  deleteReviewHistory(id: string): Promise<void>;
-
-  // チェックリスト
-  createChecklist(
-    reviewHistoryId: string,
-    content: string,
-    createdBy: ReviewChecklistCreatedBy,
-  ): Promise<void>;
-  getChecklists(reviewHistoryId: string): Promise<ReviewChecklist[]>;
-  updateChecklist(id: number, content: string): Promise<void>;
-  deleteChecklist(id: number): Promise<void>;
-  deleteSystemCreatedChecklists(reviewHistoryId: string): Promise<void>;
-
-  // レビュー結果
-  upsertReviewResult(
-    results: {
-      reviewChecklistId: number;
-      evaluation: ReviewEvaluation;
-      comment: string;
-      fileId: string;
-      fileName: string;
-    }[],
-  ): Promise<void>;
-  deleteReviewResults(
-    reviewChecklistId: number,
-    sourceId: number,
-  ): Promise<void>;
-  getReviewChecklistResults(
-    reviewHistoryId: string,
-  ): Promise<ReviewChecklistResult[]>;
-  deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
-}
-
-let reviewRepository: IReviewRepository | null = null;
+import { repositoryError } from '@/main/lib/error';
+import { IReviewRepository } from '@/main/service/port/repository';
 
 /**
  * Drizzle ORM を使用したレビューリポジトリの実装
  */
-class DrizzleReviewRepository implements IReviewRepository {
+export class DrizzleReviewRepository implements IReviewRepository {
   convertReviewChecklistEntityToReviewChecklist(
     reviewChecklistEntity: ReviewChecklistEntity,
   ): ReviewChecklist {
@@ -102,7 +46,8 @@ class DrizzleReviewRepository implements IReviewRepository {
       additionalInstructions: reviewHistoryEntity.additionalInstructions,
       commentFormat: reviewHistoryEntity.commentFormat,
       evaluationSettings: null,
-      processingStatus: (reviewHistoryEntity.processingStatus || 'idle') as ProcessingStatus,
+      processingStatus: (reviewHistoryEntity.processingStatus ||
+        'idle') as ProcessingStatus,
       createdAt: reviewHistoryEntity.createdAt,
       updatedAt: reviewHistoryEntity.updatedAt,
     } as RevieHistory;
@@ -219,10 +164,7 @@ class DrizzleReviewRepository implements IReviewRepository {
         })
         .where(eq(reviewHistories.id, id));
     } catch (err) {
-      throw repositoryError(
-        'レビューの評定項目設定の更新に失敗しました',
-        err,
-      );
+      throw repositoryError('レビューの評定項目設定の更新に失敗しました', err);
     }
   }
 
@@ -460,14 +402,3 @@ class DrizzleReviewRepository implements IReviewRepository {
     }
   }
 }
-
-/**
- * ドキュメントレビュー用のリポジトリを取得
- * @returns ReviewRepositoryのインスタンス
- */
-export function getReviewRepository(): IReviewRepository {
-  if (!reviewRepository) {
-    reviewRepository = new DrizzleReviewRepository();
-  }
-  return reviewRepository;
-}
diff --git a/src/main/repository/settingsRepository.ts b/src/adapter/db/drizzle/repository/settingsRepository.ts
similarity index 72%
rename from src/main/repository/settingsRepository.ts
rename to src/adapter/db/drizzle/repository/settingsRepository.ts
index 8e9590332..c0ef0443c 100644
--- a/src/main/repository/settingsRepository.ts
+++ b/src/adapter/db/drizzle/repository/settingsRepository.ts
@@ -1,30 +1,8 @@
 import { z } from 'zod';
 import { Settings, SettingsSchema } from '@/types';
-import { getStore } from '../store';
-import { repositoryError } from './error';
-
-export interface ISettingsRepository {
-  /**
-   * 設定を取得する
-   * @returns 設定情報
-   */
-  getSettings(): Promise<Settings>;
-
-  /**
-   * 設定を保存する
-   * @param settings 保存する設定情報
-   */
-  saveSettings(settings: Settings): Promise<void>;
-}
-
-let SettingsRepository: ISettingsRepository | null = null;
-
-export const getSettingsRepository = (): ISettingsRepository => {
-  if (!SettingsRepository) {
-    SettingsRepository = new ElectronStoreSettingsRepository();
-  }
-  return SettingsRepository;
-};
+import { getStore } from '@/main/store';
+import { repositoryError } from '@/main/lib/error';
+import { ISettingsRepository } from '@/main/service/port/repository';
 
 /** undefined を保存したら例外になるため、delete に切り替える */
 function setOrDelete<T>(store: any, key: string, value: T | undefined) {
@@ -38,7 +16,7 @@ function setOrDelete<T>(store: any, key: string, value: T | undefined) {
 /**
  * Electron Storeを使用した設定リポジトリの実装
  */
-class ElectronStoreSettingsRepository implements ISettingsRepository {
+export class ElectronStoreSettingsRepository implements ISettingsRepository {
   private store = getStore();
 
   async getSettings(): Promise<Settings> {
@@ -62,7 +40,11 @@ class ElectronStoreSettingsRepository implements ISettingsRepository {
       this.store.set('api.url', settings.api.url);
 
       // 任意系は undefined の可能性があるため setOrDelete で処理
-      setOrDelete(this.store, 'source.registerDir', settings.source.registerDir);
+      setOrDelete(
+        this.store,
+        'source.registerDir',
+        settings.source.registerDir,
+      );
 
       setOrDelete(this.store, 'redmine.endpoint', settings.redmine.endpoint);
       setOrDelete(this.store, 'redmine.apiKey', settings.redmine.apiKey);
diff --git a/src/main/repository/sourceRepository.ts b/src/adapter/db/drizzle/repository/sourceRepository.ts
similarity index 66%
rename from src/main/repository/sourceRepository.ts
rename to src/adapter/db/drizzle/repository/sourceRepository.ts
index 7929194e7..1e1855d98 100644
--- a/src/main/repository/sourceRepository.ts
+++ b/src/adapter/db/drizzle/repository/sourceRepository.ts
@@ -1,122 +1,16 @@
 import { eq, inArray, and } from 'drizzle-orm';
-import getDb from '../../db';
-import type { SourceEntity } from '../../db/schema';
-import { sources, topics } from '../../db/schema';
-import { Source, Topic, ProcessStatus } from '@/types';
-import { repositoryError } from './error';
-
-export type InsertSource = Omit<
-  Source,
-  'id' | 'createdAt' | 'updatedAt' | 'status' | 'error' | 'isEnabled'
-> &
-  Partial<Pick<Source, 'status' | 'error' | 'isEnabled'>>;
-
-export type InsertTopic = Omit<
-  Topic,
-  'id' | 'createdAt' | 'updatedAt'
->;
-
-export interface SourceRepository {
-  /**
-   * ソースを取得する
-   * @param sourceId ソースのID
-   * @returns ソース情報
-   */
-  getSourceById(sourceId: number): Promise<Source | null>;
-
-  /**
-   * idで指定された複数ソース取得する
-   * @returns ソースの配列
-   */
-  getSourcesByIds(sourceIds: number[]): Promise<Source[]>;
-
-  /**
-   * 同期処理中のソースを登録または更新する
-   * @param source 登録または更新するソース情報
-   * @returns 登録または更新されたソース情報
-   */
-  initializeProcessingSource(source: InsertSource): Promise<Source>;
-
-  /**
-   * ソース情報を更新する
-   * @param param 更新するソース情報
-   * @param param.id ソースのID
-   * @param param.title ソースのタイトル
-   * @param param.summary ソースの要約
-   * @param param.error エラー情報（nullの場合はエラーなし）
-   * @returns 更新されたソース情報
-   */
-  updateSource(param: {
-    id: number;
-    title: string;
-    summary: string;
-    error: string | null;
-  }): Promise<void>;
-
-  /**
-   * 同期処理情報を更新する
-   */
-  updateProcessingStatus(param: {
-    id: number;
-    status: ProcessStatus;
-    error?: string | null;
-  }): Promise<void>;
-
-  /**
-   * 全ソースの情報をMDのリスト形式で取得する
-   * @param sourceId ソースのID
-   * @returns ソース情報
-   */
-  getSourceListMarkdown(): Promise<string | null>;
-
-  /**
-   * トピックを登録する
-   */
-  registerTopic(topicList: InsertTopic[]): Promise<void>;
-
-  /**
-   * パスで指定されたソースを削除する
-   * @param path ソースのパス
-   * @returns 削除が成功した場合はtrue、存在しない場合はfalse
-   */
-  deleteSourceByPath(path: string): Promise<boolean>;
-
-  /**
-   * ソースをステータスに基づいて複数取得する
-   * @param status ソースのステータス
-   * @returns ソースの配列
-   */
-  getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]>;
-
-  /**
-   * ソースをステータスとパスに基づいて複数取得する
-   */
-  getSourceByPathInStatus(
-    path: string,
-    status: ProcessStatus[],
-  ): Promise<Source[]>;
-
-  /**
-   * ソースを全て取得する
-   */
-  getAllSources(): Promise<Source[]>;
-
-  /**
-   * ソーステーブルへのインサート
-   */
-  insertSources(sourceList: InsertSource[]): Promise<void>;
-
-  /**
-   * ソースの有効/無効を更新する
-   * @param sourceId ソースID
-   * @param enabled 有効/無効
-   */
-  updateSourceEnabled(sourceId: number, enabled: boolean): Promise<void>;
-}
-
-let sourceRepository: SourceRepository | null = null;
-
-class DrizzleSourceRepository implements SourceRepository {
+import getDb from '..';
+import type { SourceEntity } from '../schema';
+import { sources, topics } from '../schema';
+import { Source, ProcessStatus } from '@/types';
+import { repositoryError } from '@/main/lib/error';
+import {
+  ISourceRepository,
+  InsertSource,
+  InsertTopic,
+} from '@/main/service/port/repository';
+
+export class DrizzleSourceRepository implements ISourceRepository {
   convertSourceEntityToSource(entity: SourceEntity): Source {
     return {
       id: entity.id,
@@ -151,8 +45,13 @@ class DrizzleSourceRepository implements SourceRepository {
   async getSourcesByIds(sourceIds: number[]): Promise<Source[]> {
     try {
       const db = await getDb();
-      const sourceEntities =  await db.select().from(sources).where(inArray(sources.id, sourceIds));
-      return sourceEntities.map((entity) => this.convertSourceEntityToSource(entity));
+      const sourceEntities = await db
+        .select()
+        .from(sources)
+        .where(inArray(sources.id, sourceIds));
+      return sourceEntities.map((entity) =>
+        this.convertSourceEntityToSource(entity),
+      );
     } catch (err) {
       throw repositoryError('ドキュメント情報の取得に失敗しました', err);
     }
@@ -328,8 +227,13 @@ class DrizzleSourceRepository implements SourceRepository {
   async getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]> {
     try {
       const db = await getDb();
-      const sourceEntities = await db.select().from(sources).where(inArray(sources.status, status));
-      return sourceEntities.map((entity) => this.convertSourceEntityToSource(entity));
+      const sourceEntities = await db
+        .select()
+        .from(sources)
+        .where(inArray(sources.status, status));
+      return sourceEntities.map((entity) =>
+        this.convertSourceEntityToSource(entity),
+      );
     } catch (err) {
       throw repositoryError('ドキュメント情報の取得に失敗しました', err);
     }
@@ -345,7 +249,9 @@ class DrizzleSourceRepository implements SourceRepository {
         .select()
         .from(sources)
         .where(and(eq(sources.path, path), inArray(sources.status, status)));
-      return sourcesInStatus.map((entity) => this.convertSourceEntityToSource(entity));
+      return sourcesInStatus.map((entity) =>
+        this.convertSourceEntityToSource(entity),
+      );
     } catch (err) {
       throw repositoryError('ドキュメント情報の取得に失敗しました', err);
     }
@@ -355,7 +261,9 @@ class DrizzleSourceRepository implements SourceRepository {
     try {
       const db = await getDb();
       const sourceEntities = await db.select().from(sources);
-      return sourceEntities.map((entity) => this.convertSourceEntityToSource(entity));
+      return sourceEntities.map((entity) =>
+        this.convertSourceEntityToSource(entity),
+      );
     } catch (err) {
       throw repositoryError('ドキュメント情報の取得に失敗しました', err);
     }
@@ -386,10 +294,3 @@ class DrizzleSourceRepository implements SourceRepository {
     }
   }
 }
-
-export function getSourceRepository(): SourceRepository {
-  if (!sourceRepository) {
-    sourceRepository = new DrizzleSourceRepository();
-  }
-  return sourceRepository;
-}
diff --git a/src/db/schema.ts b/src/adapter/db/drizzle/schema.ts
similarity index 100%
rename from src/db/schema.ts
rename to src/adapter/db/drizzle/schema.ts
diff --git a/src/adapter/db/index.ts b/src/adapter/db/index.ts
new file mode 100644
index 000000000..244d3fb47
--- /dev/null
+++ b/src/adapter/db/index.ts
@@ -0,0 +1,41 @@
+import {
+  ISourceRepository,
+  IReviewRepository,
+  ISettingsRepository,
+} from '@/main/service/port/repository';
+import {
+  DrizzleReviewRepository,
+  DrizzleSourceRepository,
+  ElectronStoreSettingsRepository,
+} from './drizzle/repository';
+
+let sourceRepository: ISourceRepository | null = null;
+
+let SettingsRepository: ISettingsRepository | null = null;
+
+let reviewRepository: IReviewRepository | null = null;
+
+export function getSourceRepository(): ISourceRepository {
+  if (!sourceRepository) {
+    sourceRepository = new DrizzleSourceRepository();
+  }
+  return sourceRepository;
+}
+
+export const getSettingsRepository = (): ISettingsRepository => {
+  if (!SettingsRepository) {
+    SettingsRepository = new ElectronStoreSettingsRepository();
+  }
+  return SettingsRepository;
+};
+
+/**
+ * ドキュメントレビュー用のリポジトリを取得
+ * @returns ReviewRepositoryのインスタンス
+ */
+export function getReviewRepository(): IReviewRepository {
+  if (!reviewRepository) {
+    reviewRepository = new DrizzleReviewRepository();
+  }
+  return reviewRepository;
+}
diff --git a/src/main/lib/error.ts b/src/main/lib/error.ts
index f814b0735..750f252b3 100644
--- a/src/main/lib/error.ts
+++ b/src/main/lib/error.ts
@@ -55,6 +55,15 @@ export const internalError = (options?: {
   messageParams?: MessageParams;
 }) => new AppError('INTERNAL', options);
 
+export function repositoryError(detail: string, error: unknown) {
+  return internalError({
+    expose: true,
+    messageCode: 'DATA_ACCESS_ERROR',
+    messageParams: { detail },
+    cause: error,
+  });
+}
+
 /**
  * Zod のエラー → クライアントに安全に出せる形へ
  */
diff --git a/src/main/main.ts b/src/main/main.ts
index 7d05bf1aa..5dede7d6a 100644
--- a/src/main/main.ts
+++ b/src/main/main.ts
@@ -458,6 +458,7 @@ const setupReviewHandlers = () => {
       additionalInstructions,
       commentFormat,
       evaluationSettings,
+      documentMode,
     }) => {
       reviewService.updateReviewInstruction(
         reviewHistoryId,
@@ -476,6 +477,7 @@ const setupReviewHandlers = () => {
         evaluationSettings,
         additionalInstructions,
         commentFormat,
+        documentMode,
       );
 
       if (!result.success) {
diff --git a/src/main/repository/error.ts b/src/main/repository/error.ts
deleted file mode 100644
index 2fdbe8d49..000000000
--- a/src/main/repository/error.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { internalError } from '@/main/lib/error';
-
-export function repositoryError(detail: string, error: unknown) {
-  return internalError({
-    expose: true,
-    messageCode: 'DATA_ACCESS_ERROR',
-    messageParams: { detail },
-    cause: error,
-  });
-}
diff --git a/src/main/service/port/repository/IReviewRepository.ts b/src/main/service/port/repository/IReviewRepository.ts
new file mode 100644
index 000000000..b558873e1
--- /dev/null
+++ b/src/main/service/port/repository/IReviewRepository.ts
@@ -0,0 +1,64 @@
+import {
+  CustomEvaluationSettings,
+  ProcessingStatus,
+  RevieHistory,
+  ReviewChecklist,
+  ReviewChecklistCreatedBy,
+  ReviewChecklistResult,
+  ReviewEvaluation,
+} from '@/types';
+
+/**
+ * ドキュメントレビューで利用するDBアクセス用のインターフェース
+ */
+export interface IReviewRepository {
+  // レビュー履歴
+  createReviewHistory(title: string, id?: string): Promise<RevieHistory>;
+  getReviewHistory(id: string): Promise<RevieHistory | null>;
+  getAllReviewHistories(): Promise<RevieHistory[]>;
+  updateReviewHistoryTitle(id: string, title: string): Promise<void>;
+  updateReviewHistoryAdditionalInstructionsAndCommentFormat(
+    id: string,
+    additionalInstructions?: string,
+    commentFormat?: string,
+  ): Promise<void>;
+  updateReviewHistoryEvaluationSettings(
+    id: string,
+    evaluationSettings?: CustomEvaluationSettings,
+  ): Promise<void>;
+  updateReviewHistoryProcessingStatus(
+    id: string,
+    processingStatus: ProcessingStatus,
+  ): Promise<void>;
+  deleteReviewHistory(id: string): Promise<void>;
+
+  // チェックリスト
+  createChecklist(
+    reviewHistoryId: string,
+    content: string,
+    createdBy: ReviewChecklistCreatedBy,
+  ): Promise<void>;
+  getChecklists(reviewHistoryId: string): Promise<ReviewChecklist[]>;
+  updateChecklist(id: number, content: string): Promise<void>;
+  deleteChecklist(id: number): Promise<void>;
+  deleteSystemCreatedChecklists(reviewHistoryId: string): Promise<void>;
+
+  // レビュー結果
+  upsertReviewResult(
+    results: {
+      reviewChecklistId: number;
+      evaluation: ReviewEvaluation;
+      comment: string;
+      fileId: string;
+      fileName: string;
+    }[],
+  ): Promise<void>;
+  deleteReviewResults(
+    reviewChecklistId: number,
+    sourceId: number,
+  ): Promise<void>;
+  getReviewChecklistResults(
+    reviewHistoryId: string,
+  ): Promise<ReviewChecklistResult[]>;
+  deleteAllReviewResults(reviewHistoryId: string): Promise<void>;
+}
diff --git a/src/main/service/port/repository/ISettingsRepository.ts b/src/main/service/port/repository/ISettingsRepository.ts
new file mode 100644
index 000000000..598d027d7
--- /dev/null
+++ b/src/main/service/port/repository/ISettingsRepository.ts
@@ -0,0 +1,15 @@
+import { Settings } from '@/types';
+
+export interface ISettingsRepository {
+  /**
+   * 設定を取得する
+   * @returns 設定情報
+   */
+  getSettings(): Promise<Settings>;
+
+  /**
+   * 設定を保存する
+   * @param settings 保存する設定情報
+   */
+  saveSettings(settings: Settings): Promise<void>;
+}
diff --git a/src/main/service/port/repository/ISourceRepository.ts b/src/main/service/port/repository/ISourceRepository.ts
new file mode 100644
index 000000000..bd3785949
--- /dev/null
+++ b/src/main/service/port/repository/ISourceRepository.ts
@@ -0,0 +1,107 @@
+import { ProcessStatus, Source, Topic } from '@/types';
+
+export type InsertSource = Omit<
+  Source,
+  'id' | 'createdAt' | 'updatedAt' | 'status' | 'error' | 'isEnabled'
+> &
+  Partial<Pick<Source, 'status' | 'error' | 'isEnabled'>>;
+
+export type InsertTopic = Omit<Topic, 'id' | 'createdAt' | 'updatedAt'>;
+
+export interface ISourceRepository {
+  /**
+   * ソースを取得する
+   * @param sourceId ソースのID
+   * @returns ソース情報
+   */
+  getSourceById(sourceId: number): Promise<Source | null>;
+
+  /**
+   * idで指定された複数ソース取得する
+   * @returns ソースの配列
+   */
+  getSourcesByIds(sourceIds: number[]): Promise<Source[]>;
+
+  /**
+   * 同期処理中のソースを登録または更新する
+   * @param source 登録または更新するソース情報
+   * @returns 登録または更新されたソース情報
+   */
+  initializeProcessingSource(source: InsertSource): Promise<Source>;
+
+  /**
+   * ソース情報を更新する
+   * @param param 更新するソース情報
+   * @param param.id ソースのID
+   * @param param.title ソースのタイトル
+   * @param param.summary ソースの要約
+   * @param param.error エラー情報（nullの場合はエラーなし）
+   * @returns 更新されたソース情報
+   */
+  updateSource(param: {
+    id: number;
+    title: string;
+    summary: string;
+    error: string | null;
+  }): Promise<void>;
+
+  /**
+   * 同期処理情報を更新する
+   */
+  updateProcessingStatus(param: {
+    id: number;
+    status: ProcessStatus;
+    error?: string | null;
+  }): Promise<void>;
+
+  /**
+   * 全ソースの情報をMDのリスト形式で取得する
+   * @param sourceId ソースのID
+   * @returns ソース情報
+   */
+  getSourceListMarkdown(): Promise<string | null>;
+
+  /**
+   * トピックを登録する
+   */
+  registerTopic(topicList: InsertTopic[]): Promise<void>;
+
+  /**
+   * パスで指定されたソースを削除する
+   * @param path ソースのパス
+   * @returns 削除が成功した場合はtrue、存在しない場合はfalse
+   */
+  deleteSourceByPath(path: string): Promise<boolean>;
+
+  /**
+   * ソースをステータスに基づいて複数取得する
+   * @param status ソースのステータス
+   * @returns ソースの配列
+   */
+  getSouorceInStatus(status: ProcessStatus[]): Promise<Source[]>;
+
+  /**
+   * ソースをステータスとパスに基づいて複数取得する
+   */
+  getSourceByPathInStatus(
+    path: string,
+    status: ProcessStatus[],
+  ): Promise<Source[]>;
+
+  /**
+   * ソースを全て取得する
+   */
+  getAllSources(): Promise<Source[]>;
+
+  /**
+   * ソーステーブルへのインサート
+   */
+  insertSources(sourceList: InsertSource[]): Promise<void>;
+
+  /**
+   * ソースの有効/無効を更新する
+   * @param sourceId ソースID
+   * @param enabled 有効/無効
+   */
+  updateSourceEnabled(sourceId: number, enabled: boolean): Promise<void>;
+}
diff --git a/src/main/service/port/repository/index.ts b/src/main/service/port/repository/index.ts
new file mode 100644
index 000000000..23ffd1e78
--- /dev/null
+++ b/src/main/service/port/repository/index.ts
@@ -0,0 +1,3 @@
+export * from './IReviewRepository';
+export * from './ISourceRepository';
+export * from './ISettingsRepository';
diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
index 5a21d1a22..8e7cffbea 100644
--- a/src/main/service/reviewService.ts
+++ b/src/main/service/reviewService.ts
@@ -1,4 +1,4 @@
-import { getReviewRepository } from '@/main/repository/reviewRepository';
+import { getReviewRepository } from '@/adapter/db';
 import {
   ReviewChecklistEdit,
   ReviewChecklistResult,
@@ -8,6 +8,7 @@ import {
   DocumentType,
   ChecklistExtractionResultStatus,
   ReviewExecutionResultStatus,
+  DocumentMode,
 } from '@/types';
 import { generateReviewTitle } from '@/mastra/workflows/sourceReview/lib';
 import { RevieHistory } from '@/types';
@@ -121,6 +122,8 @@ export class ReviewService implements IReviewService {
         generateReviewTitle(),
         reviewHistoryId,
       );
+      // 新規作成時はレビュー履歴更新イベントを送信
+      publishEvent(IpcChannels.REVIEW_HISTORY_UPDATED, undefined);
     }
 
     // チェックリストの編集を実行
@@ -356,6 +359,7 @@ export class ReviewService implements IReviewService {
     evaluationSettings: CustomEvaluationSettings,
     additionalInstructions?: string,
     commentFormat?: string,
+    documentMode?: DocumentMode,
   ): Promise<{ status: ReviewExecutionResultStatus; error?: string }> {
     try {
       // レビュー履歴の存在確認
@@ -369,7 +373,7 @@ export class ReviewService implements IReviewService {
       }
 
       // Mastraワークフローを実行
-      const workflow = mastra.getWorkflow('reviewExecutionWorkflow');
+      const workflow = mastra.getWorkflow('executeReviewWorkflow');
 
       if (!workflow) {
         logger.error('レビュー実行ワークフローが見つかりません');
@@ -409,9 +413,12 @@ export class ReviewService implements IReviewService {
           evaluationSettings,
           additionalInstructions,
           commentFormat,
+          documentMode: documentMode || 'small', // デフォルトは少量ドキュメント
         },
       });
 
+      console.log('レビュー実行結果:', JSON.stringify(result, null, 2));
+
       // 結果を確認
       const checkResult = checkWorkflowResult(result);
 
@@ -535,6 +542,7 @@ export class ReviewService implements IReviewService {
     evaluationSettings: CustomEvaluationSettings,
     additionalInstructions?: string,
     commentFormat?: string,
+    documentMode?: DocumentMode,
   ): { success: boolean; error?: string } {
     try {
       this.executeReview(
@@ -543,6 +551,7 @@ export class ReviewService implements IReviewService {
         evaluationSettings,
         additionalInstructions,
         commentFormat,
+        documentMode,
       )
         .then((res) => {
           // 完了イベントを送信
diff --git a/src/main/service/settingsService.ts b/src/main/service/settingsService.ts
index e159a6e9d..5882d1d96 100644
--- a/src/main/service/settingsService.ts
+++ b/src/main/service/settingsService.ts
@@ -14,9 +14,8 @@ import { InitializeToolsConfig, initializeTools } from '@/mastra/tools';
 import { RedmineBaseInfo } from '@/mastra/tools/redmine';
 import { initializeMCPClient } from '@/mastra/tools/mcp';
 import { OrchestratorRuntimeContext } from '@/mastra/agents/orchestrator';
-import { getSourceRepository } from '@/main/repository/sourceRepository';
+import { getSourceRepository, getSettingsRepository } from '@/adapter/db';
 import { createRuntimeContext } from '@/mastra/lib/agentUtils';
-import { getSettingsRepository } from '../repository/settingsRepository';
 import { publishEvent } from '@/main/lib/eventPayloadHelper';
 import { IpcChannels } from '@/types';
 
diff --git a/src/main/service/sourceService.ts b/src/main/service/sourceService.ts
index daa09d337..e0603bcfa 100644
--- a/src/main/service/sourceService.ts
+++ b/src/main/service/sourceService.ts
@@ -4,8 +4,7 @@ import { internalError, normalizeUnknownError } from '../lib/error';
 import { publishEvent } from '../lib/eventPayloadHelper';
 import FileExtractor from '../lib/fileExtractor';
 import { getMainLogger } from '../lib/logger';
-import { getSettingsRepository } from '../repository/settingsRepository';
-import { getSourceRepository } from '../repository/sourceRepository';
+import { getSettingsRepository, getSourceRepository } from '@/adapter/db';
 import { IpcChannels, Source } from '@/types';
 import { mastra } from '@/mastra';
 import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
index 7f86d67bd..335b6d0dd 100644
--- a/src/mastra/agents/prompts.ts
+++ b/src/mastra/agents/prompts.ts
@@ -8,6 +8,9 @@ import {
   ReviewExecuteAgentRuntimeContext,
   TopicExtractionAgentRuntimeContext,
   TopicChecklistAgentRuntimeContext,
+  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
+  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
+  ReviewAnswerQuestionAgentRuntimeContext,
 } from './workflowAgents';
 
 /**
@@ -446,7 +449,11 @@ export function getDocumentReviewExecutionPrompt({
 
   // 評定項目の設定を構築
   let evaluationInstructions = '';
-  if (evaluationSettings && evaluationSettings.items && evaluationSettings.items.length > 0) {
+  if (
+    evaluationSettings &&
+    evaluationSettings.items &&
+    evaluationSettings.items.length > 0
+  ) {
     // カスタム評定項目を使用
     const evaluationList = evaluationSettings.items
       .map((item) => `   - ${item.label}: ${item.description}`)
@@ -491,3 +498,232 @@ ${additionalInstructions}
 }
 Please ensure clarity, conciseness, and a professional tone.`;
 }
+
+// レビュー時ドキュメント要約生成用のシステムプロンプト
+export const REVIEW_DOCUMENT_SUMMARIZATION_SYSTEM_PROMPT = `
+You are an expert document analyst. Your job is to carefully analyze the given document and identify all the key topics without missing anything important.
+
+Your task is to analyze the provided document and:
+1. Identify between 5 and 15 distinct topics that cover the full range of the text.
+2. For each topic, write a  title and a concise summary.
+3. Ensure the topics are comprehensive, non-overlapping, and together capture the entire meaning of the text.
+
+Guidelines:
+- Topics should be specific, independent, and cover different aspects of the document
+- Each topic should be substantial enough to warrant separate attention during review
+- The summary should be concise but comprehensive, covering all important points
+- Write topics and summary in the same language as the document (default to Japanese if unclear)
+`;
+
+// レビュー準備確認用のシステムプロンプト（初回実行用）
+export const getReviewReadinessFirstRunPrompt = ({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewCheckReviewReadinessFirstRunAgentRuntimeContext>;
+}) => {
+  const checklistItems = runtimeContext.get('checklistItems') as {
+    id: number;
+    content: string;
+  }[];
+  const additionalInstructions = runtimeContext.get(
+    'additionalInstructions',
+  ) as string | undefined;
+
+  return `
+You are a review planning expert. Your task is to generate comprehensive questions that need to be answered to conduct a thorough review of documents based on the provided checklist items.
+
+## Context
+You will review documents based on the following checklist items:
+${checklistItems.map((item) => `- [${item.id}] ${item.content}`).join('\n')}
+
+${additionalInstructions ? `Additional review instructions: ${additionalInstructions}` : ''}
+
+## Your Task
+Based on the document summaries and topics provided, generate specific questions that need to be answered to ensure each checklist item can be properly evaluated. The questions should:
+
+1. Be specific and focused on information needed for checklist evaluation
+2. Cover all aspects necessary to assess each checklist item
+3. Be answerable based on the document content
+4. Help gather detailed information that might not be apparent from just the summaries
+
+Generate questions for each document that will help collect the necessary information for a comprehensive review.
+`;
+};
+
+// レビュー準備確認用のシステムプロンプト（2回目以降実行用）
+export const getReviewCheckReadinessSubsequentPrompt = ({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewCheckReviewReadinessSubsequentAgentRuntimeContext>;
+}) => {
+  const checklistItems = runtimeContext.get('checklistItems') as {
+    id: number;
+    content: string;
+  }[];
+  const additionalInstructions = runtimeContext.get(
+    'additionalInstructions',
+  ) as string | undefined;
+  const priorQnA = runtimeContext.get('priorQnA') as Array<{
+    documentId: string;
+    documentName: string;
+    qna: Array<{ question: string; answer: string }>;
+  }>;
+
+  return `
+You are a review readiness assessor. Your task is to determine whether sufficient information has been gathered to conduct a thorough review based on the provided checklist items.
+
+## Context
+You will review documents based on the following checklist items:
+${checklistItems.map((item) => `- [${item.id}] ${item.content}`).join('\n')}
+
+${additionalInstructions ? `Additional review instructions: ${additionalInstructions}` : ''}
+
+## Previous Q&A Information
+${priorQnA
+  .map(
+    (doc) => `
+### Document: ${doc.documentName} (ID: ${doc.documentId})
+${doc.qna.map((qa) => `Q: ${qa.question}\nA: ${qa.answer}`).join('\n\n')}
+`,
+  )
+  .join('\n')}
+
+## Your Task
+1. Assess whether the provided document summaries, topics, and Q&A information are sufficient to properly evaluate each checklist item
+2. If sufficient information is available, set "ready" to true
+3. If more information is needed, set "ready" to false and generate specific additional questions that will help complete the review
+
+The questions should:
+- Fill gaps in information needed for checklist evaluation
+- Be specific and targeted to missing information
+- Be answerable based on the document content
+- Avoid redundancy with already answered questions
+`;
+};
+
+// 質問回答生成用のシステムプロンプト
+export const getReviewAnswerQuestionPrompt = ({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewAnswerQuestionAgentRuntimeContext>;
+}) => {
+  const checklistItems = runtimeContext.get('checklistItems') as {
+    id: number;
+    content: string;
+  }[];
+
+  return `
+You are a document analysis expert. Your task is to carefully read the provided document and answer specific questions accurately and comprehensively.
+
+## Context
+The questions are designed to gather information needed for reviewing the document against these checklist items:
+${checklistItems.map((item) => `- [${item.id}] ${item.content}`).join('\n')}
+
+## Your Task
+Read the document carefully and provide detailed, accurate answers to each question. Your answers should:
+
+1. Be factually accurate and based solely on the document content
+2. Be comprehensive and include all relevant details
+3. Cite specific parts of the document as evidence:
+   a) Quote relevant sections with clear section/chapter references
+   b) Separate discussions by section if some parts address the question differently
+   c) Cover every relevant occurrence—do not offer only a general summary
+4. Specify document sections that are relevant to each answer:
+   a) Identify specific file names, chapter titles, or section headers
+   b) Reference page numbers or section numbers when available
+5. Indicate if information is not available in the document
+6. Be written in the same language as the document (default to Japanese if unclear)
+
+Provide complete, section-specific answers that will enable a thorough review of the document against the checklist items.
+`;
+};
+
+// 大量ドキュメントレビュー実行用のプロンプト（要約・Q&A情報に特化）
+export function getLargeDocumentReviewExecutionPrompt({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ReviewExecuteAgentRuntimeContext>;
+}): string {
+  const checklists = runtimeContext.get('checklistItems');
+  const additionalInstructions = runtimeContext.get('additionalInstructions');
+  const commentFormat = runtimeContext.get('commentFormat');
+  const evaluationSettings = runtimeContext.get('evaluationSettings');
+
+  // Build a human-readable list of checklist items
+  const formattedList = checklists
+    .map((item) => `ID: ${item.id} - ${item.content}`)
+    .join('\n');
+
+  // デフォルトのフォーマット
+  const defaultFormat = `【評価理由・根拠】
+   Provide the reasoning and evidence here (cite specific sections or examples in the document).
+
+   【改善提案】
+   Provide actionable suggestions here (how to better satisfy the criterion).`;
+
+  const actualFormat =
+    commentFormat && commentFormat.trim() !== ''
+      ? commentFormat
+      : defaultFormat;
+
+  // 評定項目の設定を構築
+  let evaluationInstructions = '';
+  if (
+    evaluationSettings &&
+    evaluationSettings.items &&
+    evaluationSettings.items.length > 0
+  ) {
+    // カスタム評定項目を使用
+    const evaluationList = evaluationSettings.items
+      .map((item) => `   - ${item.label}: ${item.description}`)
+      .join('\n');
+    evaluationInstructions = `1. For each checklist item, assign one of these ratings:\n${evaluationList}`;
+  } else {
+    // デフォルト評定項目を使用
+    evaluationInstructions = `1. For each checklist item, assign one of these ratings:
+   - A: 基準を完全に満たしている
+   - B: 基準を一部満たしている
+   - C: 基準を満たしていない
+   - –: 評価の対象外、または評価できない`;
+  }
+
+  return `You are a professional document reviewer specializing in large document analysis. Your job is to evaluate documents against a set of checklist items based on provided topic summaries and Q&A information.
+
+Important Context:
+- You are reviewing LARGE DOCUMENTS that have been pre-processed into topic summaries and Q&A responses
+- Your evaluation is based on SUMMARIZED INFORMATION, not the full original document
+- The topics and Q&A responses represent key aspects of the original document(s)
+- Multiple documents may have been combined and analyzed together
+
+Checklist items:
+${formattedList}
+
+Instructions:
+${evaluationInstructions}
+2. For each item, write a comment in Japanese following this format:
+
+${actualFormat}
+
+3. For each checklist item, specify the review sections that should be examined for evaluation and commenting:
+   a) Identify the specific file names that need to be reviewed.
+   b) For each file, list the relevant sections within that file.
+4. In your comments, be sure to:
+   a) Cite specific parts of the document as evidence (use section names, chapter titles, page references from the Q&A information).
+   b) Separate discussions by section if some parts meet the item and others do not.
+   c) Cover every relevant occurrence—do not offer only a general summary.
+   d) Write comments as if you directly reviewed the original document (do not mention "topic summaries", "Q&A responses", or internal processing).
+5. Do not omit any checklist item; review the entire document against each criterion before finalizing your evaluation.
+6. Important: Write natural comments that reference document sections directly:
+   - Use phrases like "文書のX章では..." or "Y部分に記載されている..."
+   - Avoid mentioning internal processing like "要約によると" or "Q&Aで確認したところ"
+   - Make comments appear as if you read the original document directly
+${
+  additionalInstructions && additionalInstructions.trim() !== ''
+    ? `
+Special Instructions:
+${additionalInstructions}
+`
+    : ``
+}
+Please ensure clarity, conciseness, and a professional tone. Write comments that appear natural and comprehensive, as if you directly reviewed the complete original document.`;
+}
diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
index fbc74bfb3..a885d7a8b 100644
--- a/src/mastra/agents/workflowAgents.ts
+++ b/src/mastra/agents/workflowAgents.ts
@@ -12,6 +12,11 @@ import {
   // getChecklistIntegrationPrompt,
   getChecklistCategolizePrompt,
   getDocumentReviewExecutionPrompt,
+  getLargeDocumentReviewExecutionPrompt,
+  REVIEW_DOCUMENT_SUMMARIZATION_SYSTEM_PROMPT,
+  getReviewReadinessFirstRunPrompt,
+  getReviewCheckReadinessSubsequentPrompt,
+  getReviewAnswerQuestionPrompt,
 } from './prompts';
 import { getOpenAICompatibleModel } from './model/openAICompatible';
 import { BaseRuntimeContext } from './types';
@@ -42,6 +47,21 @@ export type TopicChecklistAgentRuntimeContext = BaseRuntimeContext & {
   checklistRequirements?: string;
 };
 
+export type ReviewCheckReviewReadinessFirstRunAgentRuntimeContext = BaseRuntimeContext & {
+  checklistItems: { id: number; content: string }[];
+  additionalInstructions?: string;
+};
+
+export type ReviewCheckReviewReadinessSubsequentAgentRuntimeContext = BaseRuntimeContext & {
+  checklistItems: { id: number; content: string }[];
+  additionalInstructions?: string;
+  priorQnA: { documentId: string; documentName: string; qna: { question: string; answer: string }[] }[];
+};
+
+export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
+  checklistItems: { id: number; content: string }[];
+};
+
 export const summarizeSourceAgent = new Agent({
   name: 'summarizeSourceAgent',
   instructions: SOURCE_ANALYSIS_SYSTEM_PROMPT,
@@ -78,6 +98,13 @@ export const reviewExecuteAgent = new Agent({
   model: getOpenAICompatibleModel,
 });
 
+// 大量ドキュメントレビュー専用エージェント（要約・Q&A情報に特化）
+export const largeDocumentReviewExecuteAgent = new Agent({
+  name: 'largeDocumentReviewExecuteAgent',
+  instructions: getLargeDocumentReviewExecutionPrompt,
+  model: getOpenAICompatibleModel,
+});
+
 export const topicExtractionAgent = new Agent({
   name: 'topicExtractionAgent',
   instructions: getTopicExtractionPrompt,
@@ -95,3 +122,27 @@ export const topicChecklistAgent = new Agent({
 //   instructions: getChecklistIntegrationPrompt,
 //   model: getOpenAICompatibleModel,
 // });
+
+export const reviewDocumentSummarizationAgent = new Agent({
+  name: 'reviewDocumentSummarizationAgent',
+  instructions: REVIEW_DOCUMENT_SUMMARIZATION_SYSTEM_PROMPT,
+  model: getOpenAICompatibleModel,
+});
+
+export const reviewCheckReviewReadinessFirstRunAgent = new Agent({
+  name: 'reviewCheckReviewReadinessFirstRunAgent',
+  instructions: getReviewReadinessFirstRunPrompt,
+  model: getOpenAICompatibleModel,
+});
+
+export const reviewCheckReviewReadinessSubsequentRunAgent = new Agent({
+  name: 'reviewCheckReviewReadinessSubsequentRunAgent',
+  instructions: getReviewCheckReadinessSubsequentPrompt,
+  model: getOpenAICompatibleModel,
+});
+
+export const reviewAnswerQuestionAgent = new Agent({
+  name: 'reviewAnswerQuestionAgent',
+  instructions: getReviewAnswerQuestionPrompt,
+  model: getOpenAICompatibleModel,
+});
diff --git a/src/mastra/index.ts b/src/mastra/index.ts
index ee263a839..b9467c7ec 100644
--- a/src/mastra/index.ts
+++ b/src/mastra/index.ts
@@ -15,12 +15,17 @@ import {
   generalDocumentChecklistAgent,
   classifyCategoryAgent,
   reviewExecuteAgent,
+  largeDocumentReviewExecuteAgent,
   topicExtractionAgent,
   topicChecklistAgent,
+  reviewDocumentSummarizationAgent,
+  reviewCheckReviewReadinessFirstRunAgent,
+  reviewCheckReviewReadinessSubsequentRunAgent,
+  reviewAnswerQuestionAgent,
 } from './agents/workflowAgents';
 import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
 import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
-import { reviewExecutionWorkflow } from './workflows/sourceReview/reviewExecution';
+import { executeReviewWorkflow } from './workflows/sourceReview/executeReview';
 import fs from 'fs';
 import path from 'path';
 import { getLogLevel } from '@/main/lib/logger';
@@ -67,13 +72,18 @@ export const mastra: Mastra = new Mastra({
     generalDocumentChecklistAgent,
     classifyCategoryAgent,
     reviewExecuteAgent,
+    largeDocumentReviewExecuteAgent,
     topicExtractionAgent,
     topicChecklistAgent,
+    reviewDocumentSummarizationAgent,
+    reviewCheckReviewReadinessFirstRunAgent,
+    reviewCheckReviewReadinessSubsequentRunAgent,
+    reviewAnswerQuestionAgent,
   },
   workflows: {
     sourceRegistrationWorkflow,
     checklistExtractionWorkflow,
-    reviewExecutionWorkflow,
+    executeReviewWorkflow,
   },
   logger,
 });
diff --git a/src/mastra/lib/agentUtils.ts b/src/mastra/lib/agentUtils.ts
index 2fac51222..f4395b252 100644
--- a/src/mastra/lib/agentUtils.ts
+++ b/src/mastra/lib/agentUtils.ts
@@ -1,7 +1,7 @@
 // @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
 import { FinishReason } from 'ai';
-import { getSettingsRepository } from '@/main/repository/settingsRepository';
+import { getSettingsRepository } from '@/adapter/db';
 import { BaseRuntimeContext } from '../agents/types';
 
 // BaseRuntimeConotextに値を入れた上で、指定したRuntimeContextを返す関数
diff --git a/src/mastra/lib/workflowUtils.ts b/src/mastra/lib/workflowUtils.ts
index befd76d84..139f28ee2 100644
--- a/src/mastra/lib/workflowUtils.ts
+++ b/src/mastra/lib/workflowUtils.ts
@@ -2,6 +2,10 @@
 import { WorkflowResult } from '@mastra/core';
 import { baseStepOutputSchema } from '../workflows/schema';
 import { z } from 'zod';
+import { normalizeUnknownError } from '@/main/lib/error';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
 
 // workflowの結果を確認するための関数
 export function checkWorkflowResult(result: WorkflowResult<any, any>): {
@@ -10,9 +14,16 @@ export function checkWorkflowResult(result: WorkflowResult<any, any>): {
 } {
   // ワークフロー全体がfailedの場合(本アプリについてはエラーの場合、stepとしては成功させ、outputのstatusをfailedと指定するため、発生しないはず)
   if (result.status === 'failed') {
+    let errorMessage;
+    if (result.error instanceof Error) {
+      errorMessage = normalizeUnknownError(result.error).message;
+    } else {
+      logger.error('Unknown error in workflow', { error: result.error });
+      errorMessage = '不明なエラー';
+    }
     return {
       status: 'failed',
-      errorMessage: result.error.message,
+      errorMessage,
     };
   }
 
diff --git a/src/mastra/tools/sourcesTools.ts b/src/mastra/tools/sourcesTools.ts
index e9723243b..ada16b17b 100644
--- a/src/mastra/tools/sourcesTools.ts
+++ b/src/mastra/tools/sourcesTools.ts
@@ -2,8 +2,8 @@ import { z } from 'zod';
 // @ts-ignore
 import { createTool } from '@mastra/core/tools';
 import { eq, and } from 'drizzle-orm';
-import { sources } from '@/db/schema';
-import getDb from '@/db/index';
+import { sources } from '@/adapter/db/drizzle/schema';
+import getDb from '@/adapter/db/drizzle';
 import FileExtractor from '@/main/lib/fileExtractor';
 import { createBaseToolResponseSchema, RunToolStatus } from './types';
 import { DocumentExpertAgentRuntimeContext } from '../agents/toolAgents';
diff --git a/src/mastra/workflows/schema.ts b/src/mastra/workflows/schema.ts
index ac31676c6..e0a391b0c 100644
--- a/src/mastra/workflows/schema.ts
+++ b/src/mastra/workflows/schema.ts
@@ -5,3 +5,53 @@ export const baseStepOutputSchema = z.object({
   status: z.enum(['success', 'failed']),
   errorMessage: z.string().optional(),
 });
+
+// ドキュメント情報のスキーマ
+export const documentInfoSchema = z.object({
+  id: z.string(),
+  name: z.string(),
+  path: z.string(),
+  type: z.string(),
+  pdfProcessMode: z.enum(['text', 'image']).optional(),
+  pdfImageMode: z.enum(['merged', 'pages']).optional(),
+  imageData: z.array(z.string()).optional(),
+  workflowDocId: z.string().optional(),
+});
+
+// テキスト抽出ステップの出力スキーマ
+export const textExtractionOutputSchema = baseStepOutputSchema.extend({
+  extractedDocuments: z.array(
+    z.object({
+      workflowDocId: z.string(),
+      name: z.string(),
+      path: z.string(),
+      content: z.string(),
+      imageData: z.array(z.string()).optional(),
+    })
+  ).optional(),
+});
+
+// ドキュメント要約ステップの出力スキーマ
+export const documentSummarizationOutputSchema = baseStepOutputSchema.extend({
+  summaries: z.array(
+    z.object({
+      workflowDocId: z.string(),
+      name: z.string(),
+      topics: z.array(z.string()),
+      summary: z.string(),
+    })
+  ).optional(),
+});
+
+// 大量ドキュメントレビューステップの出力スキーマ
+export const largeDocumentReviewOutputSchema = baseStepOutputSchema.extend({
+  reviewResults: z.array(
+    z.object({
+      checklistId: z.number(),
+      evaluation: z.string(),
+      comment: z.string(),
+      fileId: z.string(),
+      fileName: z.string(),
+    })
+  ).optional(),
+});
diff --git a/src/mastra/workflows/sourceRegistration/sourceRegistration.ts b/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
index af155c04e..a69d2f6c9 100644
--- a/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
+++ b/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
@@ -4,7 +4,7 @@ import { createWorkflow, createStep } from '@mastra/core/workflows';
 import { z } from 'zod';
 import { stepStatus } from '../types';
 import { baseStepOutputSchema } from '../schema';
-import { getSourceRepository } from '../../../main/repository/sourceRepository';
+import { getSourceRepository } from '@/adapter/db';
 import { createRuntimeContext, judgeFinishReason } from '../../lib/agentUtils';
 import { normalizeUnknownError, internalError } from '@/main/lib/error';
 import { getMainLogger } from '@/main/lib/logger';
diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
index 0098a60c8..54742d5ef 100644
--- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
@@ -3,7 +3,7 @@ import { NoObjectGeneratedError } from 'ai';
 // @ts-ignore
 import { createStep, createWorkflow } from '@mastra/core/workflows';
 import { z } from 'zod';
-import { getReviewRepository } from '@/main/repository/reviewRepository';
+import { getReviewRepository } from '@/adapter/db';
 import { baseStepOutputSchema } from '../schema';
 import { stepStatus } from '../types';
 import {
diff --git a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
new file mode 100644
index 000000000..14ac3da86
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
@@ -0,0 +1,206 @@
+import { z } from "zod";
+import { baseStepOutputSchema } from "../../schema";
+// @ts-ignore
+import { createStep } from "@mastra/core";
+// @ts-ignore
+import { MastraError } from "@mastra/core/error";
+import { NoObjectGeneratedError } from 'ai';
+import { getReviewRepository } from "@/adapter/db";
+import { extractAIAPISafeError, internalError, normalizeUnknownError } from "@/main/lib/error";
+import { MAX_CATEGORIES, MAX_CHECKLISTS_PER_CATEGORY } from ".";
+import { stepStatus } from "../../types";
+import { splitChecklistEquallyByMaxSize } from "../lib";
+import { createRuntimeContext } from "@/mastra/lib/agentUtils";
+import { ClassifyCategoryAgentRuntimeContext } from "@/mastra/agents/workflowAgents";
+import { getMainLogger } from "@/main/lib/logger";
+
+const logger = getMainLogger();
+
+export const classifyChecklistsByCategoryInputSchema = z.object({
+  reviewHistoryId: z.string().describe("レビュー履歴ID"),
+});
+
+// カテゴリ分類ステップの出力スキーマ
+export const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
+  categories: z
+    .array(
+      z.object({
+        name: z.string(),
+        checklists: z.array(
+          z.object({
+            id: z.number(),
+            content: z.string().describe('チェックリストの内容'),
+          }),
+        ),
+      }),
+    ).optional(),
+});
+
+export const classifyChecklistsByCategoryStep = createStep({
+  id: 'classifyChecklistsByCategoryStep',
+  description: 'チェックリストをカテゴリごとに分類するステップ',
+  inputSchema: classifyChecklistsByCategoryInputSchema,
+  outputSchema: classifyChecklistsByCategoryOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal, bail }) => {
+    // トリガーから入力を取得
+    const { reviewHistoryId } = inputData;
+
+    // レビューリポジトリを取得
+    const repository = getReviewRepository();
+
+    try {
+      // チェックリストを取得
+      const checklistsResult = await repository.getChecklists(reviewHistoryId);
+      if (!checklistsResult || checklistsResult.length === 0) {
+        throw internalError({
+          expose: true,
+          messageCode: 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST',
+        });
+      }
+
+      // チェックリストデータを整形
+      const checklistData = checklistsResult.map((c) => ({
+        id: c.id,
+        content: c.content,
+      }));
+
+      // MAX_CHECKLISTS_PER_CATEGORY が1の場合は早期return
+      if (MAX_CHECKLISTS_PER_CATEGORY <= 1) {
+        return {
+          status: 'success' as stepStatus,
+          categories: splitChecklistEquallyByMaxSize(
+            checklistsResult,
+            MAX_CHECKLISTS_PER_CATEGORY,
+          ),
+        };
+      }
+
+      // カテゴリ分類エージェントを使用して分類
+      const classifiCategoryAgent = mastra.getAgent('classifyCategoryAgent');
+      const outputSchema = z.object({
+        categories: z
+          .array(
+            z.object({
+              name: z.string().describe('Category name'),
+              checklistIds: z
+                .array(z.number())
+                .describe('Array of checklist IDs belonging to the category'),
+            }),
+          )
+          .describe('Classified categories'),
+      });
+      const runtimeContext =
+        await createRuntimeContext<ClassifyCategoryAgentRuntimeContext>();
+      runtimeContext.set(
+        'maxChecklistsPerCategory',
+        MAX_CHECKLISTS_PER_CATEGORY,
+      );
+      runtimeContext.set('maxCategories', MAX_CATEGORIES);
+      // チェックリスト項目をカテゴリごとに分類
+      const classificationResult = await classifiCategoryAgent.generate(
+        `checklist items:
+  ${checklistData.map((item) => `ID: ${item.id} - ${item.content}`).join('\n')}`,
+        {
+          output: outputSchema,
+          runtimeContext,
+          abortSignal,
+        },
+      );
+      // 分類結果の妥当性をチェック
+      const rawCategories = classificationResult.object.categories;
+      if (!rawCategories || rawCategories.length === 0) {
+        return {
+          status: 'success' as stepStatus,
+          categories: splitChecklistEquallyByMaxSize(
+            checklistsResult,
+            MAX_CHECKLISTS_PER_CATEGORY,
+          ),
+        };
+      }
+      // 全IDセットと、AIが返したID一覧のセットを作成
+      const allIds = new Set(checklistData.map((c) => c.id));
+      const assignedIds = new Set(rawCategories.flatMap((c) => c.checklistIds));
+
+      // 未分類アイテムがあれば「その他」カテゴリにまとめる
+      const uncategorized = Array.from(allIds).filter(
+        (id) => !assignedIds.has(id),
+      );
+      if (uncategorized.length > 0) {
+        rawCategories.push({
+          name: 'その他',
+          checklistIds: uncategorized,
+        });
+      }
+
+      const seen = new Set<number>();
+      const finalCategories: {
+        name: string;
+        checklists: { id: number; content: string }[];
+      }[] = [];
+
+      for (const { name, checklistIds } of rawCategories) {
+        // ── カテゴリ内の重複排除 ────────────────────────
+        const uniqueInCategory = Array.from(new Set(checklistIds));
+
+        // ── 他カテゴリですでに割り当て済みのIDを除外 ─────────
+        const filteredIds = uniqueInCategory.filter((id) => !seen.has(id));
+        filteredIds.forEach((id) => seen.add(id));
+
+        // ── MAX_CHECKLISTS_PER_CATEGORY件ずつチャンクに分けてサブカテゴリ化 ────────────
+        for (
+          let i = 0;
+          i < filteredIds.length;
+          i += MAX_CHECKLISTS_PER_CATEGORY
+        ) {
+          const chunkIds = filteredIds.slice(
+            i,
+            i + MAX_CHECKLISTS_PER_CATEGORY,
+          );
+          const chunkName =
+            i === 0
+              ? name
+              : `${name} (Part ${Math.floor(i / MAX_CHECKLISTS_PER_CATEGORY) + 1})`;
+
+          const checklists = chunkIds.map((id) => {
+            const item = checklistData.find((c) => c.id === id)!;
+            return { id: item.id, content: item.content };
+          });
+
+          finalCategories.push({ name: chunkName, checklists });
+        }
+      }
+
+      return {
+        status: 'success' as stepStatus,
+        categories: finalCategories,
+      };
+    } catch (error) {
+      logger.error(error, 'チェックリストのカテゴリ分類処理に失敗しました');
+      if (
+        extractAIAPISafeError(error) ||
+        NoObjectGeneratedError.isInstance(error) ||
+        error instanceof MastraError
+      ) {
+        // APIコールエラーまたはAIモデルが生成できる文字数を超えた場合、手動でカテゴリー分割
+        // AIモデルが生成できる文字数を超えているため、手動でカテゴリー分割
+        const checklistsResult =
+          await repository.getChecklists(reviewHistoryId);
+        return {
+          status: 'success' as stepStatus,
+          categories: splitChecklistEquallyByMaxSize(
+            checklistsResult,
+            MAX_CHECKLISTS_PER_CATEGORY,
+          ),
+        };
+      }
+      const normalizedError = normalizeUnknownError(error);
+      const errorDetail = normalizedError.message;
+      // エラーが発生した場合はエラーメッセージを設定
+      const errorMessage = `${errorDetail}`;
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/index.ts
new file mode 100644
index 000000000..8c3ee3bf4
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/index.ts
@@ -0,0 +1,239 @@
+// @ts-ignore
+import { createWorkflow } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../schema';
+import { stepStatus } from '../../types';
+import { textExtractionStep } from './textExtractionStep';
+import { getMainLogger } from '@/main/lib/logger';
+import { classifyChecklistsByCategoryStep } from './classifyChecklistStep';
+import { smallDocumentReviewExecutionStep } from './smallDocumentReviewStep';
+import { largeDocumentReviewWorkflow } from './largeDocumentReview';
+
+const logger = getMainLogger();
+
+// レビュー機能で利用する定数定義
+
+// 一つのカテゴリに含めるチェックリストの最大数
+export const MAX_CHECKLISTS_PER_CATEGORY = 1;
+// 分割カテゴリの最大数
+export const MAX_CATEGORIES = 50;
+
+// レビュー実行のメインワークフロー入力スキーマ
+export const executeReviewWorkflowInputSchema = z.object({
+  reviewHistoryId: z.string().describe('レビュー履歴ID'),
+  additionalInstructions: z
+    .string()
+    .optional()
+    .describe('レビューに対する追加指示'),
+  commentFormat: z
+    .string()
+    .optional()
+    .describe('レビューコメントのフォーマット'),
+  evaluationSettings: z
+    .object({
+      items: z.array(
+        z.object({
+          label: z.string(),
+          description: z.string(),
+        }),
+      ),
+    })
+    .optional()
+    .describe('カスタム評定項目設定'),
+  documentMode: z
+    .enum(['small', 'large'])
+    .default('small')
+    .describe(
+      'ドキュメントモード: small=少量ドキュメント, large=大量ドキュメント',
+    ),
+  // レビュー対象のドキュメント
+  files: z.array(
+    z.object({
+      id: z.string(),
+      name: z.string(),
+      path: z.string(),
+      type: z.string(),
+      pdfProcessMode: z.enum(['text', 'image']).optional(),
+      pdfImageMode: z.enum(['merged', 'pages']).optional(),
+      imageData: z.array(z.string()).optional(),
+    }),
+  ),
+});
+
+export const executeReviewWorkflowOutputSchema = baseStepOutputSchema;
+
+export const documentReviewExecutionInputSchema = z.object({
+  additionalInstructions: z
+    .string()
+    .optional()
+    .describe('レビューに対する追加指示'),
+  commentFormat: z
+    .string()
+    .optional()
+    .describe('レビューコメントのフォーマット'),
+  evaluationSettings: z
+    .object({
+      items: z.array(
+        z.object({
+          label: z.string(),
+          description: z.string(),
+        }),
+      ),
+    })
+    .optional()
+    .describe('カスタム評定項目設定'),
+  // レビュー対象のドキュメント
+  documents: z.array(
+    z.object({
+      id: z.string(),
+      name: z.string(),
+      path: z.string(),
+      type: z.string(),
+      pdfProcessMode: z.enum(['text', 'image']).optional(),
+      pdfImageMode: z.enum(['merged', 'pages']).optional(),
+      textContent: z.string().optional(),
+      imageData: z.array(z.string()).optional(),
+    }),
+  ),
+  checklists: z.array(
+    z.object({
+      id: z.number(),
+      content: z.string().describe('チェックリストの内容'),
+    }),
+  ),
+});
+
+export const documentReviewExecutionOutputSchema = baseStepOutputSchema;
+
+// レビュー実行のメインワークフロー
+export const executeReviewWorkflow = createWorkflow({
+  id: 'executeReviewWorkflow',
+  inputSchema: executeReviewWorkflowInputSchema,
+  outputSchema: executeReviewWorkflowOutputSchema,
+})
+  // ステップ1: テキスト抽出とカテゴリ分割
+  .parallel([
+    createWorkflow({
+      id: 'textExtraction',
+      inputSchema: executeReviewWorkflowInputSchema,
+      outputSchema: textExtractionStep.outputSchema,
+    })
+      .map(async ({ inputData }) => {
+        return { files: inputData.files } as z.infer<
+          typeof textExtractionStep.inputSchema
+        >;
+      })
+      .then(textExtractionStep)
+      .commit(),
+    createWorkflow({
+      id: 'classifyChecklistsByCategory',
+      inputSchema: executeReviewWorkflowInputSchema,
+      outputSchema: classifyChecklistsByCategoryStep.outputSchema,
+    })
+      .map(async ({ inputData }) => {
+        return { reviewHistoryId: inputData.reviewHistoryId } as z.infer<
+          typeof classifyChecklistsByCategoryStep.inputSchema
+        >;
+      })
+      .then(classifyChecklistsByCategoryStep)
+      .commit(),
+  ])
+  // ドキュメントレビューをループするためのinputに変換(大量ドキュメントも少量ドキュメントも同じ形にする)
+  .map(async ({ inputData, bail, getInitData }) => {
+    const textExtractionResult = inputData.textExtraction;
+    const classifyChecklistsResult = inputData.classifyChecklistsByCategory;
+
+    if (textExtractionResult.status !== 'success') {
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage:
+          textExtractionResult.errorMessage || 'テキスト抽出に失敗しました',
+      });
+    }
+    if (classifyChecklistsResult.status !== 'success') {
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage:
+          classifyChecklistsResult.errorMessage ||
+          'チェックリストのカテゴリ分割に失敗しました',
+      });
+    }
+
+    const initData = (await getInitData()) as z.infer<
+      typeof executeReviewWorkflowInputSchema
+    >;
+
+    return classifyChecklistsResult.categories!.map((category) => {
+      return {
+        documents: textExtractionResult.extractedDocuments!,
+        checklists: category.checklists,
+        additionalInstructions: initData.additionalInstructions,
+        commentFormat: initData.commentFormat,
+        evaluationSettings: initData.evaluationSettings,
+        documentMode: initData.documentMode,
+      } as z.infer<typeof documentReviewExecutionInputSchema>;
+    });
+  })
+  .foreach(
+    createWorkflow({
+      id: 'documentReview',
+      inputSchema: documentReviewExecutionInputSchema,
+      outputSchema: baseStepOutputSchema,
+    })
+      .branch([
+        [
+          async ({ getInitData }) => {
+            const initData = (await getInitData()) as z.infer<
+              typeof executeReviewWorkflowInputSchema
+            >;
+            return initData.documentMode === 'small';
+          },
+          smallDocumentReviewExecutionStep,
+        ],
+        [
+          async ({ getInitData }) => {
+            const initData = (await getInitData()) as z.infer<
+              typeof executeReviewWorkflowInputSchema
+            >;
+            return initData.documentMode === 'large';
+          },
+          largeDocumentReviewWorkflow,
+        ],
+      ])
+      .map(async ({ inputData, bail }) => {
+        let reviewExecutionResult:
+          | z.infer<typeof documentReviewExecutionOutputSchema>
+          | undefined;
+        if (inputData.smallDocumentReviewExecutionStep) {
+          reviewExecutionResult = inputData.smallDocumentReviewExecutionStep;
+        } else if (inputData.largeDocumentReviewWorkflow) {
+          reviewExecutionResult = inputData.largeDocumentReviewWorkflow;
+        }
+        if (!reviewExecutionResult) {
+          return bail({
+            status: 'failed' as stepStatus,
+            errorMessage: '不明なエラー',
+          });
+        }
+        return bail(reviewExecutionResult);
+      })
+      .commit(),
+    { concurrency: 5 },
+  )
+  .map(async ({ inputData, bail }) => {
+    // failedになった結果を集約
+    const failedResults = inputData.filter(
+      (item) => item.status === 'failed' && item.errorMessage,
+    );
+    if (failedResults.length > 0) {
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: failedResults.map((r) => r.errorMessage).join('\n'),
+      });
+    }
+    // 全て成功した場合
+    return {
+      status: 'success' as stepStatus,
+    };
+  })
+  .commit();
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/answerQuestionStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/answerQuestionStep.ts
new file mode 100644
index 000000000..7494d3280
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/answerQuestionStep.ts
@@ -0,0 +1,137 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../../schema';
+import { stepStatus } from '../../../types';
+import { createCombinedMessage } from '../../lib';
+import { createRuntimeContext, judgeFinishReason } from '@/mastra/lib/agentUtils';
+import { ReviewAnswerQuestionAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
+
+const answerQuestionInputSchema = z.object({
+  document: z.object({
+    id: z.string(),
+    name: z.string(),
+    path: z.string(),
+    type: z.string(),
+    pdfProcessMode: z.enum(['text', 'image']).optional(),
+    pdfImageMode: z.enum(['merged', 'pages']).optional(),
+    textContent: z.string().optional(),
+    imageData: z.array(z.string()).optional(),
+  }),
+  checklists: z.array(
+    z.object({
+      id: z.number(),
+      content: z.string().describe('レビュー対象チェックリストの内容'),
+    }),
+  ),
+  questions: z.array(z.string()).describe('ドキュメントに関する質問のリスト'),
+});
+
+const answerQuestionOutputSchema = baseStepOutputSchema.extend({
+  documentId: z.string().optional(),
+  answers: z.array(
+    z.object({
+      question: z.string().describe('ドキュメントに関する質問'),
+      answer: z.string().describe('その質問に対する回答'),
+    }),
+  ).optional(),
+});
+
+export const answerQuestionStep = createStep({
+  id: 'answerQuestionStep',
+  description: 'ドキュメントに対する質問に回答するステップ',
+  inputSchema: answerQuestionInputSchema,
+  outputSchema: answerQuestionOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal, bail }) => {
+    const { document, checklists, questions } = inputData;
+
+    if (!questions || questions.length === 0) {
+      return {
+        status: 'success' as stepStatus,
+        answers: [],
+      };
+    }
+
+    try {
+      // ドキュメントをメッセージ形式に変換
+      const message = await createCombinedMessage(
+        [document],
+        'Please answer the following questions based on the document content.',
+      );
+
+      // 質問回答エージェントを取得
+      const agent = mastra.getAgent('reviewAnswerQuestionAgent');
+
+      // ランタイムコンテキストを作成
+      const runtimeContext = await createRuntimeContext<ReviewAnswerQuestionAgentRuntimeContext>();
+      runtimeContext.set('checklistItems', checklists);
+
+      // 出力スキーマを定義
+      const outputSchema = z.object({
+        answers: z.array(
+          z.object({
+            question: z.string().describe('The question being answered'),
+            answer: z.string().describe('The comprehensive answer based on the document content'),
+          }),
+        ),
+      });
+
+      // 質問リストをメッセージに追加
+      const questionsText = `## Questions to Answer:
+${questions.map((q, index) => `${index + 1}. ${q}`).join('\n')}
+
+Please provide detailed answers to each question based on the document content.`;
+
+      const messageWithQuestions = {
+        ...message,
+        content: [
+          ...message.content,
+          {
+            type: 'text' as const,
+            text: questionsText,
+          },
+        ],
+      };
+
+      // 質問回答を実行
+      const result = await agent.generate(messageWithQuestions, {
+        output: outputSchema,
+        runtimeContext,
+        abortSignal,
+      });
+
+      const { success, reason } = judgeFinishReason(result.finishReason);
+      if (!success) {
+        throw internalError({
+          expose: true,
+          messageCode: 'AI_API_ERROR',
+          messageParams: { detail: reason },
+        });
+      }
+
+      if (result.object && result.object.answers) {
+        return {
+          status: 'success' as stepStatus,
+          documentId: document.id,
+          answers: result.object.answers,
+        };
+      } else {
+        throw new Error('回答が生成されませんでした');
+      }
+    } catch (error) {
+      logger.error(error, '質問回答ステップでエラーが発生しました');
+      const normalizedError = normalizeUnknownError(error);
+
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: normalizedError.message,
+      };
+    }
+  },
+});
+
+
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/checkReviewReadinessStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/checkReviewReadinessStep.ts
new file mode 100644
index 000000000..63d2eb942
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/checkReviewReadinessStep.ts
@@ -0,0 +1,230 @@
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../../schema';
+// @ts-ignore
+import { createStep } from '@mastra/core/workflows';
+import { getMainLogger } from '@/main/lib/logger';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import {
+  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
+  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
+} from '@/mastra/agents/workflowAgents';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { stepStatus } from '@/mastra/workflows/types';
+import { getChecklistsErrorMessage } from '../lib';
+
+const logger = getMainLogger();
+
+const checkReviewReadinessInputSchema = z.object({
+  additionalInstructions: z
+    .string()
+    .optional()
+    .describe('レビューに対する追加指示'),
+  documents: z.array(
+    z.object({
+      id: z.string(),
+      name: z.string(),
+      path: z.string(),
+      type: z.string(),
+      pdfProcessMode: z.enum(['text', 'image']).optional(),
+      pdfImageMode: z.enum(['merged', 'pages']).optional(),
+      textContent: z.string().optional(),
+      imageData: z.array(z.string()).optional(),
+      topicAndSummary: z.array(
+        z.object({
+          topic: z.string().describe('ドキュメントから抽出されたトピック'),
+          summary: z
+            .string()
+            .describe('そのトピックに関するドキュメントの要約'),
+        }),
+      ),
+      // レビューを実行するための、ドキュメントに関する質問・回答の蓄積情報
+      priorQnA: z
+        .array(
+          z.object({
+            question: z.string().describe('ドキュメントに関する質問'),
+            answer: z.string().describe('その質問に対する回答'),
+          }),
+        )
+        .optional()
+        .describe(
+          'レビューを実行するための、ドキュメントに関する質問・回答の蓄積情報',
+        ),
+    }),
+  ),
+  checklists: z.array(
+    z.object({
+      id: z.number(),
+      content: z.string().describe('チェックリストの内容'),
+    }),
+  ),
+});
+
+const checkReviewReadinessOutputSchema = baseStepOutputSchema.extend({
+  ready: z
+    .boolean()
+    .describe('レビューに十分な情報が含まれているか')
+    .optional(),
+  additionalQuestions: z
+    .array(z.object({ documentId: z.string(), questions: z.array(z.string()) }))
+    .optional()
+    .describe('不足している場合の追加質問'),
+});
+
+// チェックリストレビューに十分な情報が含まれているかを確認するstep(readyがtrueになるまで繰り返し実行するようにworkflowで制御する)
+export const checkReviewReadinessStep = createStep({
+  id: 'checkReviewReadinessStep',
+  description:
+    'チェックリストレビューに十分な情報が含まれているかを確認するステップ(readyがtrueになるまで繰り返し実行するようにworkflowで制御する)',
+  inputSchema: checkReviewReadinessInputSchema,
+  outputSchema: checkReviewReadinessOutputSchema,
+  execute: async ({ inputData, mastra }) => {
+    const { documents, checklists, additionalInstructions } = inputData;
+
+    try {
+      // priorQnAがundefinedまたは空の場合は初回実行とみなす
+      const isFirstRun = documents.every(
+        (doc) => !doc.priorQnA || doc.priorQnA.length === 0,
+      );
+
+      let agent;
+      let runtimeContext;
+
+      // ユーザプロンプト
+      const message = `${documents
+        .map(
+          (doc) => `# Document ID: ${doc.id}
+- Name: ${doc.name}
+## Summary and Topics:
+${doc.topicAndSummary
+  .map(
+    (ts) => `- Topic: ${ts.topic}
+  - Summary: ${ts.summary}`,
+  )
+  .join('\n\n')}`,
+        )
+        .join('\n\n')}
+`;
+      if (isFirstRun) {
+        // レビュー実行に必要な質問のみを生成するAIプロンプトを実行する
+        agent = mastra.getAgent('reviewCheckReviewReadinessFirstRunAgent');
+
+        runtimeContext =
+          await createRuntimeContext<ReviewCheckReviewReadinessFirstRunAgentRuntimeContext>();
+        runtimeContext.set('checklistItems', checklists);
+        runtimeContext.set('additionalInstructions', additionalInstructions);
+
+        const outputSchema = z.object({
+          additionalQuestions: z
+            .array(
+              z.object({
+                documentId: z
+                  .string()
+                  .describe(
+                    'The ID of the document for which additional information is needed.',
+                  ),
+                questions: z
+                  .array(z.string())
+                  .describe(
+                    'A list of questions that need to be answered to ensure a thorough review based on the checklist items.',
+                  ),
+              }),
+            )
+            .describe('List of additional questions needed for review'),
+        });
+
+        const result = await agent.generate(message, {
+          output: outputSchema,
+          abortSignal: undefined,
+          runtimeContext,
+        });
+
+        const { success, reason } = judgeFinishReason(result.finishReason);
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+
+        return {
+          status: 'success' as stepStatus,
+          ...result.object,
+          ready: false,
+        };
+      } else {
+        // priorQnAが存在する場合は2回目以降の実行とみなす
+        agent = mastra.getAgent('reviewCheckReviewReadinessSubsequentRunAgent');
+
+        runtimeContext =
+          await createRuntimeContext<ReviewCheckReviewReadinessSubsequentAgentRuntimeContext>();
+        runtimeContext.set('checklistItems', checklists);
+        runtimeContext.set('additionalInstructions', additionalInstructions);
+        runtimeContext.set(
+          'priorQnA',
+          documents.map((doc) => ({
+            documentId: doc.id,
+            documentName: doc.name,
+            qna: doc.priorQnA || [],
+          })),
+        );
+
+        const outputSchema = z.object({
+          additionalQuestions: z
+            .array(
+              z.object({
+                documentId: z
+                  .string()
+                  .describe(
+                    'The ID of the document for which additional information is needed.',
+                  ),
+                questions: z
+                  .array(z.string())
+                  .describe(
+                    'A list of questions that need to be answered to ensure a thorough review based on the checklist items.',
+                  ),
+              }),
+            )
+            .optional()
+            .describe('List of additional questions needed for review'),
+          ready: z
+            .boolean()
+            .describe(
+              'Indicates whether the provided information is sufficient to proceed with the review based on the checklist items.',
+            ),
+        });
+
+        const result = await agent.generate(message, {
+          output: outputSchema,
+          abortSignal: undefined,
+          runtimeContext,
+        });
+
+        const { success, reason } = judgeFinishReason(result.finishReason);
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+
+        return {
+          status: 'success' as stepStatus,
+          ...result.object,
+        };
+      }
+    } catch (error) {
+      logger.error(error, 'レビュー準備確認ステップでエラーが発生しました');
+      const normalizedError = normalizeUnknownError(error);
+
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: getChecklistsErrorMessage(checklists, normalizedError.message),
+      };
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/documentSummarizationStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/documentSummarizationStep.ts
new file mode 100644
index 000000000..2103f35b2
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/documentSummarizationStep.ts
@@ -0,0 +1,151 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../../schema';
+import { stepStatus } from '../../../types';
+import { createCombinedMessage } from '../../lib';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { getMainLogger } from '@/main/lib/logger';
+import { getChecklistsErrorMessage } from '../lib';
+
+const logger = getMainLogger();
+
+export const documentSummarizationInputSchema = z
+  .object({
+    documents: z.array(
+      z.object({
+        id: z.string(),
+        name: z.string(),
+        path: z.string(),
+        type: z.string(),
+        pdfProcessMode: z.enum(['text', 'image']).optional(),
+        pdfImageMode: z.enum(['merged', 'pages']).optional(),
+        textContent: z.string().optional(),
+        imageData: z.array(z.string()).optional(),
+      }),
+    ),
+    checklists: z.array(
+      z.object({
+        id: z.number(),
+        content: z.string(),
+      }),
+    ),
+  })
+  .describe('要約生成対象のドキュメント');
+
+const documentSummarizationOutputSchema = baseStepOutputSchema
+  .extend({
+    documents: z
+      .array(
+        z.object({
+          id: z.string(),
+          name: z.string(),
+          path: z.string(),
+          type: z.string(),
+          pdfProcessMode: z.enum(['text', 'image']).optional(),
+          pdfImageMode: z.enum(['merged', 'pages']).optional(),
+          textContent: z.string().optional(),
+          imageData: z.array(z.string()).optional(),
+          topicAndSummary: z.array(
+            z.object({
+              topic: z.string().describe('ドキュメントから抽出されたトピック'),
+              summary: z
+                .string()
+                .describe('そのトピックに関するドキュメントの要約'),
+            }),
+          ),
+        }),
+      )
+      .optional(),
+  })
+  .describe('各ドキュメントのトピックと要約のリスト');
+
+export const documentSummarizationStep = createStep({
+  id: 'documentSummarizationStep',
+  description: '個々のドキュメントのトピックと要約を生成するステップ',
+  inputSchema: documentSummarizationInputSchema,
+  outputSchema: documentSummarizationOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal, bail }) => {
+    const { documents, checklists } = inputData;
+
+    try {
+      // ドキュメントが空の場合、エラーで終了
+      if (documents.length === 0) {
+        throw internalError({
+          expose: false,
+          messageCode: 'PLAIN_MESSAGE',
+          messageParams: { message: 'ドキュメントが空です' },
+        });
+      }
+      const resultDocuments = [];
+
+      // 各ドキュメントに対して要約とトピック抽出を実行
+      for (const doc of documents) {
+        // ユーザプロンプト
+        const message = await createCombinedMessage(
+          [doc],
+          'Please summarize the document and extract key topics and summaries.',
+        );
+
+        // 要約生成エージェントを取得
+        const agent = mastra.getAgent('reviewDocumentSummarizationAgent');
+
+        // 出力スキーマを定義
+        const outputSchema = z.object({
+          topicAndSummaryList: z.array(
+            z.object({
+              topic: z.string().describe('Topics extracted from the document'),
+              summary: z
+                .string()
+                .describe('Summary of the document on the topic'),
+            }),
+          ),
+        });
+
+        const result = await agent.generate(message, {
+          output: outputSchema,
+          abortSignal,
+          runtimeContext: await createRuntimeContext(),
+        });
+
+        const { success, reason } = judgeFinishReason(result.finishReason);
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+
+        resultDocuments.push({
+          id: doc.id,
+          name: doc.name,
+          path: doc.path,
+          type: doc.type,
+          pdfProcessMode: doc.pdfProcessMode,
+          pdfImageMode: doc.pdfImageMode,
+          textContent: doc.textContent,
+          imageData: doc.imageData,
+          topicAndSummary: result.object.topicAndSummaryList,
+        });
+      }
+
+      return {
+        status: 'success' as stepStatus,
+        documents: resultDocuments,
+      };
+    } catch (error) {
+      logger.error(error, 'ドキュメント要約生成処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: getChecklistsErrorMessage(checklists, normalizedError.message),
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
new file mode 100644
index 000000000..906572083
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
@@ -0,0 +1,172 @@
+// @ts-ignore
+import { createWorkflow } from '@mastra/core';
+import { z } from 'zod';
+import { stepStatus } from '../../../types';
+import { documentSummarizationStep } from './documentSummarizationStep';
+import { checkReviewReadinessStep } from './checkReviewReadinessStep';
+import { answerQuestionStep } from './answerQuestionStep';
+import { largeDocumentReviewExecutionStep } from './reviewExecutionStep';
+import { getMainLogger } from '@/main/lib/logger';
+import {
+  documentReviewExecutionInputSchema,
+  documentReviewExecutionOutputSchema,
+} from '..';
+
+const logger = getMainLogger();
+
+//QnA生成と質問応答のサブワークフロー定義
+const qnALoopWorkflow = createWorkflow({
+  id: 'qnALoopWorkflow',
+  inputSchema: checkReviewReadinessStep.outputSchema.extend(
+    checkReviewReadinessStep.inputSchema.shape,
+  ), // loopのためinputとoutputを統合
+  outputSchema: checkReviewReadinessStep.outputSchema.extend(
+    checkReviewReadinessStep.inputSchema.shape,
+  ),
+})
+  .map(async ({ inputData }) => {
+    return {
+      documents: inputData.documents,
+      checklists: inputData.checklists,
+      additionalInstructions: inputData.additionalInstructions,
+    } as z.infer<typeof checkReviewReadinessStep.inputSchema>;
+  })
+  .then(checkReviewReadinessStep)
+  .map(async ({ inputData, bail, getInitData }) => {
+    // 前stepはthenかつbailで終了しているので、失敗した場合はここには到達しないはず
+    if (inputData.status === 'failed') {
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: inputData.errorMessage,
+      });
+    }
+    const initData = (await getInitData()) as z.infer<
+      typeof checkReviewReadinessStep.inputSchema
+    >;
+    // readyがtrueまたは質問がない場合はループを終了する
+    if (inputData.ready || !inputData.additionalQuestions) {
+      return bail({
+        status: 'success' as stepStatus,
+        ready: true,
+        additionalQuestions: [],
+        documents: initData.documents,
+        checklists: initData.checklists,
+        additionalInstructions: initData.additionalInstructions,
+      });
+    }
+    return inputData.additionalQuestions.map((questionGroup) => {
+      const document = initData.documents.find(
+        (d) => d.id === questionGroup.documentId,
+      );
+      if (document && questionGroup.questions.length > 0) {
+        return {
+          document,
+          checklists: initData.checklists,
+          questions: questionGroup.questions,
+        } as z.infer<typeof answerQuestionStep.inputSchema>;
+      }
+    });
+  })
+  .foreach(answerQuestionStep, { concurrency: 5 })
+  .map(async ({ inputData, bail, getInitData, getStepResult }) => {
+    const initData = (await getInitData()) as z.infer<
+      typeof checkReviewReadinessStep.inputSchema
+    >;
+    // 全て失敗していた場合、ここで終了させる
+    if (inputData.every((item) => item.status === 'failed')) {
+      // 最初の要素からエラーメッセージを取得
+      let errorMessage: string = '予期せぬエラーが発生しました';
+      for (const item of inputData) {
+        if (item.status === 'failed' && item.errorMessage) {
+          errorMessage = item.errorMessage;
+          break;
+        }
+      }
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage,
+      });
+    }
+    // 各ドキュメントのpriorQnAに回答を追加して返す
+    const updatedDocuments = initData.documents.map((doc) => {
+      const answersForDoc = inputData
+        .filter(
+          (item) => item.status === 'success' && item.documentId === doc.id,
+        )
+        .flatMap((item) => item.answers || []);
+      return {
+        ...doc,
+        priorQnA: [...(doc.priorQnA || []), ...answersForDoc],
+      };
+    });
+    return {
+      documents: updatedDocuments,
+      checklists: initData.checklists,
+      additionalInstructions: initData.additionalInstructions,
+      ready: getStepResult(checkReviewReadinessStep).ready,
+    } as z.infer<typeof checkReviewReadinessStep.inputSchema>;
+  })
+  .commit();
+
+// 大量ドキュメント用レビューサブワークフロー
+export const largeDocumentReviewWorkflow = createWorkflow({
+  id: 'largeDocumentReviewWorkflow',
+  inputSchema: documentReviewExecutionInputSchema,
+  outputSchema: documentReviewExecutionOutputSchema,
+})
+  .map(async ({ inputData }) => {
+    return {
+      documents: inputData.documents,
+      checklists: inputData.checklists,
+    } as z.infer<typeof documentSummarizationStep.inputSchema>;
+  })
+  .then(documentSummarizationStep)
+  .map(async ({ inputData, bail, getInitData }) => {
+    // 前stepはthenかつbailで終了しているので、失敗した場合はここには到達しないはず
+    if (inputData.status === 'failed') {
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessages: inputData.errorMessage,
+      });
+    }
+    const initData = (await getInitData()) as z.infer<
+      typeof largeDocumentReviewExecutionStep.inputSchema
+    >;
+    return {
+      documents:
+        inputData.documents?.map((doc) => ({
+          ...doc,
+          priorQnA: [] as Array<{ question: string; answer: string }>, // 初回は空
+        })) || [],
+      checklists: initData.checklists,
+      additionalInstructions: initData.additionalInstructions,
+      ready: false, // 初回はfalseでスタート
+    } as z.infer<typeof qnALoopWorkflow.inputSchema>;
+  })
+  .dountil(qnALoopWorkflow, async ({ inputData: { ready, status } }) => {
+    return ready === true || status === 'failed';
+  })
+  .map(async ({ inputData, bail, getInitData }) => {
+    // 前stepが失敗していた場合はここで終了させる
+    if (inputData.status === 'failed') {
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: inputData.errorMessage,
+      });
+    }
+    const initData = (await getInitData()) as z.infer<
+      typeof largeDocumentReviewExecutionStep.inputSchema
+    >;
+    return {
+      documents: inputData.documents.map((doc) => ({
+        ...doc,
+        qnA: doc.priorQnA || [],
+      })),
+      checklists: inputData.checklists,
+      additionalInstructions: inputData.additionalInstructions,
+      commentFormat: initData.commentFormat,
+      evaluationSettings: initData.evaluationSettings,
+    } as z.infer<typeof largeDocumentReviewExecutionStep.inputSchema>;
+  })
+  .then(largeDocumentReviewExecutionStep)
+  .commit();
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/reviewExecutionStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/reviewExecutionStep.ts
new file mode 100644
index 000000000..a0f06ce83
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/reviewExecutionStep.ts
@@ -0,0 +1,271 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { NoObjectGeneratedError } from 'ai';
+import { baseStepOutputSchema } from '@/mastra/workflows/schema';
+import { stepStatus } from '@/mastra/workflows/types';
+import { getReviewRepository } from '@/adapter/db';
+import { createRuntimeContext, judgeFinishReason } from '@/mastra/lib/agentUtils';
+import { ReviewExecuteAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { createHash } from 'crypto';
+import { ReviewEvaluation } from '@/types';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
+
+const reviewExecutionStepInputSchema = z.object({
+  additionalInstructions: z
+    .string()
+    .optional()
+    .describe('レビューに対する追加指示'),
+  commentFormat: z
+    .string()
+    .optional()
+    .describe('レビューコメントのフォーマット'),
+  evaluationSettings: z
+    .object({
+      items: z.array(
+        z.object({
+          label: z.string(),
+          description: z.string(),
+        }),
+      ),
+    })
+    .optional()
+    .describe('カスタム評定項目設定'),
+  // レビュー対象のドキュメント
+  documents: z.array(
+    z.object({
+      id: z.string(),
+      name: z.string(),
+      path: z.string(),
+      type: z.string(),
+      pdfProcessMode: z.enum(['text', 'image']).optional(),
+      pdfImageMode: z.enum(['merged', 'pages']).optional(),
+      textContent: z.string().optional(),
+      imageData: z.array(z.string()).optional(),
+      topicAndSummary: z.array(
+        z.object({
+          topic: z.string().describe('ドキュメントから抽出されたトピック'),
+          summary: z
+            .string()
+            .describe('そのトピックに関するドキュメントの要約'),
+        }),
+      ),
+      qnA: z
+        .array(
+          z.object({
+            question: z.string().describe('ドキュメントに関する質問'),
+            answer: z.string().describe('その質問に対する回答'),
+          }),
+        )
+        .describe('ドキュメントに関する質問・回答の蓄積情報'),
+    }),
+  ),
+  checklists: z.array(
+    z.object({
+      id: z.number(),
+      content: z.string().describe('チェックリストの内容'),
+    }),
+  ),
+});
+
+const reviewExecutionStepOutputSchema = baseStepOutputSchema.extend({
+  failedChecklists: z
+    .array(
+      z.object({
+        id: z.number(),
+        content: z.string().describe('レビューに失敗したチェックリストの内容'),
+      }),
+    )
+    .optional(),
+});
+
+export const largeDocumentReviewExecutionStep = createStep({
+  id: 'largeDocumentReviewExecutionStep',
+  description: '大量ドキュメント用のレビュー実行ステップ（要約・Q&A情報を使用）',
+  inputSchema: reviewExecutionStepInputSchema,
+  outputSchema: reviewExecutionStepOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal }) => {
+    const {
+      documents,
+      checklists,
+      additionalInstructions,
+      commentFormat,
+      evaluationSettings,
+    } = inputData;
+
+    const reviewRepository = getReviewRepository();
+
+    try {
+      const reviewAgent = mastra.getAgent('largeDocumentReviewExecuteAgent');
+
+      // ドキュメント情報を整理したメッセージを作成
+      const documentInfo = documents.map(doc => {
+        const topicsSummary = doc.topicAndSummary
+          .map(ts => `**Topic: ${ts.topic}**\n${ts.summary}`)
+          .join('\n\n');
+
+        const qnaInfo = doc.qnA
+          .map(qa => `Q: ${qa.question}\nA: ${qa.answer}`)
+          .join('\n\n');
+
+        return `# Document: ${doc.name} (ID: ${doc.id})
+
+## Topics and Summaries:
+${topicsSummary}
+
+## Q&A Information:
+${qnaInfo}`;
+      }).join('\n\n---\n\n');
+
+      // レビューメッセージを構築
+      const reviewMessage = {
+        role: 'user' as const,
+        content: [
+          {
+            type: 'text' as const,
+            text: `Please review the following documents based on the provided checklist items.
+
+${documentInfo}
+
+## Checklist Items to Review:
+${checklists.map((item) => `- ID: ${item.id} - ${item.content}`).join('\n')}
+
+Please provide a thorough review based on the document summaries, topics, and Q&A information provided above.`,
+          },
+        ],
+      };
+
+      // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
+      const maxAttempts = 3;
+      let attempt = 0;
+      let targetChecklists = checklists;
+
+      while (attempt < maxAttempts) {
+        // デフォルトの評定項目
+        const defaultEvaluationItems = ['A', 'B', 'C', '-'] as const;
+
+        // カスタム評定項目がある場合はそれを使用、なければデフォルトを使用
+        const evaluationItems = evaluationSettings?.items?.length
+          ? evaluationSettings.items.map((item) => item.label)
+          : defaultEvaluationItems;
+
+        // 最初の要素が存在することを確認してenumを作成
+        const evaluationEnum =
+          evaluationItems.length > 0
+            ? z.enum([evaluationItems[0], ...evaluationItems.slice(1)] as [
+                string,
+                ...string[],
+              ])
+            : z.enum(defaultEvaluationItems);
+
+        const outputSchema = z.array(
+          z.object({
+            checklistId: z.number(),
+            reviewSections: z
+              .array(
+                z.object({
+                  fileName: z.string().describe('file name to review'),
+                  sectionNames: z.array(
+                    z.string().describe('section name within the file'),
+                  ),
+                }),
+              )
+              .describe(
+                'files and sections that should be reviewed for evaluation and commenting',
+              ),
+            comment: z.string().describe('evaluation comment'),
+            evaluation: evaluationEnum.describe('evaluation'),
+          }),
+        );
+
+        const runtimeContext =
+          await createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
+        runtimeContext.set('checklistItems', targetChecklists);
+        runtimeContext.set('additionalInstructions', additionalInstructions);
+        runtimeContext.set('commentFormat', commentFormat);
+        runtimeContext.set('evaluationSettings', evaluationSettings);
+
+        // レビューエージェントを使用してレビューを実行
+        const reviewResult = await reviewAgent.generate(reviewMessage, {
+          output: outputSchema,
+          runtimeContext,
+          abortSignal,
+        });
+
+        const { success, reason } = judgeFinishReason(
+          reviewResult.finishReason,
+        );
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+
+        // レビュー結果をDBに保存（複数ファイルの情報を統合）
+        if (reviewResult.object && Array.isArray(reviewResult.object)) {
+          const combinedFileIds = documents.map((f) => f.id).join('/');
+          const idsHash = createHash('md5')
+            .update(combinedFileIds)
+            .digest('hex');
+          const combinedFileNames = documents.map((f) => f.name).join('/');
+
+          await reviewRepository.upsertReviewResult(
+            reviewResult.object.map((result) => ({
+              reviewChecklistId: result.checklistId,
+              evaluation: result.evaluation as ReviewEvaluation,
+              comment: result.comment,
+              fileId: idsHash,
+              fileName: combinedFileNames,
+            })),
+          );
+        }
+
+        // レビュー結果に含まれなかったチェックリストを抽出
+        const reviewedChecklistIds = new Set(
+          reviewResult.object && Array.isArray(reviewResult.object)
+            ? reviewResult.object.map((result) => result.checklistId)
+            : [],
+        );
+        targetChecklists = targetChecklists.filter(
+          (checklist) => !reviewedChecklistIds.has(checklist.id),
+        );
+
+        if (targetChecklists.length === 0) {
+          // 全てのチェックリストがレビューされた場合、成功
+          break;
+        }
+        attempt += 1;
+      }
+
+      if (attempt >= maxAttempts) {
+        // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
+        return {
+          status: 'failed' as stepStatus,
+          errorMessage: `${targetChecklists?.map((c) => `・${c.content}:AIの出力にレビュー結果が含まれませんでした`).join('\n')}`,
+        };
+      }
+
+      // 全てのレビューが成功した場合
+      return {
+        status: 'success' as stepStatus,
+        output: {
+          success: true,
+        },
+      };
+    } catch (error) {
+      logger.error(error, '大量ドキュメントレビュー実行処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      const errorMessage = normalizedError.message;
+      // エラーが発生した場合はエラー情報を返す
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: `${checklists?.map((c) => `・${c.content}:${errorMessage}`).join('\n')}`,
+      };
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/lib.ts b/src/mastra/workflows/sourceReview/executeReview/lib.ts
new file mode 100644
index 000000000..b4bde036c
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/lib.ts
@@ -0,0 +1,7 @@
+export const getChecklistErrorMesssage = (checklist: { id: number; content: string }, errorMessage: string) => {
+  return `・${checklist.content}:${errorMessage}`;
+};
+
+export const getChecklistsErrorMessage = (checklists: { id: number; content: string }[], errorMessage: string) => {
+  return checklists.map((checklist) => getChecklistErrorMesssage(checklist, errorMessage)).join('\n');
+}
diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
new file mode 100644
index 000000000..384a28b96
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
@@ -0,0 +1,194 @@
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../schema';
+import { NoObjectGeneratedError } from 'ai';
+// @ts-ignore
+import { createStep } from '@mastra/core/workflows';
+import { getReviewRepository } from '@/adapter/db';
+import { createCombinedMessage } from '../lib';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import { ReviewExecuteAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import { internalError, normalizeUnknownError } from '@/main/lib/error';
+import { createHash } from 'crypto';
+import { ReviewEvaluation } from '@/types';
+import { stepStatus } from '../../types';
+import { getMainLogger } from '@/main/lib/logger';
+import {
+  documentReviewExecutionInputSchema,
+  documentReviewExecutionOutputSchema,
+} from '.';
+import { getChecklistsErrorMessage } from './lib';
+
+const logger = getMainLogger();
+
+export const smallDocumentReviewExecutionStep = createStep({
+  id: 'smallDocumentReviewExecutionStep',
+  description: 'チェックリストごとにレビューを実行するステップ',
+  inputSchema: documentReviewExecutionInputSchema,
+  outputSchema: documentReviewExecutionOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal, bail }) => {
+    // レビュー対象のファイル
+    const {
+      documents,
+      additionalInstructions,
+      commentFormat,
+      evaluationSettings,
+    } = inputData;
+    // ステップ1からの入力を取得
+    const { checklists } = inputData;
+
+    // リポジトリを取得
+    const reviewRepository = getReviewRepository();
+
+    try {
+      const reviewAgent = mastra.getAgent('reviewExecuteAgent');
+
+      // 複数ファイルを統合してメッセージを作成（一度だけ）
+      const message = await createCombinedMessage(
+        documents,
+        'Please review this document against the provided checklist items',
+      );
+
+      // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
+      // レビュー結果に含まれなかったチェックリストは再度レビューを実行する（最大試行回数は3回）
+      const maxAttempts = 3;
+      let attempt = 0;
+      let targetChecklists = checklists;
+      while (attempt < maxAttempts) {
+        // デフォルトの評定項目
+        const defaultEvaluationItems = ['A', 'B', 'C', '-'] as const;
+
+        // カスタム評定項目がある場合はそれを使用、なければデフォルトを使用
+        const evaluationItems = evaluationSettings?.items?.length
+          ? evaluationSettings.items.map((item) => item.label)
+          : defaultEvaluationItems;
+
+        // 最初の要素が存在することを確認してenumを作成
+        const evaluationEnum =
+          evaluationItems.length > 0
+            ? z.enum([evaluationItems[0], ...evaluationItems.slice(1)] as [
+                string,
+                ...string[],
+              ])
+            : z.enum(defaultEvaluationItems);
+
+        const outputSchema = z.array(
+          z.object({
+            checklistId: z.number(),
+            reviewSections: z
+              .array(
+                z.object({
+                  fileName: z.string().describe('file name to review'),
+                  sectionNames: z.array(
+                    z.string().describe('section name within the file'),
+                  ),
+                }),
+              )
+              .describe(
+                'files and sections that should be reviewed for evaluation and commenting',
+              ),
+            comment: z.string().describe('evaluation comment'),
+            evaluation: evaluationEnum.describe('evaluation'),
+          }),
+        );
+        const runtimeContext =
+          await createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
+        runtimeContext.set('checklistItems', checklists);
+        runtimeContext.set('additionalInstructions', additionalInstructions);
+        runtimeContext.set('commentFormat', commentFormat);
+        runtimeContext.set('evaluationSettings', evaluationSettings);
+
+        // チェックリスト一覧をメッセージの最後にリマインドとして追加
+        const checklistReminder = `## Checklist Items to Review:
+${checklists.map((item) => `- ID: ${item.id} - ${item.content}`).join('\n')}
+
+Please review the document against the above checklist items.`;
+
+        // メッセージのcontentの最後にリマインダーを追加
+        const messageWithReminder = {
+          ...message,
+          content: [
+            ...message.content,
+            {
+              type: 'text' as const,
+              text: checklistReminder,
+            },
+          ],
+        };
+
+        // レビューエージェントを使用してレビューを実行
+        const reviewResult = await reviewAgent.generate(messageWithReminder, {
+          output: outputSchema,
+          runtimeContext,
+          abortSignal,
+        });
+        const { success, reason } = judgeFinishReason(
+          reviewResult.finishReason,
+        );
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+        // レビュー結果をDBに保存（複数ファイルの情報を統合）
+        if (reviewResult.object && Array.isArray(reviewResult.object)) {
+          const combinedFileIds = documents.map((f) => f.id).join('/');
+          const idsHash = createHash('md5')
+            .update(combinedFileIds)
+            .digest('hex');
+          const combinedFileNames = documents.map((f) => f.name).join('/');
+          await reviewRepository.upsertReviewResult(
+            reviewResult.object.map((result) => ({
+              reviewChecklistId: result.checklistId,
+              evaluation: result.evaluation as ReviewEvaluation,
+              comment: result.comment,
+              fileId: idsHash,
+              fileName: combinedFileNames,
+            })),
+          );
+        }
+        // レビュー結果に含まれなかったチェックリストを抽出
+        const reviewedChecklistIds = new Set(
+          reviewResult.object && Array.isArray(reviewResult.object)
+            ? reviewResult.object.map((result) => result.checklistId)
+            : [],
+        );
+        targetChecklists = targetChecklists.filter(
+          (checklist) => !reviewedChecklistIds.has(checklist.id),
+        );
+        if (targetChecklists.length === 0) {
+          // 全てのチェックリストがレビューされた場合、成功
+          break;
+        }
+        attempt += 1;
+      }
+      if (attempt >= maxAttempts) {
+        // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
+        return bail({
+          status: 'failed' as stepStatus,
+          errorMessage: getChecklistsErrorMessage(targetChecklists, 'AIの出力にレビュー結果が含まれませんでした'),
+        });
+      }
+      // 全てのレビューが成功した場合
+      return {
+        status: 'success' as stepStatus,
+        output: {
+          success: true,
+        },
+      };
+    } catch (error) {
+      logger.error(error, 'チェックリストのレビュー実行処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      const errorMessage = normalizedError.message;
+      // エラーが発生した場合はエラー情報を返す
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: getChecklistsErrorMessage(checklists, errorMessage),
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts b/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts
new file mode 100644
index 000000000..097fb96f9
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/textExtractionStep.ts
@@ -0,0 +1,115 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { stepStatus } from '../../types';
+import { baseStepOutputSchema } from '../../schema';
+import { normalizeUnknownError } from '@/main/lib/error';
+import FileExtractor from '@/main/lib/fileExtractor';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
+
+// 入力スキーマ
+export const textExtractionInputSchema = z.object({
+  files: z
+    .array(
+      z.object({
+        name: z.string(),
+        path: z.string(),
+        type: z.string(),
+        pdfProcessMode: z.enum(['text', 'image']).optional(),
+        pdfImageMode: z.enum(['merged', 'pages']).optional(),
+        imageData: z.array(z.string()).optional(),
+      }),
+    )
+    .describe('アップロードファイルのリスト'),
+});
+
+// テキスト抽出ステップの出力スキーマ
+export const textExtractionOutputSchema = baseStepOutputSchema.extend({
+  extractedDocuments: z.array(
+    z.object({
+      id: z.string(),
+      name: z.string(),
+      path: z.string(),
+      type: z.string(),
+      pdfProcessMode: z.enum(['text', 'image']).optional(),
+      pdfImageMode: z.enum(['merged', 'pages']).optional(),
+      textContent: z.string().optional(),
+      imageData: z.array(z.string()).optional(),
+    })
+  ).optional(),
+});
+
+export const textExtractionStep = createStep({
+  id: 'textExtractionStep',
+  description: 'ドキュメントからテキストを抽出し、ワークフロー用のIDを付与するステップ',
+  inputSchema: textExtractionInputSchema,
+  outputSchema: textExtractionOutputSchema,
+  execute: async ({ inputData, abortSignal, bail }) => {
+    const { files } = inputData;
+    const fileIdSequence = (function* () {
+      let id = 1;
+      while (true) {
+        yield id++;
+      }
+    })();
+
+    try {
+      const extractedDocuments = [];
+
+      // 各ファイルからテキストを抽出
+      for (const file of files) {
+        // ワークフロー内での一意IDを生成
+        const id = fileIdSequence.next().value.toString();
+
+        // PDFで画像として処理する場合
+        if (
+          file.type === 'application/pdf' &&
+          file.pdfProcessMode === 'image' &&
+          file.imageData &&
+          file.imageData.length > 0
+        ) {
+          // 画像データはそのまま保持、テキストは空文字
+          extractedDocuments.push({
+            id,
+            name: file.name,
+            path: file.path,
+            type: file.type,
+            pdfProcessMode: file.pdfProcessMode,
+            pdfImageMode: file.pdfImageMode,
+            textContent: undefined,
+            imageData: file.imageData,
+          });
+        } else {
+          // テキスト抽出処理
+          const { content } = await FileExtractor.extractText(file.path);
+
+          extractedDocuments.push({
+            id,
+            name: file.name,
+            path: file.path,
+            type: file.type,
+            textContent: content,
+            pdfProcessMode: file.pdfProcessMode,
+            pdfImageMode: file.pdfImageMode,
+            imageData: undefined,
+          });
+        }
+      }
+
+      return {
+        status: 'success' as stepStatus,
+        extractedDocuments,
+      };
+    } catch (error) {
+      logger.error(error, 'テキスト抽出処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: normalizedError.message,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/lib.ts b/src/mastra/workflows/sourceReview/lib.ts
index c10b4c941..0eb2681c9 100644
--- a/src/mastra/workflows/sourceReview/lib.ts
+++ b/src/mastra/workflows/sourceReview/lib.ts
@@ -65,3 +65,81 @@ export function splitChecklistEquallyByMaxSize(
 
   return result;
 }
+
+/**
+ * 抽出されたドキュメント情報
+ */
+export interface ExtractedDocument {
+  name: string;
+  type: string;
+  textContent?: string;
+  imageData?: string[];
+}
+
+/**
+ * 複数ファイルを統合したメッセージオブジェクトを作成する（テキスト抽出済み版）
+ */
+export function createCombinedMessage(
+  extractedDocuments: ExtractedDocument[],
+  promptText: string,
+): {
+  role: 'user';
+  content: Array<
+    | { type: 'text'; text: string }
+    | { type: 'image'; image: string; mimeType: string }
+  >;
+} {
+  // ファイル名一覧を作成
+  const fileNames = extractedDocuments.map((doc) => doc.name).join(', ');
+
+  // メッセージコンテンツを構築
+  const content: Array<
+    | { type: 'text'; text: string }
+    | { type: 'image'; image: string; mimeType: string }
+  > = [
+    {
+      type: 'text',
+      text: `${promptText}: ${fileNames}`,
+    },
+  ];
+
+  // ドキュメント順に処理
+  for (const document of extractedDocuments) {
+    // PDFで画像として処理する場合
+    if (
+      document.type === 'application/pdf' &&
+      document.imageData &&
+      document.imageData.length > 0
+    ) {
+      // 各ページごとに個別の説明と画像を追加
+      const totalPages = document.imageData.length;
+      for (let pageIndex = 0; pageIndex < document.imageData.length; pageIndex++) {
+        const currentPage = pageIndex + 1;
+
+        // ページ番号を含むテキスト説明を追加
+        content.push({
+          type: 'text',
+          text: `# ${document.name}: Page ${currentPage}/${totalPages}`,
+        });
+
+        // 該当ページの画像データを追加
+        content.push({
+          type: 'image',
+          image: document.imageData[pageIndex],
+          mimeType: 'image/png',
+        });
+      }
+    } else {
+      // 抽出済みテキストを使用
+      content.push({
+        type: 'text',
+        text: `# ${document.name}\n${document.textContent}`,
+      });
+    }
+  }
+
+  return {
+    role: 'user',
+    content,
+  };
+}
diff --git a/src/mastra/workflows/sourceReview/reviewExecution.ts b/src/mastra/workflows/sourceReview/reviewExecution.ts
deleted file mode 100644
index 1a5b4400b..000000000
--- a/src/mastra/workflows/sourceReview/reviewExecution.ts
+++ /dev/null
@@ -1,459 +0,0 @@
-import { NoObjectGeneratedError } from 'ai';
-// @ts-ignore
-import { createWorkflow, createStep } from '@mastra/core/workflows';
-// @ts-ignore
-import { MastraError } from '@mastra/core/error';
-import { z } from 'zod';
-import { getReviewRepository } from '@/main/repository/reviewRepository';
-import type { ReviewEvaluation } from '@/types';
-import { baseStepOutputSchema } from '../schema';
-import { stepStatus } from '../types';
-import { splitChecklistEquallyByMaxSize } from './lib';
-import {
-  ClassifyCategoryAgentRuntimeContext,
-  ReviewExecuteAgentRuntimeContext,
-} from '../../agents/workflowAgents';
-import { createRuntimeContext, judgeFinishReason } from '../../lib/agentUtils';
-import { getMainLogger } from '@/main/lib/logger';
-import { createCombinedMessage } from '../../lib/util';
-import {
-  normalizeUnknownError,
-  extractAIAPISafeError,
-  internalError,
-} from '@/main/lib/error';
-import { createHash } from 'crypto';
-
-const logger = getMainLogger();
-
-// 一つのカテゴリに含めるチェックリストの最大数
-const MAX_CHECKLISTS_PER_CATEGORY = 1;
-// 分割カテゴリの最大数
-const MAX_CATEGORIES = 50;
-
-// カテゴリ分類ステップの出力スキーマ
-const classifyChecklistsByCategoryOutputSchema = baseStepOutputSchema.extend({
-  categories: z
-    .array(
-      z.object({
-        name: z.string(),
-        checklists: z.array(
-          z.object({
-            id: z.number(),
-            content: z.string().describe('チェックリストの内容'),
-          }),
-        ),
-      }),
-    )
-    .optional(),
-});
-
-// ワークフローの入力スキーマ
-const triggerSchema = z.object({
-  reviewHistoryId: z.string().describe('レビュー履歴ID'),
-  files: z
-    .array(
-      z.object({
-        id: z.string(),
-        name: z.string(),
-        path: z.string(),
-        type: z.string(),
-        pdfProcessMode: z.enum(['text', 'image']).optional(),
-        pdfImageMode: z.enum(['merged', 'pages']).optional(),
-        imageData: z.array(z.string()).optional(),
-      }),
-    )
-    .describe('アップロードファイルのリスト'),
-  additionalInstructions: z
-    .string()
-    .optional()
-    .describe('レビューに対する追加指示'),
-  commentFormat: z
-    .string()
-    .optional()
-    .describe('レビューコメントのフォーマット'),
-  evaluationSettings: z
-    .object({
-      items: z.array(
-        z.object({
-          label: z.string(),
-          description: z.string(),
-        }),
-      ),
-    })
-    .optional()
-    .describe('カスタム評定項目設定'),
-});
-
-// ステップ1: チェックリストをカテゴリごとに分類
-const classifyChecklistsByCategoryStep = createStep({
-  id: 'classifyChecklistsByCategoryStep',
-  description: 'チェックリストをカテゴリごとに分類するステップ',
-  inputSchema: triggerSchema,
-  outputSchema: classifyChecklistsByCategoryOutputSchema,
-  execute: async ({ inputData, mastra, abortSignal }) => {
-    // トリガーから入力を取得
-    const { reviewHistoryId } = inputData;
-
-    // レビューリポジトリを取得
-    const repository = getReviewRepository();
-
-    try {
-      // チェックリストを取得
-      const checklistsResult = await repository.getChecklists(reviewHistoryId);
-      if (!checklistsResult || checklistsResult.length === 0) {
-        throw internalError({
-          expose: true,
-          messageCode: 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST',
-        });
-      }
-
-      // チェックリストデータを整形
-      const checklistData = checklistsResult.map((c) => ({
-        id: c.id,
-        content: c.content,
-      }));
-
-      // MAX_CHECKLISTS_PER_CATEGORY が1の場合は早期return
-      if (MAX_CHECKLISTS_PER_CATEGORY <= 1) {
-        return {
-          status: 'success' as stepStatus,
-          categories: splitChecklistEquallyByMaxSize(
-            checklistsResult,
-            MAX_CHECKLISTS_PER_CATEGORY,
-          ),
-        };
-      }
-
-      // カテゴリ分類エージェントを使用して分類
-      const classifiCategoryAgent = mastra.getAgent('classifyCategoryAgent');
-      const outputSchema = z.object({
-        categories: z
-          .array(
-            z.object({
-              name: z.string().describe('Category name'),
-              checklistIds: z
-                .array(z.number())
-                .describe('Array of checklist IDs belonging to the category'),
-            }),
-          )
-          .describe('Classified categories'),
-      });
-      const runtimeContext =
-        await createRuntimeContext<ClassifyCategoryAgentRuntimeContext>();
-      runtimeContext.set(
-        'maxChecklistsPerCategory',
-        MAX_CHECKLISTS_PER_CATEGORY,
-      );
-      runtimeContext.set('maxCategories', MAX_CATEGORIES);
-      // チェックリスト項目をカテゴリごとに分類
-      const classificationResult = await classifiCategoryAgent.generate(
-        `checklist items:
-  ${checklistData.map((item) => `ID: ${item.id} - ${item.content}`).join('\n')}`,
-        {
-          output: outputSchema,
-          runtimeContext,
-          abortSignal,
-        },
-      );
-      // 分類結果の妥当性をチェック
-      const rawCategories = classificationResult.object.categories;
-      if (!rawCategories || rawCategories.length === 0) {
-        return {
-          status: 'success' as stepStatus,
-          categories: splitChecklistEquallyByMaxSize(
-            checklistsResult,
-            MAX_CHECKLISTS_PER_CATEGORY,
-          ),
-        };
-      }
-      // 全IDセットと、AIが返したID一覧のセットを作成
-      const allIds = new Set(checklistData.map((c) => c.id));
-      const assignedIds = new Set(rawCategories.flatMap((c) => c.checklistIds));
-
-      // 未分類アイテムがあれば「その他」カテゴリにまとめる
-      const uncategorized = Array.from(allIds).filter(
-        (id) => !assignedIds.has(id),
-      );
-      if (uncategorized.length > 0) {
-        rawCategories.push({
-          name: 'その他',
-          checklistIds: uncategorized,
-        });
-      }
-
-      const seen = new Set<number>();
-      const finalCategories: {
-        name: string;
-        checklists: { id: number; content: string }[];
-      }[] = [];
-
-      for (const { name, checklistIds } of rawCategories) {
-        // ── カテゴリ内の重複排除 ────────────────────────
-        const uniqueInCategory = Array.from(new Set(checklistIds));
-
-        // ── 他カテゴリですでに割り当て済みのIDを除外 ─────────
-        const filteredIds = uniqueInCategory.filter((id) => !seen.has(id));
-        filteredIds.forEach((id) => seen.add(id));
-
-        // ── MAX_CHECKLISTS_PER_CATEGORY件ずつチャンクに分けてサブカテゴリ化 ────────────
-        for (
-          let i = 0;
-          i < filteredIds.length;
-          i += MAX_CHECKLISTS_PER_CATEGORY
-        ) {
-          const chunkIds = filteredIds.slice(
-            i,
-            i + MAX_CHECKLISTS_PER_CATEGORY,
-          );
-          const chunkName =
-            i === 0
-              ? name
-              : `${name} (Part ${Math.floor(i / MAX_CHECKLISTS_PER_CATEGORY) + 1})`;
-
-          const checklists = chunkIds.map((id) => {
-            const item = checklistData.find((c) => c.id === id)!;
-            return { id: item.id, content: item.content };
-          });
-
-          finalCategories.push({ name: chunkName, checklists });
-        }
-      }
-
-      return {
-        status: 'success' as stepStatus,
-        categories: finalCategories,
-      };
-    } catch (error) {
-      logger.error(error, 'チェックリストのカテゴリ分類処理に失敗しました');
-      if (
-        extractAIAPISafeError(error) ||
-        NoObjectGeneratedError.isInstance(error) ||
-        error instanceof MastraError
-      ) {
-        // APIコールエラーまたはAIモデルが生成できる文字数を超えた場合、手動でカテゴリー分割
-        // AIモデルが生成できる文字数を超えているため、手動でカテゴリー分割
-        const checklistsResult =
-          await repository.getChecklists(reviewHistoryId);
-        return {
-          status: 'success' as stepStatus,
-          categories: splitChecklistEquallyByMaxSize(
-            checklistsResult,
-            MAX_CHECKLISTS_PER_CATEGORY,
-          ),
-        };
-      }
-      const normalizedError = normalizeUnknownError(error);
-      const errorDetail = normalizedError.message;
-      // エラーが発生した場合はエラ
-      const errorMessage = `${errorDetail}`;
-      return {
-        status: 'failed' as stepStatus,
-        errorMessage,
-      };
-    }
-  },
-});
-
-// ステップ2: チェックリストごとにレビューを実行
-const reviewExecutionStep = createStep({
-  id: 'reviewExecutionStep',
-  description: 'チェックリストごとにレビューを実行するステップ',
-  inputSchema: classifyChecklistsByCategoryOutputSchema,
-  outputSchema: baseStepOutputSchema,
-  execute: async ({ inputData, getInitData, mastra, abortSignal, bail }) => {
-    // レビュー対象のファイル
-    const { files, additionalInstructions, commentFormat, evaluationSettings } =
-      getInitData() as z.infer<typeof triggerSchema>;
-    // ステップ1からの入力を取得
-    const { categories } = inputData;
-
-    // ステップ1でfailedした場合はそのまま返す
-    if (inputData.status === 'failed') {
-      return {
-        status: 'failed' as stepStatus,
-        errorMessage: inputData.errorMessage,
-      };
-    }
-
-    // リポジトリを取得
-    const reviewRepository = getReviewRepository();
-
-    try {
-      const reviewAgent = mastra.getAgent('reviewExecuteAgent');
-
-      // 複数ファイルを統合してメッセージを作成（一度だけ）
-      const message = await createCombinedMessage(
-        files,
-        'Please review this document against the provided checklist items',
-      );
-
-      // 各カテゴリごとに統合されたファイル内容をレビューする
-      for (const category of categories!) {
-        // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
-        // レビュー結果に含まれなかったチェックリストは再度レビューを実行する（最大試行回数は3回）
-        const maxAttempts = 3;
-        let attempt = 0;
-        let reviewTargetChecklists = category.checklists;
-        while (attempt < maxAttempts) {
-          // デフォルトの評定項目
-          const defaultEvaluationItems = ['A', 'B', 'C', '-'] as const;
-
-          // カスタム評定項目がある場合はそれを使用、なければデフォルトを使用
-          const evaluationItems = evaluationSettings?.items?.length
-            ? evaluationSettings.items.map((item) => item.label)
-            : defaultEvaluationItems;
-
-          // 最初の要素が存在することを確認してenumを作成
-          const evaluationEnum =
-            evaluationItems.length > 0
-              ? z.enum([evaluationItems[0], ...evaluationItems.slice(1)] as [
-                  string,
-                  ...string[],
-                ])
-              : z.enum(defaultEvaluationItems);
-
-          const outputSchema = z.array(
-            z.object({
-              checklistId: z.number(),
-              reviewSections: z
-                .array(
-                  z.object({
-                    fileName: z.string().describe('file name to review'),
-                    sectionNames: z
-                      .array(
-                        z.string().describe('section name within the file'),
-                      )
-                  }),
-                )
-                .describe(
-                  'files and sections that should be reviewed for evaluation and commenting',
-                ),
-              comment: z.string().describe('evaluation comment'),
-              evaluation: evaluationEnum.describe('evaluation'),
-            }),
-          );
-          const runtimeContext =
-            await createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
-          runtimeContext.set('checklistItems', reviewTargetChecklists);
-          runtimeContext.set('additionalInstructions', additionalInstructions);
-          runtimeContext.set('commentFormat', commentFormat);
-          runtimeContext.set('evaluationSettings', evaluationSettings);
-
-          // チェックリスト一覧をメッセージの最後にリマインドとして追加
-          const checklistReminder = `## Checklist Items to Review:
-${reviewTargetChecklists.map((item) => `- ID: ${item.id} - ${item.content}`).join('\n')}
-
-Please review the document against the above checklist items.`;
-
-          // メッセージのcontentの最後にリマインダーを追加
-          const messageWithReminder = {
-            ...message,
-            content: [
-              ...message.content,
-              {
-                type: 'text' as const,
-                text: checklistReminder,
-              },
-            ],
-          };
-
-          // レビューエージェントを使用してレビューを実行
-          const reviewResult = await reviewAgent.generate(messageWithReminder, {
-            output: outputSchema,
-            runtimeContext,
-            abortSignal,
-          });
-          const { success, reason } = judgeFinishReason(
-            reviewResult.finishReason,
-          );
-          if (!success) {
-            throw internalError({
-              expose: true,
-              messageCode: 'AI_API_ERROR',
-              messageParams: { detail: reason },
-            });
-          }
-          // レビュー結果をDBに保存（複数ファイルの情報を統合）
-          if (reviewResult.object && Array.isArray(reviewResult.object)) {
-            const combinedFileIds = files.map((f) => f.id).join('/');
-            const idsHash = createHash('md5')
-              .update(combinedFileIds)
-              .digest('hex');
-            const combinedFileNames = files.map((f) => f.name).join('/');
-            await reviewRepository.upsertReviewResult(
-              reviewResult.object.map((result) => ({
-                reviewChecklistId: result.checklistId,
-                evaluation: result.evaluation as ReviewEvaluation,
-                comment: result.comment,
-                fileId: idsHash,
-                fileName: combinedFileNames,
-              })),
-            );
-          }
-          // レビュー結果に含まれなかったチェックリストを抽出
-          const reviewedChecklistIds = new Set(
-            reviewResult.object && Array.isArray(reviewResult.object)
-              ? reviewResult.object.map((result) => result.checklistId)
-              : [],
-          );
-          reviewTargetChecklists = reviewTargetChecklists.filter(
-            (checklist) => !reviewedChecklistIds.has(checklist.id),
-          );
-          if (reviewTargetChecklists.length === 0) {
-            // 全てのチェックリストがレビューされた場合、成功
-            break;
-          }
-          attempt += 1;
-        }
-        if (attempt >= maxAttempts) {
-          // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
-          bail({
-            status: 'failed' as stepStatus,
-            errorMessage:
-              '全てのチェックリストに対してレビューを完了することができませんでした\nもう一度お試しください',
-          });
-        }
-      }
-      // 全てのレビューが成功した場合
-      return {
-        status: 'success' as stepStatus,
-        output: {
-          success: true,
-        },
-      };
-    } catch (error) {
-      logger.error(error, 'チェックリストのレビュー実行処理に失敗しました');
-      let errorMessage: string;
-      if (
-        NoObjectGeneratedError.isInstance(error) &&
-        error.finishReason === 'length'
-      ) {
-        // AIモデルが生成できる文字数を超えているため、手動でレビューを分割
-        errorMessage = `AIモデルが生成できる文字数を超えています。チェックリスト量の削減を検討してください。`;
-      } else {
-        const normalizedError = normalizeUnknownError(error);
-        errorMessage = normalizedError.message;
-      }
-      // エラーが発生した場合はエラー情報を返す
-      return {
-        status: 'failed' as stepStatus,
-        errorMessage,
-      };
-    }
-  },
-});
-
-/**
- * レビュー実行ワークフロー
- */
-export const reviewExecutionWorkflow = createWorkflow({
-  id: 'reviewExecutionWorkflow',
-  inputSchema: triggerSchema,
-  // ドキュメントには最終ステップの出力スキーマを指定すれば良いように記載があるが、実際の出力結果は{最終ステップ: outputSchema}となっている
-  // Matraのバグ？
-  outputSchema: baseStepOutputSchema,
-  steps: [classifyChecklistsByCategoryStep, reviewExecutionStep],
-})
-  .then(classifyChecklistsByCategoryStep)
-  .then(reviewExecutionStep)
-  .commit();
diff --git a/src/mastra/workflows/types.ts b/src/mastra/workflows/types.ts
index e65eab090..d5998a6e9 100644
--- a/src/mastra/workflows/types.ts
+++ b/src/mastra/workflows/types.ts
@@ -1 +1,29 @@
 export type stepStatus = 'success' | 'failed';
+
+// ドキュメント量選択タイプ
+export type DocumentVolumeType = 'small' | 'large';
+
+// ドキュメント情報（ワークフロー内で一意識別用のIDを追加）
+export interface DocumentInfo {
+  id: string;
+  name: string;
+  path: string;
+  type: string;
+  pdfProcessMode?: 'text' | 'image';
+  pdfImageMode?: 'merged' | 'pages';
+  imageData?: string[];
+  workflowDocId?: string; // ワークフロー内での一時的なID
+}
+
+// ドキュメント要約情報
+export interface DocumentSummary {
+  workflowDocId: string;
+  name: string;
+  topics: string[];
+  summary: string;
+}
+
+// ドキュメント要約レスポンス
+export interface DocumentSummaryResponse {
+  summaries: DocumentSummary[];
+}
diff --git a/src/renderer/App.tsx b/src/renderer/App.tsx
index 3db408950..72fbc401f 100644
--- a/src/renderer/App.tsx
+++ b/src/renderer/App.tsx
@@ -177,7 +177,14 @@ function App() {
                       <Alert
                         key={message.id}
                         severity={message.type}
-                        sx={{ whiteSpace: 'pre-line', boxShadow: 3 }}
+                        sx={{
+                          whiteSpace: 'pre-line',
+                          boxShadow: 3,
+                          maxHeight: '200px',
+                          overflowY: 'auto',
+                          overflowX: 'hidden',
+                          wordBreak: 'break-word',
+                        }}
                         onClose={() => closeMessage(message.id)}
                       >
                         {message.content}
@@ -191,6 +198,10 @@ function App() {
                         sx={{
                           whiteSpace: 'pre-line',
                           boxShadow: 3,
+                          maxHeight: '200px',
+                          overflowY: 'auto',
+                          overflowX: 'hidden',
+                          wordBreak: 'break-word',
                         }}
                       >
                         {error.message}
diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
index 3af4dbbab..fb13e0c70 100644
--- a/src/renderer/components/review/ReviewArea.tsx
+++ b/src/renderer/components/review/ReviewArea.tsx
@@ -12,6 +12,7 @@ import {
   CustomEvaluationSettings,
   ChecklistExtractionResultStatus,
   ReviewExecutionResultStatus,
+  DocumentMode,
 } from '@/types';
 import { ReviewAreaProps } from './types';
 import ReviewChecklistSection from './ReviewChecklistSection';
@@ -343,7 +344,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
 
   // レビュー実行処理
   const handleExecuteReview = useCallback(
-    async (files: UploadFile[]) => {
+    async (files: UploadFile[], documentMode?: DocumentMode) => {
       if (!selectedReviewHistoryId) return;
 
       const reviewApi = ReviewApi.getInstance();
@@ -363,6 +364,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
           selectedReviewHistoryId,
           files,
           evaluationSettings,
+          documentMode,
           additionalInstructions || additionalInstructions,
           commentFormat || commentFormat,
           { throwError: true, showAlert: false },
@@ -466,6 +468,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
       files: UploadFile[],
       documentType?: DocumentType,
       checklistRequirements?: string,
+      documentMode?: DocumentMode,
     ) => {
       if (modalMode === 'extract') {
         await handleExtractChecklist(
@@ -474,7 +477,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
           checklistRequirements,
         );
       } else if (modalMode === 'review') {
-        await handleExecuteReview(files);
+        await handleExecuteReview(files, documentMode);
       }
     },
     [modalMode, handleExtractChecklist, handleExecuteReview],
diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
index 63ef7654d..fffb346cb 100644
--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++ b/src/renderer/components/review/ReviewChecklistSection.tsx
@@ -14,6 +14,7 @@ import {
   TextField,
   Stack,
   Typography,
+  Tooltip,
 } from '@mui/material';
 import AddIcon from '@mui/icons-material/Add';
 import DeleteIcon from '@mui/icons-material/Delete';
@@ -169,14 +170,33 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
           チェックリスト
         </TableCell>
         {uniqueSources.map((src) => (
-          <TableCell key={src.id} align="center" sx={{ minWidth: 200 }}>
-            <TableSortLabel
-              active={sortBy === src.id}
-              direction={sortBy === src.id ? sortDirection : 'desc'}
-              onClick={() => handleSort(src.id)}
-            >
-              {src.fileName}
-            </TableSortLabel>
+          <TableCell
+            key={src.id}
+            align="center"
+            sx={{
+              minWidth: 200,
+              maxHeight: '4.5em',
+              overflow: 'hidden',
+              overflowY: 'auto',
+              lineHeight: '1.5em',
+              whiteSpace: 'normal',
+              wordBreak: 'break-all',
+              '&:hover': {
+                overflowY: 'auto',
+              },
+            }}
+          >
+            <Tooltip title={src.fileName} placement="top">
+              <div>
+                <TableSortLabel
+                  active={sortBy === src.id}
+                  direction={sortBy === src.id ? sortDirection : 'desc'}
+                  onClick={() => handleSort(src.id)}
+                >
+                  {src.fileName}
+                </TableSortLabel>
+              </div>
+            </Tooltip>
           </TableCell>
         ))}
         <TableCell align="center" sx={{ minWidth: 120 }}>
diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
index 374764d6a..1c9301bee 100644
--- a/src/renderer/components/review/ReviewSourceModal.tsx
+++ b/src/renderer/components/review/ReviewSourceModal.tsx
@@ -41,6 +41,7 @@ import {
   PdfProcessMode,
   PdfImageMode,
   EvaluationItem,
+  DocumentMode,
 } from '@/types';
 import { useAlertStore } from '@/renderer/stores/alertStore';
 import { getSafeErrorMessage } from '../../lib/error';
@@ -137,6 +138,8 @@ function ReviewSourceModal({
   const [documentType, setDocumentType] =
     useState<DocumentType>('checklist-ai');
   const [checklistRequirements, setChecklistRequirements] = useState('');
+  const [documentVolumeType, setDocumentVolumeType] =
+    useState<DocumentMode>('small');
   const [editingItemIndex, setEditingItemIndex] = useState<number | null>(null);
   const [editingItem, setEditingItem] = useState<EvaluationItem>({
     label: '',
@@ -151,6 +154,7 @@ function ReviewSourceModal({
       setUploadedFiles([]);
       setDocumentType('checklist-ai');
       setChecklistRequirements('');
+      setDocumentVolumeType('small');
     };
 
     loadSavedData();
@@ -388,6 +392,7 @@ function ReviewSourceModal({
           checklistRequirements.trim() !== ''
           ? checklistRequirements.trim()
           : undefined,
+        modalMode === 'review' ? documentVolumeType : undefined,
         modalMode === 'review' && additionalInstructions.trim() !== ''
           ? additionalInstructions.trim()
           : undefined,
@@ -489,6 +494,49 @@ function ReviewSourceModal({
 
         {modalMode === 'review' && (
           <>
+            <FormControl component="fieldset" sx={{ mb: 2 }}>
+              <FormLabel component="legend">ドキュメント量</FormLabel>
+              <RadioGroup
+                value={documentVolumeType}
+                onChange={(e) =>
+                  setDocumentVolumeType(e.target.value as 'small' | 'large')
+                }
+              >
+                <FormControlLabel
+                  value="small"
+                  control={<Radio />}
+                  label={
+                    <Tooltip title="選択されたドキュメントを全てそのままAIの入力コンテキストに与えてレビューを行います。ドキュメント量が少ない場合に選択してください。">
+                      <span>
+                        少量ドキュメント
+                        <HelpIcon
+                          fontSize="small"
+                          sx={{ ml: 0.5, color: 'text.secondary' }}
+                        />
+                      </span>
+                    </Tooltip>
+                  }
+                  disabled={processing}
+                />
+                <FormControlLabel
+                  value="large"
+                  control={<Radio />}
+                  label={
+                    <Tooltip title="ドキュメントを直接AIに入力するのではなく、個々のドキュメントの要約や分析を実行して整理し、最終的にレビューを行います。ドキュメント量が多い場合に選択してください。">
+                      <span>
+                        大量ドキュメント
+                        <HelpIcon
+                          fontSize="small"
+                          sx={{ ml: 0.5, color: 'text.secondary' }}
+                        />
+                      </span>
+                    </Tooltip>
+                  }
+                  disabled={processing}
+                />
+              </RadioGroup>
+            </FormControl>
+
             <TextField
               fullWidth
               multiline
diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
index bc92859fd..2599bdf7c 100644
--- a/src/renderer/components/review/types.ts
+++ b/src/renderer/components/review/types.ts
@@ -5,6 +5,7 @@ import {
   UploadFile,
   DocumentType,
   CustomEvaluationSettings,
+  DocumentMode,
 } from '@/types';
 
 // ReviewAreaのProps型
@@ -27,6 +28,7 @@ export interface ReviewSourceModalProps {
     files: UploadFile[],
     documentType?: DocumentType,
     checklistRequirements?: string,
+    documentMode?: DocumentMode,
     additionalInstructions?: string,
     commentFormat?: string,
     evaluationSettings?: CustomEvaluationSettings,
diff --git a/src/renderer/service/reviewApi.ts b/src/renderer/service/reviewApi.ts
index 55a386a85..5783c587e 100644
--- a/src/renderer/service/reviewApi.ts
+++ b/src/renderer/service/reviewApi.ts
@@ -6,6 +6,7 @@ import {
   ChecklistExtractionResultStatus,
   ReviewExecutionResultStatus,
   CustomEvaluationSettings,
+  DocumentMode,
 } from '@/types';
 import { ApiServiceDefaultOptions } from '../types';
 import { invokeApi } from '../lib/apiUtils';
@@ -46,6 +47,7 @@ export interface IReviewApi {
     historyId: string,
     files: UploadFile[],
     evaluationSettings: CustomEvaluationSettings,
+    documentMode: DocumentMode,
     additionalInstructions?: string,
     commentFormat?: string,
     options?: ApiServiceDefaultOptions,
@@ -151,6 +153,7 @@ export class ReviewApi implements IReviewApi {
     historyId: string,
     files: UploadFile[],
     evaluationSettings: CustomEvaluationSettings,
+    documentMode?: DocumentMode,
     additionalInstructions?: string,
     commentFormat?: string,
     options?: ApiServiceDefaultOptions,
@@ -163,6 +166,7 @@ export class ReviewApi implements IReviewApi {
           additionalInstructions,
           commentFormat,
           evaluationSettings,
+          documentMode: documentMode ? documentMode : 'small',
         }),
       options,
     );
diff --git a/src/types/ipc.ts b/src/types/ipc.ts
index 90adc42a6..88dd8012b 100644
--- a/src/types/ipc.ts
+++ b/src/types/ipc.ts
@@ -9,6 +9,7 @@ import type {
   ChecklistExtractionResultStatus,
   ReviewExecutionResultStatus,
   CustomEvaluationSettings,
+  DocumentMode,
 } from './review';
 import type { SettingsSavingStatus, Settings } from './setting';
 import type { Source, RevieHistory } from '@/types';
@@ -143,6 +144,7 @@ export type IpcRequestPayloadMap = {
     additionalInstructions?: string;
     commentFormat?: string;
     evaluationSettings: CustomEvaluationSettings;
+    documentMode: DocumentMode;
   };
   [IpcChannels.REVIEW_EXECUTE_ABORT]: string; // review history id
 };
diff --git a/src/types/review.ts b/src/types/review.ts
index f303e93b7..5ce8d1adc 100644
--- a/src/types/review.ts
+++ b/src/types/review.ts
@@ -56,7 +56,6 @@ export type ReviewChecklistEdit = {
 
 export type ModalMode = 'extract' | 'review';
 
-// ドキュメント種別の定義
 export type DocumentType = 'checklist-ai' | 'checklist-csv' | 'general';
 
 // PDF処理方式の定義
@@ -65,6 +64,9 @@ export type PdfProcessMode = 'text' | 'image';
 // PDF画像化方式の定義
 export type PdfImageMode = 'merged' | 'pages';
 
+// ドキュメントレビューのモード定義
+export type DocumentMode = 'small' | 'large';
+
 // アップロードファイル情報の型定義
 export interface UploadFile {
   id: string;
