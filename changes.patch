diff --git a/src/main/repository/settingsRepository.ts b/src/main/repository/settingsRepository.ts
index 144bdb864..8e9590332 100644
--- a/src/main/repository/settingsRepository.ts
+++ b/src/main/repository/settingsRepository.ts
@@ -26,6 +26,15 @@ export const getSettingsRepository = (): ISettingsRepository => {
   return SettingsRepository;
 };
 
+/** undefined を保存したら例外になるため、delete に切り替える */
+function setOrDelete<T>(store: any, key: string, value: T | undefined) {
+  if (value === undefined) {
+    store.delete(key);
+  } else {
+    store.set(key, value);
+  }
+}
+
 /**
  * Electron Storeを使用した設定リポジトリの実装
  */
@@ -46,21 +55,34 @@ class ElectronStoreSettingsRepository implements ISettingsRepository {
 
   async saveSettings(settings: Settings): Promise<void> {
     try {
+      // 必須系（undefined にならない想定）
       this.store.set('database.dir', settings.database.dir);
-      this.store.set('source.registerDir', settings.source.registerDir);
       this.store.set('api.key', settings.api.key);
       this.store.set('api.model', settings.api.model);
       this.store.set('api.url', settings.api.url);
-      this.store.set('redmine.endpoint', settings.redmine.endpoint);
-      this.store.set('redmine.apiKey', settings.redmine.apiKey);
-      this.store.set('gitlab.endpoint', settings.gitlab.endpoint);
-      this.store.set('gitlab.apiKey', settings.gitlab.apiKey);
-      this.store.set('systemPrompt.content', settings.systemPrompt.content);
+
+      // 任意系は undefined の可能性があるため setOrDelete で処理
+      setOrDelete(this.store, 'source.registerDir', settings.source.registerDir);
+
+      setOrDelete(this.store, 'redmine.endpoint', settings.redmine.endpoint);
+      setOrDelete(this.store, 'redmine.apiKey', settings.redmine.apiKey);
+
+      setOrDelete(this.store, 'gitlab.endpoint', settings.gitlab.endpoint);
+      setOrDelete(this.store, 'gitlab.apiKey', settings.gitlab.apiKey);
+
+      setOrDelete(
+        this.store,
+        'systemPrompt.content',
+        settings.systemPrompt.content,
+      );
+
       if (settings.mcp.serverConfig) {
         this.store.set(
           'mcp.serverConfig',
           JSON.stringify(settings.mcp.serverConfig, null, 2),
         );
+      } else {
+        this.store.delete('mcp.serverConfig');
       }
     } catch (err) {
       throw repositoryError('設定情報の保存に失敗しました', err);
diff --git a/src/renderer/hooks/useSettings.ts b/src/renderer/hooks/useSettings.ts
index 5da798fa8..fb7a118eb 100644
--- a/src/renderer/hooks/useSettings.ts
+++ b/src/renderer/hooks/useSettings.ts
@@ -291,8 +291,10 @@ const useSettingsStore = () => {
         });
       }
 
+      const parsedSettings = await SettingsSchema.parseAsync(settings);
+
       // 設定を一括保存
-      await settingsApi.setSettings(settings, {
+      await settingsApi.setSettings(parsedSettings, {
         showAlert: false,
         throwError: true,
       });
diff --git a/src/types/setting.ts b/src/types/setting.ts
index e02af8c58..a0416b4f4 100644
--- a/src/types/setting.ts
+++ b/src/types/setting.ts
@@ -75,16 +75,19 @@ export const DatabaseSchema = z.object({
  * ソース設定のスキーマ
  */
 export const SourceSchema = z.object({
-  registerDir: z.string().optional().refine(
-    async (path) => {
-      if (!path) return true;
-      if (path === '') return true; // 空文字は許容
-      return await checkPathExists(path);
-    },
-    {
-      message: '指定されたパスが存在しません',
-    },
-  ),
+  registerDir: z
+    .string()
+    .optional()
+    .refine(
+      async (path) => {
+        if (!path) return true;
+        if (path === '') return true; // 空文字は許容
+        return await checkPathExists(path);
+      },
+      {
+        message: '指定されたパスが存在しません',
+      },
+    ),
 });
 
 /**
@@ -136,7 +139,13 @@ export const McpStoreSchema = z.object({
     .optional()
     .transform((str, ctx) => {
       try {
-        if (!str || str.trim() === '') {
+        if (str === undefined) return undefined;
+
+        // 全ての空白を取り除く（半角/全角スペース・タブ・改行など）
+        const cleaned = str.replace(/[\s\u3000]/g, '');
+
+        // 空文字または "{}" の場合は undefined を返す
+        if (cleaned === '' || cleaned === '{}' || cleaned === '""') {
           return undefined;
         }
         const json = JSON.parse(str);
