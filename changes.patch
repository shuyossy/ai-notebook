diff --git a/.mcp.json b/.mcp.json
index b25d0b2fc..1afeed552 100644
--- a/.mcp.json
+++ b/.mcp.json
@@ -4,7 +4,7 @@
       "command": "npx",
       "args": [
         "-y",
-        "@mastra/mcp-docs-server@0.13.13"
+        "@mastra/mcp-docs-server@0.13.31"
       ],
       "autoApprove": [
         "mastraDocs",
diff --git a/CLAUDE.md b/CLAUDE.md
index 25db9b375..53c97238b 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -61,12 +61,13 @@ npm test
             - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
               - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
             - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
-      - どちらも複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
-      - 対応可能なファイルは以下
-        - word,excel,powerpoint,pdf,テキスト文書
-          - テキスト抽出するか画像としてAIに送信するか選択することができる
-            - 画像として送信する場合はpdfを画像化する(renderer側で画像化※main側ではcanvasが扱いづらかったため)
-              - office文書についてはmain側で一度pdf化してから画像化する
+      - （ドキュメントレビュー結果に対する）質問機能
+    - チェックリスト抽出・レビュー機能においてアップデート可能なファイルは以下
+      - word,excel,powerpoint,pdf,テキスト文書
+        - テキスト抽出するか画像としてAIに送信するか選択することができる
+          - 画像として送信する場合はpdfを画像化する(renderer側で画像化※main側ではcanvasが扱いづらかったため)
+            - office文書についてはmain側で一度pdf化してから画像化する
+      - また、複数ファイルを選択することができ、その場合は、複数ファイルが一つの統合ドキュメントとして認識される(よくある、本紙・別紙などのドキュメントに対応)
     - ユーザは対象ドキュメントをファイルアップロード形式で指定する
        - 基本的にはアップロードされたファイルはテキスト抽出処理が実行され、後続のworkflow処理で利用される
          - ただし、PDFファイルについてはテキスト抽出か画像として処理するか選択することができる
@@ -156,25 +157,27 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
 
 ## テスト作成時の注意
 - 明確な指示がある場合以外はテストコードを作成しないこと
+- renderer側のコードのテストは`src/__tests__/renderer/`に配置
+- main側のコードのテストは`src/__tests__/main/`に配
 - 外部ライブラリとの結合をテストする場合はできるだけ実際のライブラリを使用すること
   - 実際のライブラリの利用が難しい場合はモックを利用すること
-  - Electron IPCはモックを利用すること
-    - モックの実装はsrc/__tests__/test-utils/mockElectronHandler.tsに集約させること
+- renderer側テストの場合、Electron IPC通信はモックを利用すること
+  - この場合のモックの実装は`src/__tests__/renderer/test-utils/mockElectronHandler.ts`に集約させること
 - 下記の観点からテストを作成すること
-  - ビジネス的な観点
+  - ビジネス的な観点(ブラックボックステスト)
     - 正常系
     - 異常系
-  - 技術的な観点
+  - 技術的な観点(ホワイトボックステスト)
     - 正常系
     - 異常系
-- テストに関連するプロダクトコードのカバレッジを100%にすること
-- テスト関連コードはsrc/__test__に配置すること
+- テストに関連するプロダクトコードのカバレッジ(分岐カバレッジ)を100%にすること
 - テストは古典派的なスタイルで記述すること
   - つまり、単体テストはクラス単位ではなく、一つの振る舞い単位で記述すること
+  - また、最終的にMainプロセスの処理を（IPC通信にて）呼び出す場合は、モック化したIPC通信の処理を正しく呼び出せているかアサーションすること
 - テストの説明は日本語で記述すること
   - テストの説明は、何をテストしているのか、どのような条件でテストが行われるのかを明確に記述すること
 - テストの書き方で不明点があれば次のディレクトリ配下のテストコードを参考にすること
-  - src/__tests__/integration
+  - src/__tests__/renderer
 
 ## 実装上の注意
 - Mastraについては実装する際はまずMCPでドキュメントや実装例を参考にしてから正確な情報やベストプラクティスに基づいてコーディングすること
@@ -204,106 +207,38 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
 - フロントエンドでエラーメッセージを表示する(addAlertで出す想定)場合はcatchしたエラーを`src/renderer/lib/error.ts`で定義しているgetSafeErrorMessage関数に適用してエラーメッセージを取り出すこと
 - このアプリでは基本的にエラーメッセージは独自例外(`src/renderer/lib/error.ts`,`src/main/lib/error.ts`)をthrowしないとユーザにエラーメッセージが表示されないため、注意すること
 - DB用の型(`src/adapter/db/drizzle/schema.ts`)とシステム内部で利用する型（ドメイン型）(`src/types`)は将来の保守性や移植性を考慮して適切に分離し、これらの差分はrepositoryで吸収すること
-- テストについては指示されない限り、実行も修正もしなくてよい
 - DBマイグレーションの実行は指示されない限り不要
 - 適宜調査や実装の際に必要あればcodex mcpを活用すること
 - 新規追加した部分については型エラーが出ないようにすること
-
-
-## 依頼タスク
-- ビジネス要件
-  - レビュー機能利用時に、レビュー結果に対してAIとチャットできる機能を追加する
-- 機能要件
-  1. 1レビュー履歴に対して1つの（結合）ドキュメントのみ登録可能にする: 完了済み
-    - 目的
-      - AIとチャットする際に複数のドキュメントがレビュー結果として登録されているとどのドキュメントに対して回答して良いかわからなくなるため
-    - 実装方針
-      - DBテーブルの更新
-        - `review_checklist_results`を廃止して`review_checklists`に統合
-        - `review_checklist_results`のfileId,fileNameを削除して、`review_histories`にtargetDocumentName(レビュー対象の(統合)ドキュメント名のこと)として同じ役割を引き継がせる
-      - ドメイン型の更新
-        - ReviewChecklistResultのsourceEvaluations属性は配列ではなく、単一要素とする
-        - ReviewChecklistResultのfileIdとfileNameを削除、targetDocumentNameを新規追加
-        - これらに伴い既存処理の変更も必要になるので注意すること
-      - サーバサイド処理更新
-        - レビュー実行の開始時(`src/mastra/workflows/sourceReview/executeReview/index.ts`のステップ1テキスト抽出とカテゴリ分割の実行後のmap処理内)に、既存のレビュー結果は全て削除してから実行するように変更する
-  2. レビュー実行時にアップロードしたファイル内容(抽出済みテキスト、画像データ)と、（大量ドキュメントレビューの場合は）個別レビューの結果を、後にチャットする時のために保存して取り出すことができるようにする: 完了済み
-    - 実装方針
-      - DBテーブルの更新
-        - `review_document_chaches`テーブルの作成
-          - `review_histories`と一対多の関係
-          - ファイルのメタデータ(id, originalFileName(大量ドキュメントレビュー用), fileName, processMode('text' or 'image'), originalPath, cachePath,...等)を保存
-        - `review_histories`テーブルに大量ドキュメントレビューか少量ドキュメントレビューかを示すフラグを追加
-        - `review_largedocument_result_chaches`テーブルの作成
-          - `review_document_chaches`と`review_checklists`の中間テーブル
-          - 少量ドキュメントレビューの場合に、個別チェックリストに対して、個別ドキュメントをレビューするが、その際のチャンクパラメータ(チャンク総数と個別ドキュメントのチャンクインデックス)と結果を保存
-      - ドメイン型の更新
-        - 上記に合わせてドメイン型(`src/types/review.ts`)の新規作成が必要
-        - 今後も見据えて最善のドメイン型を作成してください
-      - サーバサイド処理更新
-        - レビュー実行方法が大量ドキュメントレビューであったか、それとも少量ドキュメントレビューであったのか、レビュー実行時に保存できるようにする
-        - ファイルのメタデータについてはDBに保存し、実態はキャッシュ用のディレクトリに保存
-          - キャッシュについては以下パスに保存
-            - 抽出済みテキスト`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}.txt`
-            - 画像データ`${AppDataディレクトリ}/review_chache/${レビューID}/file_cache/${id}/page_${インデックス値}.b64`
-          - キャッシュのパスはDBに保存して、後ほどチャット機能で簡単にパスを取得できるようにする
-            - processModeがtextの場合はキャッシュのパスはファイルパス(`.../${id}.txt`)になり、imageの場合はディレクトリパス(`.../${id}`)になる
-          - 実際にレビューが実行された直後にレビュー結果とともにドキュメントのキャッシュを保存する
-      - 実装時の注意点
-        - （少量、大量）レビュー実行時の処理（コンポーネント~workflow）に影響があるので、幅広く影響を見極めること
-        - DBとドメインについてはどちらも上手くrepositoryインターフェースに依存性逆転させているのでこれを利用して効率的に実装すること
-  3. レビュー結果に対してAIとチャットできるようにする: 実行中
-    - 実装方針
-      - UI
-        - チャット結果画面内(`src/renderer/components/review/ReviewChecklistSection.tsx`)にチャットを開始できるボタンを配置
-          - このボタンが押下されると画面右サイドからチャット画面が出現する
-            - チャット画面については`src/renderer/components/chat/ChatArea.tsx`を参考にすること(特にuseChatフックを利用する部分)
-        - チャットに関するコンポーネントは最大限既存のものを活用する（`src/renderer/components/chat`） 
-        - チャット内容は永続化する必要はなく、レビューIDを切り替えたらチャット内容は初期化される
-        - チャット入力欄で「@」と入力するとどのチェックリストに対して質問をするかスクロール形式で選ぶことができる
-          - 一般的にAIコーディングエディタ内で任意のファイルを参照させることができるようにするための用途で実装されているものと同じ形式と理解して実装してください
-          - 対象のチェックリストについてはuseStateで状態管理しておく
-            - 「@チェックリストA」のような完全な状態から「@チェックリスト」のように一文字でも欠けた状態になった場合は、状態管理から外す
-            - 管理下にあるチェックリストについてはチャット入力欄内の「@チェックリストA」を青字で表示する(これも一般的なAIコーディングエディタでよくある実装方法です)
-            - 複数のチェックリストを登録可能
-      - サーバサイド処理更新
-        - AIチャット機能実装
-          - mastra workflowとして実装
-            - workflowは以下のようなステップで構築する(大量ドキュメントレビュー、少量ドキュメントレビューで区別しない)
-              1. AIにユーザからの質問と対象のチェックリストを与えて、調査対象ドキュメントとその調査内容のペアの配列を出力させる
-                - AI処理詳細
-                  - システムプロンプト
-                    - 提示する内容
-                      - @で指定されたチェックリストの内容とレビュー結果（大量レビューの場合は個別のレビュー結果も） 
-                      - ドキュメントキャッシュ内容(id, FileName)
-                        - 出力時に質問対象ドキュメントを指定できるようにするため
-                      - AIの役割：ユーザから与えられたチェックリスト結果と質問に対して、最終的に良い回答ができるように、調査すべきドキュメントとその調査内容を出力すること
-                  - ユーザコンテキスト
-                      - ユーザからの質問
-                  - 出力内容
-                  ```
-                  {
-                    documentId: string # review_document_cachesテーブルのId
-                    researchContent: string
-                  }[]
-                  ```
-              2. 1で指定されたドキュメント毎に以下ステップを並列実行(foreach)
-                - `review_largedocument_result_chaches`テーブル内のドキュメントキャッシュIDが一致するレコードからtotalChunksの最大値を取得
-                - 以下をループ(dountil)※`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts`の`individualDocumentReviewWorkflow`を参考にすること
-                  - ドキュメントをtotalChunks分のチャンクに分解して(`src/mastra/workflows/sourceReview/lib.ts`を利用)、それぞれに対して以下を並列実行(foreach)
-                    - AIに調査対象ドキュメント(reviewRepository#getReviewDocumentCacheByDocumentIdを利用して取得)と調査内容を与えて、調査結果を出力する
-                  - 並列処理の結果一つでもコンテキスト長エラーになっていた場合は、チャンク数を一つ増やして処理をループする（全てsuccessの場合はループ終了）
-              3. 2の調査結果を全てAIに与えて、最終的にユーザ返す質問内容を出力する
-            - workflowの最終的な処理結果はチャット機能と同様にAI SDK形式のチャンクをイベントpushで送信する(chatService#generateを参照)
-    - 実装時の注意点
-      - workflowの実装方法は大量ドキュメントレビュー実行時のworkflowを参考にすること
-      - AIに与えるシステムプロンプトも大量ドキュメントレビュー実行時ものもを参考にすること(なぜその処理を実行させたいのか、背景もうまく伝えられるようにして欲しい)
-  - 改善依頼
-    - レビュー質問workflow内のドキュメント調査ステップにて、ドキュメントが画像の場合に
-
-### タスク実装時の注意点
-- 依頼タスクの全ての手順を理解した上で、最適な実装をすること
-- **ドキュメントレビュー機能、レビュー質問機能の全て**を正しく理解した上で実装すること
-- プロンプト作成の際はベストプラクティスに沿って効果的なプロンプトにすること
-- ユーザが直感的に操作できて、尚且つ一般的なUIにすること
-  - 美しく、ユーザへの配慮がしっかりとできているUIにすること
+- 修正箇所に関するテストを必ず実施して不具合がないか確かめること
+  - 全てのテストファイルを実行すると膨大な時間がかかるので、必要なテストファイルを絞って実行すること（テストの初回実行時はファイルは絞るが、その中のケースは絞らなくて良い）
+- 新規に追加した機能については明確な理由がない限り、新規テストを作成すること
+  - 前述の通り、古典派的な方針でテストを実装するので、機能が作成完了した段階で新規テストを作成すること
+
+## 依頼中タスク
+- チェックリスト抽出機能のcsv・excelファイルインポート改良
+  - ASIS
+    - ファイルの1列目のチェックリストを全て抽出する
+    - ヘッダ行は認識しない(1行目から全てチェックリストとしてインポートする)
+  - TOBE
+    - チェックリストに加えて、以下もインポート可能にする(チェックリストも含めてすべて任意とする)
+      - レビュー時の追加指示・コメントフォーマット・評定設定
+      - AI APIの設定項目(APIのendpoint, url, model*これらはelectron-storeで保存しているので注意)
+    - 複数項目を設定することになるので、ファイルインポート形式を以下のように変更する
+      - ヘッダ行：チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+      - 特徴
+        - 1行目：ヘッダ行（列の意味を示す）
+        - 2行目以降：データ行
+        - チェックリスト列に値があれば→チェックリスト項目として認識
+        - 評定ラベル＋評定説明の両方に値があれば→評定項目として認識
+        - 追加指示・コメントフォーマット・AI設定列に値があれば→設定値として認識
+        - 空セルは無視
+    - 新インポート形式については、チェックリスト抽出時のモーダルにて、ファイルインポートを選択した場合に、わかりやすくユーザに伝えられるように説明文を表示すること
+      - 加えて、新インポート形式のフォーマットをダウンロードできるようにすること(フォーマットにはデフォルト値または簡単な例を記載しておく)
+    - 既存のcsvエクスポート機能についても、新import形式で出力できるようにすること
+    
+
+## 依頼中タスクの注意点
+- 既存のファイルインポート処理はmain側`reviewService#extractChecklistFromCsv`で処理しているので注意すること
+- 後方互換性は意識する必要はないです
+- 関連するコンポーネントやコードを十分に分析してから、計画策定・実装をすること
diff --git a/jest.esm-smart-transformer.cjs b/jest.esm-smart-transformer.cjs
new file mode 100644
index 000000000..c67826dfc
--- /dev/null
+++ b/jest.esm-smart-transformer.cjs
@@ -0,0 +1,82 @@
+// プロジェクト直下に保存: jest.esm-smart-transformer.cjs
+const fs = require('fs');
+const path = require('path');
+const babelJest = require('babel-jest');
+
+function findNearestPackageJson(startFile) {
+  let dir = path.dirname(startFile);
+  while (true) {
+    const pkg = path.join(dir, 'package.json');
+    if (fs.existsSync(pkg)) return pkg;
+    const parent = path.dirname(dir);
+    if (parent === dir) return null;
+    dir = parent;
+  }
+}
+
+function isEsmPackage(filePath) {
+  // node_modules配下だけ対象。自分のソースは ts-jest に任せる想定。
+  if (!filePath.includes(`${path.sep}node_modules${path.sep}`)) return false;
+
+  const pkgJsonPath = findNearestPackageJson(filePath);
+  if (!pkgJsonPath) return false;
+
+  try {
+    const pkg = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
+
+    // 1) type: module
+    if (pkg.type === 'module') return true;
+
+    // 2) exports フィールドが ESM を示唆（超簡易判定）
+    const exp = pkg.exports;
+    if (
+      typeof exp === 'string' &&
+      (exp.endsWith('.mjs') || exp.includes('/esm'))
+    )
+      return true;
+    if (typeof exp === 'object' && exp !== null) {
+      const v = exp.import || exp.module;
+      if (typeof v === 'string' && (v.endsWith('.mjs') || v.includes('/esm')))
+        return true;
+    }
+
+    // 3) module フィールド
+    if (typeof pkg.module === 'string') return true;
+
+    // 4) main が .mjs
+    if (typeof pkg.main === 'string' && pkg.main.endsWith('.mjs')) return true;
+
+    return false;
+  } catch {
+    return false;
+  }
+}
+
+// 内部で babel-jest を使う。preset-env は babel.config.js を参照させる。
+const babelTransformer = babelJest.createTransformer({});
+
+module.exports = {
+  process(src, filename, jestOptions) {
+    // ESMパッケージなら Babel で CJS へ変換
+    if (isEsmPackage(filename)) {
+      return babelTransformer.process(src, filename, jestOptions);
+    }
+    // それ以外（CJS or 自前JS）は “そのまま” 返す（Jestがそのまま実行）
+    return { code: src };
+  },
+
+  // キャッシュキーに近傍 package.json の更新を織り込む（賢くキャッシュ）
+  getCacheKey(fileData, filePath, transformOptions) {
+    const pkgJsonPath = findNearestPackageJson(filePath);
+    const pkgStat =
+      pkgJsonPath && fs.existsSync(pkgJsonPath)
+        ? fs.statSync(pkgJsonPath).mtimeMs.toString()
+        : 'nopkg';
+    return [
+      'esm-smart-transformer-v1',
+      pkgStat,
+      filePath.includes(`${path.sep}node_modules${path.sep}`) ? 'nm' : 'app',
+      transformOptions && transformOptions.instrument ? 'inst' : 'noinst',
+    ].join(':');
+  },
+};
diff --git a/package-lock.json b/package-lock.json
index 8ca85c171..4155d53cb 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -10,16 +10,16 @@
       "hasInstallScript": true,
       "license": "MIT",
       "dependencies": {
-        "@ai-sdk/openai-compatible": "^0.2.14",
+        "@ai-sdk/openai-compatible": "0.2.16",
         "@electron/notarize": "^3.0.0",
         "@emotion/react": "^11.14.0",
         "@emotion/styled": "^11.14.0",
         "@gitbeaker/rest": "^42.5.0",
-        "@mastra/core": "^0.14.1",
-        "@mastra/libsql": "^0.13.4",
-        "@mastra/loggers": "^0.10.9",
-        "@mastra/mcp": "^0.10.12",
-        "@mastra/memory": "^0.13.1",
+        "@mastra/core": "0.21.1",
+        "@mastra/libsql": "0.15.2",
+        "@mastra/loggers": "0.10.16",
+        "@mastra/mcp": "0.13.5",
+        "@mastra/memory": "^0.15.7",
         "@mui/icons-material": "^7.0.2",
         "@mui/material": "^7.0.2",
         "@radix-ui/react-dialog": "^1.1.10",
@@ -41,7 +41,7 @@
         "electron-updater": "^6.3.9",
         "intl-messageformat": "^10.7.16",
         "lucide-react": "^0.503.0",
-        "mastra": "^0.10.23",
+        "mastra": "0.17.0",
         "mermaid": "^11.6.0",
         "pdfjs-dist": "^5.2.133",
         "postcss": "^8.5.3",
@@ -60,6 +60,8 @@
         "zustand": "^5.0.4"
       },
       "devDependencies": {
+        "@babel/core": "^7.28.4",
+        "@babel/preset-env": "^7.28.3",
         "@electron/rebuild": "^3.6.1",
         "@pmmmwh/react-refresh-webpack-plugin": "^0.5.15",
         "@svgr/webpack": "^8.1.0",
@@ -77,6 +79,7 @@
         "@types/webpack-bundle-analyzer": "^4.7.0",
         "@typescript-eslint/eslint-plugin": "^8.40.0",
         "@typescript-eslint/parser": "^8.40.0",
+        "babel-jest": "^30.2.0",
         "browserslist-config-erb": "^0.0.3",
         "chalk": "^4.1.2",
         "concurrently": "^9.1.2",
@@ -263,20 +266,67 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@ai-sdk/anthropic-v5": {
+      "name": "@ai-sdk/anthropic",
+      "version": "2.0.23",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/anthropic/-/anthropic-2.0.23.tgz",
+      "integrity": "sha512-ZEBiiv1UhjGjBwUU63pFhLK5LCSlNDb1idY9K1oZHm5/Fda1cuTojf32tOp0opH0RPbPAN/F8fyyNjbU33n9Kw==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@ai-sdk/provider-utils": "3.0.10"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/anthropic-v5/node_modules/@ai-sdk/provider": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider/-/provider-2.0.0.tgz",
+      "integrity": "sha512-6o7Y2SeO9vFKB8lArHXehNuusnpddKPk7xqL7T2/b+OvXMRIXUO1rR4wcv1hAFUAT9avGZshty3Wlua/XA7TvA==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "json-schema": "^0.4.0"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/@ai-sdk/anthropic-v5/node_modules/@ai-sdk/provider-utils": {
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@standard-schema/spec": "^1.0.0",
+        "eventsource-parser": "^3.0.5"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
     "node_modules/@ai-sdk/gateway": {
-      "version": "1.0.7",
-      "resolved": "https://registry.npmjs.org/@ai-sdk/gateway/-/gateway-1.0.7.tgz",
-      "integrity": "sha512-Athrq7OARuNc0iHZJP6InhSQ53tImCc990vMWyR1UHaZgPZJbXjKhIMiOj54F0I0Nlemx48V4fHYUTfLkJotnQ==",
+      "version": "1.0.33",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/gateway/-/gateway-1.0.33.tgz",
+      "integrity": "sha512-v9i3GPEo4t3fGcSkQkc07xM6KJN75VUv7C1Mqmmsu2xD8lQwnQfsrgAXyNuWe20yGY0eHuheSPDZhiqsGKtH1g==",
       "license": "Apache-2.0",
       "dependencies": {
         "@ai-sdk/provider": "2.0.0",
-        "@ai-sdk/provider-utils": "3.0.3"
+        "@ai-sdk/provider-utils": "3.0.10",
+        "@vercel/oidc": "^3.0.1"
       },
       "engines": {
         "node": ">=18"
       },
       "peerDependencies": {
-        "zod": "^3.25.76 || ^4"
+        "zod": "^3.25.76 || ^4.1.8"
       }
     },
     "node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider": {
@@ -292,27 +342,72 @@
       }
     },
     "node_modules/@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils": {
-      "version": "3.0.3",
-      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.3.tgz",
-      "integrity": "sha512-kAxIw1nYmFW1g5TvE54ZB3eNtgZna0RnLjPUp1ltz1+t9xkXJIuDT4atrwfau9IbS0BOef38wqrI8CjFfQrxhw==",
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
       "license": "Apache-2.0",
       "dependencies": {
         "@ai-sdk/provider": "2.0.0",
         "@standard-schema/spec": "^1.0.0",
-        "eventsource-parser": "^3.0.3",
-        "zod-to-json-schema": "^3.24.1"
+        "eventsource-parser": "^3.0.5"
       },
       "engines": {
         "node": ">=18"
       },
       "peerDependencies": {
-        "zod": "^3.25.76 || ^4"
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/google-v5": {
+      "name": "@ai-sdk/google",
+      "version": "2.0.17",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/google/-/google-2.0.17.tgz",
+      "integrity": "sha512-6LyuUrCZuiULg0rUV+kT4T2jG19oUntudorI4ttv1ARkSbwl8A39ue3rA487aDDy6fUScdbGFiV5Yv/o4gidVA==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@ai-sdk/provider-utils": "3.0.10"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/google-v5/node_modules/@ai-sdk/provider": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider/-/provider-2.0.0.tgz",
+      "integrity": "sha512-6o7Y2SeO9vFKB8lArHXehNuusnpddKPk7xqL7T2/b+OvXMRIXUO1rR4wcv1hAFUAT9avGZshty3Wlua/XA7TvA==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "json-schema": "^0.4.0"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/@ai-sdk/google-v5/node_modules/@ai-sdk/provider-utils": {
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@standard-schema/spec": "^1.0.0",
+        "eventsource-parser": "^3.0.5"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
       }
     },
     "node_modules/@ai-sdk/openai-compatible": {
-      "version": "0.2.14",
-      "resolved": "https://registry.npmjs.org/@ai-sdk/openai-compatible/-/openai-compatible-0.2.14.tgz",
-      "integrity": "sha512-icjObfMCHKSIbywijaoLdZ1nSnuRnWgMEMLgwoxPJgxsUHMx0aVORnsLUid4SPtdhHI3X2masrt6iaEQLvOSFw==",
+      "version": "0.2.16",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/openai-compatible/-/openai-compatible-0.2.16.tgz",
+      "integrity": "sha512-LkvfcM8slJedRyJa/MiMiaOzcMjV1zNDwzTHEGz7aAsgsQV0maLfmJRi/nuSwf5jmp0EouC+JXXDUj2l94HgQw==",
       "license": "Apache-2.0",
       "dependencies": {
         "@ai-sdk/provider": "1.1.3",
@@ -325,6 +420,98 @@
         "zod": "^3.0.0"
       }
     },
+    "node_modules/@ai-sdk/openai-compatible-v5": {
+      "name": "@ai-sdk/openai-compatible",
+      "version": "1.0.19",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/openai-compatible/-/openai-compatible-1.0.19.tgz",
+      "integrity": "sha512-hnsqPCCSNKgpZRNDOAIXZs7OcUDM4ut5ggWxj2sjB4tNL/aBn/xrM7pJkqu+WuPowyrE60wPVSlw0LvtXAlMXQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@ai-sdk/provider-utils": "3.0.10"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/openai-compatible-v5/node_modules/@ai-sdk/provider": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider/-/provider-2.0.0.tgz",
+      "integrity": "sha512-6o7Y2SeO9vFKB8lArHXehNuusnpddKPk7xqL7T2/b+OvXMRIXUO1rR4wcv1hAFUAT9avGZshty3Wlua/XA7TvA==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "json-schema": "^0.4.0"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/@ai-sdk/openai-compatible-v5/node_modules/@ai-sdk/provider-utils": {
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@standard-schema/spec": "^1.0.0",
+        "eventsource-parser": "^3.0.5"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/openai-v5": {
+      "name": "@ai-sdk/openai",
+      "version": "2.0.42",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/openai/-/openai-2.0.42.tgz",
+      "integrity": "sha512-9mM6QS8k0ooH9qMC27nlrYLQmNDnO6Rk0JTmFo/yUxpABEWOcvQhMWNHbp9lFL6Ty5vkdINrujhsAQfWuEleOg==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@ai-sdk/provider-utils": "3.0.10"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/openai-v5/node_modules/@ai-sdk/provider": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider/-/provider-2.0.0.tgz",
+      "integrity": "sha512-6o7Y2SeO9vFKB8lArHXehNuusnpddKPk7xqL7T2/b+OvXMRIXUO1rR4wcv1hAFUAT9avGZshty3Wlua/XA7TvA==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "json-schema": "^0.4.0"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/@ai-sdk/openai-v5/node_modules/@ai-sdk/provider-utils": {
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@standard-schema/spec": "^1.0.0",
+        "eventsource-parser": "^3.0.5"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
     "node_modules/@ai-sdk/provider": {
       "version": "1.1.3",
       "resolved": "https://registry.npmjs.org/@ai-sdk/provider/-/provider-1.1.3.tgz",
@@ -356,21 +543,20 @@
     },
     "node_modules/@ai-sdk/provider-utils-v5": {
       "name": "@ai-sdk/provider-utils",
-      "version": "3.0.3",
-      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.3.tgz",
-      "integrity": "sha512-kAxIw1nYmFW1g5TvE54ZB3eNtgZna0RnLjPUp1ltz1+t9xkXJIuDT4atrwfau9IbS0BOef38wqrI8CjFfQrxhw==",
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
       "license": "Apache-2.0",
       "dependencies": {
         "@ai-sdk/provider": "2.0.0",
         "@standard-schema/spec": "^1.0.0",
-        "eventsource-parser": "^3.0.3",
-        "zod-to-json-schema": "^3.24.1"
+        "eventsource-parser": "^3.0.5"
       },
       "engines": {
         "node": ">=18"
       },
       "peerDependencies": {
-        "zod": "^3.25.76 || ^4"
+        "zod": "^3.25.76 || ^4.1.8"
       }
     },
     "node_modules/@ai-sdk/provider-utils-v5/node_modules/@ai-sdk/provider": {
@@ -439,17 +625,67 @@
         "zod": "^3.23.8"
       }
     },
-    "node_modules/@ampproject/remapping": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
-      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
+    "node_modules/@ai-sdk/xai-v5": {
+      "name": "@ai-sdk/xai",
+      "version": "2.0.23",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/xai/-/xai-2.0.23.tgz",
+      "integrity": "sha512-Xo4r5W/Wvi4mkCD98DoafNxj9V3xysUlWOeqAYpqKeKkNQ2xtOTly2MHq+gP6wKud0Y/mI7hemkCMQgH6HOwzQ==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@jridgewell/gen-mapping": "^0.3.5",
-        "@jridgewell/trace-mapping": "^0.3.24"
+        "@ai-sdk/openai-compatible": "1.0.19",
+        "@ai-sdk/provider": "2.0.0",
+        "@ai-sdk/provider-utils": "3.0.10"
       },
       "engines": {
-        "node": ">=6.0.0"
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/openai-compatible": {
+      "version": "1.0.19",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/openai-compatible/-/openai-compatible-1.0.19.tgz",
+      "integrity": "sha512-hnsqPCCSNKgpZRNDOAIXZs7OcUDM4ut5ggWxj2sjB4tNL/aBn/xrM7pJkqu+WuPowyrE60wPVSlw0LvtXAlMXQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@ai-sdk/provider-utils": "3.0.10"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
+      }
+    },
+    "node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/provider": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider/-/provider-2.0.0.tgz",
+      "integrity": "sha512-6o7Y2SeO9vFKB8lArHXehNuusnpddKPk7xqL7T2/b+OvXMRIXUO1rR4wcv1hAFUAT9avGZshty3Wlua/XA7TvA==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "json-schema": "^0.4.0"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/@ai-sdk/xai-v5/node_modules/@ai-sdk/provider-utils": {
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@ai-sdk/provider": "2.0.0",
+        "@standard-schema/spec": "^1.0.0",
+        "eventsource-parser": "^3.0.5"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "zod": "^3.25.76 || ^4.1.8"
       }
     },
     "node_modules/@antfu/install-pkg": {
@@ -506,30 +742,30 @@
       }
     },
     "node_modules/@babel/compat-data": {
-      "version": "7.27.5",
-      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.27.5.tgz",
-      "integrity": "sha512-KiRAp/VoJaWkkte84TvUd9qjdbZAdiqyvMxrGl1N6vzFogKmaLgoM3L1kgtLicp2HP5fBJS8JrZKLVIZGVJAVg==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.4.tgz",
+      "integrity": "sha512-YsmSKC29MJwf0gF8Rjjrg5LQCmyh+j/nD8/eP7f+BeoQTKYqs9RoWbjGOdy0+1Ekr68RJZMUOPVQaQisnIo4Rw==",
       "license": "MIT",
       "engines": {
         "node": ">=6.9.0"
       }
     },
     "node_modules/@babel/core": {
-      "version": "7.28.3",
-      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.3.tgz",
-      "integrity": "sha512-yDBHV9kQNcr2/sUr9jghVyz9C3Y5G2zUM2H2lo+9mKv4sFgbA8s8Z9t8D1jiTkGoO/NoIfKMyKWr4s6CN23ZwQ==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.4.tgz",
+      "integrity": "sha512-2BCOP7TN8M+gVDj7/ht3hsaO/B/n5oDbiAyyvnRlNOs+u1o+JWNYTQrmpuNp1/Wq2gcFrI01JAW+paEKDMx/CA==",
       "license": "MIT",
       "dependencies": {
-        "@ampproject/remapping": "^2.2.0",
         "@babel/code-frame": "^7.27.1",
         "@babel/generator": "^7.28.3",
         "@babel/helper-compilation-targets": "^7.27.2",
         "@babel/helper-module-transforms": "^7.28.3",
-        "@babel/helpers": "^7.28.3",
-        "@babel/parser": "^7.28.3",
+        "@babel/helpers": "^7.28.4",
+        "@babel/parser": "^7.28.4",
         "@babel/template": "^7.27.2",
-        "@babel/traverse": "^7.28.3",
-        "@babel/types": "^7.28.2",
+        "@babel/traverse": "^7.28.4",
+        "@babel/types": "^7.28.4",
+        "@jridgewell/remapping": "^2.3.5",
         "convert-source-map": "^2.0.0",
         "debug": "^4.1.0",
         "gensync": "^1.0.0-beta.2",
@@ -581,20 +817,6 @@
         "node": ">=6.9.0"
       }
     },
-    "node_modules/@babel/helper-builder-binary-assignment-operator-visitor": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/helper-builder-binary-assignment-operator-visitor/-/helper-builder-binary-assignment-operator-visitor-7.24.7.tgz",
-      "integrity": "sha512-xZeCVVdwb4MsDBkkyZ64tReWYrLRHlMN72vP7Bdm3OUOuyFZExhsHUUnuWnm2/XOlAJzR0LfPpB56WXZn0X/lA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "@babel/traverse": "^7.24.7",
-        "@babel/types": "^7.24.7"
-      },
-      "engines": {
-        "node": ">=6.9.0"
-      }
-    },
     "node_modules/@babel/helper-compilation-targets": {
       "version": "7.27.2",
       "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
@@ -651,14 +873,14 @@
       }
     },
     "node_modules/@babel/helper-create-regexp-features-plugin": {
-      "version": "7.25.2",
-      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.25.2.tgz",
-      "integrity": "sha512-+wqVGP+DFmqwFD3EH6TMTfUNeqDehV3E/dl+Sd54eaXqm17tEUNbEIn4sVivVowbvUpOtIGxdo3GoXyDH9N/9g==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.27.1.tgz",
+      "integrity": "sha512-uVDC72XVf8UbrH5qQTc18Agb8emwjTiZrQE11Nv3CuBEZmVvTwwE9CBUEvHku06gQCAyYf8Nv6ja1IN+6LMbxQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-annotate-as-pure": "^7.24.7",
-        "regexpu-core": "^5.3.1",
+        "@babel/helper-annotate-as-pure": "^7.27.1",
+        "regexpu-core": "^6.2.0",
         "semver": "^6.3.1"
       },
       "engines": {
@@ -679,17 +901,17 @@
       }
     },
     "node_modules/@babel/helper-define-polyfill-provider": {
-      "version": "0.6.2",
-      "resolved": "https://registry.npmjs.org/@babel/helper-define-polyfill-provider/-/helper-define-polyfill-provider-0.6.2.tgz",
-      "integrity": "sha512-LV76g+C502biUK6AyZ3LK10vDpDyCzZnhZFXkH1L75zHPj68+qc8Zfpx2th+gzwA2MzyK+1g/3EPl62yFnVttQ==",
+      "version": "0.6.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-define-polyfill-provider/-/helper-define-polyfill-provider-0.6.5.tgz",
+      "integrity": "sha512-uJnGFcPsWQK8fvjgGP5LZUZZsYGIoPeRjSF5PGwrelYgq7Q15/Ft9NGFp1zglwgIv//W0uG4BevRuSJRyylZPg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-compilation-targets": "^7.22.6",
-        "@babel/helper-plugin-utils": "^7.22.5",
-        "debug": "^4.1.1",
+        "@babel/helper-compilation-targets": "^7.27.2",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "debug": "^4.4.1",
         "lodash.debounce": "^4.0.8",
-        "resolve": "^1.14.2"
+        "resolve": "^1.22.10"
       },
       "peerDependencies": {
         "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
@@ -769,15 +991,15 @@
       }
     },
     "node_modules/@babel/helper-remap-async-to-generator": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.25.0.tgz",
-      "integrity": "sha512-NhavI2eWEIz/H9dbrG0TuOicDhNexze43i5z7lEqwYm0WEZVTwnPpA0EafUTP7+6/W79HWIP2cTe3Z5NiSTVpw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.27.1.tgz",
+      "integrity": "sha512-7fiA521aVw8lSPeI4ZOD3vRFkoqkJcS+z4hFo82bFSH/2tNd6eJ5qCVMS5OzDmZh/kaHQeBaeyxK6wljcPtveA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-annotate-as-pure": "^7.24.7",
-        "@babel/helper-wrap-function": "^7.25.0",
-        "@babel/traverse": "^7.25.0"
+        "@babel/helper-annotate-as-pure": "^7.27.1",
+        "@babel/helper-wrap-function": "^7.27.1",
+        "@babel/traverse": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -844,40 +1066,40 @@
       }
     },
     "node_modules/@babel/helper-wrap-function": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.25.0.tgz",
-      "integrity": "sha512-s6Q1ebqutSiZnEjaofc/UKDyC4SbzV5n5SrA2Gq8UawLycr3i04f1dX4OzoQVnexm6aOCh37SQNYlJ/8Ku+PMQ==",
+      "version": "7.28.3",
+      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.28.3.tgz",
+      "integrity": "sha512-zdf983tNfLZFletc0RRXYrHrucBEg95NIFMkn6K9dbeMYnsgHaSBGcQqdsCSStG2PYwRre0Qc2NNSCXbG+xc6g==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/template": "^7.25.0",
-        "@babel/traverse": "^7.25.0",
-        "@babel/types": "^7.25.0"
+        "@babel/template": "^7.27.2",
+        "@babel/traverse": "^7.28.3",
+        "@babel/types": "^7.28.2"
       },
       "engines": {
         "node": ">=6.9.0"
       }
     },
     "node_modules/@babel/helpers": {
-      "version": "7.28.3",
-      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.3.tgz",
-      "integrity": "sha512-PTNtvUQihsAsDHMOP5pfobP8C6CM4JWXmP8DrEIt46c3r2bf87Ua1zoqevsMo9g+tWDwgWrFP5EIxuBx5RudAw==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.4.tgz",
+      "integrity": "sha512-HFN59MmQXGHVyYadKLVumYsA9dBFun/ldYxipEjzA4196jpLZd8UjEEBLkbEkvfYreDqJhZxYAWFPtrfhNpj4w==",
       "license": "MIT",
       "dependencies": {
         "@babel/template": "^7.27.2",
-        "@babel/types": "^7.28.2"
+        "@babel/types": "^7.28.4"
       },
       "engines": {
         "node": ">=6.9.0"
       }
     },
     "node_modules/@babel/parser": {
-      "version": "7.28.3",
-      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.3.tgz",
-      "integrity": "sha512-7+Ey1mAgYqFAx2h0RuoxcQT5+MlG3GTV0TQrgr7/ZliKsm/MNDxVVutlWaziMq7wJNAz8MTqz55XLpWvva6StA==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.4.tgz",
+      "integrity": "sha512-yZbBqeM6TkpP9du/I2pUZnJsRMGGvOuIrhjzC1AwHwW+6he4mni6Bp/m8ijn0iOuZuPI2BfkCoSRunpyjnrQKg==",
       "license": "MIT",
       "dependencies": {
-        "@babel/types": "^7.28.2"
+        "@babel/types": "^7.28.4"
       },
       "bin": {
         "parser": "bin/babel-parser.js"
@@ -887,14 +1109,14 @@
       }
     },
     "node_modules/@babel/plugin-bugfix-firefox-class-in-computed-class-key": {
-      "version": "7.25.3",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-firefox-class-in-computed-class-key/-/plugin-bugfix-firefox-class-in-computed-class-key-7.25.3.tgz",
-      "integrity": "sha512-wUrcsxZg6rqBXG05HG1FPYgsP6EvwF4WpBbxIpWIIYnH8wG0gzx3yZY3dtEHas4sTAOGkbTsc9EGPxwff8lRoA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-firefox-class-in-computed-class-key/-/plugin-bugfix-firefox-class-in-computed-class-key-7.27.1.tgz",
+      "integrity": "sha512-QPG3C9cCVRQLxAVwmefEmwdTanECuUBMQZ/ym5kiw3XKCGA7qkuQLcjWWHcrD/GKbn/WmJwaezfuuAOcyKlRPA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/traverse": "^7.25.3"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/traverse": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -904,13 +1126,13 @@
       }
     },
     "node_modules/@babel/plugin-bugfix-safari-class-field-initializer-scope": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-class-field-initializer-scope/-/plugin-bugfix-safari-class-field-initializer-scope-7.25.0.tgz",
-      "integrity": "sha512-Bm4bH2qsX880b/3ziJ8KD711LT7z4u8CFudmjqle65AZj/HNUFhEf90dqYv6O86buWvSBmeQDjv0Tn2aF/bIBA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-class-field-initializer-scope/-/plugin-bugfix-safari-class-field-initializer-scope-7.27.1.tgz",
+      "integrity": "sha512-qNeq3bCKnGgLkEXUuFry6dPlGfCdQNZbn7yUAPCInwAJHMU7THJfrBSozkcWq5sNM6RcF3S8XyQL2A52KNR9IA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -920,13 +1142,13 @@
       }
     },
     "node_modules/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.25.0.tgz",
-      "integrity": "sha512-lXwdNZtTmeVOOFtwM/WDe7yg1PL8sYhRk/XH0FzbR2HDQ0xC+EnQ/JHeoMYSavtU115tnUk0q9CDyq8si+LMAA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.27.1.tgz",
+      "integrity": "sha512-g4L7OYun04N1WyqMNjldFwlfPCLVkgB54A/YCXICZYBsvJJE3kByKv9c9+R/nAfmIfjl2rKYLNyMHboYbZaWaA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -936,15 +1158,15 @@
       }
     },
     "node_modules/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/-/plugin-bugfix-v8-spread-parameters-in-optional-chaining-7.24.7.tgz",
-      "integrity": "sha512-+izXIbke1T33mY4MSNnrqhPXDz01WYhEf3yF5NbnUtkiNnm+XBZJl3kNfoK6NKmYlz/D07+l2GWVK/QfDkNCuQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/-/plugin-bugfix-v8-spread-parameters-in-optional-chaining-7.27.1.tgz",
+      "integrity": "sha512-oO02gcONcD5O1iTLi/6frMJBIwWEHceWGSGqrpCmEL8nogiS6J9PBlE48CaK20/Jx1LuRml9aDftLgdjXT8+Cw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/helper-skip-transparent-expression-wrappers": "^7.24.7",
-        "@babel/plugin-transform-optional-chaining": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
+        "@babel/plugin-transform-optional-chaining": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -954,14 +1176,14 @@
       }
     },
     "node_modules/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/-/plugin-bugfix-v8-static-class-fields-redefine-readonly-7.25.0.tgz",
-      "integrity": "sha512-tggFrk1AIShG/RUQbEwt2Tr/E+ObkfwrPjR6BjbRvsx24+PSjK8zrq0GWPNCjo8qpRx4DuJzlcvWJqlm+0h3kw==",
+      "version": "7.28.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/-/plugin-bugfix-v8-static-class-fields-redefine-readonly-7.28.3.tgz",
+      "integrity": "sha512-b6YTX108evsvE4YgWyQ921ZAFFQm3Bn+CA3+ZXlNVnPhx+UfsVURoPjfGAPCjBgrqo30yX/C2nZGX96DxvR9Iw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/traverse": "^7.25.0"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/traverse": "^7.28.3"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1038,40 +1260,14 @@
         "@babel/core": "^7.0.0-0"
       }
     },
-    "node_modules/@babel/plugin-syntax-dynamic-import": {
-      "version": "7.8.3",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-dynamic-import/-/plugin-syntax-dynamic-import-7.8.3.tgz",
-      "integrity": "sha512-5gdGbFon+PszYzqs83S3E5mpi7/y/8M9eC90MRTZfduQOYW76ig6SOSPNe41IG5LoP3FGBn2N0RjVDSQiS94kQ==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "@babel/helper-plugin-utils": "^7.8.0"
-      },
-      "peerDependencies": {
-        "@babel/core": "^7.0.0-0"
-      }
-    },
-    "node_modules/@babel/plugin-syntax-export-namespace-from": {
-      "version": "7.8.3",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-export-namespace-from/-/plugin-syntax-export-namespace-from-7.8.3.tgz",
-      "integrity": "sha512-MXf5laXo6c1IbEbegDmzGPwGNTsHZmEy6QGznu5Sh2UCWvueywb2ee+CCE4zQiZstxU9BMoQO9i6zUFSY0Kj0Q==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "@babel/helper-plugin-utils": "^7.8.3"
-      },
-      "peerDependencies": {
-        "@babel/core": "^7.0.0-0"
-      }
-    },
     "node_modules/@babel/plugin-syntax-import-assertions": {
-      "version": "7.25.6",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-assertions/-/plugin-syntax-import-assertions-7.25.6.tgz",
-      "integrity": "sha512-aABl0jHw9bZ2karQ/uUD6XP4u0SG22SJrOHFoL6XB1R7dTovOP4TzTlsxOYC5yQ1pdscVK2JTUnF6QL3ARoAiQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-assertions/-/plugin-syntax-import-assertions-7.27.1.tgz",
+      "integrity": "sha512-UT/Jrhw57xg4ILHLFnzFpPDlMbcdEicaAtjPQpbj9wa8T4r5KVWCimHcL/460g8Ht0DMxDyjsLgiWSkVjnwPFg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1081,13 +1277,13 @@
       }
     },
     "node_modules/@babel/plugin-syntax-import-attributes": {
-      "version": "7.25.6",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.25.6.tgz",
-      "integrity": "sha512-sXaDXaJN9SNLymBdlWFA+bjzBhFD617ZaFiY13dGt7TVslVvVgA6fkZOP7Ki3IGElC45lwHdOTrCtKZGVAWeLQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.27.1.tgz",
+      "integrity": "sha512-oFT0FrKHgF53f4vOsZGi2Hh3I35PfSmVs4IBFLFj4dnafP+hIWDLg3VyKmUHfLoLHlyxY4C7DGtmHuJgn+IGww==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1280,13 +1476,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-arrow-functions": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.24.7.tgz",
-      "integrity": "sha512-Dt9LQs6iEY++gXUwY03DNFat5C2NbO48jj+j/bSAz6b3HgPs39qcPiYt77fDObIcFwj3/C2ICX9YMwGflUoSHQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.27.1.tgz",
+      "integrity": "sha512-8Z4TGic6xW70FKThA5HYEKKyBpOOsucTOD1DjU3fZxDg+K3zBJcXMFnt/4yQiZnf5+MiOMSXQ9PaEK/Ilh1DeA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1296,16 +1492,15 @@
       }
     },
     "node_modules/@babel/plugin-transform-async-generator-functions": {
-      "version": "7.25.4",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-generator-functions/-/plugin-transform-async-generator-functions-7.25.4.tgz",
-      "integrity": "sha512-jz8cV2XDDTqjKPwVPJBIjORVEmSGYhdRa8e5k5+vN+uwcjSrSxUaebBRa4ko1jqNF2uxyg8G6XYk30Jv285xzg==",
+      "version": "7.28.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-generator-functions/-/plugin-transform-async-generator-functions-7.28.0.tgz",
+      "integrity": "sha512-BEOdvX4+M765icNPZeidyADIvQ1m1gmunXufXxvRESy/jNNyfovIqUyE7MVgGBjWktCoJlzvFA1To2O4ymIO3Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/helper-remap-async-to-generator": "^7.25.0",
-        "@babel/plugin-syntax-async-generators": "^7.8.4",
-        "@babel/traverse": "^7.25.4"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-remap-async-to-generator": "^7.27.1",
+        "@babel/traverse": "^7.28.0"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1315,15 +1510,15 @@
       }
     },
     "node_modules/@babel/plugin-transform-async-to-generator": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.24.7.tgz",
-      "integrity": "sha512-SQY01PcJfmQ+4Ash7NE+rpbLFbmqA2GPIgqzxfFTL4t1FKRq4zTms/7htKpoCUI9OcFYgzqfmCdH53s6/jn5fA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.27.1.tgz",
+      "integrity": "sha512-NREkZsZVJS4xmTr8qzE5y8AfIPqsdQfRuUiLRTEzb7Qii8iFWCyDKaUV2c0rCuh4ljDZ98ALHP/PetiBV2nddA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-module-imports": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/helper-remap-async-to-generator": "^7.24.7"
+        "@babel/helper-module-imports": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-remap-async-to-generator": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1333,13 +1528,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-block-scoped-functions": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.24.7.tgz",
-      "integrity": "sha512-yO7RAz6EsVQDaBH18IDJcMB1HnrUn2FJ/Jslc/WtPPWcjhpUJXU/rjbwmluzp7v/ZzWcEhTMXELnnsz8djWDwQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.27.1.tgz",
+      "integrity": "sha512-cnqkuOtZLapWYZUYM5rVIdv1nXYuFVIltZ6ZJ7nIj585QsjKM5dhL2Fu/lICXZ1OyIAFc7Qy+bvDAtTXqGrlhg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1349,13 +1544,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-block-scoping": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.25.0.tgz",
-      "integrity": "sha512-yBQjYoOjXlFv9nlXb3f1casSHOZkWr29NX+zChVanLg5Nc157CrbEX9D7hxxtTpuFy7Q0YzmmWfJxzvps4kXrQ==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.28.4.tgz",
+      "integrity": "sha512-1yxmvN0MJHOhPVmAsmoW5liWwoILobu/d/ShymZmj867bAdxGbehIrew1DuLpw2Ukv+qDSSPQdYW1dLNE7t11A==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1365,14 +1560,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-class-properties": {
-      "version": "7.25.4",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-properties/-/plugin-transform-class-properties-7.25.4.tgz",
-      "integrity": "sha512-nZeZHyCWPfjkdU5pA/uHiTaDAFUEqkpzf1YoQT2NeSynCGYq9rxfyI3XpQbfx/a0hSnFH6TGlEXvae5Vi7GD8g==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-properties/-/plugin-transform-class-properties-7.27.1.tgz",
+      "integrity": "sha512-D0VcalChDMtuRvJIu3U/fwWjf8ZMykz5iZsg77Nuj821vCKI3zCyRLwRdWbsuJ/uRwZhZ002QtCqIkwC/ZkvbA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-class-features-plugin": "^7.25.4",
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-create-class-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1382,15 +1577,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-class-static-block": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-static-block/-/plugin-transform-class-static-block-7.24.7.tgz",
-      "integrity": "sha512-HMXK3WbBPpZQufbMG4B46A90PkuuhN9vBCb5T8+VAHqvAqvcLi+2cKoukcpmUYkszLhScU3l1iudhrks3DggRQ==",
+      "version": "7.28.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-static-block/-/plugin-transform-class-static-block-7.28.3.tgz",
+      "integrity": "sha512-LtPXlBbRoc4Njl/oh1CeD/3jC+atytbnf/UqLoqTDcEYGUPj022+rvfkbDYieUrSj3CaV4yHDByPE+T2HwfsJg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-class-features-plugin": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-class-static-block": "^7.14.5"
+        "@babel/helper-create-class-features-plugin": "^7.28.3",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1400,18 +1594,18 @@
       }
     },
     "node_modules/@babel/plugin-transform-classes": {
-      "version": "7.25.4",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.25.4.tgz",
-      "integrity": "sha512-oexUfaQle2pF/b6E0dwsxQtAol9TLSO88kQvym6HHBWFliV2lGdrPieX+WgMRLSJDVzdYywk7jXbLPuO2KLTLg==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.28.4.tgz",
+      "integrity": "sha512-cFOlhIYPBv/iBoc+KS3M6et2XPtbT2HiCRfBXWtfpc9OAyostldxIf9YAYB6ypURBBbx+Qv6nyrLzASfJe+hBA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-annotate-as-pure": "^7.24.7",
-        "@babel/helper-compilation-targets": "^7.25.2",
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/helper-replace-supers": "^7.25.0",
-        "@babel/traverse": "^7.25.4",
-        "globals": "^11.1.0"
+        "@babel/helper-annotate-as-pure": "^7.27.3",
+        "@babel/helper-compilation-targets": "^7.27.2",
+        "@babel/helper-globals": "^7.28.0",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-replace-supers": "^7.27.1",
+        "@babel/traverse": "^7.28.4"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1421,14 +1615,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-computed-properties": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.24.7.tgz",
-      "integrity": "sha512-25cS7v+707Gu6Ds2oY6tCkUwsJ9YIDbggd9+cu9jzzDgiNq7hR/8dkzxWfKWnTic26vsI3EsCXNd4iEB6e8esQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.27.1.tgz",
+      "integrity": "sha512-lj9PGWvMTVksbWiDT2tW68zGS/cyo4AkZ/QTp0sQT0mjPopCmrSkzxeXkznjqBxzDI6TclZhOJbBmbBLjuOZUw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/template": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/template": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1438,13 +1632,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-destructuring": {
-      "version": "7.24.8",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.24.8.tgz",
-      "integrity": "sha512-36e87mfY8TnRxc7yc6M9g9gOB7rKgSahqkIKwLpz4Ppk2+zC2Cy1is0uwtuSG6AE4zlTOUa+7JGz9jCJGLqQFQ==",
+      "version": "7.28.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.28.0.tgz",
+      "integrity": "sha512-v1nrSMBiKcodhsyJ4Gf+Z0U/yawmJDBOTpEB3mcQY52r9RIyPneGyAS/yM6seP/8I+mWI3elOMtT5dB8GJVs+A==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/traverse": "^7.28.0"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1454,14 +1649,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-dotall-regex": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.24.7.tgz",
-      "integrity": "sha512-ZOA3W+1RRTSWvyqcMJDLqbchh7U4NRGqwRfFSVbOLS/ePIP4vHB5e8T8eXcuqyN1QkgKyj5wuW0lcS85v4CrSw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.27.1.tgz",
+      "integrity": "sha512-gEbkDVGRvjj7+T1ivxrfgygpT7GUd4vmODtYpbs0gZATdkX8/iSnOtZSxiZnsgm1YjTgjI6VKBGSJJevkrclzw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-regexp-features-plugin": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1471,13 +1666,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-duplicate-keys": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.24.7.tgz",
-      "integrity": "sha512-JdYfXyCRihAe46jUIliuL2/s0x0wObgwwiGxw/UbgJBr20gQBThrokO4nYKgWkD7uBaqM7+9x5TU7NkExZJyzw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.27.1.tgz",
+      "integrity": "sha512-MTyJk98sHvSs+cvZ4nOauwTTG1JeonDjSGvGGUNHreGQns+Mpt6WX/dVzWBHgg+dYZhkC4X+zTDfkTU+Vy9y7Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1487,14 +1682,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-duplicate-named-capturing-groups-regex": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-named-capturing-groups-regex/-/plugin-transform-duplicate-named-capturing-groups-regex-7.25.0.tgz",
-      "integrity": "sha512-YLpb4LlYSc3sCUa35un84poXoraOiQucUTTu8X1j18JV+gNa8E0nyUf/CjZ171IRGr4jEguF+vzJU66QZhn29g==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-named-capturing-groups-regex/-/plugin-transform-duplicate-named-capturing-groups-regex-7.27.1.tgz",
+      "integrity": "sha512-hkGcueTEzuhB30B3eJCbCYeCaaEQOmQR0AdvzpD4LoN0GXMWzzGSuRrxR2xTnCrvNbVwK9N6/jQ92GSLfiZWoQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-regexp-features-plugin": "^7.25.0",
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1504,14 +1699,30 @@
       }
     },
     "node_modules/@babel/plugin-transform-dynamic-import": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dynamic-import/-/plugin-transform-dynamic-import-7.24.7.tgz",
-      "integrity": "sha512-sc3X26PhZQDb3JhORmakcbvkeInvxz+A8oda99lj7J60QRuPZvNAk9wQlTBS1ZynelDrDmTU4pw1tyc5d5ZMUg==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dynamic-import/-/plugin-transform-dynamic-import-7.27.1.tgz",
+      "integrity": "sha512-MHzkWQcEmjzzVW9j2q8LGjwGWpG2mjwaaB0BNQwst3FIjqsg8Ct/mIZlvSPJvfi9y2AC8mi/ktxbFVL9pZ1I4A==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-dynamic-import": "^7.8.3"
+        "@babel/helper-plugin-utils": "^7.27.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-explicit-resource-management": {
+      "version": "7.28.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-explicit-resource-management/-/plugin-transform-explicit-resource-management-7.28.0.tgz",
+      "integrity": "sha512-K8nhUcn3f6iB+P3gwCv/no7OdzOZQcKchW6N389V6PD8NUWKZHzndOd9sPDVbMoBsbmjMqlB4L9fm+fEFNVlwQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/plugin-transform-destructuring": "^7.28.0"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1521,14 +1732,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-exponentiation-operator": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.24.7.tgz",
-      "integrity": "sha512-Rqe/vSc9OYgDajNIK35u7ot+KeCoetqQYFXM4Epf7M7ez3lWlOjrDjrwMei6caCVhfdw+mIKD4cgdGNy5JQotQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.27.1.tgz",
+      "integrity": "sha512-uspvXnhHvGKf2r4VVtBpeFnuDWsJLQ6MF6lGJLC89jBR1uoVeqM416AZtTuhTezOfgHicpJQmoD5YUakO/YmXQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-builder-binary-assignment-operator-visitor": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1538,14 +1748,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-export-namespace-from": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-export-namespace-from/-/plugin-transform-export-namespace-from-7.24.7.tgz",
-      "integrity": "sha512-v0K9uNYsPL3oXZ/7F9NNIbAj2jv1whUEtyA6aujhekLs56R++JDQuzRcP2/z4WX5Vg/c5lE9uWZA0/iUoFhLTA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-export-namespace-from/-/plugin-transform-export-namespace-from-7.27.1.tgz",
+      "integrity": "sha512-tQvHWSZ3/jH2xuq/vZDy0jNn+ZdXJeM8gHvX4lnJmsc3+50yPlWdZXIc5ay+umX+2/tJIqHqiEqcJvxlmIvRvQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-export-namespace-from": "^7.8.3"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1555,14 +1764,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-for-of": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.24.7.tgz",
-      "integrity": "sha512-wo9ogrDG1ITTTBsy46oGiN1dS9A7MROBTcYsfS8DtsImMkHk9JXJ3EWQM6X2SUw4x80uGPlwj0o00Uoc6nEE3g==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.27.1.tgz",
+      "integrity": "sha512-BfbWFFEJFQzLCQ5N8VocnCtA8J1CLkNTe2Ms2wocj75dd6VpiqS5Z5quTYcUoo4Yq+DN0rtikODccuv7RU81sw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/helper-skip-transparent-expression-wrappers": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1572,15 +1781,15 @@
       }
     },
     "node_modules/@babel/plugin-transform-function-name": {
-      "version": "7.25.1",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.25.1.tgz",
-      "integrity": "sha512-TVVJVdW9RKMNgJJlLtHsKDTydjZAbwIsn6ySBPQaEAUU5+gVvlJt/9nRmqVbsV/IBanRjzWoaAQKLoamWVOUuA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.27.1.tgz",
+      "integrity": "sha512-1bQeydJF9Nr1eBCMMbC+hdwmRlsv5XYOMu03YSWFwNs0HsAmtSxxF1fyuYPqemVldVyFmlCU7w8UE14LupUSZQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-compilation-targets": "^7.24.8",
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/traverse": "^7.25.1"
+        "@babel/helper-compilation-targets": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/traverse": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1590,14 +1799,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-json-strings": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-json-strings/-/plugin-transform-json-strings-7.24.7.tgz",
-      "integrity": "sha512-2yFnBGDvRuxAaE/f0vfBKvtnvvqU8tGpMHqMNpTN2oWMKIR3NqFkjaAgGwawhqK/pIN2T3XdjGPdaG0vDhOBGw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-json-strings/-/plugin-transform-json-strings-7.27.1.tgz",
+      "integrity": "sha512-6WVLVJiTjqcQauBhn1LkICsR2H+zm62I3h9faTDKt1qP4jn2o72tSvqMwtGFKGTpojce0gJs+76eZ2uCHRZh0Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-json-strings": "^7.8.3"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1607,13 +1815,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-literals": {
-      "version": "7.25.2",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.25.2.tgz",
-      "integrity": "sha512-HQI+HcTbm9ur3Z2DkO+jgESMAMcYLuN/A7NRw9juzxAezN9AvqvUTnpKP/9kkYANz6u7dFlAyOu44ejuGySlfw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.27.1.tgz",
+      "integrity": "sha512-0HCFSepIpLTkLcsi86GG3mTUzxV5jpmbv97hTETW3yzrAij8aqlD36toB1D0daVFJM8NK6GvKO0gslVQmm+zZA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1623,14 +1831,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-logical-assignment-operators": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-logical-assignment-operators/-/plugin-transform-logical-assignment-operators-7.24.7.tgz",
-      "integrity": "sha512-4D2tpwlQ1odXmTEIFWy9ELJcZHqrStlzK/dAOWYyxX3zT0iXQB6banjgeOJQXzEc4S0E0a5A+hahxPaEFYftsw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-logical-assignment-operators/-/plugin-transform-logical-assignment-operators-7.27.1.tgz",
+      "integrity": "sha512-SJvDs5dXxiae4FbSL1aBJlG4wvl594N6YEVVn9e3JGulwioy6z3oPjx/sQBO3Y4NwUu5HNix6KJ3wBZoewcdbw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1640,13 +1847,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-member-expression-literals": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.24.7.tgz",
-      "integrity": "sha512-T/hRC1uqrzXMKLQ6UCwMT85S3EvqaBXDGf0FaMf4446Qx9vKwlghvee0+uuZcDUCZU5RuNi4781UQ7R308zzBw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.27.1.tgz",
+      "integrity": "sha512-hqoBX4dcZ1I33jCSWcXrP+1Ku7kdqXf1oeah7ooKOIiAdKQ+uqftgCFNOSzA5AMS2XIHEYeGFg4cKRCdpxzVOQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1656,14 +1863,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-modules-amd": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.24.7.tgz",
-      "integrity": "sha512-9+pB1qxV3vs/8Hdmz/CulFB8w2tuu6EB94JZFsjdqxQokwGa9Unap7Bo2gGBGIvPmDIVvQrom7r5m/TCDMURhg==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.27.1.tgz",
+      "integrity": "sha512-iCsytMg/N9/oFq6n+gFTvUYDZQOMK5kEdeYxmxt91fcJGycfxVP9CnrxoliM0oumFERba2i8ZtwRUCMhvP1LnA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-module-transforms": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-module-transforms": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1689,16 +1896,16 @@
       }
     },
     "node_modules/@babel/plugin-transform-modules-systemjs": {
-      "version": "7.25.0",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.25.0.tgz",
-      "integrity": "sha512-YPJfjQPDXxyQWg/0+jHKj1llnY5f/R6a0p/vP4lPymxLu7Lvl4k2WMitqi08yxwQcCVUUdG9LCUj4TNEgAp3Jw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.27.1.tgz",
+      "integrity": "sha512-w5N1XzsRbc0PQStASMksmUeqECuzKuTJer7kFagK8AXgpCMkeDMO5S+aaFb7A51ZYDF7XI34qsTX+fkHiIm5yA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-module-transforms": "^7.25.0",
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/helper-validator-identifier": "^7.24.7",
-        "@babel/traverse": "^7.25.0"
+        "@babel/helper-module-transforms": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.27.1",
+        "@babel/traverse": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1708,14 +1915,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-modules-umd": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.24.7.tgz",
-      "integrity": "sha512-3aytQvqJ/h9z4g8AsKPLvD4Zqi2qT+L3j7XoFFu1XBlZWEl2/1kWnhmAbxpLgPrHSY0M6UA02jyTiwUVtiKR6A==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.27.1.tgz",
+      "integrity": "sha512-iQBE/xC5BV1OxJbp6WG7jq9IWiD+xxlZhLrdwpPkTX3ydmXdvoCpyfJN7acaIBZaOqTfr76pgzqBJflNbeRK+w==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-module-transforms": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-module-transforms": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1725,14 +1932,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-named-capturing-groups-regex": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.24.7.tgz",
-      "integrity": "sha512-/jr7h/EWeJtk1U/uz2jlsCioHkZk1JJZVcc8oQsJ1dUlaJD83f4/6Zeh2aHt9BIFokHIsSeDfhUmju0+1GPd6g==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.27.1.tgz",
+      "integrity": "sha512-SstR5JYy8ddZvD6MhV0tM/j16Qds4mIpJTOd1Yu9J9pJjH93bxHECF7pgtc28XvkzTD6Pxcm/0Z73Hvk7kb3Ng==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-regexp-features-plugin": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1742,13 +1949,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-new-target": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.24.7.tgz",
-      "integrity": "sha512-RNKwfRIXg4Ls/8mMTza5oPF5RkOW8Wy/WgMAp1/F1yZ8mMbtwXW+HDoJiOsagWrAhI5f57Vncrmr9XeT4CVapA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.27.1.tgz",
+      "integrity": "sha512-f6PiYeqXQ05lYq3TIfIDu/MtliKUbNwkGApPUvyo6+tc7uaR4cPjPe7DFPr15Uyycg2lZU6btZ575CuQoYh7MQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1758,14 +1965,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-nullish-coalescing-operator": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-nullish-coalescing-operator/-/plugin-transform-nullish-coalescing-operator-7.24.7.tgz",
-      "integrity": "sha512-Ts7xQVk1OEocqzm8rHMXHlxvsfZ0cEF2yomUqpKENHWMF4zKk175Y4q8H5knJes6PgYad50uuRmt3UJuhBw8pQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-nullish-coalescing-operator/-/plugin-transform-nullish-coalescing-operator-7.27.1.tgz",
+      "integrity": "sha512-aGZh6xMo6q9vq1JGcw58lZ1Z0+i0xB2x0XaauNIUXd6O1xXc3RwoWEBlsTQrY4KQ9Jf0s5rgD6SiNkaUdJegTA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1775,14 +1981,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-numeric-separator": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-numeric-separator/-/plugin-transform-numeric-separator-7.24.7.tgz",
-      "integrity": "sha512-e6q1TiVUzvH9KRvicuxdBTUj4AdKSRwzIyFFnfnezpCfP2/7Qmbb8qbU2j7GODbl4JMkblitCQjKYUaX/qkkwA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-numeric-separator/-/plugin-transform-numeric-separator-7.27.1.tgz",
+      "integrity": "sha512-fdPKAcujuvEChxDBJ5c+0BTaS6revLV7CJL08e4m3de8qJfNIuCc2nc7XJYOjBoTMJeqSmwXJ0ypE14RCjLwaw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-numeric-separator": "^7.10.4"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1792,16 +1997,17 @@
       }
     },
     "node_modules/@babel/plugin-transform-object-rest-spread": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-rest-spread/-/plugin-transform-object-rest-spread-7.24.7.tgz",
-      "integrity": "sha512-4QrHAr0aXQCEFni2q4DqKLD31n2DL+RxcwnNjDFkSG0eNQ/xCavnRkfCUjsyqGC2OviNJvZOF/mQqZBw7i2C5Q==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-rest-spread/-/plugin-transform-object-rest-spread-7.28.4.tgz",
+      "integrity": "sha512-373KA2HQzKhQCYiRVIRr+3MjpCObqzDlyrM6u4I201wL8Mp2wHf7uB8GhDwis03k2ti8Zr65Zyyqs1xOxUF/Ew==",
       "dev": true,
       "license": "MIT",
-      "dependencies": {
-        "@babel/helper-compilation-targets": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
-        "@babel/plugin-transform-parameters": "^7.24.7"
+      "dependencies": {
+        "@babel/helper-compilation-targets": "^7.27.2",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/plugin-transform-destructuring": "^7.28.0",
+        "@babel/plugin-transform-parameters": "^7.27.7",
+        "@babel/traverse": "^7.28.4"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1811,14 +2017,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-object-super": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.24.7.tgz",
-      "integrity": "sha512-A/vVLwN6lBrMFmMDmPPz0jnE6ZGx7Jq7d6sT/Ev4H65RER6pZ+kczlf1DthF5N0qaPHBsI7UXiE8Zy66nmAovg==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.27.1.tgz",
+      "integrity": "sha512-SFy8S9plRPbIcxlJ8A6mT/CxFdJx/c04JEctz4jf8YZaVS2px34j7NXRrlGlHkN/M2gnpL37ZpGRGVFLd3l8Ng==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/helper-replace-supers": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-replace-supers": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1828,14 +2034,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-optional-catch-binding": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-catch-binding/-/plugin-transform-optional-catch-binding-7.24.7.tgz",
-      "integrity": "sha512-uLEndKqP5BfBbC/5jTwPxLh9kqPWWgzN/f8w6UwAIirAEqiIVJWWY312X72Eub09g5KF9+Zn7+hT7sDxmhRuKA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-catch-binding/-/plugin-transform-optional-catch-binding-7.27.1.tgz",
+      "integrity": "sha512-txEAEKzYrHEX4xSZN4kJ+OfKXFVSWKB2ZxM9dpcE3wT7smwkNmXo5ORRlVzMVdJbD+Q8ILTgSD7959uj+3Dm3Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1845,15 +2050,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-optional-chaining": {
-      "version": "7.24.8",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-chaining/-/plugin-transform-optional-chaining-7.24.8.tgz",
-      "integrity": "sha512-5cTOLSMs9eypEy8JUVvIKOu6NgvbJMnpG62VpIHrTmROdQ+L5mDAaI40g25k5vXti55JWNX5jCkq3HZxXBQANw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-chaining/-/plugin-transform-optional-chaining-7.27.1.tgz",
+      "integrity": "sha512-BQmKPPIuc8EkZgNKsv0X4bPmOoayeu4F1YCwx2/CfmDSXDbp7GnzlUH+/ul5VGfRg1AoFPsrIThlEBj2xb4CAg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/helper-skip-transparent-expression-wrappers": "^7.24.7",
-        "@babel/plugin-syntax-optional-chaining": "^7.8.3"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1863,13 +2067,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-parameters": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.24.7.tgz",
-      "integrity": "sha512-yGWW5Rr+sQOhK0Ot8hjDJuxU3XLRQGflvT4lhlSY0DFvdb3TwKaY26CJzHtYllU0vT9j58hc37ndFPsqT1SrzA==",
+      "version": "7.27.7",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.27.7.tgz",
+      "integrity": "sha512-qBkYTYCb76RRxUM6CcZA5KRu8K4SM8ajzVeUgVdMVO9NN9uI/GaVmBg/WKJJGnNokV9SY8FxNOVWGXzqzUidBg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1879,14 +2083,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-private-methods": {
-      "version": "7.25.4",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-methods/-/plugin-transform-private-methods-7.25.4.tgz",
-      "integrity": "sha512-ao8BG7E2b/URaUQGqN3Tlsg+M3KlHY6rJ1O1gXAEUnZoyNQnvKyH87Kfg+FoxSeyWUB8ISZZsC91C44ZuBFytw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-methods/-/plugin-transform-private-methods-7.27.1.tgz",
+      "integrity": "sha512-10FVt+X55AjRAYI9BrdISN9/AQWHqldOeZDUoLyif1Kn05a56xVBXb8ZouL8pZ9jem8QpXaOt8TS7RHUIS+GPA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-class-features-plugin": "^7.25.4",
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-create-class-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1896,16 +2100,15 @@
       }
     },
     "node_modules/@babel/plugin-transform-private-property-in-object": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-property-in-object/-/plugin-transform-private-property-in-object-7.24.7.tgz",
-      "integrity": "sha512-9z76mxwnwFxMyxZWEgdgECQglF2Q7cFLm0kMf8pGwt+GSJsY0cONKj/UuO4bOH0w/uAel3ekS4ra5CEAyJRmDA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-property-in-object/-/plugin-transform-private-property-in-object-7.27.1.tgz",
+      "integrity": "sha512-5J+IhqTi1XPa0DXF83jYOaARrX+41gOewWbkPyjMNRDqgOCqdffGh8L3f/Ek5utaEBZExjSAzcyjmV9SSAWObQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-annotate-as-pure": "^7.24.7",
-        "@babel/helper-create-class-features-plugin": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/plugin-syntax-private-property-in-object": "^7.14.5"
+        "@babel/helper-annotate-as-pure": "^7.27.1",
+        "@babel/helper-create-class-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -1915,13 +2118,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-property-literals": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.24.7.tgz",
-      "integrity": "sha512-EMi4MLQSHfd2nrCqQEWxFdha2gBCqU4ZcCng4WBGZ5CJL4bBRW0ptdqqDdeirGZcpALazVVNJqRmsO8/+oNCBA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.27.1.tgz",
+      "integrity": "sha512-oThy3BCuCha8kDZ8ZkgOg2exvPYUlprMukKQXI1r1pJ47NCvxfkEy8vK+r/hT9nF0Aa4H1WUPZZjHTFtAhGfmQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2016,14 +2219,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-regenerator": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.24.7.tgz",
-      "integrity": "sha512-lq3fvXPdimDrlg6LWBoqj+r/DEWgONuwjuOuQCSYgRroXDH/IdM1C0IZf59fL5cHLpjEH/O6opIRBbqv7ELnuA==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.28.4.tgz",
+      "integrity": "sha512-+ZEdQlBoRg9m2NnzvEeLgtvBMO4tkFBw5SQIUgLICgTrumLoU7lr+Oghi6km2PFj+dbUt2u1oby2w3BDO9YQnA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "regenerator-transform": "^0.15.2"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2032,14 +2234,31 @@
         "@babel/core": "^7.0.0-0"
       }
     },
+    "node_modules/@babel/plugin-transform-regexp-modifiers": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regexp-modifiers/-/plugin-transform-regexp-modifiers-7.27.1.tgz",
+      "integrity": "sha512-TtEciroaiODtXvLZv4rmfMhkCv8jx3wgKpL68PuiPh2M4fvz5jhsA7697N1gMvkvr/JTF13DrFYyEbY9U7cVPA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
     "node_modules/@babel/plugin-transform-reserved-words": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.24.7.tgz",
-      "integrity": "sha512-0DUq0pHcPKbjFZCfTss/pGkYMfy3vFWydkUBd9r0GHpIyfs2eCDENvqadMycRS9wZCXR41wucAfJHJmwA0UmoQ==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.27.1.tgz",
+      "integrity": "sha512-V2ABPHIJX4kC7HegLkYoDpfg9PVmuWy/i6vUM5eGK22bx4YVFD3M5F0QQnWQoDs6AGsUWTVOopBiMFQgHaSkVw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2049,13 +2268,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-shorthand-properties": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.24.7.tgz",
-      "integrity": "sha512-KsDsevZMDsigzbA09+vacnLpmPH4aWjcZjXdyFKGzpplxhbeB4wYtury3vglQkg6KM/xEPKt73eCjPPf1PgXBA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.27.1.tgz",
+      "integrity": "sha512-N/wH1vcn4oYawbJ13Y/FxcQrWk63jhfNa7jef0ih7PHSIHX2LB7GWE1rkPrOnka9kwMxb6hMl19p7lidA+EHmQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2065,14 +2284,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-spread": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.24.7.tgz",
-      "integrity": "sha512-x96oO0I09dgMDxJaANcRyD4ellXFLLiWhuwDxKZX5g2rWP1bTPkBSwCYv96VDXVT1bD9aPj8tppr5ITIh8hBng==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.27.1.tgz",
+      "integrity": "sha512-kpb3HUqaILBJcRFVhFUs6Trdd4mkrzcGXss+6/mxUd273PfbWqSDHRzMT2234gIg2QYfAjvXLSquP1xECSg09Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7",
-        "@babel/helper-skip-transparent-expression-wrappers": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2082,13 +2301,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-sticky-regex": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.24.7.tgz",
-      "integrity": "sha512-kHPSIJc9v24zEml5geKg9Mjx5ULpfncj0wRpYtxbvKyTtHCYDkVE3aHQ03FrpEo4gEe2vrJJS1Y9CJTaThA52g==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.27.1.tgz",
+      "integrity": "sha512-lhInBO5bi/Kowe2/aLdBAawijx+q1pQzicSgnkB6dUPc1+RC8QmJHKf2OjvU+NZWitguJHEaEmbV6VWEouT58g==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2098,13 +2317,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-template-literals": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.24.7.tgz",
-      "integrity": "sha512-AfDTQmClklHCOLxtGoP7HkeMw56k1/bTQjwsfhL6pppo/M4TOBSq+jjBUBLmV/4oeFg4GWMavIl44ZeCtmmZTw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.27.1.tgz",
+      "integrity": "sha512-fBJKiV7F2DxZUkg5EtHKXQdbsbURW3DZKQUWphDum0uRP6eHGGa/He9mc0mypL680pb+e/lDIthRohlv8NCHkg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2114,13 +2333,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-typeof-symbol": {
-      "version": "7.24.8",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.24.8.tgz",
-      "integrity": "sha512-adNTUpDCVnmAE58VEqKlAA6ZBlNkMnWD0ZcW76lyNFN3MJniyGFZfNwERVk8Ap56MCnXztmDr19T4mPTztcuaw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.27.1.tgz",
+      "integrity": "sha512-RiSILC+nRJM7FY5srIyc4/fGIwUhyDuuBSdWn4y6yT6gm652DpCHZjIipgn6B7MQ1ITOUnAKWixEUjQRIBIcLw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2149,13 +2368,13 @@
       }
     },
     "node_modules/@babel/plugin-transform-unicode-escapes": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.24.7.tgz",
-      "integrity": "sha512-U3ap1gm5+4edc2Q/P+9VrBNhGkfnf+8ZqppY71Bo/pzZmXhhLdqgaUl6cuB07O1+AQJtCLfaOmswiNbSQ9ivhw==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.27.1.tgz",
+      "integrity": "sha512-Ysg4v6AmF26k9vpfFuTZg8HRfVWzsh1kVfowA23y9j/Gu6dOuahdUVhkLqpObp3JIv27MLSii6noRnuKN8H0Mg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2165,14 +2384,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-unicode-property-regex": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-property-regex/-/plugin-transform-unicode-property-regex-7.24.7.tgz",
-      "integrity": "sha512-uH2O4OV5M9FZYQrwc7NdVmMxQJOCCzFeYudlZSzUAHRFeOujQefa92E74TQDVskNHCzOXoigEuoyzHDhaEaK5w==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-property-regex/-/plugin-transform-unicode-property-regex-7.27.1.tgz",
+      "integrity": "sha512-uW20S39PnaTImxp39O5qFlHLS9LJEmANjMG7SxIhap8rCHqu0Ik+tLEPX5DKmHn6CsWQ7j3lix2tFOa5YtL12Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-regexp-features-plugin": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2182,14 +2401,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-unicode-regex": {
-      "version": "7.24.7",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.24.7.tgz",
-      "integrity": "sha512-hlQ96MBZSAXUq7ltkjtu3FJCCSMx/j629ns3hA3pXnBXjanNP0LHi+JpPeA81zaWgVK1VGH95Xuy7u0RyQ8kMg==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.27.1.tgz",
+      "integrity": "sha512-xvINq24TRojDuyt6JGtHmkVkrfVV3FPT16uytxImLeBZqW3/H52yN+kM1MGuyPkIQxrzKwPHs5U/MP3qKyzkGw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-regexp-features-plugin": "^7.24.7",
-        "@babel/helper-plugin-utils": "^7.24.7"
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2199,14 +2418,14 @@
       }
     },
     "node_modules/@babel/plugin-transform-unicode-sets-regex": {
-      "version": "7.25.4",
-      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-sets-regex/-/plugin-transform-unicode-sets-regex-7.25.4.tgz",
-      "integrity": "sha512-qesBxiWkgN1Q+31xUE9RcMk79eOXXDCv6tfyGMRSs4RGlioSg2WVyQAm07k726cSE56pa+Kb0y9epX2qaXzTvA==",
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-sets-regex/-/plugin-transform-unicode-sets-regex-7.27.1.tgz",
+      "integrity": "sha512-EtkOujbc4cgvb0mlpQefi4NTPBzhSIevblFevACNLUspmrALgmEBdL/XfnyyITfd8fKBZrZys92zOWcik7j9Tw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-create-regexp-features-plugin": "^7.25.2",
-        "@babel/helper-plugin-utils": "^7.24.8"
+        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
+        "@babel/helper-plugin-utils": "^7.27.1"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -2216,94 +2435,81 @@
       }
     },
     "node_modules/@babel/preset-env": {
-      "version": "7.25.4",
-      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.25.4.tgz",
-      "integrity": "sha512-W9Gyo+KmcxjGahtt3t9fb14vFRWvPpu5pT6GBlovAK6BTBcxgjfVMSQCfJl4oi35ODrxP6xx2Wr8LNST57Mraw==",
+      "version": "7.28.3",
+      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.28.3.tgz",
+      "integrity": "sha512-ROiDcM+GbYVPYBOeCR6uBXKkQpBExLl8k9HO1ygXEyds39j+vCCsjmj7S8GOniZQlEs81QlkdJZe76IpLSiqpg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/compat-data": "^7.25.4",
-        "@babel/helper-compilation-targets": "^7.25.2",
-        "@babel/helper-plugin-utils": "^7.24.8",
-        "@babel/helper-validator-option": "^7.24.8",
-        "@babel/plugin-bugfix-firefox-class-in-computed-class-key": "^7.25.3",
-        "@babel/plugin-bugfix-safari-class-field-initializer-scope": "^7.25.0",
-        "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.25.0",
-        "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.24.7",
-        "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": "^7.25.0",
+        "@babel/compat-data": "^7.28.0",
+        "@babel/helper-compilation-targets": "^7.27.2",
+        "@babel/helper-plugin-utils": "^7.27.1",
+        "@babel/helper-validator-option": "^7.27.1",
+        "@babel/plugin-bugfix-firefox-class-in-computed-class-key": "^7.27.1",
+        "@babel/plugin-bugfix-safari-class-field-initializer-scope": "^7.27.1",
+        "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.27.1",
+        "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.27.1",
+        "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": "^7.28.3",
         "@babel/plugin-proposal-private-property-in-object": "7.21.0-placeholder-for-preset-env.2",
-        "@babel/plugin-syntax-async-generators": "^7.8.4",
-        "@babel/plugin-syntax-class-properties": "^7.12.13",
-        "@babel/plugin-syntax-class-static-block": "^7.14.5",
-        "@babel/plugin-syntax-dynamic-import": "^7.8.3",
-        "@babel/plugin-syntax-export-namespace-from": "^7.8.3",
-        "@babel/plugin-syntax-import-assertions": "^7.24.7",
-        "@babel/plugin-syntax-import-attributes": "^7.24.7",
-        "@babel/plugin-syntax-import-meta": "^7.10.4",
-        "@babel/plugin-syntax-json-strings": "^7.8.3",
-        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
-        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
-        "@babel/plugin-syntax-numeric-separator": "^7.10.4",
-        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
-        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
-        "@babel/plugin-syntax-optional-chaining": "^7.8.3",
-        "@babel/plugin-syntax-private-property-in-object": "^7.14.5",
-        "@babel/plugin-syntax-top-level-await": "^7.14.5",
+        "@babel/plugin-syntax-import-assertions": "^7.27.1",
+        "@babel/plugin-syntax-import-attributes": "^7.27.1",
         "@babel/plugin-syntax-unicode-sets-regex": "^7.18.6",
-        "@babel/plugin-transform-arrow-functions": "^7.24.7",
-        "@babel/plugin-transform-async-generator-functions": "^7.25.4",
-        "@babel/plugin-transform-async-to-generator": "^7.24.7",
-        "@babel/plugin-transform-block-scoped-functions": "^7.24.7",
-        "@babel/plugin-transform-block-scoping": "^7.25.0",
-        "@babel/plugin-transform-class-properties": "^7.25.4",
-        "@babel/plugin-transform-class-static-block": "^7.24.7",
-        "@babel/plugin-transform-classes": "^7.25.4",
-        "@babel/plugin-transform-computed-properties": "^7.24.7",
-        "@babel/plugin-transform-destructuring": "^7.24.8",
-        "@babel/plugin-transform-dotall-regex": "^7.24.7",
-        "@babel/plugin-transform-duplicate-keys": "^7.24.7",
-        "@babel/plugin-transform-duplicate-named-capturing-groups-regex": "^7.25.0",
-        "@babel/plugin-transform-dynamic-import": "^7.24.7",
-        "@babel/plugin-transform-exponentiation-operator": "^7.24.7",
-        "@babel/plugin-transform-export-namespace-from": "^7.24.7",
-        "@babel/plugin-transform-for-of": "^7.24.7",
-        "@babel/plugin-transform-function-name": "^7.25.1",
-        "@babel/plugin-transform-json-strings": "^7.24.7",
-        "@babel/plugin-transform-literals": "^7.25.2",
-        "@babel/plugin-transform-logical-assignment-operators": "^7.24.7",
-        "@babel/plugin-transform-member-expression-literals": "^7.24.7",
-        "@babel/plugin-transform-modules-amd": "^7.24.7",
-        "@babel/plugin-transform-modules-commonjs": "^7.24.8",
-        "@babel/plugin-transform-modules-systemjs": "^7.25.0",
-        "@babel/plugin-transform-modules-umd": "^7.24.7",
-        "@babel/plugin-transform-named-capturing-groups-regex": "^7.24.7",
-        "@babel/plugin-transform-new-target": "^7.24.7",
-        "@babel/plugin-transform-nullish-coalescing-operator": "^7.24.7",
-        "@babel/plugin-transform-numeric-separator": "^7.24.7",
-        "@babel/plugin-transform-object-rest-spread": "^7.24.7",
-        "@babel/plugin-transform-object-super": "^7.24.7",
-        "@babel/plugin-transform-optional-catch-binding": "^7.24.7",
-        "@babel/plugin-transform-optional-chaining": "^7.24.8",
-        "@babel/plugin-transform-parameters": "^7.24.7",
-        "@babel/plugin-transform-private-methods": "^7.25.4",
-        "@babel/plugin-transform-private-property-in-object": "^7.24.7",
-        "@babel/plugin-transform-property-literals": "^7.24.7",
-        "@babel/plugin-transform-regenerator": "^7.24.7",
-        "@babel/plugin-transform-reserved-words": "^7.24.7",
-        "@babel/plugin-transform-shorthand-properties": "^7.24.7",
-        "@babel/plugin-transform-spread": "^7.24.7",
-        "@babel/plugin-transform-sticky-regex": "^7.24.7",
-        "@babel/plugin-transform-template-literals": "^7.24.7",
-        "@babel/plugin-transform-typeof-symbol": "^7.24.8",
-        "@babel/plugin-transform-unicode-escapes": "^7.24.7",
-        "@babel/plugin-transform-unicode-property-regex": "^7.24.7",
-        "@babel/plugin-transform-unicode-regex": "^7.24.7",
-        "@babel/plugin-transform-unicode-sets-regex": "^7.25.4",
+        "@babel/plugin-transform-arrow-functions": "^7.27.1",
+        "@babel/plugin-transform-async-generator-functions": "^7.28.0",
+        "@babel/plugin-transform-async-to-generator": "^7.27.1",
+        "@babel/plugin-transform-block-scoped-functions": "^7.27.1",
+        "@babel/plugin-transform-block-scoping": "^7.28.0",
+        "@babel/plugin-transform-class-properties": "^7.27.1",
+        "@babel/plugin-transform-class-static-block": "^7.28.3",
+        "@babel/plugin-transform-classes": "^7.28.3",
+        "@babel/plugin-transform-computed-properties": "^7.27.1",
+        "@babel/plugin-transform-destructuring": "^7.28.0",
+        "@babel/plugin-transform-dotall-regex": "^7.27.1",
+        "@babel/plugin-transform-duplicate-keys": "^7.27.1",
+        "@babel/plugin-transform-duplicate-named-capturing-groups-regex": "^7.27.1",
+        "@babel/plugin-transform-dynamic-import": "^7.27.1",
+        "@babel/plugin-transform-explicit-resource-management": "^7.28.0",
+        "@babel/plugin-transform-exponentiation-operator": "^7.27.1",
+        "@babel/plugin-transform-export-namespace-from": "^7.27.1",
+        "@babel/plugin-transform-for-of": "^7.27.1",
+        "@babel/plugin-transform-function-name": "^7.27.1",
+        "@babel/plugin-transform-json-strings": "^7.27.1",
+        "@babel/plugin-transform-literals": "^7.27.1",
+        "@babel/plugin-transform-logical-assignment-operators": "^7.27.1",
+        "@babel/plugin-transform-member-expression-literals": "^7.27.1",
+        "@babel/plugin-transform-modules-amd": "^7.27.1",
+        "@babel/plugin-transform-modules-commonjs": "^7.27.1",
+        "@babel/plugin-transform-modules-systemjs": "^7.27.1",
+        "@babel/plugin-transform-modules-umd": "^7.27.1",
+        "@babel/plugin-transform-named-capturing-groups-regex": "^7.27.1",
+        "@babel/plugin-transform-new-target": "^7.27.1",
+        "@babel/plugin-transform-nullish-coalescing-operator": "^7.27.1",
+        "@babel/plugin-transform-numeric-separator": "^7.27.1",
+        "@babel/plugin-transform-object-rest-spread": "^7.28.0",
+        "@babel/plugin-transform-object-super": "^7.27.1",
+        "@babel/plugin-transform-optional-catch-binding": "^7.27.1",
+        "@babel/plugin-transform-optional-chaining": "^7.27.1",
+        "@babel/plugin-transform-parameters": "^7.27.7",
+        "@babel/plugin-transform-private-methods": "^7.27.1",
+        "@babel/plugin-transform-private-property-in-object": "^7.27.1",
+        "@babel/plugin-transform-property-literals": "^7.27.1",
+        "@babel/plugin-transform-regenerator": "^7.28.3",
+        "@babel/plugin-transform-regexp-modifiers": "^7.27.1",
+        "@babel/plugin-transform-reserved-words": "^7.27.1",
+        "@babel/plugin-transform-shorthand-properties": "^7.27.1",
+        "@babel/plugin-transform-spread": "^7.27.1",
+        "@babel/plugin-transform-sticky-regex": "^7.27.1",
+        "@babel/plugin-transform-template-literals": "^7.27.1",
+        "@babel/plugin-transform-typeof-symbol": "^7.27.1",
+        "@babel/plugin-transform-unicode-escapes": "^7.27.1",
+        "@babel/plugin-transform-unicode-property-regex": "^7.27.1",
+        "@babel/plugin-transform-unicode-regex": "^7.27.1",
+        "@babel/plugin-transform-unicode-sets-regex": "^7.27.1",
         "@babel/preset-modules": "0.1.6-no-external-plugins",
-        "babel-plugin-polyfill-corejs2": "^0.4.10",
-        "babel-plugin-polyfill-corejs3": "^0.10.6",
-        "babel-plugin-polyfill-regenerator": "^0.6.1",
-        "core-js-compat": "^3.37.1",
+        "babel-plugin-polyfill-corejs2": "^0.4.14",
+        "babel-plugin-polyfill-corejs3": "^0.13.0",
+        "babel-plugin-polyfill-regenerator": "^0.6.5",
+        "core-js-compat": "^3.43.0",
         "semver": "^6.3.1"
       },
       "engines": {
@@ -2378,13 +2584,6 @@
         "@babel/core": "^7.0.0-0"
       }
     },
-    "node_modules/@babel/regjsgen": {
-      "version": "0.8.0",
-      "resolved": "https://registry.npmjs.org/@babel/regjsgen/-/regjsgen-0.8.0.tgz",
-      "integrity": "sha512-x/rqGMdzj+fWZvCOYForTghzbtqPDZ5gPwaoNGHdgDfF2QA/XZbCBp4Moo5scrkAMPhB7z26XM/AaHuIJdgauA==",
-      "dev": true,
-      "license": "MIT"
-    },
     "node_modules/@babel/runtime": {
       "version": "7.27.0",
       "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.0.tgz",
@@ -2412,17 +2611,17 @@
       }
     },
     "node_modules/@babel/traverse": {
-      "version": "7.28.3",
-      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.3.tgz",
-      "integrity": "sha512-7w4kZYHneL3A6NP2nxzHvT3HCZ7puDZZjFMqDpBPECub79sTtSO5CGXDkKrTQq8ksAwfD/XI2MRFX23njdDaIQ==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.4.tgz",
+      "integrity": "sha512-YEzuboP2qvQavAcjgQNVgsvHIDv6ZpwXvcvjmyySP2DIMuByS/6ioU5G9pYrWHM6T2YDfc7xga9iNzYOs12CFQ==",
       "license": "MIT",
       "dependencies": {
         "@babel/code-frame": "^7.27.1",
         "@babel/generator": "^7.28.3",
         "@babel/helper-globals": "^7.28.0",
-        "@babel/parser": "^7.28.3",
+        "@babel/parser": "^7.28.4",
         "@babel/template": "^7.27.2",
-        "@babel/types": "^7.28.2",
+        "@babel/types": "^7.28.4",
         "debug": "^4.3.1"
       },
       "engines": {
@@ -2430,9 +2629,9 @@
       }
     },
     "node_modules/@babel/types": {
-      "version": "7.28.2",
-      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.2.tgz",
-      "integrity": "sha512-ruv7Ae4J5dUYULmeXw1gmb7rYRz57OWCPM57pHojnLq/3Z1CK2lNSLTCVjxVk1F/TZHwOZZrOWi0ur95BbLxNQ==",
+      "version": "7.28.4",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.4.tgz",
+      "integrity": "sha512-bkFqkLhh3pMBUQQkpVgWDWq/lqzc2678eUyDlTBhRqhCHFguYYGM0Efga7tYk4TogG/3x0EEl66/OQ+WGbWB/Q==",
       "license": "MIT",
       "dependencies": {
         "@babel/helper-string-parser": "^7.27.1",
@@ -2515,15 +2714,6 @@
         "sisteransi": "^1.0.5"
       }
     },
-    "node_modules/@colors/colors": {
-      "version": "1.5.0",
-      "resolved": "https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz",
-      "integrity": "sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.1.90"
-      }
-    },
     "node_modules/@cspotcode/source-map-support": {
       "version": "0.8.1",
       "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
@@ -3435,9 +3625,9 @@
       }
     },
     "node_modules/@esbuild/aix-ppc64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.9.tgz",
-      "integrity": "sha512-OaGtL73Jck6pBKjNIe24BnFE6agGl+6KxDtTfHhy1HmhthfKouEcOhqpSL64K4/0WCtbKFLOdzD/44cJ4k9opA==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.11.tgz",
+      "integrity": "sha512-Xt1dOL13m8u0WE8iplx9Ibbm+hFAO0GsU2P34UNoDGvZYkY8ifSiy6Zuc1lYxfG7svWE2fzqCUmFp5HCn51gJg==",
       "cpu": [
         "ppc64"
       ],
@@ -3451,9 +3641,9 @@
       }
     },
     "node_modules/@esbuild/android-arm": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.9.tgz",
-      "integrity": "sha512-5WNI1DaMtxQ7t7B6xa572XMXpHAaI/9Hnhk8lcxF4zVN4xstUgTlvuGDorBguKEnZO70qwEcLpfifMLoxiPqHQ==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.11.tgz",
+      "integrity": "sha512-uoa7dU+Dt3HYsethkJ1k6Z9YdcHjTrSb5NUy66ZfZaSV8hEYGD5ZHbEMXnqLFlbBflLsl89Zke7CAdDJ4JI+Gg==",
       "cpu": [
         "arm"
       ],
@@ -3467,9 +3657,9 @@
       }
     },
     "node_modules/@esbuild/android-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.9.tgz",
-      "integrity": "sha512-IDrddSmpSv51ftWslJMvl3Q2ZT98fUSL2/rlUXuVqRXHCs5EUF1/f+jbjF5+NG9UffUDMCiTyh8iec7u8RlTLg==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.11.tgz",
+      "integrity": "sha512-9slpyFBc4FPPz48+f6jyiXOx/Y4v34TUeDDXJpZqAWQn/08lKGeD8aDp9TMn9jDz2CiEuHwfhRmGBvpnd/PWIQ==",
       "cpu": [
         "arm64"
       ],
@@ -3483,9 +3673,9 @@
       }
     },
     "node_modules/@esbuild/android-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.9.tgz",
-      "integrity": "sha512-I853iMZ1hWZdNllhVZKm34f4wErd4lMyeV7BLzEExGEIZYsOzqDWDf+y082izYUE8gtJnYHdeDpN/6tUdwvfiw==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.11.tgz",
+      "integrity": "sha512-Sgiab4xBjPU1QoPEIqS3Xx+R2lezu0LKIEcYe6pftr56PqPygbB7+szVnzoShbx64MUupqoE0KyRlN7gezbl8g==",
       "cpu": [
         "x64"
       ],
@@ -3499,9 +3689,9 @@
       }
     },
     "node_modules/@esbuild/darwin-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.9.tgz",
-      "integrity": "sha512-XIpIDMAjOELi/9PB30vEbVMs3GV1v2zkkPnuyRRURbhqjyzIINwj+nbQATh4H9GxUgH1kFsEyQMxwiLFKUS6Rg==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.11.tgz",
+      "integrity": "sha512-VekY0PBCukppoQrycFxUqkCojnTQhdec0vevUL/EDOCnXd9LKWqD/bHwMPzigIJXPhC59Vd1WFIL57SKs2mg4w==",
       "cpu": [
         "arm64"
       ],
@@ -3515,9 +3705,9 @@
       }
     },
     "node_modules/@esbuild/darwin-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.9.tgz",
-      "integrity": "sha512-jhHfBzjYTA1IQu8VyrjCX4ApJDnH+ez+IYVEoJHeqJm9VhG9Dh2BYaJritkYK3vMaXrf7Ogr/0MQ8/MeIefsPQ==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.11.tgz",
+      "integrity": "sha512-+hfp3yfBalNEpTGp9loYgbknjR695HkqtY3d3/JjSRUyPg/xd6q+mQqIb5qdywnDxRZykIHs3axEqU6l1+oWEQ==",
       "cpu": [
         "x64"
       ],
@@ -3531,9 +3721,9 @@
       }
     },
     "node_modules/@esbuild/freebsd-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.9.tgz",
-      "integrity": "sha512-z93DmbnY6fX9+KdD4Ue/H6sYs+bhFQJNCPZsi4XWJoYblUqT06MQUdBCpcSfuiN72AbqeBFu5LVQTjfXDE2A6Q==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.11.tgz",
+      "integrity": "sha512-CmKjrnayyTJF2eVuO//uSjl/K3KsMIeYeyN7FyDBjsR3lnSJHaXlVoAK8DZa7lXWChbuOk7NjAc7ygAwrnPBhA==",
       "cpu": [
         "arm64"
       ],
@@ -3547,9 +3737,9 @@
       }
     },
     "node_modules/@esbuild/freebsd-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.9.tgz",
-      "integrity": "sha512-mrKX6H/vOyo5v71YfXWJxLVxgy1kyt1MQaD8wZJgJfG4gq4DpQGpgTB74e5yBeQdyMTbgxp0YtNj7NuHN0PoZg==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.11.tgz",
+      "integrity": "sha512-Dyq+5oscTJvMaYPvW3x3FLpi2+gSZTCE/1ffdwuM6G1ARang/mb3jvjxs0mw6n3Lsw84ocfo9CrNMqc5lTfGOw==",
       "cpu": [
         "x64"
       ],
@@ -3563,9 +3753,9 @@
       }
     },
     "node_modules/@esbuild/linux-arm": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.9.tgz",
-      "integrity": "sha512-HBU2Xv78SMgaydBmdor38lg8YDnFKSARg1Q6AT0/y2ezUAKiZvc211RDFHlEZRFNRVhcMamiToo7bDx3VEOYQw==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.11.tgz",
+      "integrity": "sha512-TBMv6B4kCfrGJ8cUPo7vd6NECZH/8hPpBHHlYI3qzoYFvWu2AdTvZNuU/7hsbKWqu/COU7NIK12dHAAqBLLXgw==",
       "cpu": [
         "arm"
       ],
@@ -3579,9 +3769,9 @@
       }
     },
     "node_modules/@esbuild/linux-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.9.tgz",
-      "integrity": "sha512-BlB7bIcLT3G26urh5Dmse7fiLmLXnRlopw4s8DalgZ8ef79Jj4aUcYbk90g8iCa2467HX8SAIidbL7gsqXHdRw==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.11.tgz",
+      "integrity": "sha512-Qr8AzcplUhGvdyUF08A1kHU3Vr2O88xxP0Tm8GcdVOUm25XYcMPp2YqSVHbLuXzYQMf9Bh/iKx7YPqECs6ffLA==",
       "cpu": [
         "arm64"
       ],
@@ -3595,9 +3785,9 @@
       }
     },
     "node_modules/@esbuild/linux-ia32": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.9.tgz",
-      "integrity": "sha512-e7S3MOJPZGp2QW6AK6+Ly81rC7oOSerQ+P8L0ta4FhVi+/j/v2yZzx5CqqDaWjtPFfYz21Vi1S0auHrap3Ma3A==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.11.tgz",
+      "integrity": "sha512-TmnJg8BMGPehs5JKrCLqyWTVAvielc615jbkOirATQvWWB1NMXY77oLMzsUjRLa0+ngecEmDGqt5jiDC6bfvOw==",
       "cpu": [
         "ia32"
       ],
@@ -3611,9 +3801,9 @@
       }
     },
     "node_modules/@esbuild/linux-loong64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.9.tgz",
-      "integrity": "sha512-Sbe10Bnn0oUAB2AalYztvGcK+o6YFFA/9829PhOCUS9vkJElXGdphz0A3DbMdP8gmKkqPmPcMJmJOrI3VYB1JQ==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.11.tgz",
+      "integrity": "sha512-DIGXL2+gvDaXlaq8xruNXUJdT5tF+SBbJQKbWy/0J7OhU8gOHOzKmGIlfTTl6nHaCOoipxQbuJi7O++ldrxgMw==",
       "cpu": [
         "loong64"
       ],
@@ -3627,9 +3817,9 @@
       }
     },
     "node_modules/@esbuild/linux-mips64el": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.9.tgz",
-      "integrity": "sha512-YcM5br0mVyZw2jcQeLIkhWtKPeVfAerES5PvOzaDxVtIyZ2NUBZKNLjC5z3/fUlDgT6w89VsxP2qzNipOaaDyA==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.11.tgz",
+      "integrity": "sha512-Osx1nALUJu4pU43o9OyjSCXokFkFbyzjXb6VhGIJZQ5JZi8ylCQ9/LFagolPsHtgw6himDSyb5ETSfmp4rpiKQ==",
       "cpu": [
         "mips64el"
       ],
@@ -3643,9 +3833,9 @@
       }
     },
     "node_modules/@esbuild/linux-ppc64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.9.tgz",
-      "integrity": "sha512-++0HQvasdo20JytyDpFvQtNrEsAgNG2CY1CLMwGXfFTKGBGQT3bOeLSYE2l1fYdvML5KUuwn9Z8L1EWe2tzs1w==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.11.tgz",
+      "integrity": "sha512-nbLFgsQQEsBa8XSgSTSlrnBSrpoWh7ioFDUmwo158gIm5NNP+17IYmNWzaIzWmgCxq56vfr34xGkOcZ7jX6CPw==",
       "cpu": [
         "ppc64"
       ],
@@ -3659,9 +3849,9 @@
       }
     },
     "node_modules/@esbuild/linux-riscv64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.9.tgz",
-      "integrity": "sha512-uNIBa279Y3fkjV+2cUjx36xkx7eSjb8IvnL01eXUKXez/CBHNRw5ekCGMPM0BcmqBxBcdgUWuUXmVWwm4CH9kg==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.11.tgz",
+      "integrity": "sha512-HfyAmqZi9uBAbgKYP1yGuI7tSREXwIb438q0nqvlpxAOs3XnZ8RsisRfmVsgV486NdjD7Mw2UrFSw51lzUk1ww==",
       "cpu": [
         "riscv64"
       ],
@@ -3675,9 +3865,9 @@
       }
     },
     "node_modules/@esbuild/linux-s390x": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.9.tgz",
-      "integrity": "sha512-Mfiphvp3MjC/lctb+7D287Xw1DGzqJPb/J2aHHcHxflUo+8tmN/6d4k6I2yFR7BVo5/g7x2Monq4+Yew0EHRIA==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.11.tgz",
+      "integrity": "sha512-HjLqVgSSYnVXRisyfmzsH6mXqyvj0SA7pG5g+9W7ESgwA70AXYNpfKBqh1KbTxmQVaYxpzA/SvlB9oclGPbApw==",
       "cpu": [
         "s390x"
       ],
@@ -3691,9 +3881,9 @@
       }
     },
     "node_modules/@esbuild/linux-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.9.tgz",
-      "integrity": "sha512-iSwByxzRe48YVkmpbgoxVzn76BXjlYFXC7NvLYq+b+kDjyyk30J0JY47DIn8z1MO3K0oSl9fZoRmZPQI4Hklzg==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.11.tgz",
+      "integrity": "sha512-HSFAT4+WYjIhrHxKBwGmOOSpphjYkcswF449j6EjsjbinTZbp8PJtjsVK1XFJStdzXdy/jaddAep2FGY+wyFAQ==",
       "cpu": [
         "x64"
       ],
@@ -3707,9 +3897,9 @@
       }
     },
     "node_modules/@esbuild/netbsd-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.9.tgz",
-      "integrity": "sha512-9jNJl6FqaUG+COdQMjSCGW4QiMHH88xWbvZ+kRVblZsWrkXlABuGdFJ1E9L7HK+T0Yqd4akKNa/lO0+jDxQD4Q==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.11.tgz",
+      "integrity": "sha512-hr9Oxj1Fa4r04dNpWr3P8QKVVsjQhqrMSUzZzf+LZcYjZNqhA3IAfPQdEh1FLVUJSiu6sgAwp3OmwBfbFgG2Xg==",
       "cpu": [
         "arm64"
       ],
@@ -3723,9 +3913,9 @@
       }
     },
     "node_modules/@esbuild/netbsd-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.9.tgz",
-      "integrity": "sha512-RLLdkflmqRG8KanPGOU7Rpg829ZHu8nFy5Pqdi9U01VYtG9Y0zOG6Vr2z4/S+/3zIyOxiK6cCeYNWOFR9QP87g==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.11.tgz",
+      "integrity": "sha512-u7tKA+qbzBydyj0vgpu+5h5AeudxOAGncb8N6C9Kh1N4n7wU1Xw1JDApsRjpShRpXRQlJLb9wY28ELpwdPcZ7A==",
       "cpu": [
         "x64"
       ],
@@ -3739,9 +3929,9 @@
       }
     },
     "node_modules/@esbuild/openbsd-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.9.tgz",
-      "integrity": "sha512-YaFBlPGeDasft5IIM+CQAhJAqS3St3nJzDEgsgFixcfZeyGPCd6eJBWzke5piZuZ7CtL656eOSYKk4Ls2C0FRQ==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.11.tgz",
+      "integrity": "sha512-Qq6YHhayieor3DxFOoYM1q0q1uMFYb7cSpLD2qzDSvK1NAvqFi8Xgivv0cFC6J+hWVw2teCYltyy9/m/14ryHg==",
       "cpu": [
         "arm64"
       ],
@@ -3755,9 +3945,9 @@
       }
     },
     "node_modules/@esbuild/openbsd-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.9.tgz",
-      "integrity": "sha512-1MkgTCuvMGWuqVtAvkpkXFmtL8XhWy+j4jaSO2wxfJtilVCi0ZE37b8uOdMItIHz4I6z1bWWtEX4CJwcKYLcuA==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.11.tgz",
+      "integrity": "sha512-CN+7c++kkbrckTOz5hrehxWN7uIhFFlmS/hqziSFVWpAzpWrQoAG4chH+nN3Be+Kzv/uuo7zhX716x3Sn2Jduw==",
       "cpu": [
         "x64"
       ],
@@ -3771,9 +3961,9 @@
       }
     },
     "node_modules/@esbuild/openharmony-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.9.tgz",
-      "integrity": "sha512-4Xd0xNiMVXKh6Fa7HEJQbrpP3m3DDn43jKxMjxLLRjWnRsfxjORYJlXPO4JNcXtOyfajXorRKY9NkOpTHptErg==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.11.tgz",
+      "integrity": "sha512-rOREuNIQgaiR+9QuNkbkxubbp8MSO9rONmwP5nKncnWJ9v5jQ4JxFnLu4zDSRPf3x4u+2VN4pM4RdyIzDty/wQ==",
       "cpu": [
         "arm64"
       ],
@@ -3787,9 +3977,9 @@
       }
     },
     "node_modules/@esbuild/sunos-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.9.tgz",
-      "integrity": "sha512-WjH4s6hzo00nNezhp3wFIAfmGZ8U7KtrJNlFMRKxiI9mxEK1scOMAaa9i4crUtu+tBr+0IN6JCuAcSBJZfnphw==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.11.tgz",
+      "integrity": "sha512-nq2xdYaWxyg9DcIyXkZhcYulC6pQ2FuCgem3LI92IwMgIZ69KHeY8T4Y88pcwoLIjbed8n36CyKoYRDygNSGhA==",
       "cpu": [
         "x64"
       ],
@@ -3803,9 +3993,9 @@
       }
     },
     "node_modules/@esbuild/win32-arm64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.9.tgz",
-      "integrity": "sha512-mGFrVJHmZiRqmP8xFOc6b84/7xa5y5YvR1x8djzXpJBSv/UsNK6aqec+6JDjConTgvvQefdGhFDAs2DLAds6gQ==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.11.tgz",
+      "integrity": "sha512-3XxECOWJq1qMZ3MN8srCJ/QfoLpL+VaxD/WfNRm1O3B4+AZ/BnLVgFbUV3eiRYDMXetciH16dwPbbHqwe1uU0Q==",
       "cpu": [
         "arm64"
       ],
@@ -3819,9 +4009,9 @@
       }
     },
     "node_modules/@esbuild/win32-ia32": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.9.tgz",
-      "integrity": "sha512-b33gLVU2k11nVx1OhX3C8QQP6UHQK4ZtN56oFWvVXvz2VkDoe6fbG8TOgHFxEvqeqohmRnIHe5A1+HADk4OQww==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.11.tgz",
+      "integrity": "sha512-3ukss6gb9XZ8TlRyJlgLn17ecsK4NSQTmdIXRASVsiS2sQ6zPPZklNJT5GR5tE/MUarymmy8kCEf5xPCNCqVOA==",
       "cpu": [
         "ia32"
       ],
@@ -3835,9 +4025,9 @@
       }
     },
     "node_modules/@esbuild/win32-x64": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.9.tgz",
-      "integrity": "sha512-PPOl1mi6lpLNQxnGoyAfschAodRFYXJ+9fs6WHXz7CSWKbOqiMZsubC+BQsVKuul+3vKLuwTHsS2c2y9EoKwxQ==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.11.tgz",
+      "integrity": "sha512-D7Hpz6A2L4hzsRpPaCYkQnGOotdUpDzSGRIv9I+1ITdHROSFUWW95ZPZWQmGka1Fg7W3zFJowyn9WGwMJ0+KPA==",
       "cpu": [
         "x64"
       ],
@@ -3966,6 +4156,61 @@
         "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
       }
     },
+    "node_modules/@expo/devcert": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/@expo/devcert/-/devcert-1.2.0.tgz",
+      "integrity": "sha512-Uilcv3xGELD5t/b0eM4cxBFEKQRIivB3v7i+VhWLV/gL98aw810unLKKJbGAxAIhY6Ipyz8ChWibFsKFXYwstA==",
+      "license": "MIT",
+      "dependencies": {
+        "@expo/sudo-prompt": "^9.3.1",
+        "debug": "^3.1.0",
+        "glob": "^10.4.2"
+      }
+    },
+    "node_modules/@expo/devcert/node_modules/debug": {
+      "version": "3.2.7",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
+      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.1"
+      }
+    },
+    "node_modules/@expo/devcert/node_modules/glob": {
+      "version": "10.4.5",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.4.5.tgz",
+      "integrity": "sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==",
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/@expo/devcert/node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "license": "ISC",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
+    "node_modules/@expo/sudo-prompt": {
+      "version": "9.3.2",
+      "resolved": "https://registry.npmjs.org/@expo/sudo-prompt/-/sudo-prompt-9.3.2.tgz",
+      "integrity": "sha512-HHQigo3rQWKMDzYDLkubN5WQOYXJJE2eNqIQC2axC2iO3mHdwnIR7FgZVvHWtBwAdzBgAP0ECp8KqS8TiMKvgw==",
+      "license": "MIT"
+    },
     "node_modules/@floating-ui/core": {
       "version": "1.6.9",
       "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.6.9.tgz",
@@ -4235,7 +4480,6 @@
       "version": "8.0.2",
       "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
       "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
-      "dev": true,
       "license": "ISC",
       "dependencies": {
         "string-width": "^5.1.2",
@@ -4253,7 +4497,6 @@
       "version": "6.1.0",
       "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
       "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=12"
@@ -4266,7 +4509,6 @@
       "version": "6.2.1",
       "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz",
       "integrity": "sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=12"
@@ -4279,7 +4521,6 @@
       "version": "5.1.2",
       "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
       "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "eastasianwidth": "^0.2.0",
@@ -4297,7 +4538,6 @@
       "version": "7.1.0",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
       "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-regex": "^6.0.1"
@@ -4313,7 +4553,6 @@
       "version": "8.1.0",
       "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
       "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-styles": "^6.1.0",
@@ -4327,6 +4566,15 @@
         "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
       }
     },
+    "node_modules/@isaacs/ttlcache": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/@isaacs/ttlcache/-/ttlcache-1.4.1.tgz",
+      "integrity": "sha512-RQgQ4uQ+pLbqXfOmieB91ejmLwvSgv9nLx6sT6sD83s7umBypgg+OIBOBbEUiJXrfpnp9j0mRhYYdzp9uqq3lA==",
+      "license": "ISC",
+      "engines": {
+        "node": ">=12"
+      }
+    },
     "node_modules/@istanbuljs/load-nyc-config": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.1.0.tgz",
@@ -4639,6 +4887,30 @@
         "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
       }
     },
+    "node_modules/@jest/pattern": {
+      "version": "30.0.1",
+      "resolved": "https://registry.npmjs.org/@jest/pattern/-/pattern-30.0.1.tgz",
+      "integrity": "sha512-gWp7NfQW27LaBQz3TITS8L7ZCQ0TLvtmI//4OwlQRx4rnWxcPNIYjxZpDcN4+UlGxgm3jS5QPz8IPTCkb59wZA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/node": "*",
+        "jest-regex-util": "30.0.1"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
+    "node_modules/@jest/pattern/node_modules/jest-regex-util": {
+      "version": "30.0.1",
+      "resolved": "https://registry.npmjs.org/jest-regex-util/-/jest-regex-util-30.0.1.tgz",
+      "integrity": "sha512-jHEQgBXAgc+Gh4g0p3bCevgRCVRkB4VB70zhoAE48gxeSr1hfUOsM/C2WoJgVL7Eyg//hudYENbm3Ne+/dRVVA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
     "node_modules/@jest/reporters": {
       "version": "29.7.0",
       "resolved": "https://registry.npmjs.org/@jest/reporters/-/reporters-29.7.0.tgz",
@@ -4798,6 +5070,16 @@
         "@jridgewell/trace-mapping": "^0.3.24"
       }
     },
+    "node_modules/@jridgewell/remapping": {
+      "version": "2.3.5",
+      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
+      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
     "node_modules/@jridgewell/resolve-uri": {
       "version": "3.1.2",
       "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
@@ -4914,31 +5196,31 @@
       "license": "MIT"
     },
     "node_modules/@libsql/client": {
-      "version": "0.15.12",
-      "resolved": "https://registry.npmjs.org/@libsql/client/-/client-0.15.12.tgz",
-      "integrity": "sha512-JIqB0XsNrqYqBQZuhcgZdTcQoNOoQ5AMF+1yxc7vcZrLtm42QJwRazmTuBfyDwtWASEmVgjxeaLF4NT1iyVX8g==",
+      "version": "0.15.15",
+      "resolved": "https://registry.npmjs.org/@libsql/client/-/client-0.15.15.tgz",
+      "integrity": "sha512-twC0hQxPNHPKfeOv3sNT6u2pturQjLcI+CnpTM0SjRpocEGgfiZ7DWKXLNnsothjyJmDqEsBQJ5ztq9Wlu470w==",
       "license": "MIT",
       "dependencies": {
-        "@libsql/core": "^0.15.12",
+        "@libsql/core": "^0.15.14",
         "@libsql/hrana-client": "^0.7.0",
         "js-base64": "^3.7.5",
-        "libsql": "^0.5.15",
+        "libsql": "^0.5.22",
         "promise-limit": "^2.7.0"
       }
     },
     "node_modules/@libsql/core": {
-      "version": "0.15.12",
-      "resolved": "https://registry.npmjs.org/@libsql/core/-/core-0.15.12.tgz",
-      "integrity": "sha512-S3tF6885ZizVjfym7f8SevL2VId/+DzxiKmP5zFbrhA8oMLh2XH8bYXChmhab7o9qUSHx+XjK4jCFpUwR5g+Ig==",
+      "version": "0.15.15",
+      "resolved": "https://registry.npmjs.org/@libsql/core/-/core-0.15.15.tgz",
+      "integrity": "sha512-C88Z6UKl+OyuKKPwz224riz02ih/zHYI3Ho/LAcVOgjsunIRZoBw7fjRfaH9oPMmSNeQfhGklSG2il1URoOIsA==",
       "license": "MIT",
       "dependencies": {
         "js-base64": "^3.7.5"
       }
     },
     "node_modules/@libsql/darwin-arm64": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/darwin-arm64/-/darwin-arm64-0.5.17.tgz",
-      "integrity": "sha512-WTYG2skZsUnZmfZ2v7WFj7s3/5s2PfrYBZOWBKOnxHA8g4XCDc/4bFDaqob9Q2e88+GC7cWeJ8VNkVBFpD2Xxg==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/darwin-arm64/-/darwin-arm64-0.5.22.tgz",
+      "integrity": "sha512-4B8ZlX3nIDPndfct7GNe0nI3Yw6ibocEicWdC4fvQbSs/jdq/RC2oCsoJxJ4NzXkvktX70C1J4FcmmoBy069UA==",
       "cpu": [
         "arm64"
       ],
@@ -4949,9 +5231,9 @@
       ]
     },
     "node_modules/@libsql/darwin-x64": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/darwin-x64/-/darwin-x64-0.5.17.tgz",
-      "integrity": "sha512-ab0RlTR4KYrxgjNrZhAhY/10GibKoq6G0W4oi0kdm+eYiAv/Ip8GDMpSaZdAcoKA4T+iKR/ehczKHnMEB8MFxA==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/darwin-x64/-/darwin-x64-0.5.22.tgz",
+      "integrity": "sha512-ny2HYWt6lFSIdNFzUFIJ04uiW6finXfMNJ7wypkAD8Pqdm6nAByO+Fdqu8t7sD0sqJGeUCiOg480icjyQ2/8VA==",
       "cpu": [
         "x64"
       ],
@@ -4993,9 +5275,9 @@
       }
     },
     "node_modules/@libsql/linux-arm-gnueabihf": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/linux-arm-gnueabihf/-/linux-arm-gnueabihf-0.5.17.tgz",
-      "integrity": "sha512-PcASh4k47RqC+kMWAbLUKf1y6Do0q8vnUGi0yhKY4ghJcimMExViBimjbjYRSa+WIb/zh3QxNoXOhQAXx3tiuw==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/linux-arm-gnueabihf/-/linux-arm-gnueabihf-0.5.22.tgz",
+      "integrity": "sha512-3Uo3SoDPJe/zBnyZKosziRGtszXaEtv57raWrZIahtQDsjxBVjuzYQinCm9LRCJCUT5t2r5Z5nLDPJi2CwZVoA==",
       "cpu": [
         "arm"
       ],
@@ -5006,9 +5288,9 @@
       ]
     },
     "node_modules/@libsql/linux-arm-musleabihf": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/linux-arm-musleabihf/-/linux-arm-musleabihf-0.5.17.tgz",
-      "integrity": "sha512-vxOkSLG9Wspit+SNle84nuIzMtr2G2qaxFzW7BhsZBjlZ8+kErf9RXcT2YJQdJYxmBYRbsOrc91gg0jLEQVCqg==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/linux-arm-musleabihf/-/linux-arm-musleabihf-0.5.22.tgz",
+      "integrity": "sha512-LCsXh07jvSojTNJptT9CowOzwITznD+YFGGW+1XxUr7fS+7/ydUrpDfsMX7UqTqjm7xG17eq86VkWJgHJfvpNg==",
       "cpu": [
         "arm"
       ],
@@ -5019,9 +5301,9 @@
       ]
     },
     "node_modules/@libsql/linux-arm64-gnu": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/linux-arm64-gnu/-/linux-arm64-gnu-0.5.17.tgz",
-      "integrity": "sha512-L8jnaN01TxjBJlDuDTX2W2BKzBkAOhcnKfCOf3xzvvygblxnDOK0whkYwIXeTfwtd/rr4jN/d6dZD/bcHiDxEQ==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/linux-arm64-gnu/-/linux-arm64-gnu-0.5.22.tgz",
+      "integrity": "sha512-KSdnOMy88c9mpOFKUEzPskSaF3VLflfSUCBwas/pn1/sV3pEhtMF6H8VUCd2rsedwoukeeCSEONqX7LLnQwRMA==",
       "cpu": [
         "arm64"
       ],
@@ -5032,9 +5314,9 @@
       ]
     },
     "node_modules/@libsql/linux-arm64-musl": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/linux-arm64-musl/-/linux-arm64-musl-0.5.17.tgz",
-      "integrity": "sha512-HfFD7TzQtmmTwyQsuiHhWZdMRtdNpKJ1p4tbMMTMRECk+971NFHrj69D64cc2ClVTAmn7fA9XibKPil7WN/Q7w==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/linux-arm64-musl/-/linux-arm64-musl-0.5.22.tgz",
+      "integrity": "sha512-mCHSMAsDTLK5YH//lcV3eFEgiR23Ym0U9oEvgZA0667gqRZg/2px+7LshDvErEKv2XZ8ixzw3p1IrBzLQHGSsw==",
       "cpu": [
         "arm64"
       ],
@@ -5045,9 +5327,9 @@
       ]
     },
     "node_modules/@libsql/linux-x64-gnu": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/linux-x64-gnu/-/linux-x64-gnu-0.5.17.tgz",
-      "integrity": "sha512-5l3XxWqUPVFrtX0xnZaXwqsXs0BFbP4w6ahRFTPSdXU50YBfUOajFznJRB6bJTMsCvraDSD0IkHhjSNfrE1CuQ==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/linux-x64-gnu/-/linux-x64-gnu-0.5.22.tgz",
+      "integrity": "sha512-kNBHaIkSg78Y4BqAdgjcR2mBilZXs4HYkAmi58J+4GRwDQZh5fIUWbnQvB9f95DkWUIGVeenqLRFY2pcTmlsew==",
       "cpu": [
         "x64"
       ],
@@ -5058,9 +5340,9 @@
       ]
     },
     "node_modules/@libsql/linux-x64-musl": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/linux-x64-musl/-/linux-x64-musl-0.5.17.tgz",
-      "integrity": "sha512-FvSpWlwc+dIeYIFYlsSv+UdQ/NiZWr+SstwVji+QZ//8NnvzwWQU9cgP+Vpps6Qiq4jyYQm9chJhTYOVT9Y3BA==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/linux-x64-musl/-/linux-x64-musl-0.5.22.tgz",
+      "integrity": "sha512-UZ4Xdxm4pu3pQXjvfJiyCzZop/9j/eA2JjmhMaAhe3EVLH2g11Fy4fwyUp9sT1QJYR1kpc2JLuybPM0kuXv/Tg==",
       "cpu": [
         "x64"
       ],
@@ -5071,9 +5353,9 @@
       ]
     },
     "node_modules/@libsql/win32-x64-msvc": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/@libsql/win32-x64-msvc/-/win32-x64-msvc-0.5.17.tgz",
-      "integrity": "sha512-f5bGH8+3A5sn6Lrqg8FsQ09a1pYXPnKGXGTFiAYlfQXVst1tUTxDTugnuWcJYKXyzDe/T7ccxyIZXeSmPOhq8A==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/@libsql/win32-x64-msvc/-/win32-x64-msvc-0.5.22.tgz",
+      "integrity": "sha512-Fj0j8RnBpo43tVZUVoNK6BV/9AtDUM5S7DF3LB4qTYg1LMSZqi3yeCneUTLJD6XomQJlZzbI4mst89yspVSAnA==",
       "cpu": [
         "x64"
       ],
@@ -5083,27 +5365,6 @@
         "win32"
       ]
     },
-    "node_modules/@lukeed/csprng": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/@lukeed/csprng/-/csprng-1.1.0.tgz",
-      "integrity": "sha512-Z7C/xXCiGWsg0KuKsHTKJxbWhpI3Vs5GwLfOean7MGyVFGqdRgBbAjOCh6u4bbjPc/8MJ2pZmK/0DLdCbivLDA==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/@lukeed/uuid": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/@lukeed/uuid/-/uuid-2.0.1.tgz",
-      "integrity": "sha512-qC72D4+CDdjGqJvkFMMEAtancHUQ7/d/tAiHf64z8MopFDmcrtbcJuerDtFceuAfQJ2pDSfCKCtbqoGBNnwg0w==",
-      "license": "MIT",
-      "dependencies": {
-        "@lukeed/csprng": "^1.1.0"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
     "node_modules/@malept/cross-spawn-promise": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/@malept/cross-spawn-promise/-/cross-spawn-promise-2.0.0.tgz",
@@ -5361,20 +5622,27 @@
       }
     },
     "node_modules/@mastra/core": {
-      "version": "0.14.1",
-      "resolved": "https://registry.npmjs.org/@mastra/core/-/core-0.14.1.tgz",
-      "integrity": "sha512-DYAIJhEUUEOd7u6sVMXLExHFmYjpQrSShSypDDswTXauoVJNgCeEjyRRxDM0sN9+mfm8Q5Ai44c5/2PMMW+ObQ==",
+      "version": "0.21.1",
+      "resolved": "https://registry.npmjs.org/@mastra/core/-/core-0.21.1.tgz",
+      "integrity": "sha512-lyASrQCLiW+tleVRL16pBN5YfBg14IBEXYl2uGmrOsJ0QiPX/pHzcmYe0n7Oh48dYzu9YB/MgbQuY5PLzks8uQ==",
       "license": "Apache-2.0",
       "dependencies": {
         "@a2a-js/sdk": "~0.2.4",
+        "@ai-sdk/anthropic-v5": "npm:@ai-sdk/anthropic@2.0.23",
+        "@ai-sdk/google-v5": "npm:@ai-sdk/google@2.0.17",
+        "@ai-sdk/openai-compatible-v5": "npm:@ai-sdk/openai-compatible@1.0.19",
+        "@ai-sdk/openai-v5": "npm:@ai-sdk/openai@2.0.42",
         "@ai-sdk/provider": "^1.1.3",
         "@ai-sdk/provider-utils": "^2.2.8",
-        "@ai-sdk/provider-utils-v5": "npm:@ai-sdk/provider-utils@3.0.3",
+        "@ai-sdk/provider-utils-v5": "npm:@ai-sdk/provider-utils@3.0.10",
         "@ai-sdk/provider-v5": "npm:@ai-sdk/provider@2.0.0",
         "@ai-sdk/ui-utils": "^1.2.11",
-        "@mastra/schema-compat": "0.10.7",
+        "@ai-sdk/xai-v5": "npm:@ai-sdk/xai@2.0.23",
+        "@isaacs/ttlcache": "^1.4.1",
+        "@mastra/schema-compat": "0.11.4",
+        "@openrouter/ai-sdk-provider-v5": "npm:@openrouter/ai-sdk-provider@1.2.0",
         "@opentelemetry/api": "^1.9.0",
-        "@opentelemetry/auto-instrumentations-node": "^0.62.0",
+        "@opentelemetry/auto-instrumentations-node": "^0.62.1",
         "@opentelemetry/core": "^2.0.1",
         "@opentelemetry/exporter-trace-otlp-grpc": "^0.203.0",
         "@opentelemetry/exporter-trace-otlp-http": "^0.203.0",
@@ -5388,27 +5656,28 @@
         "@opentelemetry/semantic-conventions": "^1.36.0",
         "@sindresorhus/slugify": "^2.2.1",
         "ai": "^4.3.19",
-        "ai-v5": "npm:ai@5.0.15",
+        "ai-v5": "npm:ai@5.0.60",
         "date-fns": "^3.6.0",
         "dotenv": "^16.6.1",
-        "hono": "^4.8.12",
+        "hono": "^4.9.7",
         "hono-openapi": "^0.4.8",
         "js-tiktoken": "^1.0.20",
         "json-schema": "^0.4.0",
         "json-schema-to-zod": "^2.6.1",
         "p-map": "^7.0.3",
+        "p-retry": "^7.1.0",
         "pino": "^9.7.0",
         "pino-pretty": "^13.0.0",
         "radash": "^12.1.1",
         "sift": "^17.1.3",
         "xstate": "^5.20.1",
-        "zod-to-json-schema": "^3.24.5"
+        "zod-to-json-schema": "^3.24.6"
       },
       "engines": {
         "node": ">=20"
       },
       "peerDependencies": {
-        "zod": "^3.0.0"
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/@mastra/core/node_modules/@sinclair/typebox": {
@@ -5497,43 +5766,60 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/@mastra/core/node_modules/p-retry": {
+      "version": "7.1.0",
+      "resolved": "https://registry.npmjs.org/p-retry/-/p-retry-7.1.0.tgz",
+      "integrity": "sha512-xL4PiFRQa/f9L9ZvR4/gUCRNus4N8YX80ku8kv9Jqz+ZokkiZLM0bcvX0gm1F3PDi9SPRsww1BDsTWgE6Y1GLQ==",
+      "license": "MIT",
+      "dependencies": {
+        "is-network-error": "^1.1.0"
+      },
+      "engines": {
+        "node": ">=20"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/@mastra/deployer": {
-      "version": "0.14.1",
-      "resolved": "https://registry.npmjs.org/@mastra/deployer/-/deployer-0.14.1.tgz",
-      "integrity": "sha512-75BLlYFfaarfr0HxGVLVOWKtxqMF4hfXa8+5NvLvZaxOLu8eJeJfBkVlGoZ+5zUAd9juc5wKcWnAr4c4Ug5fbw==",
+      "version": "0.21.1",
+      "resolved": "https://registry.npmjs.org/@mastra/deployer/-/deployer-0.21.1.tgz",
+      "integrity": "sha512-bkwARFO9PRCvVzCsTYGOP/JpYem9QEYqSEjv8i1MdH/6u+GK4XqbCufO5NLM014aAN3h5OrTIcdImuy2rnih6w==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@babel/core": "^7.28.0",
+        "@babel/core": "^7.28.4",
         "@babel/helper-module-imports": "^7.27.1",
         "@babel/preset-typescript": "^7.27.1",
-        "@mastra/server": "^0.14.1",
+        "@mastra/server": "^0.21.1",
         "@neon-rs/load": "^0.1.82",
         "@optimize-lodash/rollup-plugin": "^5.0.2",
-        "@rollup/plugin-alias": "^5.1.1",
-        "@rollup/plugin-commonjs": "^28.0.6",
-        "@rollup/plugin-esm-shim": "^0.1.8",
-        "@rollup/plugin-json": "^6.1.0",
-        "@rollup/plugin-node-resolve": "^16.0.1",
-        "@rollup/plugin-virtual": "^3.0.2",
+        "@rollup/plugin-alias": "5.1.1",
+        "@rollup/plugin-commonjs": "28.0.6",
+        "@rollup/plugin-esm-shim": "0.1.8",
+        "@rollup/plugin-json": "6.1.0",
+        "@rollup/plugin-node-resolve": "16.0.2",
+        "@rollup/plugin-virtual": "3.0.2",
         "@sindresorhus/slugify": "^2.2.1",
         "builtins": "^5.1.0",
         "detect-libc": "^2.0.4",
         "dotenv": "^16.6.1",
-        "esbuild": "^0.25.8",
+        "empathic": "^2.0.0",
+        "esbuild": "^0.25.10",
         "find-workspaces": "^0.3.1",
-        "fs-extra": "^11.3.0",
-        "globby": "^14.1.0",
-        "hono": "^4.8.12",
-        "package-directory": "^8.1.0",
+        "fs-extra": "^11.3.2",
+        "hono": "^4.9.7",
+        "local-pkg": "^1.1.2",
         "resolve-from": "^5.0.0",
-        "rollup": "~4.46.2",
+        "resolve.exports": "^2.0.3",
+        "rollup": "~4.50.2",
         "rollup-plugin-esbuild": "^6.2.1",
         "rollup-plugin-node-externals": "^8.0.1",
-        "typescript-paths": "^1.5.1",
-        "zod": "^3.25.67"
+        "tinyglobby": "^0.2.15",
+        "typescript-paths": "^1.5.1"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.14.0-0 <0.15.0-0"
+        "@mastra/core": ">=0.21.0-0 <0.22.0-0",
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/@mastra/deployer/node_modules/@neon-rs/load": {
@@ -5543,9 +5829,9 @@
       "license": "MIT"
     },
     "node_modules/@mastra/deployer/node_modules/fs-extra": {
-      "version": "11.3.1",
-      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-11.3.1.tgz",
-      "integrity": "sha512-eXvGGwZ5CL17ZSwHWd3bbgk7UUpF6IFHtP57NYYakPvHOs8GDgDe5KJI36jIJzDkJ6eJjuzRA8eBQb6SkKue0g==",
+      "version": "11.3.2",
+      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-11.3.2.tgz",
+      "integrity": "sha512-Xr9F6z6up6Ws+NjzMCZc6WXg2YFRlrLP9NQDO3VQrWrfiojdhS56TzueT88ze0uBdCTwEIhQ3ptnmKeWGFAe0A==",
       "license": "MIT",
       "dependencies": {
         "graceful-fs": "^4.2.0",
@@ -5556,116 +5842,64 @@
         "node": ">=14.14"
       }
     },
-    "node_modules/@mastra/deployer/node_modules/globby": {
-      "version": "14.1.0",
-      "resolved": "https://registry.npmjs.org/globby/-/globby-14.1.0.tgz",
-      "integrity": "sha512-0Ia46fDOaT7k4og1PDW4YbodWWr3scS2vAr2lTbsplOt2WkKp0vQbkI9wKis/T5LV/dqPjO3bpS/z6GTJB82LA==",
-      "license": "MIT",
-      "dependencies": {
-        "@sindresorhus/merge-streams": "^2.1.0",
-        "fast-glob": "^3.3.3",
-        "ignore": "^7.0.3",
-        "path-type": "^6.0.0",
-        "slash": "^5.1.0",
-        "unicorn-magic": "^0.3.0"
-      },
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/@mastra/deployer/node_modules/ignore": {
-      "version": "7.0.5",
-      "resolved": "https://registry.npmjs.org/ignore/-/ignore-7.0.5.tgz",
-      "integrity": "sha512-Hs59xBNfUIunMFgWAbGX5cq6893IbWg4KnrjbYwX3tx0ztorVgTDA6B2sxf8ejHJ4wz8BqGUMYlnzNBer5NvGg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 4"
-      }
-    },
-    "node_modules/@mastra/deployer/node_modules/path-type": {
-      "version": "6.0.0",
-      "resolved": "https://registry.npmjs.org/path-type/-/path-type-6.0.0.tgz",
-      "integrity": "sha512-Vj7sf++t5pBD637NSfkxpHSMfWaeig5+DKWLhcqIYx6mWQz5hdJTGDVMQiJcw1ZYkhs7AazKDGpRVji1LJCZUQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
     "node_modules/@mastra/deployer/node_modules/resolve-from": {
-      "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
-      "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/@mastra/deployer/node_modules/slash": {
-      "version": "5.1.0",
-      "resolved": "https://registry.npmjs.org/slash/-/slash-5.1.0.tgz",
-      "integrity": "sha512-ZA6oR3T/pEyuqwMgAKT0/hAv8oAXckzbkmR0UkUosQ+Mc4RxGoJkRmwHgHufaenlyAgE1Mxgpdcrf75y6XcnDg==",
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
+      "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
       "license": "MIT",
       "engines": {
-        "node": ">=14.16"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
+        "node": ">=8"
       }
     },
     "node_modules/@mastra/libsql": {
-      "version": "0.13.4",
-      "resolved": "https://registry.npmjs.org/@mastra/libsql/-/libsql-0.13.4.tgz",
-      "integrity": "sha512-NKALT6CY3bkHcTzWlhvIOL9bAonzZ3ZjrsRCL3yGD6pFzoYHd8W/6WKmBPn8ex9FamFyYctQgoI3MV4oObodSQ==",
-      "license": "MIT",
+      "version": "0.15.2",
+      "resolved": "https://registry.npmjs.org/@mastra/libsql/-/libsql-0.15.2.tgz",
+      "integrity": "sha512-WBOIXal7nj7qDxryIMBx4DnWGyiw3+iDoT/2cuoKIVFSGVrf5tE3but5u2Dv8gawjM3DGizVCmJhv5cpSheOHg==",
+      "license": "Apache-2.0",
       "dependencies": {
-        "@libsql/client": "^0.15.12"
+        "@libsql/client": "^0.15.15"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.13.0-0 <0.15.0-0"
+        "@mastra/core": ">=0.19.0-alpha.1 <0.22.0-0"
       }
     },
     "node_modules/@mastra/loggers": {
-      "version": "0.10.9",
-      "resolved": "https://registry.npmjs.org/@mastra/loggers/-/loggers-0.10.9.tgz",
-      "integrity": "sha512-uNX9bNO6wRSd8Gi8EDk8GnDjjwFc44y0ASYqQV5zZseYePaIKRm57UD4Gpaq+ic4Q3oSrJe+5K9K1fkUX/5JBA==",
+      "version": "0.10.16",
+      "resolved": "https://registry.npmjs.org/@mastra/loggers/-/loggers-0.10.16.tgz",
+      "integrity": "sha512-zZiaz/kfChdA9L8ks0F73pn/kh6gU8FkS8VMigKH5uc7Ez8gvWsaC9Orgg5k7Og4bkXrZ3j2fN5RewtjI8appA==",
       "license": "Apache-2.0",
       "dependencies": {
         "pino": "^9.7.0",
         "pino-pretty": "^13.0.0"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.10.4-0 <0.16.0-0"
+        "@mastra/core": ">=0.18.1-0 <0.22.0-0"
       }
     },
     "node_modules/@mastra/mcp": {
-      "version": "0.10.12",
-      "resolved": "https://registry.npmjs.org/@mastra/mcp/-/mcp-0.10.12.tgz",
-      "integrity": "sha512-/nrRMXFtqOqUqlX9EXJlqsr+rcqUznXJ3LyKvrz5BumwvOKncPVXxT7AdKt3LaGJnlK/4NwM20YIfxF5Qx32ow==",
+      "version": "0.13.5",
+      "resolved": "https://registry.npmjs.org/@mastra/mcp/-/mcp-0.13.5.tgz",
+      "integrity": "sha512-GFHOHTbUY8PuEwzObIVCaHF855M4S4xIOnNJE1WJeEsPvWOllyL+y1Wz3HGjusrAfZIDrZ8j8Z5Diqxf3KTW/A==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@apidevtools/json-schema-ref-parser": "^14.1.1",
-        "@modelcontextprotocol/sdk": "^1.17.0",
+        "@apidevtools/json-schema-ref-parser": "^14.2.1",
+        "@modelcontextprotocol/sdk": "^1.17.5",
         "date-fns": "^4.1.0",
         "exit-hook": "^4.0.0",
         "fast-deep-equal": "^3.1.3",
         "uuid": "^11.1.0",
-        "zod-from-json-schema": "^0.0.5"
+        "zod-from-json-schema": "^0.5.0",
+        "zod-from-json-schema-v3": "npm:zod-from-json-schema@^0.0.5"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.10.2-0 <0.15.0-0",
-        "zod": "^3.0.0"
+        "@mastra/core": ">=0.20.1-0 <0.22.0-0",
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/@mastra/mcp/node_modules/@apidevtools/json-schema-ref-parser": {
-      "version": "14.2.0",
-      "resolved": "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-14.2.0.tgz",
-      "integrity": "sha512-NaGMMWwppbByagq+LwQMq6PMXHFWVu6kSwwx+eJfYTJ5zdpOvb9TIk6ZWxEEeXMUvGdVOZq3JalYsjsTZDvtkA==",
+      "version": "14.2.1",
+      "resolved": "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-14.2.1.tgz",
+      "integrity": "sha512-HmdFw9CDYqM6B25pqGBpNeLCKvGPlIx1EbLrVL0zPvj50CJQUHyBNBw45Muk0kEIkogo1VZvOKHajdMuAzSxRg==",
       "license": "MIT",
       "dependencies": {
         "js-yaml": "^4.1.0"
@@ -5691,53 +5925,54 @@
       }
     },
     "node_modules/@mastra/memory": {
-      "version": "0.13.1",
-      "resolved": "https://registry.npmjs.org/@mastra/memory/-/memory-0.13.1.tgz",
-      "integrity": "sha512-nYkr2+es8Xw0W35HAekPFyvOjclX886ZC91Sc7R4V3nFBQsIjTfA7149QERXciPTWI7HgdKS+v+95sN5pBNp1w==",
+      "version": "0.15.7",
+      "resolved": "https://registry.npmjs.org/@mastra/memory/-/memory-0.15.7.tgz",
+      "integrity": "sha512-7UzIQBM0RePgAfKK7IuhE6UEy6TWy3CTrKSEpybGfI3JtuifCpSbu4VfvWK0iW3B3KLd/6Lq+mWlm13P6k8ZrQ==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@mastra/schema-compat": "0.10.7",
-        "@upstash/redis": "^1.35.3",
+        "@mastra/schema-compat": "0.11.4",
+        "@upstash/redis": "^1.35.5",
         "ai": "^4.3.19",
-        "ai-v5": "npm:ai@5.0.15",
+        "ai-v5": "npm:ai@5.0.60",
         "async-mutex": "^0.5.0",
         "js-tiktoken": "^1.0.20",
         "json-schema": "^0.4.0",
         "pg": "^8.16.3",
         "pg-pool": "^3.10.1",
         "postgres": "^3.4.7",
-        "redis": "^5.8.2",
+        "redis": "^5.8.3",
         "xxhash-wasm": "^1.1.0",
-        "zod": "^3.25.67",
-        "zod-to-json-schema": "^3.24.5"
+        "zod-to-json-schema": "^3.24.6"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.14.0-0 <0.15.0-0"
+        "@mastra/core": ">=0.20.1-0 <0.22.0-0",
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/@mastra/schema-compat": {
-      "version": "0.10.7",
-      "resolved": "https://registry.npmjs.org/@mastra/schema-compat/-/schema-compat-0.10.7.tgz",
-      "integrity": "sha512-lY1V57fHfCRVafNuwmDEmQJNncVZI+wdOdvL/WbgYWLQmL3YjBl3CrM+7yTOM/gG/GPKm8BRxmqnHLhS1rD1zg==",
+      "version": "0.11.4",
+      "resolved": "https://registry.npmjs.org/@mastra/schema-compat/-/schema-compat-0.11.4.tgz",
+      "integrity": "sha512-oh3+enP3oYftZlmJAKQQj5VXR86KgTMwfMnwALZyLk04dPSWfVD2wGytoDg5Qbi3rX9qHj6g0rMNa0CUjR6aTg==",
       "license": "Apache-2.0",
       "dependencies": {
         "json-schema": "^0.4.0",
-        "zod-from-json-schema": "^0.0.5",
-        "zod-to-json-schema": "^3.24.5"
+        "zod-from-json-schema": "^0.5.0",
+        "zod-from-json-schema-v3": "npm:zod-from-json-schema@^0.0.5",
+        "zod-to-json-schema": "^3.24.6"
       },
       "peerDependencies": {
-        "ai": "^4.0.0",
-        "zod": "^3.0.0"
+        "ai": "^4.0.0 || ^5.0.0",
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/@mastra/server": {
-      "version": "0.14.1",
-      "resolved": "https://registry.npmjs.org/@mastra/server/-/server-0.14.1.tgz",
-      "integrity": "sha512-VdptgxpjmqpgzJkyIAxv8f1XQDTWhMi9Gd60i4PwuqSjjMRtvZF6TuZj9jS/gS9Zt+26DbHS9uzIWwLuQyIrsg==",
+      "version": "0.21.1",
+      "resolved": "https://registry.npmjs.org/@mastra/server/-/server-0.21.1.tgz",
+      "integrity": "sha512-qf14MT+lGiPAgv7oqOC2+bcOa5jED1Ucmlm66y7TZKywUr1n8qDNePoGj+RTU1Nz/oLI0NloNYu3kCUO2GW/sA==",
       "license": "Apache-2.0",
       "peerDependencies": {
-        "@mastra/core": ">=0.14.0-0 <0.15.0-0",
-        "zod": "^3.0.0"
+        "@mastra/core": ">=0.21.0-0 <0.22.0-0",
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/@mdn/browser-compat-data": {
@@ -5757,9 +5992,9 @@
       }
     },
     "node_modules/@modelcontextprotocol/sdk": {
-      "version": "1.17.4",
-      "resolved": "https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-1.17.4.tgz",
-      "integrity": "sha512-zq24hfuAmmlNZvik0FLI58uE5sriN0WWsQzIlYnzSuKDAHFqJtBFrl/LfB1NLgJT5Y7dEBzaX4yAKqOPrcetaw==",
+      "version": "1.20.1",
+      "resolved": "https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-1.20.1.tgz",
+      "integrity": "sha512-j/P+yuxXfgxb+mW7OEoRCM3G47zCTDqUPivJo/VzpjbG8I9csTXtOprCf5FfOfHK4whOJny0aHuBEON+kS7CCA==",
       "license": "MIT",
       "dependencies": {
         "ajv": "^6.12.6",
@@ -5986,18 +6221,34 @@
       }
     },
     "node_modules/@modelcontextprotocol/sdk/node_modules/raw-body": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
-      "integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.1.tgz",
+      "integrity": "sha512-9G8cA+tuMS75+6G/TzW8OtLzmBDMo8p1JRxN5AZ+LAp8uxGA8V8GZm4GQ4/N5QNQEnLmg6SS7wyuSmbKepiKqA==",
       "license": "MIT",
       "dependencies": {
         "bytes": "3.1.2",
         "http-errors": "2.0.0",
-        "iconv-lite": "0.6.3",
+        "iconv-lite": "0.7.0",
         "unpipe": "1.0.0"
       },
       "engines": {
-        "node": ">= 0.8"
+        "node": ">= 0.10"
+      }
+    },
+    "node_modules/@modelcontextprotocol/sdk/node_modules/raw-body/node_modules/iconv-lite": {
+      "version": "0.7.0",
+      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.0.tgz",
+      "integrity": "sha512-cf6L2Ds3h57VVmkZe+Pn+5APsT7FpqJtEhhieDCvrE2MK5Qk9MyffgQyuxQTm6BChfeZNtcOLHp9IcWRVcIcBQ==",
+      "license": "MIT",
+      "dependencies": {
+        "safer-buffer": ">= 2.1.2 < 3.0.0"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/express"
       }
     },
     "node_modules/@modelcontextprotocol/sdk/node_modules/send": {
@@ -6565,6 +6816,20 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/@openrouter/ai-sdk-provider-v5": {
+      "name": "@openrouter/ai-sdk-provider",
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/@openrouter/ai-sdk-provider/-/ai-sdk-provider-1.2.0.tgz",
+      "integrity": "sha512-stuIwq7Yb7DNmk3GuCtz+oS3nZOY4TXEV3V5KsknDGQN7Fpu3KRMQVWRc1J073xKdf0FC9EHOctSyzsACmp5Ag==",
+      "license": "Apache-2.0",
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "ai": "^5.0.0",
+        "zod": "^3.24.1 || ^v4"
+      }
+    },
     "node_modules/@opentelemetry/api": {
       "version": "1.9.0",
       "resolved": "https://registry.npmjs.org/@opentelemetry/api/-/api-1.9.0.tgz",
@@ -8017,7 +8282,6 @@
       "version": "0.11.0",
       "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
       "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
-      "dev": true,
       "license": "MIT",
       "optional": true,
       "engines": {
@@ -8831,21 +9095,21 @@
       "license": "MIT"
     },
     "node_modules/@redis/bloom": {
-      "version": "5.8.2",
-      "resolved": "https://registry.npmjs.org/@redis/bloom/-/bloom-5.8.2.tgz",
-      "integrity": "sha512-855DR0ChetZLarblio5eM0yLwxA9Dqq50t8StXKp5bAtLT0G+rZ+eRzzqxl37sPqQKjUudSYypz55o6nNhbz0A==",
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/@redis/bloom/-/bloom-5.8.3.tgz",
+      "integrity": "sha512-1eldTzHvdW3Oi0TReb8m1yiFt8ZwyF6rv1NpZyG5R4TpCwuAdKQetBKoCw7D96tNFgsVVd6eL+NaGZZCqhRg4g==",
       "license": "MIT",
       "engines": {
         "node": ">= 18"
       },
       "peerDependencies": {
-        "@redis/client": "^5.8.2"
+        "@redis/client": "^5.8.3"
       }
     },
     "node_modules/@redis/client": {
-      "version": "5.8.2",
-      "resolved": "https://registry.npmjs.org/@redis/client/-/client-5.8.2.tgz",
-      "integrity": "sha512-WtMScno3+eBpTac1Uav2zugXEoXqaU23YznwvFgkPwBQVwEHTDgOG7uEAObtZ/Nyn8SmAMbqkEubJaMOvnqdsQ==",
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/@redis/client/-/client-5.8.3.tgz",
+      "integrity": "sha512-MZVUE+l7LmMIYlIjubPosruJ9ltSLGFmJqsXApTqPLyHLjsJUSAbAJb/A3N34fEqean4ddiDkdWzNu4ZKPvRUg==",
       "license": "MIT",
       "dependencies": {
         "cluster-key-slot": "1.1.2"
@@ -8855,39 +9119,39 @@
       }
     },
     "node_modules/@redis/json": {
-      "version": "5.8.2",
-      "resolved": "https://registry.npmjs.org/@redis/json/-/json-5.8.2.tgz",
-      "integrity": "sha512-uxpVfas3I0LccBX9rIfDgJ0dBrUa3+0Gc8sEwmQQH0vHi7C1Rx1Qn8Nv1QWz5bohoeIXMICFZRcyDONvum2l/w==",
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/@redis/json/-/json-5.8.3.tgz",
+      "integrity": "sha512-DRR09fy/u8gynHGJ4gzXYeM7D8nlS6EMv5o+h20ndTJiAc7RGR01fdk2FNjnn1Nz5PjgGGownF+s72bYG4nZKQ==",
       "license": "MIT",
       "engines": {
         "node": ">= 18"
       },
       "peerDependencies": {
-        "@redis/client": "^5.8.2"
+        "@redis/client": "^5.8.3"
       }
     },
     "node_modules/@redis/search": {
-      "version": "5.8.2",
-      "resolved": "https://registry.npmjs.org/@redis/search/-/search-5.8.2.tgz",
-      "integrity": "sha512-cNv7HlgayavCBXqPXgaS97DRPVWFznuzsAmmuemi2TMCx5scwLiP50TeZvUS06h/MG96YNPe6A0Zt57yayfxwA==",
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/@redis/search/-/search-5.8.3.tgz",
+      "integrity": "sha512-EMIvEeGRR2I0BJEz4PV88DyCuPmMT1rDtznlsHY3cKSDcc9vj0Q411jUnX0iU2vVowUgWn/cpySKjpXdZ8m+5g==",
       "license": "MIT",
       "engines": {
         "node": ">= 18"
       },
       "peerDependencies": {
-        "@redis/client": "^5.8.2"
+        "@redis/client": "^5.8.3"
       }
     },
     "node_modules/@redis/time-series": {
-      "version": "5.8.2",
-      "resolved": "https://registry.npmjs.org/@redis/time-series/-/time-series-5.8.2.tgz",
-      "integrity": "sha512-g2NlHM07fK8H4k+613NBsk3y70R2JIM2dPMSkhIjl2Z17SYvaYKdusz85d7VYOrZBWtDrHV/WD2E3vGu+zni8A==",
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/@redis/time-series/-/time-series-5.8.3.tgz",
+      "integrity": "sha512-5Jwy3ilsUYQjzpE7WZ1lEeG1RkqQ5kHtwV1p8yxXHSEmyUbC/T/AVgyjMcm52Olj/Ov/mhDKjx6ndYUi14bXsw==",
       "license": "MIT",
       "engines": {
         "node": ">= 18"
       },
       "peerDependencies": {
-        "@redis/client": "^5.8.2"
+        "@redis/client": "^5.8.3"
       }
     },
     "node_modules/@rollup/plugin-alias": {
@@ -9004,9 +9268,9 @@
       }
     },
     "node_modules/@rollup/plugin-node-resolve": {
-      "version": "16.0.1",
-      "resolved": "https://registry.npmjs.org/@rollup/plugin-node-resolve/-/plugin-node-resolve-16.0.1.tgz",
-      "integrity": "sha512-tk5YCxJWIG81umIvNkSod2qK5KyQW19qcBF/B78n1bjtOON6gzKoVeSzAE8yHCZEDmqkHKkxplExA8KzdJLJpA==",
+      "version": "16.0.2",
+      "resolved": "https://registry.npmjs.org/@rollup/plugin-node-resolve/-/plugin-node-resolve-16.0.2.tgz",
+      "integrity": "sha512-tCtHJ2BlhSoK4cCs25NMXfV7EALKr0jyasmqVCq3y9cBrKdmJhtsy1iTz36Xhk/O+pDJbzawxF4K6ZblqCnITQ==",
       "license": "MIT",
       "dependencies": {
         "@rollup/pluginutils": "^5.0.1",
@@ -9045,9 +9309,9 @@
       }
     },
     "node_modules/@rollup/pluginutils": {
-      "version": "5.2.0",
-      "resolved": "https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-5.2.0.tgz",
-      "integrity": "sha512-qWJ2ZTbmumwiLFomfzTyt5Kng4hwPi9rwCYN4SHb6eaRU1KNO4ccxINHr/VhH4GgPlt1XfSTLX2LBTme8ne4Zw==",
+      "version": "5.3.0",
+      "resolved": "https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-5.3.0.tgz",
+      "integrity": "sha512-5EdhGZtnu3V88ces7s53hhfK5KSASnJZv8Lulpc04cWO3REESroJXg73DFsOmgbU2BhwV0E20bu2IDZb3VKW4Q==",
       "license": "MIT",
       "dependencies": {
         "@types/estree": "^1.0.0",
@@ -9079,9 +9343,9 @@
       }
     },
     "node_modules/@rollup/rollup-android-arm-eabi": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.46.4.tgz",
-      "integrity": "sha512-B2wfzCJ+ps/OBzRjeds7DlJumCU3rXMxJJS1vzURyj7+KBHGONm7c9q1TfdBl4vCuNMkDvARn3PBl2wZzuR5mw==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.50.2.tgz",
+      "integrity": "sha512-uLN8NAiFVIRKX9ZQha8wy6UUs06UNSZ32xj6giK/rmMXAgKahwExvK6SsmgU5/brh4w/nSgj8e0k3c1HBQpa0A==",
       "cpu": [
         "arm"
       ],
@@ -9092,9 +9356,9 @@
       ]
     },
     "node_modules/@rollup/rollup-android-arm64": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.46.4.tgz",
-      "integrity": "sha512-FGJYXvYdn8Bs6lAlBZYT5n+4x0ciEp4cmttsvKAZc/c8/JiPaQK8u0c/86vKX8lA7OY/+37lIQSe0YoAImvBAA==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.50.2.tgz",
+      "integrity": "sha512-oEouqQk2/zxxj22PNcGSskya+3kV0ZKH+nQxuCCOGJ4oTXBdNTbv+f/E3c74cNLeMO1S5wVWacSws10TTSB77g==",
       "cpu": [
         "arm64"
       ],
@@ -9105,9 +9369,9 @@
       ]
     },
     "node_modules/@rollup/rollup-darwin-arm64": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.46.4.tgz",
-      "integrity": "sha512-/9qwE/BM7ATw/W/OFEMTm3dmywbJyLQb4f4v5nmOjgYxPIGpw7HaxRi6LnD4Pjn/q7k55FGeHe1/OD02w63apA==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.50.2.tgz",
+      "integrity": "sha512-OZuTVTpj3CDSIxmPgGH8en/XtirV5nfljHZ3wrNwvgkT5DQLhIKAeuFSiwtbMto6oVexV0k1F1zqURPKf5rI1Q==",
       "cpu": [
         "arm64"
       ],
@@ -9118,9 +9382,9 @@
       ]
     },
     "node_modules/@rollup/rollup-darwin-x64": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.46.4.tgz",
-      "integrity": "sha512-QkWfNbeRuzFnv2d0aPlrzcA3Ebq2mE8kX/5Pl7VdRShbPBjSnom7dbT8E3Jmhxo2RL784hyqGvR5KHavCJQciw==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.50.2.tgz",
+      "integrity": "sha512-Wa/Wn8RFkIkr1vy1k1PB//VYhLnlnn5eaJkfTQKivirOvzu5uVd2It01ukeQstMursuz7S1bU+8WW+1UPXpa8A==",
       "cpu": [
         "x64"
       ],
@@ -9131,9 +9395,9 @@
       ]
     },
     "node_modules/@rollup/rollup-freebsd-arm64": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.46.4.tgz",
-      "integrity": "sha512-+ToyOMYnSfV8D+ckxO6NthPln/PDNp1P6INcNypfZ7muLmEvPKXqduUiD8DlJpMMT8LxHcE5W0dK9kXfJke9Zw==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.50.2.tgz",
+      "integrity": "sha512-QkzxvH3kYN9J1w7D1A+yIMdI1pPekD+pWx7G5rXgnIlQ1TVYVC6hLl7SOV9pi5q9uIDF9AuIGkuzcbF7+fAhow==",
       "cpu": [
         "arm64"
       ],
@@ -9144,9 +9408,9 @@
       ]
     },
     "node_modules/@rollup/rollup-freebsd-x64": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.46.4.tgz",
-      "integrity": "sha512-cGT6ey/W+sje6zywbLiqmkfkO210FgRz7tepWAzzEVgQU8Hn91JJmQWNqs55IuglG8sJdzk7XfNgmGRtcYlo1w==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.50.2.tgz",
+      "integrity": "sha512-dkYXB0c2XAS3a3jmyDkX4Jk0m7gWLFzq1C3qUnJJ38AyxIF5G/dyS4N9B30nvFseCfgtCEdbYFhk0ChoCGxPog==",
       "cpu": [
         "x64"
       ],
@@ -9157,9 +9421,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.46.4.tgz",
-      "integrity": "sha512-9fhTJyOb275w5RofPSl8lpr4jFowd+H4oQKJ9XTYzD1JWgxdZKE8bA6d4npuiMemkecQOcigX01FNZNCYnQBdA==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.50.2.tgz",
+      "integrity": "sha512-9VlPY/BN3AgbukfVHAB8zNFWB/lKEuvzRo1NKev0Po8sYFKx0i+AQlCYftgEjcL43F2h9Ui1ZSdVBc4En/sP2w==",
       "cpu": [
         "arm"
       ],
@@ -9170,9 +9434,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-arm-musleabihf": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.46.4.tgz",
-      "integrity": "sha512-+6kCIM5Zjvz2HwPl/udgVs07tPMIp1VU2Y0c72ezjOvSvEfAIWsUgpcSDvnC7g9NrjYR6X9bZT92mZZ90TfvXw==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.50.2.tgz",
+      "integrity": "sha512-+GdKWOvsifaYNlIVf07QYan1J5F141+vGm5/Y8b9uCZnG/nxoGqgCmR24mv0koIWWuqvFYnbURRqw1lv7IBINw==",
       "cpu": [
         "arm"
       ],
@@ -9183,9 +9447,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-arm64-gnu": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.46.4.tgz",
-      "integrity": "sha512-SWuXdnsayCZL4lXoo6jn0yyAj7TTjWE4NwDVt9s7cmu6poMhtiras5c8h6Ih6Y0Zk6Z+8t/mLumvpdSPTWub2Q==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.50.2.tgz",
+      "integrity": "sha512-df0Eou14ojtUdLQdPFnymEQteENwSJAdLf5KCDrmZNsy1c3YaCNaJvYsEUHnrg+/DLBH612/R0xd3dD03uz2dg==",
       "cpu": [
         "arm64"
       ],
@@ -9196,9 +9460,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-arm64-musl": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.46.4.tgz",
-      "integrity": "sha512-vDknMDqtMhrrroa5kyX6tuC0aRZZlQ+ipDfbXd2YGz5HeV2t8HOl/FDAd2ynhs7Ki5VooWiiZcCtxiZ4IjqZwQ==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.50.2.tgz",
+      "integrity": "sha512-iPeouV0UIDtz8j1YFR4OJ/zf7evjauqv7jQ/EFs0ClIyL+by++hiaDAfFipjOgyz6y6xbDvJuiU4HwpVMpRFDQ==",
       "cpu": [
         "arm64"
       ],
@@ -9208,10 +9472,10 @@
         "linux"
       ]
     },
-    "node_modules/@rollup/rollup-linux-loongarch64-gnu": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.46.4.tgz",
-      "integrity": "sha512-mCBkjRZWhvjtl/x+Bd4fQkWZT8canStKDxGrHlBiTnZmJnWygGcvBylzLVCZXka4dco5ymkWhZlLwKCGFF4ivw==",
+    "node_modules/@rollup/rollup-linux-loong64-gnu": {
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.50.2.tgz",
+      "integrity": "sha512-OL6KaNvBopLlj5fTa5D5bau4W82f+1TyTZRr2BdnfsrnQnmdxh4okMxR2DcDkJuh4KeoQZVuvHvzuD/lyLn2Kw==",
       "cpu": [
         "loong64"
       ],
@@ -9222,9 +9486,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-ppc64-gnu": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.46.4.tgz",
-      "integrity": "sha512-YMdz2phOTFF+Z66dQfGf0gmeDSi5DJzY5bpZyeg9CPBkV9QDzJ1yFRlmi/j7WWRf3hYIWrOaJj5jsfwgc8GTHQ==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.50.2.tgz",
+      "integrity": "sha512-I21VJl1w6z/K5OTRl6aS9DDsqezEZ/yKpbqlvfHbW0CEF5IL8ATBMuUx6/mp683rKTK8thjs/0BaNrZLXetLag==",
       "cpu": [
         "ppc64"
       ],
@@ -9235,9 +9499,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-riscv64-gnu": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.46.4.tgz",
-      "integrity": "sha512-r0WKLSfFAK8ucG024v2yiLSJMedoWvk8yWqfNICX28NHDGeu3F/wBf8KG6mclghx4FsLePxJr/9N8rIj1PtCnw==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.50.2.tgz",
+      "integrity": "sha512-Hq6aQJT/qFFHrYMjS20nV+9SKrXL2lvFBENZoKfoTH2kKDOJqff5OSJr4x72ZaG/uUn+XmBnGhfr4lwMRrmqCQ==",
       "cpu": [
         "riscv64"
       ],
@@ -9248,9 +9512,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-riscv64-musl": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.46.4.tgz",
-      "integrity": "sha512-IaizpPP2UQU3MNyPH1u0Xxbm73D+4OupL0bjo4Hm0496e2wg3zuvoAIhubkD1NGy9fXILEExPQy87mweujEatA==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.50.2.tgz",
+      "integrity": "sha512-82rBSEXRv5qtKyr0xZ/YMF531oj2AIpLZkeNYxmKNN6I2sVE9PGegN99tYDLK2fYHJITL1P2Lgb4ZXnv0PjQvw==",
       "cpu": [
         "riscv64"
       ],
@@ -9261,9 +9525,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-s390x-gnu": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.46.4.tgz",
-      "integrity": "sha512-aCM29orANR0a8wk896p6UEgIfupReupnmISz6SUwMIwTGaTI8MuKdE0OD2LvEg8ondDyZdMvnaN3bW4nFbATPA==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.50.2.tgz",
+      "integrity": "sha512-4Q3S3Hy7pC6uaRo9gtXUTJ+EKo9AKs3BXKc2jYypEcMQ49gDPFU2P1ariX9SEtBzE5egIX6fSUmbmGazwBVF9w==",
       "cpu": [
         "s390x"
       ],
@@ -9274,9 +9538,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-x64-gnu": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.46.4.tgz",
-      "integrity": "sha512-0Xj1vZE3cbr/wda8d/m+UeuSL+TDpuozzdD4QaSzu/xSOMK0Su5RhIkF7KVHFQsobemUNHPLEcYllL7ZTCP/Cg==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.50.2.tgz",
+      "integrity": "sha512-9Jie/At6qk70dNIcopcL4p+1UirusEtznpNtcq/u/C5cC4HBX7qSGsYIcG6bdxj15EYWhHiu02YvmdPzylIZlA==",
       "cpu": [
         "x64"
       ],
@@ -9287,9 +9551,9 @@
       ]
     },
     "node_modules/@rollup/rollup-linux-x64-musl": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.46.4.tgz",
-      "integrity": "sha512-kM/orjpolfA5yxsx84kI6bnK47AAZuWxglGKcNmokw2yy9i5eHY5UAjcX45jemTJnfHAWo3/hOoRqEeeTdL5hw==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.50.2.tgz",
+      "integrity": "sha512-HPNJwxPL3EmhzeAnsWQCM3DcoqOz3/IC6de9rWfGR8ZCuEHETi9km66bH/wG3YH0V3nyzyFEGUZeL5PKyy4xvw==",
       "cpu": [
         "x64"
       ],
@@ -9299,10 +9563,23 @@
         "linux"
       ]
     },
+    "node_modules/@rollup/rollup-openharmony-arm64": {
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.50.2.tgz",
+      "integrity": "sha512-nMKvq6FRHSzYfKLHZ+cChowlEkR2lj/V0jYj9JnGUVPL2/mIeFGmVM2mLaFeNa5Jev7W7TovXqXIG2d39y1KYA==",
+      "cpu": [
+        "arm64"
+      ],
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "openharmony"
+      ]
+    },
     "node_modules/@rollup/rollup-win32-arm64-msvc": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.46.4.tgz",
-      "integrity": "sha512-cNLH4psMEsWKILW0isbpQA2OvjXLbKvnkcJFmqAptPQbtLrobiapBJVj6RoIvg6UXVp5w0wnIfd/Q56cNpF+Ew==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.50.2.tgz",
+      "integrity": "sha512-eFUvvnTYEKeTyHEijQKz81bLrUQOXKZqECeiWH6tb8eXXbZk+CXSG2aFrig2BQ/pjiVRj36zysjgILkqarS2YA==",
       "cpu": [
         "arm64"
       ],
@@ -9313,9 +9590,9 @@
       ]
     },
     "node_modules/@rollup/rollup-win32-ia32-msvc": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.46.4.tgz",
-      "integrity": "sha512-OiEa5lRhiANpv4SfwYVgQ3opYWi/QmPDC5ve21m8G9pf6ZO+aX1g2EEF1/IFaM1xPSP7mK0msTRXlPs6mIagkg==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.50.2.tgz",
+      "integrity": "sha512-cBaWmXqyfRhH8zmUxK3d3sAhEWLrtMjWBRwdMMHJIXSjvjLKvv49adxiEz+FJ8AP90apSDDBx2Tyd/WylV6ikA==",
       "cpu": [
         "ia32"
       ],
@@ -9326,9 +9603,9 @@
       ]
     },
     "node_modules/@rollup/rollup-win32-x64-msvc": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.46.4.tgz",
-      "integrity": "sha512-IKL9mewGZ5UuuX4NQlwOmxPyqielvkAPUS2s1cl6yWjjQvyN3h5JTdVFGD5Jr5xMjRC8setOfGQDVgX8V+dkjg==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.50.2.tgz",
+      "integrity": "sha512-APwKy6YUhvZaEoHyM+9xqmTpviEI+9eL7LoCH+aLcvWYHJ663qG5zx7WzWZY+a9qkg5JtzcMyJ9z0WtQBMDmgA==",
       "cpu": [
         "x64"
       ],
@@ -9351,75 +9628,6 @@
       "integrity": "sha512-831qok9r2t8AlxLko40y2ebgSDhenenCatLVeW/uBtnHPyhHOvG0C7TvfgecV+wHzIm5KUICgzmVpWS+IMEAeg==",
       "license": "MIT"
     },
-    "node_modules/@shikijs/core": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/core/-/core-1.29.2.tgz",
-      "integrity": "sha512-vju0lY9r27jJfOY4Z7+Rt/nIOjzJpZ3y+nYpqtUZInVoXQ/TJZcfGnNOGnKjFdVZb8qexiCuSlZRKcGfhhTTZQ==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/engine-javascript": "1.29.2",
-        "@shikijs/engine-oniguruma": "1.29.2",
-        "@shikijs/types": "1.29.2",
-        "@shikijs/vscode-textmate": "^10.0.1",
-        "@types/hast": "^3.0.4",
-        "hast-util-to-html": "^9.0.4"
-      }
-    },
-    "node_modules/@shikijs/engine-javascript": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/engine-javascript/-/engine-javascript-1.29.2.tgz",
-      "integrity": "sha512-iNEZv4IrLYPv64Q6k7EPpOCE/nuvGiKl7zxdq0WFuRPF5PAE9PRo2JGq/d8crLusM59BRemJ4eOqrFrC4wiQ+A==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/types": "1.29.2",
-        "@shikijs/vscode-textmate": "^10.0.1",
-        "oniguruma-to-es": "^2.2.0"
-      }
-    },
-    "node_modules/@shikijs/engine-oniguruma": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/engine-oniguruma/-/engine-oniguruma-1.29.2.tgz",
-      "integrity": "sha512-7iiOx3SG8+g1MnlzZVDYiaeHe7Ez2Kf2HrJzdmGwkRisT7r4rak0e655AcM/tF9JG/kg5fMNYlLLKglbN7gBqA==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/types": "1.29.2",
-        "@shikijs/vscode-textmate": "^10.0.1"
-      }
-    },
-    "node_modules/@shikijs/langs": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/langs/-/langs-1.29.2.tgz",
-      "integrity": "sha512-FIBA7N3LZ+223U7cJDUYd5shmciFQlYkFXlkKVaHsCPgfVLiO+e12FmQE6Tf9vuyEsFe3dIl8qGWKXgEHL9wmQ==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/types": "1.29.2"
-      }
-    },
-    "node_modules/@shikijs/themes": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/themes/-/themes-1.29.2.tgz",
-      "integrity": "sha512-i9TNZlsq4uoyqSbluIcZkmPL9Bfi3djVxRnofUHwvx/h6SRW3cwgBC5SML7vsDcWyukY0eCzVN980rqP6qNl9g==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/types": "1.29.2"
-      }
-    },
-    "node_modules/@shikijs/types": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/types/-/types-1.29.2.tgz",
-      "integrity": "sha512-VJjK0eIijTZf0QSTODEXCqinjBn0joAHQ+aPSBzrv4O2d/QSbsMw+ZeSRx03kV34Hy7NzUvV/7NqfYGRLrASmw==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/vscode-textmate": "^10.0.1",
-        "@types/hast": "^3.0.4"
-      }
-    },
-    "node_modules/@shikijs/vscode-textmate": {
-      "version": "10.0.2",
-      "resolved": "https://registry.npmjs.org/@shikijs/vscode-textmate/-/vscode-textmate-10.0.2.tgz",
-      "integrity": "sha512-83yeghZ2xxin3Nj8z1NMd/NCuca+gsYXswywDy5bHvwlWL8tpTQmzGeUuHd9FC3E/SBEMvzJRwWEOz5gGes9Qg==",
-      "license": "MIT"
-    },
     "node_modules/@sinclair/typebox": {
       "version": "0.27.8",
       "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz",
@@ -9440,18 +9648,6 @@
         "url": "https://github.com/sindresorhus/is?sponsor=1"
       }
     },
-    "node_modules/@sindresorhus/merge-streams": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/@sindresorhus/merge-streams/-/merge-streams-2.3.0.tgz",
-      "integrity": "sha512-LtoMMhxAlorcGhmFYI+LhPgbPZCkgP6ra1YL604EeF6U98pLlQ3iWIGMdWSC+vWmPBWBNgmDBAhnAobLROJmwg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
     "node_modules/@sindresorhus/slugify": {
       "version": "2.2.1",
       "resolved": "https://registry.npmjs.org/@sindresorhus/slugify/-/slugify-2.2.1.tgz",
@@ -10069,9 +10265,9 @@
       }
     },
     "node_modules/@types/babel__generator": {
-      "version": "7.6.8",
-      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.6.8.tgz",
-      "integrity": "sha512-ASsj+tpEDsEiFr1arWrlN6V3mdfjRMZt6LtK/Vp/kreFLnr5QH5+DhvD5nINYZXzwJvXeGq+05iUXcAzVrqWtw==",
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
+      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
@@ -10090,13 +10286,13 @@
       }
     },
     "node_modules/@types/babel__traverse": {
-      "version": "7.20.6",
-      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.6.tgz",
-      "integrity": "sha512-r1bzfrm0tomOI8g1SzvCaQHo6Lcv6zu0EA+W2kHrt8dyrHQxGzBBL4kdkzIS+jBMV+EYcMAEAqXqYaLJq5rOZg==",
+      "version": "7.28.0",
+      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
+      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/types": "^7.20.7"
+        "@babel/types": "^7.28.2"
       }
     },
     "node_modules/@types/body-parser": {
@@ -11271,14 +11467,23 @@
       ]
     },
     "node_modules/@upstash/redis": {
-      "version": "1.35.3",
-      "resolved": "https://registry.npmjs.org/@upstash/redis/-/redis-1.35.3.tgz",
-      "integrity": "sha512-hSjv66NOuahW3MisRGlSgoszU2uONAY2l5Qo3Sae8OT3/Tng9K+2/cBRuyPBX8egwEGcNNCF9+r0V6grNnhL+w==",
+      "version": "1.35.6",
+      "resolved": "https://registry.npmjs.org/@upstash/redis/-/redis-1.35.6.tgz",
+      "integrity": "sha512-aSEIGJgJ7XUfTYvhQcQbq835re7e/BXjs8Janq6Pvr6LlmTZnyqwT97RziZLO/8AVUL037RLXqqiQC6kCt+5pA==",
       "license": "MIT",
       "dependencies": {
         "uncrypto": "^0.1.3"
       }
     },
+    "node_modules/@vercel/oidc": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/@vercel/oidc/-/oidc-3.0.3.tgz",
+      "integrity": "sha512-yNEQvPcVrK9sIe637+I0jD6leluPxzwJKx/Haw6F4H77CdDsszUn5V3o96LPziXkSNE2B83+Z3mjqGKBK/R6Gg==",
+      "license": "Apache-2.0",
+      "engines": {
+        "node": ">= 20"
+      }
+    },
     "node_modules/@webassemblyjs/ast": {
       "version": "1.14.1",
       "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.14.1.tgz",
@@ -11668,21 +11873,21 @@
     },
     "node_modules/ai-v5": {
       "name": "ai",
-      "version": "5.0.15",
-      "resolved": "https://registry.npmjs.org/ai/-/ai-5.0.15.tgz",
-      "integrity": "sha512-EX5hF+NVFm6R11mvdZRbg6eJEjyMlniI4/xOnyTh4VtDQ457lhIgi3kDGrHW3/qw9ELon9m2e7AK3g5z5sLwsQ==",
+      "version": "5.0.60",
+      "resolved": "https://registry.npmjs.org/ai/-/ai-5.0.60.tgz",
+      "integrity": "sha512-80U/3kmdBW6g+JkLXpz/P2EwkyEaWlPlYtuLUpx/JYK9F7WZh9NnkYoh1KvUi1Sbpo0NyurBTvX0a2AG9mmbDA==",
       "license": "Apache-2.0",
       "dependencies": {
-        "@ai-sdk/gateway": "1.0.7",
+        "@ai-sdk/gateway": "1.0.33",
         "@ai-sdk/provider": "2.0.0",
-        "@ai-sdk/provider-utils": "3.0.3",
+        "@ai-sdk/provider-utils": "3.0.10",
         "@opentelemetry/api": "1.9.0"
       },
       "engines": {
         "node": ">=18"
       },
       "peerDependencies": {
-        "zod": "^3.25.76 || ^4"
+        "zod": "^3.25.76 || ^4.1.8"
       }
     },
     "node_modules/ai-v5/node_modules/@ai-sdk/provider": {
@@ -11698,21 +11903,20 @@
       }
     },
     "node_modules/ai-v5/node_modules/@ai-sdk/provider-utils": {
-      "version": "3.0.3",
-      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.3.tgz",
-      "integrity": "sha512-kAxIw1nYmFW1g5TvE54ZB3eNtgZna0RnLjPUp1ltz1+t9xkXJIuDT4atrwfau9IbS0BOef38wqrI8CjFfQrxhw==",
+      "version": "3.0.10",
+      "resolved": "https://registry.npmjs.org/@ai-sdk/provider-utils/-/provider-utils-3.0.10.tgz",
+      "integrity": "sha512-T1gZ76gEIwffep6MWI0QNy9jgoybUHE7TRaHB5k54K8mF91ciGFlbtCGxDYhMH3nCRergKwYFIDeFF0hJSIQHQ==",
       "license": "Apache-2.0",
       "dependencies": {
         "@ai-sdk/provider": "2.0.0",
         "@standard-schema/spec": "^1.0.0",
-        "eventsource-parser": "^3.0.3",
-        "zod-to-json-schema": "^3.24.1"
+        "eventsource-parser": "^3.0.5"
       },
       "engines": {
         "node": ">=18"
       },
       "peerDependencies": {
-        "zod": "^3.25.76 || ^4"
+        "zod": "^3.25.76 || ^4.1.8"
       }
     },
     "node_modules/ajv": {
@@ -12474,73 +12678,301 @@
         "postcss": "^8.1.0"
       }
     },
-    "node_modules/available-typed-arrays": {
-      "version": "1.0.7",
-      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.7.tgz",
-      "integrity": "sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==",
+    "node_modules/available-typed-arrays": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.7.tgz",
+      "integrity": "sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "possible-typed-array-names": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/axe-core": {
+      "version": "4.10.0",
+      "resolved": "https://registry.npmjs.org/axe-core/-/axe-core-4.10.0.tgz",
+      "integrity": "sha512-Mr2ZakwQ7XUAjp7pAwQWRhhK8mQQ6JAaNWSjmjxil0R8BPioMtQsTLOolGYkji1rcL++3dCqZA3zWqpT+9Ew6g==",
+      "dev": true,
+      "license": "MPL-2.0",
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/axios": {
+      "version": "1.10.0",
+      "resolved": "https://registry.npmjs.org/axios/-/axios-1.10.0.tgz",
+      "integrity": "sha512-/1xYAC4MP/HEG+3duIhFr4ZQXR4sQXOIe+o6sdqzeykGLx6Upp/1p8MHqhINOvGeP7xyNHe7tsiJByc4SSVUxw==",
+      "license": "MIT",
+      "dependencies": {
+        "follow-redirects": "^1.15.6",
+        "form-data": "^4.0.0",
+        "proxy-from-env": "^1.1.0"
+      }
+    },
+    "node_modules/axobject-query": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/axobject-query/-/axobject-query-4.1.0.tgz",
+      "integrity": "sha512-qIj0G9wZbMGNLjLmg1PT6v2mE9AH2zlnADJD/2tC6E00hgmhUOfEB6greHPAfLRSufHqROIUTkw6E+M3lH0PTQ==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/babel-jest": {
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/babel-jest/-/babel-jest-30.2.0.tgz",
+      "integrity": "sha512-0YiBEOxWqKkSQWL9nNGGEgndoeL0ZpWrbLMNL5u/Kaxrli3Eaxlt3ZtIDktEvXt4L/R9r3ODr2zKwGM/2BjxVw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jest/transform": "30.2.0",
+        "@types/babel__core": "^7.20.5",
+        "babel-plugin-istanbul": "^7.0.1",
+        "babel-preset-jest": "30.2.0",
+        "chalk": "^4.1.2",
+        "graceful-fs": "^4.2.11",
+        "slash": "^3.0.0"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.11.0 || ^8.0.0-0"
+      }
+    },
+    "node_modules/babel-jest/node_modules/@jest/schemas": {
+      "version": "30.0.5",
+      "resolved": "https://registry.npmjs.org/@jest/schemas/-/schemas-30.0.5.tgz",
+      "integrity": "sha512-DmdYgtezMkh3cpU8/1uyXakv3tJRcmcXxBOcO0tbaozPwpmh4YMsnWrQm9ZmZMfa5ocbxzbFk6O4bDPEc/iAnA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@sinclair/typebox": "^0.34.0"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
+    "node_modules/babel-jest/node_modules/@jest/transform": {
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/@jest/transform/-/transform-30.2.0.tgz",
+      "integrity": "sha512-XsauDV82o5qXbhalKxD7p4TZYYdwcaEXC77PPD2HixEFF+6YGppjrAAQurTl2ECWcEomHBMMNS9AH3kcCFx8jA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/core": "^7.27.4",
+        "@jest/types": "30.2.0",
+        "@jridgewell/trace-mapping": "^0.3.25",
+        "babel-plugin-istanbul": "^7.0.1",
+        "chalk": "^4.1.2",
+        "convert-source-map": "^2.0.0",
+        "fast-json-stable-stringify": "^2.1.0",
+        "graceful-fs": "^4.2.11",
+        "jest-haste-map": "30.2.0",
+        "jest-regex-util": "30.0.1",
+        "jest-util": "30.2.0",
+        "micromatch": "^4.0.8",
+        "pirates": "^4.0.7",
+        "slash": "^3.0.0",
+        "write-file-atomic": "^5.0.1"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
+    "node_modules/babel-jest/node_modules/@jest/types": {
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/@jest/types/-/types-30.2.0.tgz",
+      "integrity": "sha512-H9xg1/sfVvyfU7o3zMfBEjQ1gcsdeTMgqHoYdN79tuLqfTtuu7WckRA1R5whDwOzxaZAeMKTYWqP+WCAi0CHsg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jest/pattern": "30.0.1",
+        "@jest/schemas": "30.0.5",
+        "@types/istanbul-lib-coverage": "^2.0.6",
+        "@types/istanbul-reports": "^3.0.4",
+        "@types/node": "*",
+        "@types/yargs": "^17.0.33",
+        "chalk": "^4.1.2"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
+    "node_modules/babel-jest/node_modules/@sinclair/typebox": {
+      "version": "0.34.41",
+      "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.34.41.tgz",
+      "integrity": "sha512-6gS8pZzSXdyRHTIqoqSVknxolr1kzfy4/CeDnrzsVz8TTIWUbOBr6gnzOmTYJ3eXQNh4IYHIGi5aIL7sOZ2G/g==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/babel-jest/node_modules/babel-plugin-istanbul": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-istanbul/-/babel-plugin-istanbul-7.0.1.tgz",
+      "integrity": "sha512-D8Z6Qm8jCvVXtIRkBnqNHX0zJ37rQcFJ9u8WOS6tkYOsRdHBzypCstaxWiu5ZIlqQtviRYbgnRLSoCEvjqcqbA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "workspaces": [
+        "test/babel-8"
+      ],
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.0.0",
+        "@istanbuljs/load-nyc-config": "^1.0.0",
+        "@istanbuljs/schema": "^0.1.3",
+        "istanbul-lib-instrument": "^6.0.2",
+        "test-exclude": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/babel-jest/node_modules/ci-info": {
+      "version": "4.3.1",
+      "resolved": "https://registry.npmjs.org/ci-info/-/ci-info-4.3.1.tgz",
+      "integrity": "sha512-Wdy2Igu8OcBpI2pZePZ5oWjPC38tmDVx5WKUXKwlLYkA0ozo85sLsLvkBbBn/sZaSCMFOGZJ14fvW9t5/d7kdA==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/sibiraj-s"
+        }
+      ],
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/babel-jest/node_modules/jest-haste-map": {
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/jest-haste-map/-/jest-haste-map-30.2.0.tgz",
+      "integrity": "sha512-sQA/jCb9kNt+neM0anSj6eZhLZUIhQgwDt7cPGjumgLM4rXsfb9kpnlacmvZz3Q5tb80nS+oG/if+NBKrHC+Xw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jest/types": "30.2.0",
+        "@types/node": "*",
+        "anymatch": "^3.1.3",
+        "fb-watchman": "^2.0.2",
+        "graceful-fs": "^4.2.11",
+        "jest-regex-util": "30.0.1",
+        "jest-util": "30.2.0",
+        "jest-worker": "30.2.0",
+        "micromatch": "^4.0.8",
+        "walker": "^1.0.8"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      },
+      "optionalDependencies": {
+        "fsevents": "^2.3.3"
+      }
+    },
+    "node_modules/babel-jest/node_modules/jest-regex-util": {
+      "version": "30.0.1",
+      "resolved": "https://registry.npmjs.org/jest-regex-util/-/jest-regex-util-30.0.1.tgz",
+      "integrity": "sha512-jHEQgBXAgc+Gh4g0p3bCevgRCVRkB4VB70zhoAE48gxeSr1hfUOsM/C2WoJgVL7Eyg//hudYENbm3Ne+/dRVVA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
+    "node_modules/babel-jest/node_modules/jest-util": {
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/jest-util/-/jest-util-30.2.0.tgz",
+      "integrity": "sha512-QKNsM0o3Xe6ISQU869e+DhG+4CK/48aHYdJZGlFQVTjnbvgpcKyxpzk29fGiO7i/J8VENZ+d2iGnSsvmuHywlA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jest/types": "30.2.0",
+        "@types/node": "*",
+        "chalk": "^4.1.2",
+        "ci-info": "^4.2.0",
+        "graceful-fs": "^4.2.11",
+        "picomatch": "^4.0.2"
+      },
+      "engines": {
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
+      }
+    },
+    "node_modules/babel-jest/node_modules/jest-worker": {
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-30.2.0.tgz",
+      "integrity": "sha512-0Q4Uk8WF7BUwqXHuAjc23vmopWJw5WH7w2tqBoUOZpOjW/ZnR44GXXd1r82RvnmI2GZge3ivrYXk/BE2+VtW2g==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "possible-typed-array-names": "^1.0.0"
+        "@types/node": "*",
+        "@ungap/structured-clone": "^1.3.0",
+        "jest-util": "30.2.0",
+        "merge-stream": "^2.0.0",
+        "supports-color": "^8.1.1"
       },
       "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
       }
     },
-    "node_modules/axe-core": {
-      "version": "4.10.0",
-      "resolved": "https://registry.npmjs.org/axe-core/-/axe-core-4.10.0.tgz",
-      "integrity": "sha512-Mr2ZakwQ7XUAjp7pAwQWRhhK8mQQ6JAaNWSjmjxil0R8BPioMtQsTLOolGYkji1rcL++3dCqZA3zWqpT+9Ew6g==",
+    "node_modules/babel-jest/node_modules/picomatch": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
+      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
       "dev": true,
-      "license": "MPL-2.0",
-      "engines": {
-        "node": ">=4"
-      }
-    },
-    "node_modules/axios": {
-      "version": "1.10.0",
-      "resolved": "https://registry.npmjs.org/axios/-/axios-1.10.0.tgz",
-      "integrity": "sha512-/1xYAC4MP/HEG+3duIhFr4ZQXR4sQXOIe+o6sdqzeykGLx6Upp/1p8MHqhINOvGeP7xyNHe7tsiJByc4SSVUxw==",
       "license": "MIT",
-      "dependencies": {
-        "follow-redirects": "^1.15.6",
-        "form-data": "^4.0.0",
-        "proxy-from-env": "^1.1.0"
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/jonschlinkert"
       }
     },
-    "node_modules/axobject-query": {
+    "node_modules/babel-jest/node_modules/signal-exit": {
       "version": "4.1.0",
-      "resolved": "https://registry.npmjs.org/axobject-query/-/axobject-query-4.1.0.tgz",
-      "integrity": "sha512-qIj0G9wZbMGNLjLmg1PT6v2mE9AH2zlnADJD/2tC6E00hgmhUOfEB6greHPAfLRSufHqROIUTkw6E+M3lH0PTQ==",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
+      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
       "dev": true,
-      "license": "Apache-2.0",
+      "license": "ISC",
       "engines": {
-        "node": ">= 0.4"
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
       }
     },
-    "node_modules/babel-jest": {
-      "version": "29.7.0",
-      "resolved": "https://registry.npmjs.org/babel-jest/-/babel-jest-29.7.0.tgz",
-      "integrity": "sha512-BrvGY3xZSwEcCzKvKsCi2GgHqDqsYkOP4/by5xCgIwGXQxIEh+8ew3gmrE1y7XRR6LHZIj6yLYnUi/mm2KXKBg==",
+    "node_modules/babel-jest/node_modules/supports-color": {
+      "version": "8.1.1",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
+      "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@jest/transform": "^29.7.0",
-        "@types/babel__core": "^7.1.14",
-        "babel-plugin-istanbul": "^6.1.1",
-        "babel-preset-jest": "^29.6.3",
-        "chalk": "^4.0.0",
-        "graceful-fs": "^4.2.9",
-        "slash": "^3.0.0"
+        "has-flag": "^4.0.0"
       },
       "engines": {
-        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
+        "node": ">=10"
       },
-      "peerDependencies": {
-        "@babel/core": "^7.8.0"
+      "funding": {
+        "url": "https://github.com/chalk/supports-color?sponsor=1"
+      }
+    },
+    "node_modules/babel-jest/node_modules/write-file-atomic": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-5.0.1.tgz",
+      "integrity": "sha512-+QU2zd6OTD8XWIJCbffaiQeH9U73qIqafo1x6V1snCWYGJf6cVE0cDR4D8xRzcEnfI21IFrUPzPGtcPf8AC+Rw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "imurmurhash": "^0.1.4",
+        "signal-exit": "^4.0.1"
+      },
+      "engines": {
+        "node": "^14.17.0 || ^16.13.0 || >=18.0.0"
       }
     },
     "node_modules/babel-plugin-istanbul": {
@@ -12588,19 +13020,16 @@
       }
     },
     "node_modules/babel-plugin-jest-hoist": {
-      "version": "29.6.3",
-      "resolved": "https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-29.6.3.tgz",
-      "integrity": "sha512-ESAc/RJvGTFEzRwOTT4+lNDk/GNHMkKbNzsvT0qKRfDyyYTskxB5rnU2njIDYVxXCBHHEI1c0YwHob3WaYujOg==",
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-30.2.0.tgz",
+      "integrity": "sha512-ftzhzSGMUnOzcCXd6WHdBGMyuwy15Wnn0iyyWGKgBDLxf9/s5ABuraCSpBX2uG0jUg4rqJnxsLc5+oYBqoxVaA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/template": "^7.3.3",
-        "@babel/types": "^7.3.3",
-        "@types/babel__core": "^7.1.14",
-        "@types/babel__traverse": "^7.0.6"
+        "@types/babel__core": "^7.20.5"
       },
       "engines": {
-        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
       }
     },
     "node_modules/babel-plugin-macros": {
@@ -12635,14 +13064,14 @@
       }
     },
     "node_modules/babel-plugin-polyfill-corejs2": {
-      "version": "0.4.11",
-      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs2/-/babel-plugin-polyfill-corejs2-0.4.11.tgz",
-      "integrity": "sha512-sMEJ27L0gRHShOh5G54uAAPaiCOygY/5ratXuiyb2G46FmlSpc9eFCzYVyDiPxfNbwzA7mYahmjQc5q+CZQ09Q==",
+      "version": "0.4.14",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs2/-/babel-plugin-polyfill-corejs2-0.4.14.tgz",
+      "integrity": "sha512-Co2Y9wX854ts6U8gAAPXfn0GmAyctHuK8n0Yhfjd6t30g7yvKjspvvOo9yG+z52PZRgFErt7Ka2pYnXCjLKEpg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/compat-data": "^7.22.6",
-        "@babel/helper-define-polyfill-provider": "^0.6.2",
+        "@babel/compat-data": "^7.27.7",
+        "@babel/helper-define-polyfill-provider": "^0.6.5",
         "semver": "^6.3.1"
       },
       "peerDependencies": {
@@ -12660,36 +13089,36 @@
       }
     },
     "node_modules/babel-plugin-polyfill-corejs3": {
-      "version": "0.10.6",
-      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs3/-/babel-plugin-polyfill-corejs3-0.10.6.tgz",
-      "integrity": "sha512-b37+KR2i/khY5sKmWNVQAnitvquQbNdWy6lJdsr0kmquCKEEUgMKK4SboVM3HtfnZilfjr4MMQ7vY58FVWDtIA==",
+      "version": "0.13.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs3/-/babel-plugin-polyfill-corejs3-0.13.0.tgz",
+      "integrity": "sha512-U+GNwMdSFgzVmfhNm8GJUX88AadB3uo9KpJqS3FaqNIPKgySuvMb+bHPsOmmuWyIcuqZj/pzt1RUIUZns4y2+A==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-define-polyfill-provider": "^0.6.2",
-        "core-js-compat": "^3.38.0"
+        "@babel/helper-define-polyfill-provider": "^0.6.5",
+        "core-js-compat": "^3.43.0"
       },
       "peerDependencies": {
         "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
       }
     },
     "node_modules/babel-plugin-polyfill-regenerator": {
-      "version": "0.6.2",
-      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-regenerator/-/babel-plugin-polyfill-regenerator-0.6.2.tgz",
-      "integrity": "sha512-2R25rQZWP63nGwaAswvDazbPXfrM3HwVoBXK6HcqeKrSrL/JqcC/rDcf95l4r7LXLyxDXc8uQDa064GubtCABg==",
+      "version": "0.6.5",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-regenerator/-/babel-plugin-polyfill-regenerator-0.6.5.tgz",
+      "integrity": "sha512-ISqQ2frbiNU9vIJkzg7dlPpznPZ4jOiUQ1uSmB0fEHeowtN3COYRsXr/xexn64NpU13P06jc/L5TgiJXOgrbEg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/helper-define-polyfill-provider": "^0.6.2"
+        "@babel/helper-define-polyfill-provider": "^0.6.5"
       },
       "peerDependencies": {
         "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
       }
     },
     "node_modules/babel-preset-current-node-syntax": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/babel-preset-current-node-syntax/-/babel-preset-current-node-syntax-1.1.0.tgz",
-      "integrity": "sha512-ldYss8SbBlWva1bs28q78Ju5Zq1F+8BrqBZZ0VFhLBvhh6lCpC2o3gDJi/5DRLs9FgYZCnmPYIVFU4lRXCkyUw==",
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/babel-preset-current-node-syntax/-/babel-preset-current-node-syntax-1.2.0.tgz",
+      "integrity": "sha512-E/VlAEzRrsLEb2+dv8yp3bo4scof3l9nR4lrld+Iy5NyVqgVYUJnDAmunkhPMisRI32Qc4iRiz425d8vM++2fg==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
@@ -12710,24 +13139,24 @@
         "@babel/plugin-syntax-top-level-await": "^7.14.5"
       },
       "peerDependencies": {
-        "@babel/core": "^7.0.0"
+        "@babel/core": "^7.0.0 || ^8.0.0-0"
       }
     },
     "node_modules/babel-preset-jest": {
-      "version": "29.6.3",
-      "resolved": "https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-29.6.3.tgz",
-      "integrity": "sha512-0B3bhxR6snWXJZtR/RliHTDPRgn1sNHOR0yVtq/IiQFyuOVjFS+wuio/R4gSNkyYmKmJB4wGZv2NZanmKmTnNA==",
+      "version": "30.2.0",
+      "resolved": "https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-30.2.0.tgz",
+      "integrity": "sha512-US4Z3NOieAQumwFnYdUWKvUKh8+YSnS/gB3t6YBiz0bskpu7Pine8pPCheNxlPEW4wnUkma2a94YuW2q3guvCQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "babel-plugin-jest-hoist": "^29.6.3",
-        "babel-preset-current-node-syntax": "^1.0.0"
+        "babel-plugin-jest-hoist": "30.2.0",
+        "babel-preset-current-node-syntax": "^1.2.0"
       },
       "engines": {
-        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
+        "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
       },
       "peerDependencies": {
-        "@babel/core": "^7.0.0"
+        "@babel/core": "^7.11.0 || ^8.0.0-beta.1"
       }
     },
     "node_modules/bail": {
@@ -12744,7 +13173,6 @@
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
       "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/base64-js": {
@@ -12767,6 +13195,15 @@
       ],
       "license": "MIT"
     },
+    "node_modules/baseline-browser-mapping": {
+      "version": "2.8.19",
+      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.8.19.tgz",
+      "integrity": "sha512-zoKGUdu6vb2jd3YOq0nnhEDQVbPcHhco3UImJrv5dSkvxTc2pl2WjOPsjZXDwPDSl5eghIMuY3R6J9NDKF3KcQ==",
+      "license": "Apache-2.0",
+      "bin": {
+        "baseline-browser-mapping": "dist/cli.js"
+      }
+    },
     "node_modules/batch": {
       "version": "0.6.1",
       "resolved": "https://registry.npmjs.org/batch/-/batch-0.6.1.tgz",
@@ -12932,7 +13369,6 @@
       "version": "2.0.2",
       "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
       "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "balanced-match": "^1.0.0"
@@ -13082,9 +13518,9 @@
       "license": "MIT"
     },
     "node_modules/browserslist": {
-      "version": "4.24.4",
-      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.4.tgz",
-      "integrity": "sha512-KDi1Ny1gSePi1vm0q4oxSF8b4DR44GF4BbmS2YdhPLOEqd8pDviZOGH/GsmRwoWJ2+5Lr085X7naowMwKHDG1A==",
+      "version": "4.26.3",
+      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.26.3.tgz",
+      "integrity": "sha512-lAUU+02RFBuCKQPj/P6NgjlbCnLBMp4UtgTx7vNHd3XSIJF87s9a5rA3aH2yw3GS9DqZAUbOtZdCCiZeVRqt0w==",
       "funding": [
         {
           "type": "opencollective",
@@ -13101,10 +13537,11 @@
       ],
       "license": "MIT",
       "dependencies": {
-        "caniuse-lite": "^1.0.30001688",
-        "electron-to-chromium": "^1.5.73",
-        "node-releases": "^2.0.19",
-        "update-browserslist-db": "^1.1.1"
+        "baseline-browser-mapping": "^2.8.9",
+        "caniuse-lite": "^1.0.30001746",
+        "electron-to-chromium": "^1.5.227",
+        "node-releases": "^2.0.21",
+        "update-browserslist-db": "^1.1.3"
       },
       "bin": {
         "browserslist": "cli.js"
@@ -13565,9 +14002,9 @@
       }
     },
     "node_modules/caniuse-lite": {
-      "version": "1.0.30001737",
-      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001737.tgz",
-      "integrity": "sha512-BiloLiXtQNrY5UyF0+1nSJLXUENuhka2pzy2Fx5pGxqavdrxSCW4U6Pn/PoG3Efspi2frRbHpBV2XsrPE6EDlw==",
+      "version": "1.0.30001751",
+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001751.tgz",
+      "integrity": "sha512-A0QJhug0Ly64Ii3eIqHu5X51ebln3k4yTUkY1j8drqpWHVreg/VLijN48cZ1bYPiqOQuqpkIKnzr/Ul8V+p6Cw==",
       "funding": [
         {
           "type": "opencollective",
@@ -14023,15 +14460,6 @@
       "integrity": "sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==",
       "license": "MIT"
     },
-    "node_modules/colors": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/colors/-/colors-1.0.3.tgz",
-      "integrity": "sha512-pFGrxThWcWQ2MsAz6RtgeWe4NK2kUE1WfsrvvlctdII745EW9I0yflqhe7++M5LEc7bV2c/9/5zc8sFcpL0Drw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.1.90"
-      }
-    },
     "node_modules/combined-stream": {
       "version": "1.0.8",
       "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
@@ -14277,9 +14705,9 @@
       "license": "MIT"
     },
     "node_modules/confbox": {
-      "version": "0.2.2",
-      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.2.2.tgz",
-      "integrity": "sha512-1NB+BKqhtNipMsov4xI/NnhCKp9XG9NamYp5PVm9klAT0fsrNPjaFICsCFhNhwZJKNh7zB/3q8qXz0E9oaMNtQ==",
+      "version": "0.1.8",
+      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz",
+      "integrity": "sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==",
       "license": "MIT"
     },
     "node_modules/config-file-ts": {
@@ -14390,21 +14818,6 @@
       "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
       "license": "MIT"
     },
-    "node_modules/copy-anything": {
-      "version": "3.0.5",
-      "resolved": "https://registry.npmjs.org/copy-anything/-/copy-anything-3.0.5.tgz",
-      "integrity": "sha512-yCEafptTtb4bk7GLEQoM8KVJpxAfdBJYaXyzQEgQQQgYrZiDp8SJmGKlYza6CYjEDNstAdNdKA3UuoULlEbS6w==",
-      "license": "MIT",
-      "dependencies": {
-        "is-what": "^4.1.8"
-      },
-      "engines": {
-        "node": ">=12.13"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/mesqueeb"
-      }
-    },
     "node_modules/copy-to-clipboard": {
       "version": "3.3.3",
       "resolved": "https://registry.npmjs.org/copy-to-clipboard/-/copy-to-clipboard-3.3.3.tgz",
@@ -14450,13 +14863,13 @@
       }
     },
     "node_modules/core-js-compat": {
-      "version": "3.38.1",
-      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.38.1.tgz",
-      "integrity": "sha512-JRH6gfXxGmrzF3tZ57lFx97YARxCXPaMzPo6jELZhv88pBH5VXpQ+y0znKGlFnzuaihqhLbefxSJxWJMPtfDzw==",
+      "version": "3.46.0",
+      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.46.0.tgz",
+      "integrity": "sha512-p9hObIIEENxSV8xIu+V68JjSeARg6UVMG5mR+JEUguG3sI6MsiS1njz2jHmyJDvA+8jX/sytkBHup6kxhM9law==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "browserslist": "^4.23.3"
+        "browserslist": "^4.26.3"
       },
       "funding": {
         "type": "opencollective",
@@ -15013,14 +15426,6 @@
       "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
       "license": "MIT"
     },
-    "node_modules/cycle": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/cycle/-/cycle-1.0.3.tgz",
-      "integrity": "sha512-TVF6svNzeQCOpjCqsy0/CSy8VgObG3wXusJ73xW2GbG5rGx7lC8zxDSURicsXI2UsGdi2L0QNRCi745/wUDvsA==",
-      "engines": {
-        "node": ">=0.4.0"
-      }
-    },
     "node_modules/cytoscape": {
       "version": "3.32.0",
       "resolved": "https://registry.npmjs.org/cytoscape/-/cytoscape-3.32.0.tgz",
@@ -15662,9 +16067,9 @@
       }
     },
     "node_modules/debug": {
-      "version": "4.4.0",
-      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
-      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
       "license": "MIT",
       "dependencies": {
         "ms": "^2.1.3"
@@ -16491,7 +16896,6 @@
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
       "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/ee-first": {
@@ -16685,9 +17089,9 @@
       }
     },
     "node_modules/electron-to-chromium": {
-      "version": "1.5.120",
-      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.120.tgz",
-      "integrity": "sha512-oTUp3gfX1gZI+xfD2djr2rzQdHCwHzPQrrK0CD7WpTdF0nPdQ/INcRVjWgLdCT4a9W3jFObR9DAfsuyFQnI8CQ==",
+      "version": "1.5.238",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.238.tgz",
+      "integrity": "sha512-khBdc+w/Gv+cS8e/Pbnaw/FXcBUeKrRVik9IxfXtgREOWyJhR4tj43n3amkVogJ/yeQUqzkrZcFhtIxIdqmmcQ==",
       "license": "ISC"
     },
     "node_modules/electron-updater": {
@@ -16779,13 +17183,6 @@
       "version": "9.2.2",
       "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
       "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/emoji-regex-xs": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/emoji-regex-xs/-/emoji-regex-xs-1.0.0.tgz",
-      "integrity": "sha512-LRlerrMYoIDrT6jgpeZ2YYl/L8EulRTt5hQcYjy5AInh7HWXKimpqx68aknBFpGL2+/IcogTcaydJEgaTmOpDg==",
       "license": "MIT"
     },
     "node_modules/emojis-list": {
@@ -16798,6 +17195,15 @@
         "node": ">= 4"
       }
     },
+    "node_modules/empathic": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/empathic/-/empathic-2.0.0.tgz",
+      "integrity": "sha512-i6UzDscO/XfAcNYD75CfICkmfLedpyPDdozrLMmQc5ORaQcdMoc21OnlEylMIqI7U8eniKrPMxxtj8k0vhmJhA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=14"
+      }
+    },
     "node_modules/encodeurl": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
@@ -17086,9 +17492,9 @@
       "optional": true
     },
     "node_modules/esbuild": {
-      "version": "0.25.9",
-      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.9.tgz",
-      "integrity": "sha512-CRbODhYyQx3qp7ZEwzxOk4JBqmD/seJrzPa/cGjY1VtIn5E09Oi9/dB4JwctnfZ8Q8iT7rioVv5k/FNT/uf54g==",
+      "version": "0.25.11",
+      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.11.tgz",
+      "integrity": "sha512-KohQwyzrKTQmhXDW1PjCv3Tyspn9n5GcY2RTDqeORIdIJY8yKIF7sTSopFmn/wpMPW4rdPXI0UE5LJLuq3bx0Q==",
       "hasInstallScript": true,
       "license": "MIT",
       "bin": {
@@ -17098,32 +17504,32 @@
         "node": ">=18"
       },
       "optionalDependencies": {
-        "@esbuild/aix-ppc64": "0.25.9",
-        "@esbuild/android-arm": "0.25.9",
-        "@esbuild/android-arm64": "0.25.9",
-        "@esbuild/android-x64": "0.25.9",
-        "@esbuild/darwin-arm64": "0.25.9",
-        "@esbuild/darwin-x64": "0.25.9",
-        "@esbuild/freebsd-arm64": "0.25.9",
-        "@esbuild/freebsd-x64": "0.25.9",
-        "@esbuild/linux-arm": "0.25.9",
-        "@esbuild/linux-arm64": "0.25.9",
-        "@esbuild/linux-ia32": "0.25.9",
-        "@esbuild/linux-loong64": "0.25.9",
-        "@esbuild/linux-mips64el": "0.25.9",
-        "@esbuild/linux-ppc64": "0.25.9",
-        "@esbuild/linux-riscv64": "0.25.9",
-        "@esbuild/linux-s390x": "0.25.9",
-        "@esbuild/linux-x64": "0.25.9",
-        "@esbuild/netbsd-arm64": "0.25.9",
-        "@esbuild/netbsd-x64": "0.25.9",
-        "@esbuild/openbsd-arm64": "0.25.9",
-        "@esbuild/openbsd-x64": "0.25.9",
-        "@esbuild/openharmony-arm64": "0.25.9",
-        "@esbuild/sunos-x64": "0.25.9",
-        "@esbuild/win32-arm64": "0.25.9",
-        "@esbuild/win32-ia32": "0.25.9",
-        "@esbuild/win32-x64": "0.25.9"
+        "@esbuild/aix-ppc64": "0.25.11",
+        "@esbuild/android-arm": "0.25.11",
+        "@esbuild/android-arm64": "0.25.11",
+        "@esbuild/android-x64": "0.25.11",
+        "@esbuild/darwin-arm64": "0.25.11",
+        "@esbuild/darwin-x64": "0.25.11",
+        "@esbuild/freebsd-arm64": "0.25.11",
+        "@esbuild/freebsd-x64": "0.25.11",
+        "@esbuild/linux-arm": "0.25.11",
+        "@esbuild/linux-arm64": "0.25.11",
+        "@esbuild/linux-ia32": "0.25.11",
+        "@esbuild/linux-loong64": "0.25.11",
+        "@esbuild/linux-mips64el": "0.25.11",
+        "@esbuild/linux-ppc64": "0.25.11",
+        "@esbuild/linux-riscv64": "0.25.11",
+        "@esbuild/linux-s390x": "0.25.11",
+        "@esbuild/linux-x64": "0.25.11",
+        "@esbuild/netbsd-arm64": "0.25.11",
+        "@esbuild/netbsd-x64": "0.25.11",
+        "@esbuild/openbsd-arm64": "0.25.11",
+        "@esbuild/openbsd-x64": "0.25.11",
+        "@esbuild/openharmony-arm64": "0.25.11",
+        "@esbuild/sunos-x64": "0.25.11",
+        "@esbuild/win32-arm64": "0.25.11",
+        "@esbuild/win32-ia32": "0.25.11",
+        "@esbuild/win32-x64": "0.25.11"
       }
     },
     "node_modules/esbuild-register": {
@@ -18703,12 +19109,12 @@
       }
     },
     "node_modules/eventsource-parser": {
-      "version": "3.0.5",
-      "resolved": "https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.5.tgz",
-      "integrity": "sha512-bSRG85ZrMdmWtm7qkF9He9TNRzc/Bm99gEJMaQoHJ9E6Kv9QBbsldh2oMj7iXmYNEAVvNgvv5vPorG6W+XtBhQ==",
+      "version": "3.0.6",
+      "resolved": "https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.6.tgz",
+      "integrity": "sha512-Vo1ab+QXPzZ4tCa8SwIHJFaSzy4R6SHf7BY79rFBDf0idraZWAkYrDjDj8uWaSm3S2TK+hJ7/t1CEmZ7jXw+pg==",
       "license": "MIT",
       "engines": {
-        "node": ">=20.0.0"
+        "node": ">=18.0.0"
       }
     },
     "node_modules/evp_bytestokey": {
@@ -18890,9 +19296,9 @@
       "license": "MIT"
     },
     "node_modules/exsolve": {
-      "version": "1.0.5",
-      "resolved": "https://registry.npmjs.org/exsolve/-/exsolve-1.0.5.tgz",
-      "integrity": "sha512-pz5dvkYYKQ1AHVrgOzBKWeP4u4FRb3a6DNK2ucr0OoNwYIU4QWsJ+NM36LLzORT+z845MzKHHhpXiUF5nvQoJg==",
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/exsolve/-/exsolve-1.0.7.tgz",
+      "integrity": "sha512-VO5fQUzZtI6C+vx4w/4BWJpg3s/5l+6pRQEHzFRM8WFi4XffSP1Z+4qi7GbjWbvRQEbdIco5mIMq+zX4rPuLrw==",
       "license": "MIT"
     },
     "node_modules/extend": {
@@ -18933,14 +19339,6 @@
       "license": "MIT",
       "optional": true
     },
-    "node_modules/eyes": {
-      "version": "0.1.8",
-      "resolved": "https://registry.npmjs.org/eyes/-/eyes-0.1.8.tgz",
-      "integrity": "sha512-GipyPsXO1anza0AOZdy69Im7hGFCNB7Y/NGjDlZGJ3GJJLtwNSb2vrzYrTYJRrRloVx7pl+bhUaTB8yiccPvFQ==",
-      "engines": {
-        "node": "> 0.1.90"
-      }
-    },
     "node_modules/fast-copy": {
       "version": "3.0.2",
       "resolved": "https://registry.npmjs.org/fast-copy/-/fast-copy-3.0.2.tgz",
@@ -19290,18 +19688,6 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/find-up-simple": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/find-up-simple/-/find-up-simple-1.0.1.tgz",
-      "integrity": "sha512-afd4O7zpqHeRyg4PfDQsXmlDe2PfdHtJt6Akt8jOWaApLOZk5JXs6VMR29lz03pRe9mpykrRCYIYxaJYcfpncQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
     "node_modules/find-workspaces": {
       "version": "0.3.1",
       "resolved": "https://registry.npmjs.org/find-workspaces/-/find-workspaces-0.3.1.tgz",
@@ -19313,23 +19699,6 @@
         "yaml": "^2.3.4"
       }
     },
-    "node_modules/find-workspaces/node_modules/confbox": {
-      "version": "0.1.8",
-      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz",
-      "integrity": "sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==",
-      "license": "MIT"
-    },
-    "node_modules/find-workspaces/node_modules/pkg-types": {
-      "version": "1.3.1",
-      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-1.3.1.tgz",
-      "integrity": "sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==",
-      "license": "MIT",
-      "dependencies": {
-        "confbox": "^0.1.8",
-        "mlly": "^1.7.4",
-        "pathe": "^2.0.1"
-      }
-    },
     "node_modules/find-workspaces/node_modules/yaml": {
       "version": "2.8.1",
       "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.8.1.tgz",
@@ -19431,7 +19800,6 @@
       "version": "3.3.1",
       "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
       "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
-      "dev": true,
       "license": "ISC",
       "dependencies": {
         "cross-spawn": "^7.0.6",
@@ -19448,7 +19816,6 @@
       "version": "4.1.0",
       "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
       "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
-      "dev": true,
       "license": "ISC",
       "engines": {
         "node": ">=14"
@@ -19967,16 +20334,6 @@
         "node": ">=10.0"
       }
     },
-    "node_modules/globals": {
-      "version": "11.12.0",
-      "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
-      "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=4"
-      }
-    },
     "node_modules/globalthis": {
       "version": "1.0.4",
       "resolved": "https://registry.npmjs.org/globalthis/-/globalthis-1.0.4.tgz",
@@ -20254,29 +20611,6 @@
         "url": "https://opencollective.com/unified"
       }
     },
-    "node_modules/hast-util-to-html": {
-      "version": "9.0.5",
-      "resolved": "https://registry.npmjs.org/hast-util-to-html/-/hast-util-to-html-9.0.5.tgz",
-      "integrity": "sha512-OguPdidb+fbHQSU4Q4ZiLKnzWo8Wwsf5bZfbvu7//a9oTYoqD/fWpe96NuHkoS9h0ccGOTe0C4NGXdtS0iObOw==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/hast": "^3.0.0",
-        "@types/unist": "^3.0.0",
-        "ccount": "^2.0.0",
-        "comma-separated-tokens": "^2.0.0",
-        "hast-util-whitespace": "^3.0.0",
-        "html-void-elements": "^3.0.0",
-        "mdast-util-to-hast": "^13.0.0",
-        "property-information": "^7.0.0",
-        "space-separated-tokens": "^2.0.0",
-        "stringify-entities": "^4.0.0",
-        "zwitch": "^2.0.4"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/unified"
-      }
-    },
     "node_modules/hast-util-to-jsx-runtime": {
       "version": "2.3.6",
       "resolved": "https://registry.npmjs.org/hast-util-to-jsx-runtime/-/hast-util-to-jsx-runtime-2.3.6.tgz",
@@ -20441,9 +20775,9 @@
       "license": "MIT"
     },
     "node_modules/hono": {
-      "version": "4.9.4",
-      "resolved": "https://registry.npmjs.org/hono/-/hono-4.9.4.tgz",
-      "integrity": "sha512-61hl6MF6ojTl/8QSRu5ran6GXt+6zsngIUN95KzF5v5UjiX/xnrLR358BNRawwIRO49JwUqJqQe3Rb2v559R8Q==",
+      "version": "4.10.1",
+      "resolved": "https://registry.npmjs.org/hono/-/hono-4.10.1.tgz",
+      "integrity": "sha512-rpGNOfacO4WEPClfkEt1yfl8cbu10uB1lNpiI33AKoiAHwOS8lV748JiLx4b5ozO/u4qLjIvfpFsPXdY5Qjkmg==",
       "license": "MIT",
       "engines": {
         "node": ">=16.9.0"
@@ -20614,16 +20948,6 @@
         "url": "https://opencollective.com/unified"
       }
     },
-    "node_modules/html-void-elements": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/html-void-elements/-/html-void-elements-3.0.0.tgz",
-      "integrity": "sha512-bEqo66MRXsUGxWHV5IP0PUiAWwoEjba4VCzg0LjFJBpchPaTfyfCKTG6bc5F8ucKec3q5y6qOdGyYTSBEvhCrg==",
-      "license": "MIT",
-      "funding": {
-        "type": "github",
-        "url": "https://github.com/sponsors/wooorm"
-      }
-    },
     "node_modules/html-webpack-plugin": {
       "version": "5.6.3",
       "resolved": "https://registry.npmjs.org/html-webpack-plugin/-/html-webpack-plugin-5.6.3.tgz",
@@ -21296,9 +21620,9 @@
       }
     },
     "node_modules/is-core-module": {
-      "version": "2.15.1",
-      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.15.1.tgz",
-      "integrity": "sha512-z0vtXSwucUJtANQWldhbtbt7BnL0vxiFjIdDLAatwhDYty2bad6s+rijD6Ri4YuYJubLzIJLUidCh09e1djEVQ==",
+      "version": "2.16.1",
+      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
+      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
       "license": "MIT",
       "dependencies": {
         "hasown": "^2.0.2"
@@ -21513,7 +21837,6 @@
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/is-network-error/-/is-network-error-1.1.0.tgz",
       "integrity": "sha512-tUdRRAnhT+OtCZR/LxZelH/C7QtjtFrTu5tXCA8pl55eTUElUHT+GPYV8MBMBvea/j+NxQqVt3LbWMRir7Gx9g==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=16"
@@ -21782,18 +22105,6 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
-    "node_modules/is-what": {
-      "version": "4.1.16",
-      "resolved": "https://registry.npmjs.org/is-what/-/is-what-4.1.16.tgz",
-      "integrity": "sha512-ZhMwEosbFJkA0YhFnNDgTM4ZxDRsS6HqTo7qsZM08fehyRYIYa0yHu5R6mgo1n/8MgaPBXiPimPD77baVFYg+A==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=12.13"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/mesqueeb"
-      }
-    },
     "node_modules/is-wsl": {
       "version": "3.1.0",
       "resolved": "https://registry.npmjs.org/is-wsl/-/is-wsl-3.1.0.tgz",
@@ -21859,12 +22170,6 @@
         "node": ">=0.10.0"
       }
     },
-    "node_modules/isstream": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/isstream/-/isstream-0.1.2.tgz",
-      "integrity": "sha512-Yljz7ffyPbrLpLngrMtZ7NduUgVvi6wG9RJ9IUcyCd59YQ911PBJphODUcbOVbqYfxe1wuYf/LJ8PauMRwsM/g==",
-      "license": "MIT"
-    },
     "node_modules/istanbul-lib-coverage": {
       "version": "3.2.2",
       "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
@@ -21968,7 +22273,6 @@
       "version": "3.4.3",
       "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
       "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
-      "dev": true,
       "license": "BlueOak-1.0.0",
       "dependencies": {
         "@isaacs/cliui": "^8.0.2"
@@ -22200,29 +22504,84 @@
         "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
       },
       "peerDependencies": {
-        "@types/node": "*",
-        "ts-node": ">=9.0.0"
+        "@types/node": "*",
+        "ts-node": ">=9.0.0"
+      },
+      "peerDependenciesMeta": {
+        "@types/node": {
+          "optional": true
+        },
+        "ts-node": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/jest-config/node_modules/ansi-styles": {
+      "version": "5.2.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
+      "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/jest-config/node_modules/babel-jest": {
+      "version": "29.7.0",
+      "resolved": "https://registry.npmjs.org/babel-jest/-/babel-jest-29.7.0.tgz",
+      "integrity": "sha512-BrvGY3xZSwEcCzKvKsCi2GgHqDqsYkOP4/by5xCgIwGXQxIEh+8ew3gmrE1y7XRR6LHZIj6yLYnUi/mm2KXKBg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jest/transform": "^29.7.0",
+        "@types/babel__core": "^7.1.14",
+        "babel-plugin-istanbul": "^6.1.1",
+        "babel-preset-jest": "^29.6.3",
+        "chalk": "^4.0.0",
+        "graceful-fs": "^4.2.9",
+        "slash": "^3.0.0"
+      },
+      "engines": {
+        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.8.0"
+      }
+    },
+    "node_modules/jest-config/node_modules/babel-plugin-jest-hoist": {
+      "version": "29.6.3",
+      "resolved": "https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-29.6.3.tgz",
+      "integrity": "sha512-ESAc/RJvGTFEzRwOTT4+lNDk/GNHMkKbNzsvT0qKRfDyyYTskxB5rnU2njIDYVxXCBHHEI1c0YwHob3WaYujOg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/template": "^7.3.3",
+        "@babel/types": "^7.3.3",
+        "@types/babel__core": "^7.1.14",
+        "@types/babel__traverse": "^7.0.6"
       },
-      "peerDependenciesMeta": {
-        "@types/node": {
-          "optional": true
-        },
-        "ts-node": {
-          "optional": true
-        }
+      "engines": {
+        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
       }
     },
-    "node_modules/jest-config/node_modules/ansi-styles": {
-      "version": "5.2.0",
-      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
-      "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
+    "node_modules/jest-config/node_modules/babel-preset-jest": {
+      "version": "29.6.3",
+      "resolved": "https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-29.6.3.tgz",
+      "integrity": "sha512-0B3bhxR6snWXJZtR/RliHTDPRgn1sNHOR0yVtq/IiQFyuOVjFS+wuio/R4gSNkyYmKmJB4wGZv2NZanmKmTnNA==",
       "dev": true,
       "license": "MIT",
+      "dependencies": {
+        "babel-plugin-jest-hoist": "^29.6.3",
+        "babel-preset-current-node-syntax": "^1.0.0"
+      },
       "engines": {
-        "node": ">=10"
+        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
       },
-      "funding": {
-        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
       }
     },
     "node_modules/jest-config/node_modules/pretty-format": {
@@ -23492,9 +23851,9 @@
       }
     },
     "node_modules/libsql": {
-      "version": "0.5.17",
-      "resolved": "https://registry.npmjs.org/libsql/-/libsql-0.5.17.tgz",
-      "integrity": "sha512-RRlj5XQI9+Wq+/5UY8EnugSWfRmHEw4hn3DKlPrkUgZONsge1PwTtHcpStP6MSNi8ohcbsRgEHJaymA33a8cBw==",
+      "version": "0.5.22",
+      "resolved": "https://registry.npmjs.org/libsql/-/libsql-0.5.22.tgz",
+      "integrity": "sha512-NscWthMQt7fpU8lqd7LXMvT9pi+KhhmTHAJWUB/Lj6MWa0MKFv0F2V4C6WKKpjCVZl0VwcDz4nOI3CyaT1DDiA==",
       "cpu": [
         "x64",
         "arm64",
@@ -23512,15 +23871,15 @@
         "detect-libc": "2.0.2"
       },
       "optionalDependencies": {
-        "@libsql/darwin-arm64": "0.5.17",
-        "@libsql/darwin-x64": "0.5.17",
-        "@libsql/linux-arm-gnueabihf": "0.5.17",
-        "@libsql/linux-arm-musleabihf": "0.5.17",
-        "@libsql/linux-arm64-gnu": "0.5.17",
-        "@libsql/linux-arm64-musl": "0.5.17",
-        "@libsql/linux-x64-gnu": "0.5.17",
-        "@libsql/linux-x64-musl": "0.5.17",
-        "@libsql/win32-x64-msvc": "0.5.17"
+        "@libsql/darwin-arm64": "0.5.22",
+        "@libsql/darwin-x64": "0.5.22",
+        "@libsql/linux-arm-gnueabihf": "0.5.22",
+        "@libsql/linux-arm-musleabihf": "0.5.22",
+        "@libsql/linux-arm64-gnu": "0.5.22",
+        "@libsql/linux-arm64-musl": "0.5.22",
+        "@libsql/linux-x64-gnu": "0.5.22",
+        "@libsql/linux-x64-musl": "0.5.22",
+        "@libsql/win32-x64-msvc": "0.5.22"
       }
     },
     "node_modules/libsql/node_modules/detect-libc": {
@@ -23586,14 +23945,14 @@
       }
     },
     "node_modules/local-pkg": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/local-pkg/-/local-pkg-1.1.1.tgz",
-      "integrity": "sha512-WunYko2W1NcdfAFpuLUoucsgULmgDBRkdxHxWQ7mK0cQqwPiy8E1enjuRBrhLtZkB5iScJ1XIPdhVEFK8aOLSg==",
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/local-pkg/-/local-pkg-1.1.2.tgz",
+      "integrity": "sha512-arhlxbFRmoQHl33a0Zkle/YWlmNwoyt6QNZEIJcqNbdrsix5Lvc4HyyI3EnwxTYlZYc32EbYrQ8SzEZ7dqgg9A==",
       "license": "MIT",
       "dependencies": {
         "mlly": "^1.7.4",
-        "pkg-types": "^2.0.1",
-        "quansync": "^0.2.8"
+        "pkg-types": "^2.3.0",
+        "quansync": "^0.2.11"
       },
       "engines": {
         "node": ">=14"
@@ -23602,6 +23961,23 @@
         "url": "https://github.com/sponsors/antfu"
       }
     },
+    "node_modules/local-pkg/node_modules/confbox": {
+      "version": "0.2.2",
+      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.2.2.tgz",
+      "integrity": "sha512-1NB+BKqhtNipMsov4xI/NnhCKp9XG9NamYp5PVm9klAT0fsrNPjaFICsCFhNhwZJKNh7zB/3q8qXz0E9oaMNtQ==",
+      "license": "MIT"
+    },
+    "node_modules/local-pkg/node_modules/pkg-types": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-2.3.0.tgz",
+      "integrity": "sha512-SIqCzDRg0s9npO5XQ3tNZioRY1uK06lA41ynBC1YmFTmnY6FjUjVt6s4LoADmwoig1qqD0oK8h1p/8mlMx8Oig==",
+      "license": "MIT",
+      "dependencies": {
+        "confbox": "^0.2.2",
+        "exsolve": "^1.0.7",
+        "pathe": "^2.0.3"
+      }
+    },
     "node_modules/locate-path": {
       "version": "6.0.0",
       "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
@@ -23622,6 +23998,7 @@
       "version": "4.17.21",
       "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
       "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
+      "dev": true,
       "license": "MIT"
     },
     "node_modules/lodash-es": {
@@ -23823,9 +24200,9 @@
       }
     },
     "node_modules/magic-string": {
-      "version": "0.30.18",
-      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.18.tgz",
-      "integrity": "sha512-yi8swmWbO17qHhwIBNeeZxTceJMeBvWJaId6dyvTSOwTipqeHhMhOrz6513r1sOKnpvQ7zkhlG8tPrpilwTxHQ==",
+      "version": "0.30.19",
+      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.19.tgz",
+      "integrity": "sha512-2N21sPY9Ws53PZvsEpVtNuSW+ScYbQdp4b9qUaL+9QkHUrGFKo56Lg9Emg5s9V/qrtNBmiR01sYhUOwu3H+VOw==",
       "license": "MIT",
       "dependencies": {
         "@jridgewell/sourcemap-codec": "^1.5.5"
@@ -23925,17 +24302,16 @@
       }
     },
     "node_modules/mastra": {
-      "version": "0.10.23",
-      "resolved": "https://registry.npmjs.org/mastra/-/mastra-0.10.23.tgz",
-      "integrity": "sha512-xjM5rRJZdc37KRi16Qf2NAZLxGT47QLzDttghSjf8Vn45cRVJC57CQJgQeekjziGwy7Eed5/LJKvw6jfTaaw4Q==",
+      "version": "0.17.0",
+      "resolved": "https://registry.npmjs.org/mastra/-/mastra-0.17.0.tgz",
+      "integrity": "sha512-PKFqD6toWiTcoBLa6B/9Pqb1SEQNptr+4SHTWNl27gTaprmad3ZSC/b2yvRNyNG25aDBeYs0YQGoeuD81mLhxg==",
       "license": "Apache-2.0",
       "dependencies": {
         "@clack/prompts": "^0.11.0",
-        "@lukeed/uuid": "^2.0.1",
-        "@mastra/deployer": "^0.14.1",
-        "@mastra/loggers": "^0.10.7",
-        "@mastra/mcp": "^0.10.12",
-        "@opentelemetry/auto-instrumentations-node": "^0.62.0",
+        "@expo/devcert": "^1.2.0",
+        "@mastra/deployer": "^0.21.1",
+        "@mastra/loggers": "^0.10.16",
+        "@opentelemetry/auto-instrumentations-node": "^0.62.1",
         "@opentelemetry/core": "^2.0.1",
         "@opentelemetry/exporter-trace-otlp-grpc": "^0.203.0",
         "@opentelemetry/exporter-trace-otlp-http": "^0.203.0",
@@ -23948,29 +24324,23 @@
         "commander": "^12.1.0",
         "dotenv": "^16.6.1",
         "execa": "^9.6.0",
-        "fs-extra": "^11.3.0",
+        "fs-extra": "^11.3.2",
         "get-port": "^7.1.0",
-        "json-schema-to-zod": "^2.6.1",
         "open": "^10.1.2",
         "picocolors": "^1.1.1",
         "posthog-node": "4.18.0",
         "prettier": "^3.6.2",
-        "prompt": "^1.3.0",
         "shell-quote": "^1.8.3",
-        "shiki": "^1.29.2",
-        "strip-json-comments": "^5.0.2",
-        "superjson": "^2.2.2",
-        "swr": "^2.3.4",
+        "strip-json-comments": "^5.0.3",
         "tcp-port-used": "^1.0.2",
-        "yocto-spinner": "^0.2.3",
-        "zod": "^3.25.67",
-        "zod-to-json-schema": "^3.24.5"
+        "yocto-spinner": "^0.2.3"
       },
       "bin": {
         "mastra": "dist/index.js"
       },
       "peerDependencies": {
-        "@mastra/core": ">=0.10.2-0 <0.15.0-0"
+        "@mastra/core": ">=0.21.0-0 <0.22.0-0",
+        "zod": "^3.25.0 || ^4.0.0"
       }
     },
     "node_modules/mastra/node_modules/@sindresorhus/merge-streams": {
@@ -24021,9 +24391,9 @@
       }
     },
     "node_modules/mastra/node_modules/fs-extra": {
-      "version": "11.3.0",
-      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-11.3.0.tgz",
-      "integrity": "sha512-Z4XaCL6dUDHfP/jT25jJKMmtxvuwbkrD1vNSMFlo9lNLY2c5FHYSQgHPRZUjAB26TpDEoW9HCOgplrdbaPV/ew==",
+      "version": "11.3.2",
+      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-11.3.2.tgz",
+      "integrity": "sha512-Xr9F6z6up6Ws+NjzMCZc6WXg2YFRlrLP9NQDO3VQrWrfiojdhS56TzueT88ze0uBdCTwEIhQ3ptnmKeWGFAe0A==",
       "license": "MIT",
       "dependencies": {
         "graceful-fs": "^4.2.0",
@@ -24136,9 +24506,9 @@
       }
     },
     "node_modules/mastra/node_modules/strip-json-comments": {
-      "version": "5.0.2",
-      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-5.0.2.tgz",
-      "integrity": "sha512-4X2FR3UwhNUE9G49aIsJW5hRRR3GXGTBTZRMfv568O60ojM8HcWjV/VxAxCDW3SUND33O6ZY66ZuRcdkj73q2g==",
+      "version": "5.0.3",
+      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-5.0.3.tgz",
+      "integrity": "sha512-1tB5mhVo7U+ETBKNf92xT4hrQa3pm0MZ0PQvuDnWgAAGHDsfp4lPSpiS6psrSiet87wyGPh9ft6wmhOMQ0hDiw==",
       "license": "MIT",
       "engines": {
         "node": ">=14.16"
@@ -25286,7 +25656,6 @@
       "version": "9.0.5",
       "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
       "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
-      "dev": true,
       "license": "ISC",
       "dependencies": {
         "brace-expansion": "^2.0.1"
@@ -25443,23 +25812,6 @@
         "ufo": "^1.5.4"
       }
     },
-    "node_modules/mlly/node_modules/confbox": {
-      "version": "0.1.8",
-      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz",
-      "integrity": "sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==",
-      "license": "MIT"
-    },
-    "node_modules/mlly/node_modules/pkg-types": {
-      "version": "1.3.1",
-      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-1.3.1.tgz",
-      "integrity": "sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==",
-      "license": "MIT",
-      "dependencies": {
-        "confbox": "^0.1.8",
-        "mlly": "^1.7.4",
-        "pathe": "^2.0.1"
-      }
-    },
     "node_modules/module-details-from-path": {
       "version": "1.0.4",
       "resolved": "https://registry.npmjs.org/module-details-from-path/-/module-details-from-path-1.0.4.tgz",
@@ -25496,12 +25848,6 @@
         "multicast-dns": "cli.js"
       }
     },
-    "node_modules/mute-stream": {
-      "version": "0.0.8",
-      "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.8.tgz",
-      "integrity": "sha512-nnbWWOkoWyUsTjKrhgD0dcz22mdkSnpYqbEjIm2nhwhuxlSkpywJmBo8h0ZqJdkp73mb90SssHkN4rsRaBAfAA==",
-      "license": "ISC"
-    },
     "node_modules/mylas": {
       "version": "2.1.13",
       "resolved": "https://registry.npmjs.org/mylas/-/mylas-2.1.13.tgz",
@@ -25726,9 +26072,9 @@
       }
     },
     "node_modules/node-releases": {
-      "version": "2.0.19",
-      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
-      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
+      "version": "2.0.26",
+      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.26.tgz",
+      "integrity": "sha512-S2M9YimhSjBSvYnlr5/+umAnPHE++ODwt5e2Ij6FoX45HA/s4vHdkDx1eax2pAPeAOqu4s9b7ppahsyEFdVqQA==",
       "license": "MIT"
     },
     "node_modules/nopt": {
@@ -26011,17 +26357,6 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/oniguruma-to-es": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/oniguruma-to-es/-/oniguruma-to-es-2.3.0.tgz",
-      "integrity": "sha512-bwALDxriqfKGfUufKGGepCzu9x7nJQuoRoAFp4AnwehhC2crqrDIAP/uN2qdlsAvSMpeRC3+Yzhqc7hLmle5+g==",
-      "license": "MIT",
-      "dependencies": {
-        "emoji-regex-xs": "^1.0.0",
-        "regex": "^5.1.1",
-        "regex-recursion": "^5.1.1"
-      }
-    },
     "node_modules/open": {
       "version": "10.1.2",
       "resolved": "https://registry.npmjs.org/open/-/open-10.1.2.tgz",
@@ -26213,26 +26548,10 @@
         "node": ">=6"
       }
     },
-    "node_modules/package-directory": {
-      "version": "8.1.0",
-      "resolved": "https://registry.npmjs.org/package-directory/-/package-directory-8.1.0.tgz",
-      "integrity": "sha512-qHKRW0pw3lYdZMQVkjDBqh8HlamH/LCww2PH7OWEp4Qrt3SFeYMNpnJrQzlSnGrDD5zGR51XqBh7FnNCdVNEHA==",
-      "license": "MIT",
-      "dependencies": {
-        "find-up-simple": "^1.0.0"
-      },
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
     "node_modules/package-json-from-dist": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
       "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
-      "dev": true,
       "license": "BlueOak-1.0.0"
     },
     "node_modules/package-manager-detector": {
@@ -26432,7 +26751,6 @@
       "version": "1.11.1",
       "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
       "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
-      "dev": true,
       "license": "BlueOak-1.0.0",
       "dependencies": {
         "lru-cache": "^10.2.0",
@@ -26449,14 +26767,12 @@
       "version": "10.4.3",
       "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
       "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
-      "dev": true,
       "license": "ISC"
     },
     "node_modules/path-scurry/node_modules/minipass": {
       "version": "7.1.2",
       "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
       "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
-      "dev": true,
       "license": "ISC",
       "engines": {
         "node": ">=16 || 14 >=14.17"
@@ -26788,9 +27104,9 @@
       "license": "MIT"
     },
     "node_modules/pirates": {
-      "version": "4.0.6",
-      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.6.tgz",
-      "integrity": "sha512-saLsH7WeYYPiD25LDuLRRY/i+6HaPYr6G1OUlN39otzkSTxKnubR9RTxS3/Kk50s1g2JTgFwWQDQyplC5/SHZg==",
+      "version": "4.0.7",
+      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
+      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
       "dev": true,
       "license": "MIT",
       "engines": {
@@ -26876,14 +27192,14 @@
       }
     },
     "node_modules/pkg-types": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-2.1.0.tgz",
-      "integrity": "sha512-wmJwA+8ihJixSoHKxZJRBQG1oY8Yr9pGLzRmSsNms0iNWyHHAlZCa7mmKiFR10YPZuz/2k169JiS/inOjBCZ2A==",
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-1.3.1.tgz",
+      "integrity": "sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==",
       "license": "MIT",
       "dependencies": {
-        "confbox": "^0.2.1",
-        "exsolve": "^1.0.1",
-        "pathe": "^2.0.3"
+        "confbox": "^0.1.8",
+        "mlly": "^1.7.4",
+        "pathe": "^2.0.1"
       }
     },
     "node_modules/plimit-lit": {
@@ -27737,28 +28053,6 @@
         "node": ">=10"
       }
     },
-    "node_modules/prompt": {
-      "version": "1.3.0",
-      "resolved": "https://registry.npmjs.org/prompt/-/prompt-1.3.0.tgz",
-      "integrity": "sha512-ZkaRWtaLBZl7KKAKndKYUL8WqNT+cQHKRZnT4RYYms48jQkFw3rrBL+/N5K/KtdEveHkxs982MX2BkDKub2ZMg==",
-      "license": "MIT",
-      "dependencies": {
-        "@colors/colors": "1.5.0",
-        "async": "3.2.3",
-        "read": "1.0.x",
-        "revalidator": "0.1.x",
-        "winston": "2.x"
-      },
-      "engines": {
-        "node": ">= 6.0.0"
-      }
-    },
-    "node_modules/prompt/node_modules/async": {
-      "version": "3.2.3",
-      "resolved": "https://registry.npmjs.org/async/-/async-3.2.3.tgz",
-      "integrity": "sha512-spZRyzKL5l5BZQrr/6m/SqFdBN0q3OCI0f9rjfBzCMBIP4p75P620rR3gTmaksNOhmzgdxcaxdNfMy6anrbM0g==",
-      "license": "MIT"
-    },
     "node_modules/prompts": {
       "version": "2.4.2",
       "resolved": "https://registry.npmjs.org/prompts/-/prompts-2.4.2.tgz",
@@ -27933,9 +28227,9 @@
       }
     },
     "node_modules/quansync": {
-      "version": "0.2.10",
-      "resolved": "https://registry.npmjs.org/quansync/-/quansync-0.2.10.tgz",
-      "integrity": "sha512-t41VRkMYbkHyCYmOvx/6URnN80H7k4X0lLdBMGsz+maAwrJQYB1djpV6vHrQIBE0WBSGqhtEHrK9U3DWWH8v7A==",
+      "version": "0.2.11",
+      "resolved": "https://registry.npmjs.org/quansync/-/quansync-0.2.11.tgz",
+      "integrity": "sha512-AifT7QEbW9Nri4tAwR5M/uzpBuqfZf+zwaEM/QkzEjj7NBuFD2rBuy0K3dE+8wltbezDV7JMA0WfnCPYRSYbXA==",
       "funding": [
         {
           "type": "individual",
@@ -28362,18 +28656,6 @@
         "react-dom": ">=16.6.0"
       }
     },
-    "node_modules/read": {
-      "version": "1.0.7",
-      "resolved": "https://registry.npmjs.org/read/-/read-1.0.7.tgz",
-      "integrity": "sha512-rSOKNYUmaxy0om1BNjMN4ezNT6VKK+2xF4GBhc81mkH7L60i6dp8qPYrkndNLT3QPphoII3maL9PVC9XmhHwVQ==",
-      "license": "ISC",
-      "dependencies": {
-        "mute-stream": "~0.0.4"
-      },
-      "engines": {
-        "node": ">=0.8"
-      }
-    },
     "node_modules/read-binary-file-arch": {
       "version": "1.0.6",
       "resolved": "https://registry.npmjs.org/read-binary-file-arch/-/read-binary-file-arch-1.0.6.tgz",
@@ -28477,16 +28759,16 @@
       }
     },
     "node_modules/redis": {
-      "version": "5.8.2",
-      "resolved": "https://registry.npmjs.org/redis/-/redis-5.8.2.tgz",
-      "integrity": "sha512-31vunZj07++Y1vcFGcnNWEf5jPoTkGARgfWI4+Tk55vdwHxhAvug8VEtW7Cx+/h47NuJTEg/JL77zAwC6E0OeA==",
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/redis/-/redis-5.8.3.tgz",
+      "integrity": "sha512-MfSrfV6+tEfTw8c4W0yFp6XWX8Il4laGU7Bx4kvW4uiYM1AuZ3KGqEGt1LdQHeD1nEyLpIWetZ/SpY3kkbgrYw==",
       "license": "MIT",
       "dependencies": {
-        "@redis/bloom": "5.8.2",
-        "@redis/client": "5.8.2",
-        "@redis/json": "5.8.2",
-        "@redis/search": "5.8.2",
-        "@redis/time-series": "5.8.2"
+        "@redis/bloom": "5.8.3",
+        "@redis/client": "5.8.3",
+        "@redis/json": "5.8.3",
+        "@redis/search": "5.8.3",
+        "@redis/time-series": "5.8.3"
       },
       "engines": {
         "node": ">= 18"
@@ -28639,9 +28921,9 @@
       "license": "MIT"
     },
     "node_modules/regenerate-unicode-properties": {
-      "version": "10.1.1",
-      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-10.1.1.tgz",
-      "integrity": "sha512-X007RyZLsCJVVrjgEFVpLUTZwyOZk3oiL75ZcuYjlIWd6rNJtOjkBwQc5AsRrpbKVkxN6sklw/k/9m2jJYOf8Q==",
+      "version": "10.2.2",
+      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-10.2.2.tgz",
+      "integrity": "sha512-m03P+zhBeQd1RGnYxrGyDAPpWX/epKirLrp8e3qevZdVkKtnCrjjWczIbYc8+xd6vcTStVlqfycTx1KR4LOr0g==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
@@ -28657,41 +28939,6 @@
       "integrity": "sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw==",
       "license": "MIT"
     },
-    "node_modules/regenerator-transform": {
-      "version": "0.15.2",
-      "resolved": "https://registry.npmjs.org/regenerator-transform/-/regenerator-transform-0.15.2.tgz",
-      "integrity": "sha512-hfMp2BoF0qOk3uc5V20ALGDS2ddjQaLrdl7xrGXvAIow7qeWRM2VA2HuCHkUKk9slq3VwEwLNK3DFBqDfPGYtg==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "@babel/runtime": "^7.8.4"
-      }
-    },
-    "node_modules/regex": {
-      "version": "5.1.1",
-      "resolved": "https://registry.npmjs.org/regex/-/regex-5.1.1.tgz",
-      "integrity": "sha512-dN5I359AVGPnwzJm2jN1k0W9LPZ+ePvoOeVMMfqIMFz53sSwXkxaJoxr50ptnsC771lK95BnTrVSZxq0b9yCGw==",
-      "license": "MIT",
-      "dependencies": {
-        "regex-utilities": "^2.3.0"
-      }
-    },
-    "node_modules/regex-recursion": {
-      "version": "5.1.1",
-      "resolved": "https://registry.npmjs.org/regex-recursion/-/regex-recursion-5.1.1.tgz",
-      "integrity": "sha512-ae7SBCbzVNrIjgSbh7wMznPcQel1DNlDtzensnFxpiNpXt1U2ju/bHugH422r+4LAVS1FpW1YCwilmnNsjum9w==",
-      "license": "MIT",
-      "dependencies": {
-        "regex": "^5.1.1",
-        "regex-utilities": "^2.3.0"
-      }
-    },
-    "node_modules/regex-utilities": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/regex-utilities/-/regex-utilities-2.3.0.tgz",
-      "integrity": "sha512-8VhliFJAWRaUiVvREIiW2NXXTmHs4vMNnSzuJVhscgmGav3g9VDxLrQndI3dZZVVdp0ZO/5v0xmX516/7M9cng==",
-      "license": "MIT"
-    },
     "node_modules/regexp.prototype.flags": {
       "version": "1.5.4",
       "resolved": "https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.5.4.tgz",
@@ -28714,45 +28961,43 @@
       }
     },
     "node_modules/regexpu-core": {
-      "version": "5.3.2",
-      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-5.3.2.tgz",
-      "integrity": "sha512-RAM5FlZz+Lhmo7db9L298p2vHP5ZywrVXmVXpmAD9GuL5MPH6t9ROw1iA/wfHkQ76Qe7AaPF0nGuim96/IrQMQ==",
+      "version": "6.4.0",
+      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-6.4.0.tgz",
+      "integrity": "sha512-0ghuzq67LI9bLXpOX/ISfve/Mq33a4aFRzoQYhnnok1JOFpmE/A2TBGkNVenOGEeSBCjIiWcc6MVOG5HEQv0sA==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "@babel/regjsgen": "^0.8.0",
         "regenerate": "^1.4.2",
-        "regenerate-unicode-properties": "^10.1.0",
-        "regjsparser": "^0.9.1",
+        "regenerate-unicode-properties": "^10.2.2",
+        "regjsgen": "^0.8.0",
+        "regjsparser": "^0.13.0",
         "unicode-match-property-ecmascript": "^2.0.0",
-        "unicode-match-property-value-ecmascript": "^2.1.0"
+        "unicode-match-property-value-ecmascript": "^2.2.1"
       },
       "engines": {
         "node": ">=4"
       }
     },
+    "node_modules/regjsgen": {
+      "version": "0.8.0",
+      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.8.0.tgz",
+      "integrity": "sha512-RvwtGe3d7LvWiDQXeQw8p5asZUmfU1G/l6WbUXeHta7Y2PEIvBTwH6E2EfmYUK8pxcxEdEmaomqyp0vZZ7C+3Q==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/regjsparser": {
-      "version": "0.9.1",
-      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.9.1.tgz",
-      "integrity": "sha512-dQUtn90WanSNl+7mQKcXAgZxvUe7Z0SqXlgzv0za4LwiUhyzBC58yQO3liFoUgu8GiJVInAhJjkj1N0EtQ5nkQ==",
+      "version": "0.13.0",
+      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.13.0.tgz",
+      "integrity": "sha512-NZQZdC5wOE/H3UT28fVGL+ikOZcEzfMGk/c3iN9UGxzWHMa1op7274oyiUVrAG4B2EuFhus8SvkaYnhvW92p9Q==",
       "dev": true,
       "license": "BSD-2-Clause",
       "dependencies": {
-        "jsesc": "~0.5.0"
+        "jsesc": "~3.1.0"
       },
       "bin": {
         "regjsparser": "bin/parser"
       }
     },
-    "node_modules/regjsparser/node_modules/jsesc": {
-      "version": "0.5.0",
-      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-0.5.0.tgz",
-      "integrity": "sha512-uZz5UnB7u4T9LvwmFqXii7pZSouaRPorGs5who1Ip7VO0wxanFvBL7GkM6dTHlgX+jhBApRetaWpnDabOeTcnA==",
-      "dev": true,
-      "bin": {
-        "jsesc": "bin/jsesc"
-      }
-    },
     "node_modules/relateurl": {
       "version": "0.2.7",
       "resolved": "https://registry.npmjs.org/relateurl/-/relateurl-0.2.7.tgz",
@@ -28908,18 +29153,21 @@
       }
     },
     "node_modules/resolve": {
-      "version": "1.22.8",
-      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.8.tgz",
-      "integrity": "sha512-oKWePCxqpd6FlLvGV1VU0x7bkPmmCNolxzjMf4NczoDnQcIWrAF+cPtZn5i6n+RfD2d9i0tzpKnG6Yk168yIyw==",
+      "version": "1.22.11",
+      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
+      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
       "license": "MIT",
       "dependencies": {
-        "is-core-module": "^2.13.0",
+        "is-core-module": "^2.16.1",
         "path-parse": "^1.0.7",
         "supports-preserve-symlinks-flag": "^1.0.0"
       },
       "bin": {
         "resolve": "bin/resolve"
       },
+      "engines": {
+        "node": ">= 0.4"
+      },
       "funding": {
         "url": "https://github.com/sponsors/ljharb"
       }
@@ -28973,10 +29221,9 @@
       }
     },
     "node_modules/resolve.exports": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/resolve.exports/-/resolve.exports-2.0.2.tgz",
-      "integrity": "sha512-X2UW6Nw3n/aMgDVy+0rSqgHlv39WZAlZrXCdnbyEiKm17DSqHX4MmQMaST3FbeWR5FTuRcUwYAziZajji0Y7mg==",
-      "dev": true,
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/resolve.exports/-/resolve.exports-2.0.3.tgz",
+      "integrity": "sha512-OcXjMsGdhL4XnbShKpAcSqPMzQoYkYyhbEaeSko47MjRP9NfEQMhZkXL1DoFlt9LWQn4YttrdnV6X2OiyzBi+A==",
       "license": "MIT",
       "engines": {
         "node": ">=10"
@@ -29028,15 +29275,6 @@
         "node": ">=0.10.0"
       }
     },
-    "node_modules/revalidator": {
-      "version": "0.1.8",
-      "resolved": "https://registry.npmjs.org/revalidator/-/revalidator-0.1.8.tgz",
-      "integrity": "sha512-xcBILK2pA9oh4SiinPEZfhP8HfrB/ha+a2fTMyl7Om2WjlDVrOQy99N2MXXlUHqGJz4qEu2duXxHJjDWuK/0xg==",
-      "license": "Apache 2.0",
-      "engines": {
-        "node": ">= 0.4.0"
-      }
-    },
     "node_modules/rimraf": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-6.0.1.tgz",
@@ -29187,9 +29425,9 @@
       "license": "Unlicense"
     },
     "node_modules/rollup": {
-      "version": "4.46.4",
-      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.46.4.tgz",
-      "integrity": "sha512-YbxoxvoqNg9zAmw4+vzh1FkGAiZRK+LhnSrbSrSXMdZYsRPDWoshcSd/pldKRO6lWzv/e9TiJAVQyirYIeSIPQ==",
+      "version": "4.50.2",
+      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.50.2.tgz",
+      "integrity": "sha512-BgLRGy7tNS9H66aIMASq1qSYbAAJV6Z6WR4QYTvj5FgF15rZ/ympT1uixHXwzbZUBDbkvqUI1KR0fH1FhMaQ9w==",
       "license": "MIT",
       "dependencies": {
         "@types/estree": "1.0.8"
@@ -29202,26 +29440,27 @@
         "npm": ">=8.0.0"
       },
       "optionalDependencies": {
-        "@rollup/rollup-android-arm-eabi": "4.46.4",
-        "@rollup/rollup-android-arm64": "4.46.4",
-        "@rollup/rollup-darwin-arm64": "4.46.4",
-        "@rollup/rollup-darwin-x64": "4.46.4",
-        "@rollup/rollup-freebsd-arm64": "4.46.4",
-        "@rollup/rollup-freebsd-x64": "4.46.4",
-        "@rollup/rollup-linux-arm-gnueabihf": "4.46.4",
-        "@rollup/rollup-linux-arm-musleabihf": "4.46.4",
-        "@rollup/rollup-linux-arm64-gnu": "4.46.4",
-        "@rollup/rollup-linux-arm64-musl": "4.46.4",
-        "@rollup/rollup-linux-loongarch64-gnu": "4.46.4",
-        "@rollup/rollup-linux-ppc64-gnu": "4.46.4",
-        "@rollup/rollup-linux-riscv64-gnu": "4.46.4",
-        "@rollup/rollup-linux-riscv64-musl": "4.46.4",
-        "@rollup/rollup-linux-s390x-gnu": "4.46.4",
-        "@rollup/rollup-linux-x64-gnu": "4.46.4",
-        "@rollup/rollup-linux-x64-musl": "4.46.4",
-        "@rollup/rollup-win32-arm64-msvc": "4.46.4",
-        "@rollup/rollup-win32-ia32-msvc": "4.46.4",
-        "@rollup/rollup-win32-x64-msvc": "4.46.4",
+        "@rollup/rollup-android-arm-eabi": "4.50.2",
+        "@rollup/rollup-android-arm64": "4.50.2",
+        "@rollup/rollup-darwin-arm64": "4.50.2",
+        "@rollup/rollup-darwin-x64": "4.50.2",
+        "@rollup/rollup-freebsd-arm64": "4.50.2",
+        "@rollup/rollup-freebsd-x64": "4.50.2",
+        "@rollup/rollup-linux-arm-gnueabihf": "4.50.2",
+        "@rollup/rollup-linux-arm-musleabihf": "4.50.2",
+        "@rollup/rollup-linux-arm64-gnu": "4.50.2",
+        "@rollup/rollup-linux-arm64-musl": "4.50.2",
+        "@rollup/rollup-linux-loong64-gnu": "4.50.2",
+        "@rollup/rollup-linux-ppc64-gnu": "4.50.2",
+        "@rollup/rollup-linux-riscv64-gnu": "4.50.2",
+        "@rollup/rollup-linux-riscv64-musl": "4.50.2",
+        "@rollup/rollup-linux-s390x-gnu": "4.50.2",
+        "@rollup/rollup-linux-x64-gnu": "4.50.2",
+        "@rollup/rollup-linux-x64-musl": "4.50.2",
+        "@rollup/rollup-openharmony-arm64": "4.50.2",
+        "@rollup/rollup-win32-arm64-msvc": "4.50.2",
+        "@rollup/rollup-win32-ia32-msvc": "4.50.2",
+        "@rollup/rollup-win32-x64-msvc": "4.50.2",
         "fsevents": "~2.3.2"
       }
     },
@@ -29245,9 +29484,9 @@
       }
     },
     "node_modules/rollup-plugin-node-externals": {
-      "version": "8.1.0",
-      "resolved": "https://registry.npmjs.org/rollup-plugin-node-externals/-/rollup-plugin-node-externals-8.1.0.tgz",
-      "integrity": "sha512-0D3S0E0Dl1V3Q6Cywnc7wt88VAfOB9AC5QHwVdgvP1vByRHW2wnEXoK0x3VYZzJ/EmGsR5Uix5HUmMJNG+hz2Q==",
+      "version": "8.1.1",
+      "resolved": "https://registry.npmjs.org/rollup-plugin-node-externals/-/rollup-plugin-node-externals-8.1.1.tgz",
+      "integrity": "sha512-MEWJmXMGjo5E7o9hgAmma6XLCdU9gTVRcaaCubugTJdoJD3A91qxtxiukT9k2PeUdogtCaNehV3pvJUWrRNtwg==",
       "funding": [
         {
           "type": "patreon",
@@ -29295,12 +29534,13 @@
       }
     },
     "node_modules/router/node_modules/path-to-regexp": {
-      "version": "8.2.0",
-      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
-      "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
+      "version": "8.3.0",
+      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz",
+      "integrity": "sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==",
       "license": "MIT",
-      "engines": {
-        "node": ">=16"
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/express"
       }
     },
     "node_modules/rspack-resolver": {
@@ -30040,22 +30280,6 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
-    "node_modules/shiki": {
-      "version": "1.29.2",
-      "resolved": "https://registry.npmjs.org/shiki/-/shiki-1.29.2.tgz",
-      "integrity": "sha512-njXuliz/cP+67jU2hukkxCNuH1yUi4QfdZZY+sMr5PPrIyXSu5iTb/qYC4BiWWB0vZ+7TbdvYUCeL23zpwCfbg==",
-      "license": "MIT",
-      "dependencies": {
-        "@shikijs/core": "1.29.2",
-        "@shikijs/engine-javascript": "1.29.2",
-        "@shikijs/engine-oniguruma": "1.29.2",
-        "@shikijs/langs": "1.29.2",
-        "@shikijs/themes": "1.29.2",
-        "@shikijs/types": "1.29.2",
-        "@shikijs/vscode-textmate": "^10.0.1",
-        "@types/hast": "^3.0.4"
-      }
-    },
     "node_modules/side-channel": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
@@ -30467,15 +30691,6 @@
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/stack-trace": {
-      "version": "0.0.10",
-      "resolved": "https://registry.npmjs.org/stack-trace/-/stack-trace-0.0.10.tgz",
-      "integrity": "sha512-KGzahc7puUKkzyMt+IqAep+TVNbKP+k2Lmwhub39m1AsTSkaDutx56aDCo+HLDzf/D26BIHTJWNiTG1KAJiQCg==",
-      "license": "MIT",
-      "engines": {
-        "node": "*"
-      }
-    },
     "node_modules/stack-utils": {
       "version": "2.0.6",
       "resolved": "https://registry.npmjs.org/stack-utils/-/stack-utils-2.0.6.tgz",
@@ -30579,7 +30794,6 @@
       "version": "4.2.3",
       "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
       "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "emoji-regex": "^8.0.0",
@@ -30594,7 +30808,6 @@
       "version": "8.0.0",
       "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
       "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/string-width/node_modules/emoji-regex": {
@@ -30747,7 +30960,6 @@
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
       "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-regex": "^5.0.1"
@@ -30878,18 +31090,6 @@
         "node": ">= 8.0"
       }
     },
-    "node_modules/superjson": {
-      "version": "2.2.2",
-      "resolved": "https://registry.npmjs.org/superjson/-/superjson-2.2.2.tgz",
-      "integrity": "sha512-5JRxVqC8I8NuOUjzBbvVJAKNM8qoVuH0O77h4WInc/qC2q5IreqKxYwgkga3PfA22OayK2ikceb/B26dztPl+Q==",
-      "license": "MIT",
-      "dependencies": {
-        "copy-anything": "^3.0.2"
-      },
-      "engines": {
-        "node": ">=16"
-      }
-    },
     "node_modules/supports-color": {
       "version": "7.2.0",
       "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
@@ -31376,13 +31576,13 @@
       "license": "MIT"
     },
     "node_modules/tinyglobby": {
-      "version": "0.2.12",
-      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.12.tgz",
-      "integrity": "sha512-qkf4trmKSIiMTs/E63cxH+ojC2unam7rJ0WrauAzpT3ECNTxGRMlaXxVbfxMUC/w0LaYk6jQ4y/nGR9uBO3tww==",
+      "version": "0.2.15",
+      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
+      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
       "license": "MIT",
       "dependencies": {
-        "fdir": "^6.4.3",
-        "picomatch": "^4.0.2"
+        "fdir": "^6.5.0",
+        "picomatch": "^4.0.3"
       },
       "engines": {
         "node": ">=12.0.0"
@@ -31392,10 +31592,13 @@
       }
     },
     "node_modules/tinyglobby/node_modules/fdir": {
-      "version": "6.4.3",
-      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.4.3.tgz",
-      "integrity": "sha512-PMXmW2y1hDDfTSRc9gaXIuCCRpuoz3Kaz8cUelp3smouvfT632ozg2vrT6lJsHKKOF59YLbOGfAWGUcKEfRMQw==",
+      "version": "6.5.0",
+      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
+      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
       "license": "MIT",
+      "engines": {
+        "node": ">=12.0.0"
+      },
       "peerDependencies": {
         "picomatch": "^3 || ^4"
       },
@@ -31406,9 +31609,9 @@
       }
     },
     "node_modules/tinyglobby/node_modules/picomatch": {
-      "version": "4.0.2",
-      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.2.tgz",
-      "integrity": "sha512-M7BAV6Rlcy5u+m6oPhAPFgJTzAioX/6B0DxyvDlo9l8+T3nLKbrczg2WLUyzd45L8RqfUMyGPzekbMvX2Ldkwg==",
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
+      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
       "license": "MIT",
       "engines": {
         "node": ">=12"
@@ -32085,9 +32288,9 @@
       "license": "MIT"
     },
     "node_modules/unicode-canonical-property-names-ecmascript": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-2.0.0.tgz",
-      "integrity": "sha512-yY5PpDlfVIU5+y/BSCxAJRBIS1Zc2dDG3Ujq+sR0U+JjUevW2JhocOF+soROYDSaAezOzOKuyyixhD6mBknSmQ==",
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-2.0.1.tgz",
+      "integrity": "sha512-dA8WbNeb2a6oQzAQ55YlT5vQAWGV9WXOsi3SskE3bcCdM0P4SDd+24zS/OCacdRq5BkdsRj9q3Pg6YyQoxIGqg==",
       "dev": true,
       "license": "MIT",
       "engines": {
@@ -32109,9 +32312,9 @@
       }
     },
     "node_modules/unicode-match-property-value-ecmascript": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-2.1.0.tgz",
-      "integrity": "sha512-qxkjQt6qjg/mYscYMC0XKRn3Rh0wFPlfxB0xkt9CfyTvpX1Ra0+rAmdX2QyAobptSEvuy4RtpPRui6XkV+8wjA==",
+      "version": "2.2.1",
+      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-2.2.1.tgz",
+      "integrity": "sha512-JQ84qTuMg4nVkx8ga4A16a1epI9H6uTXAknqxkGF/aFfRLw1xC/Bp24HNLaZhHSkWd3+84t8iXnp1J0kYcZHhg==",
       "dev": true,
       "license": "MIT",
       "engines": {
@@ -32119,9 +32322,9 @@
       }
     },
     "node_modules/unicode-property-aliases-ecmascript": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-2.1.0.tgz",
-      "integrity": "sha512-6t3foTQI9qne+OZoVQB/8x8rk2k1eVy1gRXhV3oFQ5T6R1dqQ1xtin3XqSlx3+ATBkliTaR/hHyJBm+LVPNM8w==",
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-2.2.0.tgz",
+      "integrity": "sha512-hpbDzxUY9BFwX+UeBnxv3Sh1q7HFxj48DTmXchNgRa46lO8uj3/1iEn3MiNUYTg1g9ctIqXCCERn8gYZhHC5lQ==",
       "dev": true,
       "license": "MIT",
       "engines": {
@@ -33271,32 +33474,6 @@
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/winston": {
-      "version": "2.4.7",
-      "resolved": "https://registry.npmjs.org/winston/-/winston-2.4.7.tgz",
-      "integrity": "sha512-vLB4BqzCKDnnZH9PHGoS2ycawueX4HLqENXQitvFHczhgW2vFpSOn31LZtVr1KU8YTw7DS4tM+cqyovxo8taVg==",
-      "license": "MIT",
-      "dependencies": {
-        "async": "^2.6.4",
-        "colors": "1.0.x",
-        "cycle": "1.0.x",
-        "eyes": "0.1.x",
-        "isstream": "0.1.x",
-        "stack-trace": "0.0.x"
-      },
-      "engines": {
-        "node": ">= 0.10.0"
-      }
-    },
-    "node_modules/winston/node_modules/async": {
-      "version": "2.6.4",
-      "resolved": "https://registry.npmjs.org/async/-/async-2.6.4.tgz",
-      "integrity": "sha512-mzo5dfJYwAn29PeiJ0zvwTo04zj8HDJj0Mn8TD7sno7q12prdbnasKJHhkm2c1LgrhlJ0teaea8860oxi51mGA==",
-      "license": "MIT",
-      "dependencies": {
-        "lodash": "^4.17.14"
-      }
-    },
     "node_modules/word-wrap": {
       "version": "1.2.5",
       "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
@@ -33329,7 +33506,6 @@
       "version": "7.0.0",
       "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
       "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-styles": "^4.0.0",
@@ -33610,6 +33786,16 @@
       }
     },
     "node_modules/zod-from-json-schema": {
+      "version": "0.5.0",
+      "resolved": "https://registry.npmjs.org/zod-from-json-schema/-/zod-from-json-schema-0.5.0.tgz",
+      "integrity": "sha512-W1v1YIoimOJfvuorGGp1QroizLL3jEGELJtgrHiVg/ytxVZdh/BTTVyPypGB7YK30LHrCkkebbjuyHIjBGCEzw==",
+      "license": "MIT",
+      "dependencies": {
+        "zod": "^4.0.17"
+      }
+    },
+    "node_modules/zod-from-json-schema-v3": {
+      "name": "zod-from-json-schema",
       "version": "0.0.5",
       "resolved": "https://registry.npmjs.org/zod-from-json-schema/-/zod-from-json-schema-0.0.5.tgz",
       "integrity": "sha512-zYEoo86M1qpA1Pq6329oSyHLS785z/mTwfr9V1Xf/ZLhuuBGaMlDGu/pDVGVUe4H4oa1EFgWZT53DP0U3oT9CQ==",
@@ -33618,10 +33804,19 @@
         "zod": "^3.24.2"
       }
     },
+    "node_modules/zod-from-json-schema/node_modules/zod": {
+      "version": "4.1.12",
+      "resolved": "https://registry.npmjs.org/zod/-/zod-4.1.12.tgz",
+      "integrity": "sha512-JInaHOamG8pt5+Ey8kGmdcAcg3OL9reK8ltczgHTAwNhMys/6ThXHityHxVV2p3fkw/c+MAvBHFVYHFZDmjMCQ==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://github.com/sponsors/colinhacks"
+      }
+    },
     "node_modules/zod-to-json-schema": {
-      "version": "3.24.5",
-      "resolved": "https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.5.tgz",
-      "integrity": "sha512-/AuWwMP+YqiPbsJx5D6TfgRTc4kTLjsh5SOcd4bLsfUg2RcEXrFMJl1DGgdHy2aCfsIA/cr/1JM0xcB2GZji8g==",
+      "version": "3.24.6",
+      "resolved": "https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.6.tgz",
+      "integrity": "sha512-h/z3PKvcTcTetyjl1fkj79MHNEjm+HpD6NXheWjzOekY7kV+lwDYnHw+ivHkijnCSMz1yJaWBD9vu/Fcmk+vEg==",
       "license": "ISC",
       "peerDependencies": {
         "zod": "^3.24.1"
diff --git a/package.json b/package.json
index e1012a7f1..d3e08514f 100644
--- a/package.json
+++ b/package.json
@@ -51,6 +51,10 @@
     ]
   },
   "jest": {
+    "testEnvironment": "jsdom",
+    "testEnvironmentOptions": {
+      "url": "http://localhost/"
+    },
     "moduleDirectories": [
       "node_modules",
       "release/app/node_modules",
@@ -64,39 +68,61 @@
       "json"
     ],
     "moduleNameMapper": {
+      "^@/(.*)$": "<rootDir>/src/$1",
       "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/.erb/mocks/fileMock.js",
-      "\\.(css|less|sass|scss)$": "identity-obj-proxy"
+      "\\.(css|less|sass|scss)$": "identity-obj-proxy",
+      "^(\\.{1,2}/.*)\\.js$": "$1"
     },
     "setupFiles": [
-      "./.erb/scripts/check-build-exists.ts"
+      "<rootDir>/.erb/scripts/check-build-exists.ts"
     ],
-    "testEnvironment": "jsdom",
-    "testEnvironmentOptions": {
-      "url": "http://localhost/"
-    },
     "testPathIgnorePatterns": [
       "release/app/dist",
-      ".erb/dll",
-      "src/__tests__/test-utils"
+      "\\.erb/dll",
+      "src/__tests__/.*/test-utils"
     ],
     "transform": {
-      "\\.(ts|tsx|js|jsx)$": "ts-jest"
+      "^.+\\.(js|jsx)$": [
+        "babel-jest",
+        {
+          "presets": [
+            [
+              "@babel/preset-env",
+              {
+                "targets": {
+                  "node": "current"
+                }
+              }
+            ]
+          ]
+        }
+      ],
+      "^.+\\.(ts|tsx)$": "ts-jest"
     },
-    "transformIgnorePatterns": [
-      "/node_modules/(?!(react-syntax-highlighter)/)"
-    ]
+    "transformIgnorePatterns": [],
+    "collectCoverageFrom": [
+      "src/**/*.{ts,tsx,js,jsx}",
+      "!src/__tests__/**",
+      "!src/**/__mocks__/**"
+    ],
+    "coverageReporters": [
+      "text-summary",
+      "lcov",
+      "html"
+    ],
+    "maxWorkers": 2
   },
   "dependencies": {
-    "@ai-sdk/openai-compatible": "^0.2.14",
+    "@ai-sdk/openai-compatible": "0.2.16",
     "@electron/notarize": "^3.0.0",
     "@emotion/react": "^11.14.0",
     "@emotion/styled": "^11.14.0",
     "@gitbeaker/rest": "^42.5.0",
-    "@mastra/core": "^0.14.1",
-    "@mastra/libsql": "^0.13.4",
-    "@mastra/loggers": "^0.10.9",
-    "@mastra/mcp": "^0.10.12",
-    "@mastra/memory": "^0.13.1",
+    "@mastra/core": "0.21.1",
+    "@mastra/libsql": "0.15.2",
+    "@mastra/loggers": "0.10.16",
+    "@mastra/mcp": "0.13.5",
+    "@mastra/memory": "^0.15.7",
     "@mui/icons-material": "^7.0.2",
     "@mui/material": "^7.0.2",
     "@radix-ui/react-dialog": "^1.1.10",
@@ -118,7 +144,7 @@
     "electron-updater": "^6.3.9",
     "intl-messageformat": "^10.7.16",
     "lucide-react": "^0.503.0",
-    "mastra": "^0.10.23",
+    "mastra": "0.17.0",
     "mermaid": "^11.6.0",
     "pdfjs-dist": "^5.2.133",
     "postcss": "^8.5.3",
@@ -137,6 +163,8 @@
     "zustand": "^5.0.4"
   },
   "devDependencies": {
+    "@babel/core": "^7.28.4",
+    "@babel/preset-env": "^7.28.3",
     "@electron/rebuild": "^3.6.1",
     "@pmmmwh/react-refresh-webpack-plugin": "^0.5.15",
     "@svgr/webpack": "^8.1.0",
@@ -154,6 +182,7 @@
     "@types/webpack-bundle-analyzer": "^4.7.0",
     "@typescript-eslint/eslint-plugin": "^8.40.0",
     "@typescript-eslint/parser": "^8.40.0",
+    "babel-jest": "^30.2.0",
     "browserslist-config-erb": "^0.0.3",
     "chalk": "^4.1.2",
     "concurrently": "^9.1.2",
diff --git a/src/__tests__/integration/SettingsModal.test.tsx b/src/__tests__/integration/SettingsModal.test.tsx
deleted file mode 100644
index 96994ecf5..000000000
--- a/src/__tests__/integration/SettingsModal.test.tsx
+++ /dev/null
@@ -1,677 +0,0 @@
-/**
- * @jest-environment jsdom
- */
-import React from 'react';
-import { render, screen, waitFor } from '@testing-library/react';
-import userEvent from '@testing-library/user-event';
-import '@testing-library/jest-dom';
-
-import SettingsModal from '../../renderer/components/common/SettingsModal';
-import { createMockElectronWithOptions } from '../../__tests__/test-utils/mockElectronHandler';
-
-describe('SettingsModal Component', () => {
-  // 共通のプロップス
-  const defaultProps = {
-    open: true,
-    onClose: jest.fn(),
-    onSettingsUpdated: jest.fn(),
-    onValidChange: jest.fn(),
-  };
-
-  // テスト前のセットアップ
-  beforeEach(() => {
-    window.electron = createMockElectronWithOptions();
-  });
-
-  // テスト後のクリーンアップ
-  afterEach(() => {
-    jest.clearAllMocks();
-  });
-
-  // テスト1: 正常に設定モーダルが表示され、初期値が設定されること
-  test('正常に設定モーダルが表示され、初期値が設定されること', async () => {
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    // 設定値が取得されるまで待機
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    // データベース設定
-    await waitFor(() => {
-      const dbPath = screen.getByRole('textbox', {
-        name: 'データベース保存フォルダ',
-      });
-      expect(dbPath).toHaveValue('/test/db');
-    });
-
-    // ソース設定
-    expect(screen.getByLabelText('ドキュメント格納フォルダ')).toHaveValue(
-      './test/source',
-    );
-
-    // API設定
-    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-    expect(apiKeyInput).toHaveValue('test-api-key');
-    expect(screen.getByLabelText('APIエンドポイントURL')).toHaveValue(
-      'https://api.test.com',
-    );
-    expect(screen.getByLabelText('モデル名')).toHaveValue('test-model');
-
-    // Redmine設定
-    const redmineEndpoint = screen.getByLabelText('Redmineエンドポイント');
-    const redmineApiKey = screen.getByLabelText('RedmineAPIキー');
-    expect(redmineEndpoint).toHaveValue('https://redmine.test.com');
-    expect(redmineApiKey).toHaveValue('test-redmine-key');
-
-    // GitLab設定
-    const gitlabEndpoint = screen.getByLabelText('GitLabエンドポイント');
-    const gitlabApiKey = screen.getByLabelText('GitLabAPIキー');
-    expect(gitlabEndpoint).toHaveValue('https://gitlab.test.com');
-    expect(gitlabApiKey).toHaveValue('test-gitlab-key');
-
-    // MCPサーバー設定
-    expect(screen.getByLabelText('MCPサーバー設定（JSON）')).toHaveValue(
-      '{"testMcp": {"url": "https://mcp.test.com"} }',
-    );
-
-    // システムプロンプト設定
-    expect(
-      screen.getByLabelText('システムプロンプトのカスタマイズが可能です'),
-    ).toHaveValue('test system prompt');
-  });
-
-  // テスト2: 設定値を更新して保存できること
-  test('設定値を更新して保存できること', async () => {
-    const user = userEvent.setup({ delay: null });
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    // 全ての入力フィールドが有効になるまで待機
-    await waitFor(() => {
-      const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-      expect(apiKeyInput).toBeEnabled();
-    });
-
-    // API設定の更新
-    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-    const apiEndpointInput = screen.getByLabelText('APIエンドポイントURL');
-    const apiModelInput = screen.getByLabelText('モデル名');
-
-    await user.clear(apiKeyInput);
-    await user.type(apiKeyInput, 'new-test-api-key');
-    await user.clear(apiEndpointInput);
-    await user.type(apiEndpointInput, 'https://new.api.test.com');
-    await user.clear(apiModelInput);
-    await user.type(apiModelInput, 'new-test-model');
-
-    // データベース設定の更新
-    const dbDirInput = screen.getByLabelText('データベース保存フォルダ');
-    await user.clear(dbDirInput);
-    await user.type(dbDirInput, '/new/test/db');
-
-    // ソース設定の更新
-    const sourceInput = screen.getByLabelText('ドキュメント格納フォルダ');
-    await user.clear(sourceInput);
-    await user.type(sourceInput, './new/test/source');
-
-    // Redmine設定の更新
-    const redmineEndpoint = screen.getByLabelText('Redmineエンドポイント');
-    const redmineApiKey = screen.getByLabelText('RedmineAPIキー');
-
-    await user.clear(redmineEndpoint);
-    await user.type(redmineEndpoint, 'https://new.redmine.test.com');
-    await user.clear(redmineApiKey);
-    await user.type(redmineApiKey, 'new-test-redmine-key');
-
-    // GitLab設定の更新
-    const gitlabEndpoint = screen.getByLabelText('GitLabエンドポイント');
-    const gitlabApiKey = screen.getByLabelText('GitLabAPIキー');
-
-    await user.clear(gitlabEndpoint);
-    await user.type(gitlabEndpoint, 'https://new.gitlab.test.com');
-    await user.clear(gitlabApiKey);
-    await user.type(gitlabApiKey, 'new-test-gitlab-key');
-
-    // MCPサーバー設定の更新
-    const mcpConfigInput = screen.getByLabelText('MCPサーバー設定（JSON）');
-    const validMcpConfig = {
-      weather: {
-        command: 'npx',
-        args: ['tsx', 'weather.ts'],
-        env: { API_KEY: 'test-key' },
-        cwd: '/test/weather',
-      },
-    };
-    await user.clear(mcpConfigInput);
-    await userEvent.type(
-      mcpConfigInput,
-      JSON.stringify(validMcpConfig, null, 2).replace(/[{[]/g, '$&$&'),
-    );
-
-    // システムプロンプト設定の更新
-    const systemPromptInput = screen.getByLabelText(
-      'システムプロンプトのカスタマイズが可能です',
-    );
-    await user.clear(systemPromptInput);
-    await user.type(systemPromptInput, 'new test system prompt');
-
-    // 保存ボタンをクリック
-    await waitFor(() => {
-      expect(screen.getByText('保存')).toBeEnabled();
-    });
-    await user.click(screen.getByText('保存'));
-
-    // 各設定の更新が正しく呼ばれることを確認
-    await waitFor(() => {
-      // API設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('api', {
-        key: 'new-test-api-key',
-        url: 'https://new.api.test.com',
-        model: 'new-test-model',
-      });
-
-      // データベース設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('database', {
-        dir: '/new/test/db',
-      });
-
-      // ソース設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('source', {
-        registerDir: './new/test/source',
-      });
-
-      // Redmine設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('redmine', {
-        endpoint: 'https://new.redmine.test.com',
-        apiKey: 'new-test-redmine-key',
-      });
-
-      // GitLab設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('gitlab', {
-        endpoint: 'https://new.gitlab.test.com',
-        apiKey: 'new-test-gitlab-key',
-      });
-
-      // MCP設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('mcp', {
-        serverConfigText: JSON.stringify(validMcpConfig, null, 2),
-      });
-
-      // システムプロンプト設定
-      expect(window.electron.store.set).toHaveBeenCalledWith('systemPrompt', {
-        content: 'new test system prompt',
-      });
-    });
-
-    // エージェントの再初期化が呼ばれることを確認
-    expect(window.electron.settings.reinitialize).toHaveBeenCalled();
-
-    // コールバック関数が呼ばれることを確認
-    expect(defaultProps.onSettingsUpdated).toHaveBeenCalled();
-    expect(defaultProps.onClose).toHaveBeenCalled();
-    expect(defaultProps.onValidChange).toHaveBeenCalledWith(true);
-  }, 60000);
-
-  // テスト3: バリデーションエラーが正しく表示されること
-  test('バリデーションエラーが正しく表示されること', async () => {
-    window.electron = createMockElectronWithOptions({
-      fsAccess: false,
-    });
-
-    const user = userEvent.setup({ delay: null });
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    // 必須フィールドを空にする
-    const apiKeyInput = screen.getByLabelText('APIキー');
-    const apiEndpointInput = screen.getByLabelText('APIエンドポイントURL');
-    const apiModelInput = screen.getByLabelText('モデル名');
-    const dbDirInput = screen.getByLabelText('データベース保存フォルダ');
-
-    await waitFor(() => {
-      expect(apiKeyInput).toBeEnabled();
-    });
-
-    // 必須フィールドをクリア
-    await user.clear(apiKeyInput);
-    await user.clear(apiEndpointInput);
-    await user.clear(apiModelInput);
-    await user.clear(dbDirInput);
-
-    // 無効なURL形式を入力
-    const redmineEndpoint = screen.getByLabelText('Redmineエンドポイント');
-    const gitlabEndpoint = screen.getByLabelText('GitLabエンドポイント');
-
-    await user.clear(apiEndpointInput);
-    await user.type(apiEndpointInput, 'invalid-url');
-    await user.clear(redmineEndpoint);
-    await user.type(redmineEndpoint, 'not-a-url');
-    await user.clear(gitlabEndpoint);
-    await user.type(gitlabEndpoint, 'wrong-url');
-
-    // MCPサーバー設定の無効な形式をテスト
-    const mcpConfigInput = screen.getByLabelText('MCPサーバー設定（JSON）');
-
-    // 無効なJSON構文
-    await user.clear(mcpConfigInput);
-    await userEvent.type(
-      mcpConfigInput,
-      '{ invalid json'.replace(/[{[]/g, '$&$&'),
-    );
-
-    // バリデーションエラーメッセージが表示されることを確認
-    await waitFor(() => {
-      // 必須フィールドのエラー
-      expect(screen.getByText('APIキーは必須です')).toBeInTheDocument();
-      expect(screen.getByText('モデル名は必須です')).toBeInTheDocument();
-
-      // パスが存在しないエラー（DB,ドキュメント登録フォルダ）
-      expect(
-        screen.getAllByText('指定されたパスが存在しません').length,
-      ).toEqual(2);
-
-      // 無効なURL形式のエラー
-      expect(screen.getAllByText('有効なURLを入力してください').length).toEqual(
-        3,
-      );
-
-      // MCPサーバー設定のエラー
-      expect(screen.getByText('JSONの形式が不正です')).toBeInTheDocument();
-    });
-
-    // 保存ボタンが無効化されていることを確認
-    expect(screen.getByText('保存')).toBeDisabled();
-
-    // バリデーションエラー状態であることを確認
-    await waitFor(() => {
-      expect(defaultProps.onValidChange).toHaveBeenLastCalledWith(false);
-    });
-  }, 30000);
-
-  // テスト4: MCPスキーマのバリデーションエラーが正しく表示されること
-  test('MCPスキーマのバリデーションエラーが正しく表示されること', async () => {
-    const user = userEvent.setup({ delay: null });
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    const mcpConfigInput = screen.getByLabelText('MCPサーバー設定（JSON）');
-    await waitFor(() => {
-      expect(mcpConfigInput).toBeEnabled();
-    });
-
-    // 1. 不正なコマンド構造 (必須フィールドの欠如)
-    await user.clear(mcpConfigInput);
-    await userEvent.type(
-      mcpConfigInput,
-      JSON.stringify(
-        {
-          weather: {
-            wrong_field: 'value',
-          },
-        },
-        null,
-        2,
-      ).replace(/[{[]/g, '$&$&'),
-    );
-
-    await waitFor(() => {
-      const element = screen.getByText((content, element) =>
-        content.includes('MCP設定形式が不正です'),
-      );
-      expect(element).toBeInTheDocument();
-      expect(screen.getByText('保存')).toBeDisabled();
-    });
-
-    // 2. 不正な引数フォーマット
-    await user.clear(mcpConfigInput);
-    await userEvent.type(
-      mcpConfigInput,
-      JSON.stringify(
-        {
-          weather: {
-            command: 'npx',
-            args: 'not-an-array',
-          },
-        },
-        null,
-        2,
-      ).replace(/[{[]/g, '$&$&'),
-    );
-
-    await waitFor(() => {
-      const element = screen.getByText((content, element) =>
-        content.includes('MCP設定形式が不正です'),
-      );
-      expect(element).toBeInTheDocument();
-      expect(screen.getByText('保存')).toBeDisabled();
-    });
-
-    // 3. 不正なURL形式
-    await user.clear(mcpConfigInput);
-    await userEvent.type(
-      mcpConfigInput,
-      JSON.stringify(
-        {
-          service: {
-            url: 'invalid-url',
-          },
-        },
-        null,
-        2,
-      ).replace(/[{[]/g, '$&$&'),
-    );
-
-    await waitFor(() => {
-      const element = screen.getByText((content, element) =>
-        content.includes('MCP設定形式が不正です'),
-      );
-      expect(element).toBeInTheDocument();
-      expect(screen.getByText('保存')).toBeDisabled();
-    });
-
-    // 4. 不正な環境変数形式
-    await user.clear(mcpConfigInput);
-    await userEvent.type(
-      mcpConfigInput,
-      JSON.stringify(
-        {
-          weather: {
-            command: 'npx',
-            env: ['not', 'an', 'object'],
-          },
-        },
-        null,
-        2,
-      ).replace(/[{[]/g, '$&$&'),
-    );
-
-    await waitFor(() => {
-      const element = screen.getByText((content, element) =>
-        content.includes('MCP設定形式が不正です'),
-      );
-      expect(element).toBeInTheDocument();
-      expect(screen.getByText('保存')).toBeDisabled();
-    });
-
-    // バリデーション失敗の状態を確認
-    await waitFor(() => {
-      expect(defaultProps.onValidChange).toHaveBeenLastCalledWith(false);
-    });
-  }, 20000);
-
-  // テスト5: 保存に失敗した場合のエラー表示を確認
-  test('保存に失敗した場合のエラー表示を確認', async () => {
-    const user = userEvent.setup({ delay: null });
-
-    // ストアの更新に失敗するようにモックを設定
-    window.electron.store.set = jest
-      .fn()
-      .mockRejectedValue(new Error('Failed to save settings'));
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    // APIキーを更新してバリデーション完了を待機
-    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-    await waitFor(() => {
-      expect(apiKeyInput).toBeEnabled();
-    });
-
-    await user.type(apiKeyInput, 'new-api-key');
-
-    // バリデーションの完了を待機
-    await waitFor(() => {
-      expect(defaultProps.onValidChange).toHaveBeenCalledWith(true);
-    });
-
-    // 保存ボタンが有効になることを確認
-    await waitFor(() => {
-      expect(screen.getByText('保存')).toBeEnabled();
-    });
-
-    // 保存ボタンをクリック
-    await user.click(screen.getByText('保存'));
-
-    // エラーメッセージが表示されることを確認
-    await waitFor(() => {
-      expect(screen.getByText('Failed to save settings')).toBeInTheDocument();
-    });
-
-    // モーダルが閉じられないことを確認
-    expect(defaultProps.onClose).not.toHaveBeenCalled();
-  });
-
-  // テスト6: キャンセルボタンの動作を確認
-  test('キャンセルボタンの動作を確認', async () => {
-    const user = userEvent.setup({ delay: null });
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    // APIキーを更新
-    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-    await waitFor(() => {
-      expect(apiKeyInput).toBeEnabled();
-    });
-    await user.clear(apiKeyInput);
-    await user.type(apiKeyInput, 'new-api-key');
-
-    // キャンセルボタンをクリック
-    await user.click(screen.getByText('キャンセル'));
-
-    // storeのset関数が呼ばれないことを確認
-    expect(window.electron.store.set).not.toHaveBeenCalled();
-
-    // モーダルが閉じられることを確認
-    expect(defaultProps.onClose).toHaveBeenCalled();
-  });
-
-  // テスト7: ローディング状態の表示を確認
-  test('ローディング状態の表示を確認', async () => {
-    // ストアの取得を遅延させる
-    window.electron.store.get = jest.fn().mockImplementation((key: string) => {
-      return new Promise((resolve) => {
-        setTimeout(() => {
-          if (key === 'api') {
-            resolve({
-              key: 'test-api-key',
-              url: 'https://api.test.com',
-              model: 'test-model',
-            });
-          } else {
-            resolve(undefined);
-          }
-        }, 100);
-      });
-    });
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    // 全ての入力フィールドが無効化されていることを確認
-    const inputs = screen.getAllByRole('textbox');
-    inputs.forEach((input) => {
-      expect(input).toBeDisabled();
-    });
-
-    // データがロードされるまで待機
-    await waitFor(
-      () => {
-        const textInputs = screen.getAllByRole('textbox');
-        expect(textInputs[0]).toBeEnabled();
-      },
-      { timeout: 1000 },
-    );
-  });
-
-  // テスト8: 保存中の状態表示を確認
-  test('保存中の状態表示を確認', async () => {
-    const user = userEvent.setup({ delay: null });
-
-    // ストアの更新を遅延させる
-    window.electron.store.set = jest.fn().mockImplementation(
-      () =>
-        new Promise((resolve) => {
-          setTimeout(() => {
-            resolve(undefined);
-          }, 100);
-        }),
-    );
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    await waitFor(() => {
-      expect(window.electron.store.get).toHaveBeenCalledTimes(7);
-    });
-
-    // APIキーを更新
-    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-    await waitFor(() => {
-      expect(apiKeyInput).toBeEnabled();
-    });
-    await user.clear(apiKeyInput);
-    await user.type(apiKeyInput, 'new-api-key');
-    await new Promise((resolve) => {
-      setTimeout(resolve, 500);
-    });
-
-    // バリデーション状態の確認
-    await waitFor(
-      () => {
-        const { mock } = defaultProps.onValidChange as jest.Mock;
-        expect(mock.calls[mock.calls.length - 1][0]).toBe(true);
-      },
-      { timeout: 5000 },
-    );
-
-    // 保存ボタンの状態を確認
-    await waitFor(
-      () => {
-        const saveButton = screen.getByText('保存');
-        expect(saveButton).toBeEnabled();
-      },
-      { timeout: 2000 },
-    );
-
-    // 保存ボタンをクリック
-    await user.click(screen.getByText('保存'));
-
-    // ボタンが無効化され、ローディングアイコンが表示されることを確認
-    expect(screen.getByText('保存')).toBeDisabled();
-    expect(screen.getByRole('progressbar')).toBeInTheDocument();
-
-    // 保存が完了するまで待機
-    await waitFor(
-      () => {
-        expect(defaultProps.onClose).toHaveBeenCalled();
-      },
-      { timeout: 1000 },
-    );
-  });
-
-  // テスト9: 設定の取得に失敗した場合のエラー表示を確認
-  test('設定の取得に失敗した場合のエラー表示を確認', async () => {
-    // コンソールエラーをスパイ
-    const consoleSpy = jest
-      .spyOn(console, 'error')
-      .mockImplementation(() => {});
-
-    // ストアの取得に失敗するようにモックを設定
-    window.electron.store.get = jest
-      .fn()
-      .mockRejectedValue(new Error('Failed to get settings'));
-
-    render(
-      <SettingsModal
-        open={defaultProps.open}
-        onClose={defaultProps.onClose}
-        onSettingsUpdated={defaultProps.onSettingsUpdated}
-        onValidChange={defaultProps.onValidChange}
-      />,
-    );
-
-    // エラーログが出力されることを確認
-    await waitFor(() => {
-      expect(consoleSpy).toHaveBeenCalledWith(
-        'Failed to get value for key "database":',
-        expect.any(Error),
-      );
-    });
-
-    consoleSpy.mockRestore();
-  });
-});
diff --git a/src/__tests__/integration/Sidebar.test.tsx b/src/__tests__/integration/Sidebar.test.tsx
deleted file mode 100644
index a66dd0796..000000000
--- a/src/__tests__/integration/Sidebar.test.tsx
+++ /dev/null
@@ -1,603 +0,0 @@
-/**
- * @jest-environment jsdom
- */
-import React from 'react';
-import { render, screen, waitFor, act } from '@testing-library/react';
-import { MemoryRouter, Route, Routes } from 'react-router-dom';
-import userEvent from '@testing-library/user-event';
-import '@testing-library/jest-dom';
-import { v4 as uuidv4 } from 'uuid';
-
-import Sidebar from '@/renderer/components/sidebar/Sidebar';
-import type { ChatRoom, ProcessStatus } from '@/types';
-import type { Source } from '@/db/schema';
-import { StoreSchema as Settings } from '@/adapter/db/electron-store/store';
-import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
-import ChatRoomList from '@/renderer/components/chat/ChatRoomList';
-import ReviewHistoryList from '@/renderer/components/review/ReviewHistoryList';
-import { ROUTES } from '@/types';
-
-// uuidv4をモック化
-jest.mock('uuid', () => ({
-  v4: jest.fn(),
-}));
-
-// テスト用のモックデータ
-const mockChatRooms: ChatRoom[] = [
-  {
-    id: '1',
-    resourceId: 'resource-1',
-    title: 'Chat Room 1',
-    createdAt: new Date('2025-05-01T12:00:00.000Z'),
-    updatedAt: new Date('2025-05-01T12:00:00.000Z'),
-  },
-  {
-    id: '2',
-    resourceId: 'resource-2',
-    title: 'Chat Room 2',
-    createdAt: new Date('2025-05-02T12:00:00.000Z'),
-    updatedAt: new Date('2025-05-02T12:00:00.000Z'),
-  },
-];
-
-// ソースのモックデータ
-const mockSources: Source[] = [
-  {
-    id: 1,
-    path: '/test/source1.md',
-    title: 'Source 1',
-    status: 'completed' as ProcessStatus,
-    isEnabled: 1,
-    error: null,
-    createdAt: '2025-05-01T12:00:00.000Z',
-    updatedAt: '2025-05-01T12:00:00.000Z',
-    summary: 'Test summary 1',
-  },
-  {
-    id: 2,
-    path: '/test/source2.md',
-    title: 'Source 2',
-    status: 'completed' as ProcessStatus,
-    isEnabled: 1,
-    error: null,
-    createdAt: '2025-05-02T12:00:00.000Z',
-    updatedAt: '2025-05-02T12:00:00.000Z',
-    summary: 'Test summary 2',
-  },
-  {
-    id: 3,
-    path: '/test/source3.md',
-    title: 'Source 3',
-    status: 'failed' as ProcessStatus,
-    isEnabled: 0,
-    error: 'Processing error',
-    createdAt: '2025-05-03T12:00:00.000Z',
-    updatedAt: '2025-05-03T12:00:00.000Z',
-    summary: 'Test summary 3',
-  },
-];
-
-describe('Sidebar Component', () => {
-  // テスト前のセットアップ
-  beforeEach(() => {
-    // Electronグローバルオブジェクトをモック化
-    window.electron = createMockElectronWithOptions({
-      chatRooms: mockChatRooms,
-      sources: mockSources,
-    });
-
-    // uuidv4のモックをリセット
-    (uuidv4 as jest.Mock).mockReset();
-    (uuidv4 as jest.Mock).mockReturnValue('new-room-id');
-  });
-
-  // テスト後のクリーンアップ
-  afterEach(() => {
-    jest.clearAllMocks();
-  });
-
-  // 共通のプロップス
-  const defaultProps = {
-    selectedRoomId: null,
-    onRoomSelect: jest.fn(),
-    onReloadSources: jest.fn(),
-    showSnackbar: jest.fn(),
-    onSettingsUpdated: jest.fn(),
-  };
-
-  const renderAtPath = (initialPath: string) => {
-    render(
-      // MemoryRouter でテスト用の履歴を用意
-      <MemoryRouter initialEntries={[initialPath]}>
-        <Sidebar
-          onReloadSources={defaultProps.onReloadSources}
-          showSnackbar={defaultProps.showSnackbar}
-        >
-          <Routes>
-            <Route
-              path={ROUTES.CHAT}
-              element={
-                <ChatRoomList onRoomSelect={defaultProps.onRoomSelect} />
-              }
-            />
-            <Route
-              path={ROUTES.REVIEW}
-              element={
-                <ReviewHistoryList
-                  onReviewHistorySelect={defaultProps.onRoomSelect}
-                />
-              }
-            />
-          </Routes>
-        </Sidebar>
-      </MemoryRouter>,
-    );
-  };
-
-  // テスト1: 正常にサイドバーとチャットルーム一覧が表示されること
-  test('正常にサイドバーとチャットルーム一覧が表示されること', async () => {
-    renderAtPath(ROUTES.CHAT);
-
-    // New Chatボタンが表示されることを確認
-    expect(screen.getByText('新規チャット')).toBeInTheDocument();
-
-    // チャットルーム一覧が表示されるまで待機
-    await waitFor(() => {
-      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
-      expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
-    });
-
-    // フッターのボタンが表示されることを確認
-    expect(screen.getByLabelText('登録ドキュメント一覧')).toBeInTheDocument();
-    expect(screen.getByLabelText('設定')).toBeInTheDocument();
-  });
-
-  // テスト2: ローディング状態の表示が正しく機能すること
-  test('ローディング状態の表示が正しく機能すること', async () => {
-    // チャットルーム取得を遅延させる
-    window.electron.chat.getRooms = jest.fn().mockImplementation(
-      () =>
-        new Promise((resolve) => {
-          setTimeout(() => resolve(mockChatRooms), 100);
-        }),
-    );
-
-    renderAtPath(ROUTES.CHAT);
-
-    // ローディング表示を確認
-    expect(screen.getByText('チャット履歴取得中')).toBeInTheDocument();
-
-    // チャットルーム一覧が表示されるまで待機
-    await waitFor(() => {
-      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
-      expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
-    });
-
-    // ローディング表示が消えていることを確認
-    expect(screen.queryByText('チャット履歴取得中')).not.toBeInTheDocument();
-  });
-
-  // テスト3: チャットルームが空の場合の表示が正しいこと
-  test('チャットルームが空の場合の表示が正しいこと', async () => {
-    // 空の配列を返すようにモックを設定
-    window.electron.chat.getRooms = jest.fn().mockResolvedValue([]);
-
-    renderAtPath(ROUTES.CHAT);
-
-    // 空の状態のメッセージが表示されることを確認
-    await waitFor(() => {
-      expect(screen.getByText('チャット履歴がありません')).toBeInTheDocument();
-    });
-  });
-
-  // テスト4: 新規チャットルームの作成
-  test('新規チャットルームの作成', async () => {
-    const user = userEvent.setup();
-    renderAtPath(ROUTES.CHAT);
-    screen.debug(undefined, 100000);
-
-    // チャットルーム一覧が表示されるまで待機
-    await waitFor(() => {
-      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
-      expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
-    });
-
-    // New Chatボタンをクリック
-    await user.click(screen.getByText('新規チャット'));
-
-    // uuidv4が呼ばれることを確認
-    expect(uuidv4).toHaveBeenCalled();
-
-    // onRoomSelectが新しいIDで呼ばれることを確認
-    expect(defaultProps.onRoomSelect).toHaveBeenCalledWith('new-room-id');
-  });
-
-  // テスト5: チャットルームの選択
-  test('チャットルームの選択', async () => {
-    const user = userEvent.setup();
-    renderAtPath(ROUTES.CHAT);
-
-    // チャットルーム一覧が表示されるまで待機
-    await waitFor(() => {
-      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
-    });
-
-    // チャットルームをクリック
-    await user.click(screen.getByText('Chat Room 1'));
-
-    // onRoomSelectが正しいIDで呼ばれることを確認
-    expect(defaultProps.onRoomSelect).toHaveBeenCalledWith('1');
-  });
-
-  // テスト6: チャットルームの削除
-  test('チャットルームの削除の際に正しく指定したチャットルームが削除されること（チャットルームのソート確認も含む）', async () => {
-    const user = userEvent.setup();
-    renderAtPath(ROUTES.CHAT);
-
-    // チャットルーム一覧が表示されるまで待機
-    await waitFor(() => {
-      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
-    });
-
-    // メニューボタンをクリック
-    const menuButtons = screen.getAllByLabelText('more');
-    console.log('Menu buttons:', menuButtons);
-    await user.click(menuButtons[0]);
-
-    // 削除メニューが表示されることを確認
-    expect(screen.getByText('削除')).toBeInTheDocument();
-
-    // 削除メニューをクリック
-    await user.click(screen.getByText('削除'));
-
-    // deleteRoomが呼ばれることを確認(id:2のルームがソートされて一番上にくるはず)
-    expect(window.electron.chat.deleteRoom).toHaveBeenCalledWith('2');
-
-    // 一覧が再取得されることを確認
-    await waitFor(() => {
-      expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(2);
-    });
-  });
-
-  // テスト7: チャットルーム削除時のエラーハンドリング
-  test('チャットルーム削除時のエラーハンドリング', async () => {
-    // コンソールエラーをスパイ
-    const consoleSpy = jest
-      .spyOn(console, 'error')
-      .mockImplementation(() => {});
-
-    // 削除に失敗するようにモックを設定
-    window.electron.chat.deleteRoom = jest
-      .fn()
-      .mockRejectedValue(new Error('Failed to delete chat room'));
-
-    const user = userEvent.setup();
-    renderAtPath(ROUTES.CHAT);
-
-    // チャットルーム一覧が表示されるまで待機
-    await waitFor(() => {
-      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
-    });
-
-    // メニューボタンをクリック
-    const menuButtons = screen.getAllByLabelText('more');
-    await user.click(menuButtons[0]);
-
-    // 削除メニューをクリック
-    await user.click(screen.getByText('削除'));
-
-    // エラーログが出力されることを確認
-    await waitFor(() => {
-      expect(consoleSpy).toHaveBeenCalledWith(expect.any(Error));
-    });
-
-    consoleSpy.mockRestore();
-  });
-
-  // テスト8: フッターのソース一覧モーダル表示
-  test('フッターのソース一覧モーダル表示', async () => {
-    const user = userEvent.setup();
-    renderAtPath(ROUTES.CHAT);
-
-    // ソース一覧ボタンをクリック
-    await user.click(screen.getByTestId('document-list-button'));
-
-    // SourceListModalが表示されることを確認
-    expect(screen.getByText('登録ドキュメント一覧')).toBeInTheDocument();
-  });
-
-  // テスト9: フッターの設定モーダル表示
-  test('フッターの設定モーダル表示', async () => {
-    const user = userEvent.setup();
-    renderAtPath(ROUTES.CHAT);
-
-    // 設定ボタンをクリック
-    await user.click(screen.getByTestId('settings-button'));
-
-    // SettingsModalが表示されることを確認
-    expect(screen.getByRole('dialog')).toBeInTheDocument();
-  });
-
-  // テスト10: チャットルーム一覧の自動更新
-  test('チャットルーム一覧の自動更新', async () => {
-    // jestのタイマーを使用
-    jest.useFakeTimers();
-
-    renderAtPath(ROUTES.CHAT);
-
-    // 初回の取得を確認
-    await waitFor(() => {
-      expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(1);
-    });
-
-    // 5秒進める
-    jest.advanceTimersByTime(5000);
-
-    // 更新が呼ばれることを確認
-    expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(2);
-
-    // タイマーをクリーンアップ
-    jest.useRealTimers();
-  });
-
-  // テスト11: チャットルーム取得時のエラーハンドリング
-  test('チャットルーム取得時のエラーハンドリング', async () => {
-    // コンソールエラーをスパイ
-    const consoleSpy = jest
-      .spyOn(console, 'error')
-      .mockImplementation(() => {});
-
-    // 取得に失敗するようにモックを設定
-    window.electron.chat.getRooms = jest
-      .fn()
-      .mockRejectedValue(new Error('Failed to fetch chat rooms'));
-
-    renderAtPath(ROUTES.CHAT);
-
-    // エラーログが出力されることを確認
-    await waitFor(() => {
-      expect(consoleSpy).toHaveBeenCalledWith(expect.any(Error));
-    });
-
-    // ローディング状態が維持されることを確認
-    expect(screen.getByText('チャット履歴取得中')).toBeInTheDocument();
-
-    consoleSpy.mockRestore();
-  });
-
-  // テスト12: 設定エラーバッジの初期表示
-  test('設定エラーバッジの初期表示', async () => {
-    renderAtPath(ROUTES.CHAT);
-
-    // 設定エラーがない場合、バッジは非表示
-    const settingsButton = screen.getByTestId('settings-button');
-    const settingsButtonParent = settingsButton.closest('.MuiBadge-root');
-
-    await waitFor(() => {
-      const errorBadge = settingsButtonParent?.querySelector('.MuiBadge-badge');
-      expect(errorBadge).toHaveClass('MuiBadge-invisible');
-    });
-  });
-
-  // テスト13: 設定保存後のバッジ表示更新
-  test('設定保存後のバッジ表示更新', async () => {
-    const user = userEvent.setup({ delay: null });
-    renderAtPath(ROUTES.CHAT);
-
-    // 設定ボタンをクリックしてモーダルを開く
-    await user.click(screen.getByTestId('settings-button'));
-
-    // 設定が不正な状態を作る
-    const settingsModal = screen.getByRole('dialog');
-    await waitFor(() => {
-      expect(settingsModal).toBeInTheDocument();
-    });
-
-    // バリデーションエラーを発生させる
-    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
-    await waitFor(() => {
-      expect(apiKeyInput).toBeEnabled();
-    });
-    await user.clear(apiKeyInput);
-
-    // エラーバッジが表示されることを確認
-    const settingsButton = screen.getByTestId('settings-button');
-    const settingsButtonParent = settingsButton.closest('.MuiBadge-root');
-    const errorBadge = settingsButtonParent?.querySelector('.MuiBadge-badge');
-    await waitFor(() => {
-      expect(errorBadge).not.toHaveClass('MuiBadge-invisible');
-    });
-
-    // APIキーを入力して有効な状態にする
-    await user.type(apiKeyInput, 'valid-api-key');
-
-    // エラーバッジが非表示になることを確認
-    await waitFor(() => {
-      expect(errorBadge).toHaveClass('MuiBadge-invisible');
-    });
-  });
-
-  // テスト14: ソースリストの初期表示で有効なソース数が正しく表示される
-  test('ソースリストの初期表示で有効なソース数が正しく表示される', async () => {
-    // タイマーのモック
-    jest.useFakeTimers();
-
-    renderAtPath(ROUTES.CHAT);
-
-    // 進める
-    act(() => {
-      jest.advanceTimersByTime(5000);
-    });
-
-    // ソースデータが取得されるまで待機
-    await waitFor(() => {
-      expect(window.electron.source.getSources).toHaveBeenCalled();
-    });
-
-    // ソース一覧ボタンのバッジを取得
-    const sourceListButton = screen.getByTestId('document-list-button');
-    const sourceListButtonParent = sourceListButton.closest('.MuiBadge-root');
-    const badge = sourceListButtonParent?.querySelector('.MuiBadge-badge');
-
-    // バッジに正しい数が表示されていることを確認
-    await waitFor(() => {
-      expect(badge).toHaveTextContent('2');
-    });
-  });
-
-  // テスト15: ソースの読み込み中は処理中の表示になり、完了後にソース数が表示される
-  test('ソースの読み込み中は処理中の表示になり、完了後にソース数が表示される', async () => {
-    // タイマーのモック
-    jest.useFakeTimers();
-
-    // 処理中のソースデータ
-    const processingMockSources: Source[] = [
-      {
-        id: 1,
-        path: '/test/processing1.md',
-        title: 'Processing 1',
-        status: 'processing' as ProcessStatus,
-        isEnabled: 1,
-        error: null,
-        createdAt: '2025-05-01T12:00:00.000Z',
-        updatedAt: '2025-05-01T12:00:00.000Z',
-        summary: 'Test summary 1',
-      },
-      {
-        id: 2,
-        path: '/test/processing2.md',
-        title: 'Processing 2',
-        status: 'completed' as ProcessStatus,
-        isEnabled: 1,
-        error: null,
-        createdAt: '2025-05-02T12:00:00.000Z',
-        updatedAt: '2025-05-02T12:00:00.000Z',
-        summary: 'Test summary 2',
-      },
-    ];
-
-    // 完了後のソースデータ
-    const completedMockSources: Source[] = [
-      {
-        id: 1,
-        path: '/test/processing1.md',
-        title: 'Processing 1',
-        status: 'completed' as ProcessStatus,
-        isEnabled: 1,
-        error: null,
-        createdAt: '2025-05-01T12:00:00.000Z',
-        updatedAt: '2025-05-01T12:00:00.000Z',
-        summary: 'Test summary 1',
-      },
-      {
-        id: 2,
-        path: '/test/processing2.md',
-        title: 'Processing 2',
-        status: 'completed' as ProcessStatus,
-        isEnabled: 1,
-        error: null,
-        createdAt: '2025-05-02T12:00:00.000Z',
-        updatedAt: '2025-05-02T12:00:00.000Z',
-        summary: 'Test summary 2',
-      },
-    ];
-
-    // ソース取得のモックを設定（最初は処理中、その後完了）
-    window.electron.source.getSources = jest.fn().mockImplementation(() => {
-      return Promise.resolve({
-        success: true,
-        sources: processingMockSources,
-      });
-    });
-
-    renderAtPath(ROUTES.CHAT);
-
-    // ソースデータが取得されるまで待機
-    await waitFor(() => {
-      expect(window.electron.source.getSources).toHaveBeenCalled();
-    });
-
-    // 処理中のインジケータが表示されることを確認
-    await waitFor(() => {
-      expect(
-        screen.getByTestId('document-loading-indicator'),
-      ).toBeInTheDocument();
-    });
-
-    window.electron.source.getSources = jest.fn().mockImplementation(() => {
-      return Promise.resolve({
-        success: true,
-        sources: completedMockSources,
-      });
-    });
-
-    // 進める
-    act(() => {
-      jest.advanceTimersByTime(5000);
-    });
-
-    // ソースデータが取得されるまで待機
-    await waitFor(() => {
-      expect(window.electron.source.getSources).toHaveBeenCalled();
-    });
-
-    // バッジに有効なソース数（2）が表示されることを確認
-    await waitFor(() => {
-      const button = screen.getByTestId('document-list-button');
-      const buttonParent = button.closest('.MuiBadge-root');
-      const badge = buttonParent?.querySelector('.MuiBadge-badge');
-      expect(badge).toHaveTextContent('2');
-    });
-
-    // タイマーをクリーンアップ
-    jest.useRealTimers();
-  }, 20000);
-
-  // テスト16: ソース数が100以上の場合は99+と表示される
-  test('ソース数が100以上の場合は99+と表示される', async () => {
-    // タイマーのモック
-    jest.useFakeTimers();
-
-    // 100個以上の有効なソースを含むテストデータを生成
-    const largeMockSources: Source[] = Array.from({ length: 150 }, (_, i) => ({
-      id: i + 1,
-      path: `/test/source${i + 1}.md`,
-      title: `Source ${i + 1}`,
-      status: 'completed' as ProcessStatus,
-      isEnabled: 1,
-      error: null,
-      createdAt: '2025-05-01T12:00:00.000Z',
-      updatedAt: '2025-05-01T12:00:00.000Z',
-      summary: `Test summary ${i + 1}`,
-    }));
-
-    // ソース取得のモックを設定
-    window.electron.source.getSources = jest.fn().mockResolvedValue({
-      success: true,
-      sources: largeMockSources,
-    });
-
-    renderAtPath(ROUTES.CHAT);
-
-    // タイマーを進める
-    act(() => {
-      jest.advanceTimersByTime(5000);
-    });
-
-    // ソースデータが取得されるまで待機
-    await waitFor(() => {
-      expect(window.electron.source.getSources).toHaveBeenCalled();
-    });
-
-    // バッジに"99+"が表示されることを確認
-    await waitFor(() => {
-      const button = screen.getByTestId('document-list-button');
-      const buttonParent = button.closest('.MuiBadge-root');
-      const badge = buttonParent?.querySelector('.MuiBadge-badge');
-      expect(badge).toHaveTextContent('99+');
-    });
-
-    // タイマーをクリーンアップ
-    jest.useRealTimers();
-  });
-});
diff --git a/src/__tests__/main/csvParser.test.ts b/src/__tests__/main/csvParser.test.ts
new file mode 100644
index 000000000..749285be7
--- /dev/null
+++ b/src/__tests__/main/csvParser.test.ts
@@ -0,0 +1,140 @@
+import { CsvParser } from '@/main/lib/csvParser';
+import { AppError } from '@/main/lib/error';
+
+describe('CsvParser - 新フォーマット対応', () => {
+  describe('parseImportFormat', () => {
+    it('新フォーマットのCSVを正しくパースできること', () => {
+      const csvText = `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+要件が明確に定義されているか,,,,,,
+設計書に矛盾がないか,,,,,,
+,A,優秀 - 問題なし,,,,,
+,B,良好 - 軽微な改善推奨,,,,,
+,,,レビューは厳格に実施してください。,"【評価】{evaluation}
+【コメント】{comment}",http://localhost:11434/v1,test-api-key,llama3`;
+
+      const result = CsvParser.parseImportFormat(csvText);
+
+      // チェックリスト項目の検証
+      expect(result.checklists).toEqual([
+        '要件が明確に定義されているか',
+        '設計書に矛盾がないか',
+      ]);
+
+      // 評定設定の検証
+      expect(result.evaluationSettings).toBeDefined();
+      expect(result.evaluationSettings?.items).toEqual([
+        { label: 'A', description: '優秀 - 問題なし' },
+        { label: 'B', description: '良好 - 軽微な改善推奨' },
+      ]);
+
+      // 追加指示の検証
+      expect(result.additionalInstructions).toBe(
+        'レビューは厳格に実施してください。',
+      );
+
+      // コメントフォーマットの検証
+      expect(result.commentFormat).toBe(
+        '【評価】{evaluation}\n【コメント】{comment}',
+      );
+
+      // API設定の検証
+      expect(result.apiSettings).toEqual({
+        url: 'http://localhost:11434/v1',
+        key: 'test-api-key',
+        model: 'llama3',
+      });
+    });
+
+    it('チェックリスト項目のみのCSVを正しくパースできること', () => {
+      const csvText = `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,,
+項目2,,,,,,
+項目3,,,,,,`;
+
+      const result = CsvParser.parseImportFormat(csvText);
+
+      expect(result.checklists).toEqual(['項目1', '項目2', '項目3']);
+      expect(result.evaluationSettings).toBeUndefined();
+      expect(result.additionalInstructions).toBeUndefined();
+      expect(result.commentFormat).toBeUndefined();
+      expect(result.apiSettings).toBeUndefined();
+    });
+
+    it('評定設定のみのCSVを正しくパースできること', () => {
+      const csvText = `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+,A,優秀,,,,,
+,B,良好,,,,,
+,C,要改善,,,,,`;
+
+      const result = CsvParser.parseImportFormat(csvText);
+
+      expect(result.checklists).toEqual([]);
+      expect(result.evaluationSettings?.items).toEqual([
+        { label: 'A', description: '優秀' },
+        { label: 'B', description: '良好' },
+        { label: 'C', description: '要改善' },
+      ]);
+    });
+
+    it('空のCSVでエラーをスローすること', () => {
+      const csvText = '';
+
+      expect(() => {
+        CsvParser.parseImportFormat(csvText);
+      }).toThrow(AppError);
+
+      try {
+        CsvParser.parseImportFormat(csvText);
+      } catch (error) {
+        expect(error).toBeInstanceOf(AppError);
+        expect((error as AppError).message).toContain('空です');
+      }
+    });
+
+    it('不正なヘッダでエラーをスローすること', () => {
+      const csvText = `invalid,header
+データ1,データ2`;
+
+      expect(() => {
+        CsvParser.parseImportFormat(csvText);
+      }).toThrow(AppError);
+
+      try {
+        CsvParser.parseImportFormat(csvText);
+      } catch (error) {
+        expect(error).toBeInstanceOf(AppError);
+        expect((error as AppError).message).toContain('フォーマットが不正');
+      }
+    });
+
+    it('評定ラベルのみ（説明なし）は無視されること', () => {
+      const csvText = `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+,A,,,,,,`;
+
+      const result = CsvParser.parseImportFormat(csvText);
+
+      expect(result.evaluationSettings).toBeUndefined();
+    });
+
+    it('空のセルは無視されること', () => {
+      const csvText = `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+,,,,,,
+項目1,,,,,,
+,,,,,,`;
+
+      const result = CsvParser.parseImportFormat(csvText);
+
+      expect(result.checklists).toEqual(['項目1']);
+    });
+
+    it('セル内改行を正しく処理できること', () => {
+      const csvText = `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+"項目1
+改行あり",,,,,,`;
+
+      const result = CsvParser.parseImportFormat(csvText);
+
+      expect(result.checklists).toEqual(['項目1\n改行あり']);
+    });
+  });
+});
diff --git a/src/__tests__/main/reviewService.test.ts b/src/__tests__/main/reviewService.test.ts
new file mode 100644
index 000000000..58007555f
--- /dev/null
+++ b/src/__tests__/main/reviewService.test.ts
@@ -0,0 +1,417 @@
+/**
+ * ReviewService - extractChecklistFromCsv メソッドのテスト
+ * @jest-environment node
+ */
+
+// Electron モックを最初に適用
+jest.mock('electron', () => require('./test-utils/mockElectron').mockElectron);
+jest.mock('electron-store', () => require('./test-utils/mockElectron').default);
+
+// main.ts の初期化処理をスキップ
+jest.mock('@/main/main', () => {
+  const path = require('path');
+  const os = require('os');
+  const testAppData = path.join(os.tmpdir(), 'ai-notebook-test');
+  return {
+    getCustomAppDataDir: jest.fn(() => testAppData),
+  };
+});
+
+import { ReviewService } from '@/main/service/reviewService';
+import { getReviewRepository, getSettingsRepository } from '@/adapter/db';
+import FileExtractor from '@/main/lib/fileExtractor';
+import { IpcChannels } from '@/types';
+import type { IReviewRepository, ISettingsRepository } from '@/main/service/port/repository';
+import type { UploadFile, Settings } from '@/types';
+
+// モック設定
+const mockExtractText = jest.fn();
+jest.mock('@/main/lib/fileExtractor', () => ({
+  __esModule: true,
+  default: {
+    get extractText() {
+      return mockExtractText;
+    },
+  },
+}));
+
+// イベント発火のモック
+const mockPublishEvent = jest.fn();
+jest.mock('@/main/lib/eventPayloadHelper', () => ({
+  publishEvent: (...args: any[]) => mockPublishEvent(...args),
+}));
+
+// リポジトリのモック
+const mockGetReviewRepository = jest.fn();
+const mockGetSettingsRepository = jest.fn();
+jest.mock('@/adapter/db', () => ({
+  getReviewRepository: () => mockGetReviewRepository(),
+  getSettingsRepository: () => mockGetSettingsRepository(),
+  getSourceRepository: jest.fn(() => ({
+    getAllSources: jest.fn(),
+  })),
+  getChatRepository: jest.fn(() => ({
+    getChatRooms: jest.fn(),
+  })),
+}));
+
+describe('ReviewService - extractChecklistFromCsv', () => {
+  let reviewService: ReviewService;
+  let mockReviewRepository: jest.Mocked<IReviewRepository>;
+  let mockSettingsRepository: jest.Mocked<ISettingsRepository>;
+
+  const defaultSettings: Settings = {
+    api: { key: 'old-key', url: 'http://old.com', model: 'old-model' },
+    database: { dir: '/test/db' },
+    source: { registerDir: './source' },
+    redmine: { endpoint: '', apiKey: '' },
+    gitlab: { endpoint: '', apiKey: '' },
+    mcp: { serverConfig: undefined },
+    systemPrompt: { content: '' },
+  };
+
+  beforeEach(() => {
+    jest.clearAllMocks();
+
+    // シングルトンをリセット（内部的にインスタンスを破棄）
+    (ReviewService as any).instance = undefined;
+
+    // ReviewRepository のモック
+    mockReviewRepository = {
+      getReviewHistory: jest.fn().mockResolvedValue(null),
+      createReviewHistory: jest.fn().mockResolvedValue({
+        id: 'review-1',
+        title: 'テストレビュー',
+        processingStatus: 'idle',
+        createdAt: new Date().toISOString(),
+        updatedAt: new Date().toISOString(),
+      }),
+      deleteSystemCreatedChecklists: jest.fn().mockResolvedValue(undefined),
+      createChecklist: jest.fn().mockResolvedValue(undefined),
+      updateReviewHistoryEvaluationSettings: jest.fn().mockResolvedValue(undefined),
+      updateReviewHistoryAdditionalInstructionsAndCommentFormat: jest.fn().mockResolvedValue(undefined),
+    } as any;
+
+    // SettingsRepository のモック
+    mockSettingsRepository = {
+      getSettings: jest.fn().mockResolvedValue(defaultSettings),
+      saveSettings: jest.fn().mockResolvedValue(undefined),
+    } as any;
+
+    // モック関数を設定
+    mockGetReviewRepository.mockReturnValue(mockReviewRepository);
+    mockGetSettingsRepository.mockReturnValue(mockSettingsRepository);
+
+    // ReviewService インスタンス作成（シングルトンのgetInstance使用）
+    reviewService = ReviewService.getInstance();
+  });
+
+  describe('API設定を含むCSVインポート', () => {
+    it('API設定を含むCSVインポート時にSETTINGS_UPDATEDイベントが発火すること', async () => {
+      // CSVファイルのモック（API設定含む）
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      // FileExtractor.extractText をモック（API設定を含むCSV）
+      mockExtractText.mockResolvedValue({
+        content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,http://new-api.com,new-key,new-model
+項目2,,,,,,`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // SETTINGS_UPDATEDイベントが発火したことを検証
+      expect(mockPublishEvent).toHaveBeenCalledWith(
+        IpcChannels.SETTINGS_UPDATED,
+        undefined
+      );
+
+      // settingsRepository.saveSettingsが呼ばれたことを検証
+      expect(mockSettingsRepository.saveSettings).toHaveBeenCalledWith(
+        expect.objectContaining({
+          api: {
+            key: 'new-key',
+            url: 'http://new-api.com',
+            model: 'new-model',
+          },
+        })
+      );
+
+      // REVIEW_EXTRACT_CHECKLIST_FINISHEDイベントも発火すること
+      expect(mockPublishEvent).toHaveBeenCalledWith(
+        IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+        expect.objectContaining({
+          reviewHistoryId: 'review-1',
+          status: 'success',
+        })
+      );
+    });
+
+    it('API設定の一部のみ指定された場合、既存設定とマージされること', async () => {
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      // APIキーのみ更新するCSV
+      mockExtractText.mockResolvedValue({
+        content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,,new-key-only,`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // 既存のURLとmodelは保持され、keyのみ更新されること
+      expect(mockSettingsRepository.saveSettings).toHaveBeenCalledWith(
+        expect.objectContaining({
+          api: {
+            key: 'new-key-only',
+            url: 'http://old.com', // 既存値を保持
+            model: 'old-model', // 既存値を保持
+          },
+        })
+      );
+
+      // SETTINGS_UPDATEDイベントが発火すること
+      expect(mockPublishEvent).toHaveBeenCalledWith(
+        IpcChannels.SETTINGS_UPDATED,
+        undefined
+      );
+    });
+  });
+
+  describe('API設定を含まないCSVインポート', () => {
+    it('API設定を含まないCSVインポート時はSETTINGS_UPDATEDイベントが発火しないこと', async () => {
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      // API設定を含まないCSV
+      mockExtractText.mockResolvedValue({
+        content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,,
+項目2,,,,,,`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // SETTINGS_UPDATEDイベントが発火していないことを検証
+      expect(mockPublishEvent).not.toHaveBeenCalledWith(
+        IpcChannels.SETTINGS_UPDATED,
+        undefined
+      );
+
+      // settingsRepository.saveSettingsが呼ばれていないことを検証
+      expect(mockSettingsRepository.saveSettings).not.toHaveBeenCalled();
+
+      // REVIEW_EXTRACT_CHECKLIST_FINISHEDイベントは発火すること
+      expect(mockPublishEvent).toHaveBeenCalledWith(
+        IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+        expect.objectContaining({
+          reviewHistoryId: 'review-1',
+          status: 'success',
+        })
+      );
+    });
+
+    it('チェックリスト項目のみのCSVでも正常に処理されること', async () => {
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      mockExtractText.mockResolvedValue({
+        content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,,
+項目2,,,,,,
+項目3,,,,,,`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // チェックリスト作成が3回呼ばれること
+      expect(mockReviewRepository.createChecklist).toHaveBeenCalledTimes(3);
+      expect(mockReviewRepository.createChecklist).toHaveBeenCalledWith(
+        'review-1',
+        '項目1',
+        'system'
+      );
+      expect(mockReviewRepository.createChecklist).toHaveBeenCalledWith(
+        'review-1',
+        '項目2',
+        'system'
+      );
+      expect(mockReviewRepository.createChecklist).toHaveBeenCalledWith(
+        'review-1',
+        '項目3',
+        'system'
+      );
+    });
+  });
+
+  describe('評定設定・追加指示・コメントフォーマットを含むCSVインポート', () => {
+    it('評定設定が正しくDB更新されること', async () => {
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      mockExtractText.mockResolvedValue({
+        content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,,
+,A,優秀,,,,,
+,B,良好,,,,,`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // 評定設定の更新が呼ばれること
+      expect(mockReviewRepository.updateReviewHistoryEvaluationSettings).toHaveBeenCalledWith(
+        'review-1',
+        expect.objectContaining({
+          items: [
+            { label: 'A', description: '優秀' },
+            { label: 'B', description: '良好' },
+          ],
+        })
+      );
+    });
+
+    it('追加指示とコメントフォーマットが正しくDB更新されること', async () => {
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      mockExtractText.mockResolvedValue({
+        content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,厳格にレビューしてください,【評価】{evaluation},,`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // 追加指示とコメントフォーマットの更新が呼ばれること
+      expect(mockReviewRepository.updateReviewHistoryAdditionalInstructionsAndCommentFormat).toHaveBeenCalledWith(
+        'review-1',
+        '厳格にレビューしてください',
+        '【評価】{evaluation}'
+      );
+    });
+  });
+
+  describe('エラーハンドリング', () => {
+    it('CSVパースエラー時はREVIEW_EXTRACT_CHECKLIST_FINISHEDイベント（失敗）が発火すること', async () => {
+      const mockFiles: UploadFile[] = [{
+        id: 'file-1',
+        name: 'import.csv',
+        path: '/test/import.csv',
+        type: 'text/csv',
+      }];
+
+      // 不正なCSVフォーマット
+      mockExtractText.mockResolvedValue({
+        content: `invalid,header
+データ1,データ2`,
+        metadata: {},
+      });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // REVIEW_EXTRACT_CHECKLIST_FINISHEDイベント（失敗）が発火すること
+      expect(mockPublishEvent).toHaveBeenCalledWith(
+        IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED,
+        expect.objectContaining({
+          reviewHistoryId: 'review-1',
+          status: 'failed',
+          error: expect.any(String),
+        })
+      );
+
+      // SETTINGS_UPDATEDイベントは発火しないこと
+      expect(mockPublishEvent).not.toHaveBeenCalledWith(
+        IpcChannels.SETTINGS_UPDATED,
+        undefined
+      );
+    });
+  });
+
+  describe('複数ファイルのCSVインポート', () => {
+    it('複数ファイルの場合、最初のファイルの設定値が優先されること', async () => {
+      const mockFiles: UploadFile[] = [
+        {
+          id: 'file-1',
+          name: 'import1.csv',
+          path: '/test/import1.csv',
+          type: 'text/csv',
+        },
+        {
+          id: 'file-2',
+          name: 'import2.csv',
+          path: '/test/import2.csv',
+          type: 'text/csv',
+        },
+      ];
+
+      // 1つ目のファイルにAPI設定あり
+      mockExtractText
+        .mockResolvedValueOnce({
+          content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目1,,,,,http://first.com,first-key,first-model`,
+          metadata: {},
+        })
+        // 2つ目のファイルにも異なるAPI設定あり（無視されるべき）
+        .mockResolvedValueOnce({
+          content: `チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+項目2,,,,,http://second.com,second-key,second-model`,
+          metadata: {},
+        });
+
+      await reviewService.extractChecklistFromCsv('review-1', mockFiles);
+
+      // 1つ目のファイルの設定が使用されること
+      expect(mockSettingsRepository.saveSettings).toHaveBeenCalledWith(
+        expect.objectContaining({
+          api: {
+            key: 'first-key',
+            url: 'http://first.com',
+            model: 'first-model',
+          },
+        })
+      );
+
+      // チェックリスト項目は両方とも登録されること
+      expect(mockReviewRepository.createChecklist).toHaveBeenCalledWith(
+        'review-1',
+        '項目1',
+        'system'
+      );
+      expect(mockReviewRepository.createChecklist).toHaveBeenCalledWith(
+        'review-1',
+        '項目2',
+        'system'
+      );
+    });
+  });
+});
diff --git a/src/__tests__/main/test-utils/mockElectron.ts b/src/__tests__/main/test-utils/mockElectron.ts
new file mode 100644
index 000000000..791110446
--- /dev/null
+++ b/src/__tests__/main/test-utils/mockElectron.ts
@@ -0,0 +1,131 @@
+/**
+ * Main プロセステスト用の Electron モック
+ *
+ * Electron の app モジュールなどをモック化して、
+ * テスト環境でも正常に動作するようにする
+ */
+
+import path from 'path';
+
+// テスト用のデータディレクトリ
+const TEST_USER_DATA_PATH = path.join(__dirname, '..', '..', '..', '..', 'test_data');
+
+/**
+ * Electron の app モジュールのモック
+ */
+const mockApp = {
+  // 開発モードとして動作（パッケージ版ではない）
+  isPackaged: false,
+
+  // アプリの準備完了状態（electron-log で使用）
+  isReady: jest.fn(() => Promise.resolve()),
+
+  // whenReady も追加（electron-log で使用される可能性がある）
+  whenReady: jest.fn(() => Promise.resolve()),
+
+  // ユーザーデータディレクトリを返す
+  getPath: jest.fn((name: string) => {
+    if (name === 'userData') {
+      return TEST_USER_DATA_PATH;
+    }
+    return TEST_USER_DATA_PATH;
+  }),
+
+  // パスの設定（何もしない）
+  setPath: jest.fn(),
+
+  // その他必要に応じて追加
+  getName: jest.fn(() => 'test-app'),
+  getVersion: jest.fn(() => '1.0.0'),
+
+  // イベントリスナー関連（electron-log で使用）
+  on: jest.fn(),
+  once: jest.fn(),
+  removeListener: jest.fn(),
+};
+
+/**
+ * Electron モジュール全体のモック
+ */
+export const mockElectron = {
+  app: mockApp,
+
+  // 必要に応じて他のモジュールも追加
+  ipcMain: {
+    handle: jest.fn(),
+    on: jest.fn(),
+    removeHandler: jest.fn(),
+  },
+
+  BrowserWindow: jest.fn(),
+
+  dialog: {
+    showOpenDialog: jest.fn(),
+    showSaveDialog: jest.fn(),
+    showMessageBox: jest.fn(),
+  },
+
+  shell: {
+    openExternal: jest.fn(),
+  },
+
+  // crashReporter のモック
+  crashReporter: {
+    start: jest.fn(),
+    getLastCrashReport: jest.fn(),
+    getUploadedReports: jest.fn(),
+    getUploadToServer: jest.fn(),
+    setUploadToServer: jest.fn(),
+  },
+};
+
+/**
+ * electron-store モジュールのモック
+ *
+ * electron-store は内部で Electron の app を使用するため、
+ * テスト環境では簡易的なインメモリストアに置き換える
+ */
+export class MockStore<T extends Record<string, any> = Record<string, any>> {
+  private data: Map<string, any> = new Map();
+
+  constructor(options?: { defaults?: T; schema?: any; cwd?: string }) {
+    if (options?.defaults) {
+      // デフォルト値を設定
+      Object.entries(options.defaults).forEach(([key, value]) => {
+        this.data.set(key, value);
+      });
+    }
+  }
+
+  get<K extends keyof T>(key: K): T[K] {
+    return this.data.get(key as string);
+  }
+
+  set<K extends keyof T>(key: K, value: T[K]): void {
+    this.data.set(key as string, value);
+  }
+
+  has(key: keyof T): boolean {
+    return this.data.has(key as string);
+  }
+
+  delete(key: keyof T): void {
+    this.data.delete(key as string);
+  }
+
+  clear(): void {
+    this.data.clear();
+  }
+
+  // Store 全体を取得
+  store: T = new Proxy({} as T, {
+    get: (_, prop) => this.data.get(prop as string),
+    set: (_, prop, value) => {
+      this.data.set(prop as string, value);
+      return true;
+    },
+  });
+}
+
+// デフォルトエクスポート（electron-store の代替）
+export default MockStore;
diff --git a/src/__tests__/main/workflows/checklistExtraction.test.ts b/src/__tests__/main/workflows/checklistExtraction.test.ts
new file mode 100644
index 000000000..356848b17
--- /dev/null
+++ b/src/__tests__/main/workflows/checklistExtraction.test.ts
@@ -0,0 +1,1006 @@
+/**
+ * チェックリスト抽出ワークフローのテスト
+ * @jest-environment node
+ */
+
+// Electron モックを最初に適用（他のインポートより前に実行する必要がある）
+jest.mock('electron', () => require('../test-utils/mockElectron').mockElectron);
+jest.mock('electron-store', () => require('../test-utils/mockElectron').default);
+
+// main.ts の初期化処理をスキップ（テスト環境では不要）
+jest.mock('@/main/main', () => {
+  const path = require('path');
+  const os = require('os');
+  // テンポラリディレクトリを使用（実際に存在するディレクトリ）
+  const testAppData = path.join(os.tmpdir(), 'ai-notebook-test');
+  return {
+    getCustomAppDataDir: jest.fn(() => testAppData),
+  };
+});
+
+import { checklistExtractionWorkflow } from '@/mastra/workflows/sourceReview/checklistExtraction';
+import { mastra } from '@/mastra';
+import { getReviewRepository } from '@/adapter/db';
+import FileExtractor from '@/main/lib/fileExtractor';
+import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
+import type { IReviewRepository } from '@/main/service/port/repository';
+import type { UploadFile } from '@/types';
+import { internalError } from '@/main/lib/error';
+
+// モック設定
+jest.mock('@/adapter/db', () => ({
+  getReviewRepository: jest.fn(),
+  getSourceRepository: jest.fn(() => ({
+    // 必要最小限のモック（ソースリポジトリは直接使用しないが、インポート時に呼ばれる）
+    getAllSources: jest.fn(),
+    getSourceById: jest.fn(),
+    createSource: jest.fn(),
+    updateSource: jest.fn(),
+    deleteSource: jest.fn(),
+    updateSourceEnabled: jest.fn(),
+  })),
+  getChatRepository: jest.fn(() => ({
+    // チャットリポジトリのモック（インポート時に必要）
+    getChatRooms: jest.fn(),
+    getChatMessages: jest.fn(),
+  })),
+  getSettingsRepository: jest.fn(() => ({
+    // 設定リポジトリのモック（インポート時に必要）
+    getSettings: jest.fn().mockReturnValue({
+      api: {
+        url: 'http://localhost:11434/v1',
+        key: 'test-api-key',
+        model: 'test-model',
+      },
+      database: {
+        dir: '/test/db',
+      },
+      source: {
+        registerDir: './test/source',
+      },
+    }),
+    setSettings: jest.fn(),
+  })),
+}));
+// FileExtractor のモック（最初に設定）
+const mockExtractText = jest.fn();
+const mockCleanCacheDirectory = jest.fn();
+
+jest.mock('@/main/lib/fileExtractor', () => ({
+  __esModule: true,
+  default: {
+    get extractText() {
+      return mockExtractText;
+    },
+    get cleanCacheDirectory() {
+      return mockCleanCacheDirectory;
+    },
+  },
+}));
+jest.mock('@/main/lib/eventPayloadHelper', () => ({
+  publishEvent: jest.fn(),
+}));
+
+describe('checklistExtractionWorkflow', () => {
+  // モックリポジトリ
+  let mockRepository: jest.Mocked<IReviewRepository>;
+
+  // モックエージェント
+  let mockChecklistExtractionAgent: any;
+  let mockTopicExtractionAgent: any;
+  let mockTopicChecklistAgent: any;
+
+  beforeEach(() => {
+    // リポジトリのモック
+    mockRepository = {
+      deleteSystemCreatedChecklists: jest.fn().mockResolvedValue(undefined),
+      createChecklist: jest.fn().mockResolvedValue(undefined),
+      getReviewHistory: jest.fn().mockResolvedValue({ id: 'review-1' }),
+      createReviewHistory: jest.fn(),
+      getAllReviewHistories: jest.fn(),
+      updateReviewHistoryTitle: jest.fn(),
+      updateReviewHistoryAdditionalInstructionsAndCommentFormat: jest.fn(),
+      updateReviewHistoryEvaluationSettings: jest.fn(),
+      updateReviewHistoryProcessingStatus: jest.fn(),
+      updateReviewHistoryTargetDocumentName: jest.fn(),
+      deleteReviewHistory: jest.fn(),
+      getChecklists: jest.fn(),
+      updateChecklist: jest.fn(),
+      deleteChecklist: jest.fn(),
+      upsertReviewResult: jest.fn(),
+      getReviewChecklistResults: jest.fn(),
+      deleteAllReviewResults: jest.fn(),
+      deleteReviewDocumentCaches: jest.fn(),
+      deleteReviewLargedocumentResultCaches: jest.fn(),
+      updateReviewHistoryDocumentMode: jest.fn(),
+      createReviewDocumentCache: jest.fn(),
+      getReviewDocumentCaches: jest.fn(),
+      getReviewDocumentCacheById: jest.fn(),
+      getReviewDocumentCacheByIds: jest.fn(),
+      createReviewLargedocumentResultCache: jest.fn(),
+      getReviewLargedocumentResultCaches: jest.fn(),
+      getMaxTotalChunksForDocument: jest.fn(),
+      getChecklistResultsWithIndividualResults: jest.fn(),
+    } as jest.Mocked<IReviewRepository>;
+
+    (getReviewRepository as jest.Mock).mockReturnValue(mockRepository);
+
+    // FileExtractorのモック
+    mockExtractText.mockResolvedValue({
+      content: 'テストファイルの内容',
+    });
+
+    // Mastraエージェントのモック
+    mockChecklistExtractionAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockTopicExtractionAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockTopicChecklistAgent = {
+      generateLegacy: jest.fn(),
+    };
+
+    // mastra.getAgentのモック
+    jest.spyOn(mastra, 'getAgent').mockImplementation((agentName: string) => {
+      if (agentName === 'checklistExtractionAgent') {
+        return mockChecklistExtractionAgent;
+      }
+      if (agentName === 'topicExtractionAgent') {
+        return mockTopicExtractionAgent;
+      }
+      if (agentName === 'topicChecklistAgent') {
+        return mockTopicChecklistAgent;
+      }
+      throw new Error(`Unknown agent: ${agentName}`);
+    });
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+    mockExtractText.mockReset();
+  });
+
+  describe('チェックリストドキュメント（AI抽出）', () => {
+    describe('正常系', () => {
+      it('基本的なチェックリスト抽出が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'checklist.pdf',
+            path: '/test/checklist.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            isChecklistDocument: true,
+            newChecklists: [
+              'チェック項目1',
+              'チェック項目2',
+              'チェック項目3',
+            ],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockRepository.deleteSystemCreatedChecklists).toHaveBeenCalledWith(
+          reviewHistoryId,
+        );
+        expect(mockRepository.createChecklist).toHaveBeenCalledTimes(3);
+        expect(mockRepository.createChecklist).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'チェック項目1',
+          'system',
+        );
+        expect(mockRepository.createChecklist).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'チェック項目2',
+          'system',
+        );
+        expect(mockRepository.createChecklist).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'チェック項目3',
+          'system',
+        );
+      });
+
+      it('複数ファイルの統合抽出が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'checklist1.pdf',
+            path: '/test/checklist1.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+          {
+            id: 'file-2',
+            name: 'checklist2.pdf',
+            path: '/test/checklist2.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            isChecklistDocument: true,
+            newChecklists: ['統合チェック項目1', '統合チェック項目2'],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(FileExtractor.extractText).toHaveBeenCalledTimes(2);
+        expect(mockChecklistExtractionAgent.generateLegacy).toHaveBeenCalledTimes(
+          1,
+        );
+
+        // generateLegacyに渡されたメッセージを確認
+        const callArgs = mockChecklistExtractionAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'text',
+              text: expect.stringContaining('checklist1.pdf, checklist2.pdf'),
+            }),
+          ]),
+        );
+      });
+
+      it('画像モード（ページ別）での抽出が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'checklist.pdf',
+            path: '/test/checklist.pdf',
+            type: 'application/pdf',
+            processMode: 'image',
+            imageMode: 'pages',
+            imageData: [
+              'data:image/png;base64,page1data',
+              'data:image/png;base64,page2data',
+            ],
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            isChecklistDocument: true,
+            newChecklists: ['画像から抽出した項目1', '画像から抽出した項目2'],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // FileExtractor.extractTextが呼ばれないことを確認
+        expect(FileExtractor.extractText).not.toHaveBeenCalled();
+
+        // generateLegacyに画像データが含まれることを確認
+        const callArgs = mockChecklistExtractionAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'text',
+              text: expect.stringContaining('Page 1/2'),
+            }),
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page1data',
+              mimeType: 'image/png',
+            }),
+            expect.objectContaining({
+              type: 'text',
+              text: expect.stringContaining('Page 2/2'),
+            }),
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page2data',
+              mimeType: 'image/png',
+            }),
+          ]),
+        );
+      });
+
+      it('画像モード（統合）での抽出が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'checklist.pdf',
+            path: '/test/checklist.pdf',
+            type: 'application/pdf',
+            processMode: 'image',
+            imageMode: 'merged',
+            imageData: ['data:image/png;base64,mergeddata'],
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            isChecklistDocument: true,
+            newChecklists: ['統合画像から抽出した項目'],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // generateLegacyに統合画像データが含まれることを確認
+        const callArgs = mockChecklistExtractionAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'text',
+              text: expect.stringContaining('Page 1/1'),
+            }),
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,mergeddata',
+              mimeType: 'image/png',
+            }),
+          ]),
+        );
+      });
+    });
+
+    describe('異常系', () => {
+      it('チェックリストドキュメントでないファイルでエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            isChecklistDocument: false,
+            newChecklists: [],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(
+          'チェックリスト抽出に適さないドキュメント',
+        );
+        expect(mockRepository.createChecklist).not.toHaveBeenCalled();
+      });
+
+      it('チェックリスト項目が抽出されない場合にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'empty.pdf',
+            path: '/test/empty.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            isChecklistDocument: true,
+            newChecklists: [],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(
+          'チェックリストが抽出されませんでした',
+        );
+        expect(mockRepository.createChecklist).not.toHaveBeenCalled();
+      });
+
+      it('AI API呼び出しエラー時に適切にハンドリングされること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'checklist.pdf',
+            path: '/test/checklist.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockChecklistExtractionAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'テストエラー' },
+          }),
+        );
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'checklist-ai',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toBe('テストエラー');
+        expect(mockRepository.createChecklist).not.toHaveBeenCalled();
+      });
+    });
+  });
+
+  describe('一般ドキュメント', () => {
+    describe('正常系', () => {
+      it('トピック抽出とチェックリスト作成が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+        const checklistRequirements = 'セキュリティに関する項目を作成してください';
+
+        mockTopicExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            topics: [
+              {
+                topic: 'セキュリティ対策',
+                reason: 'セキュリティは重要',
+              },
+              {
+                topic: 'データ保護',
+                reason: 'データ保護は必須',
+              },
+            ],
+          },
+        });
+
+        mockTopicChecklistAgent.generateLegacy
+          .mockResolvedValueOnce({
+            object: {
+              checklistItems: [
+                {
+                  checklistItem: 'セキュリティ項目1',
+                  reason: '理由1',
+                },
+                {
+                  checklistItem: 'セキュリティ項目2',
+                  reason: '理由2',
+                },
+              ],
+            },
+          })
+          .mockResolvedValueOnce({
+            object: {
+              checklistItems: [
+                {
+                  checklistItem: 'データ保護項目1',
+                  reason: '理由3',
+                },
+              ],
+            },
+          });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+            checklistRequirements,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockRepository.deleteSystemCreatedChecklists).toHaveBeenCalledWith(
+          reviewHistoryId,
+        );
+        expect(mockTopicExtractionAgent.generateLegacy).toHaveBeenCalledTimes(1);
+        expect(mockTopicChecklistAgent.generateLegacy).toHaveBeenCalledTimes(2);
+        expect(mockRepository.createChecklist).toHaveBeenCalledTimes(3);
+        expect(mockRepository.createChecklist).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'セキュリティ項目1',
+          'system',
+        );
+        expect(mockRepository.createChecklist).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'セキュリティ項目2',
+          'system',
+        );
+        expect(mockRepository.createChecklist).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'データ保護項目1',
+          'system',
+        );
+      });
+
+      it('複数トピックに対してチェックリストが作成されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockTopicExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            topics: [
+              { topic: 'トピック1', reason: '理由1' },
+              { topic: 'トピック2', reason: '理由2' },
+              { topic: 'トピック3', reason: '理由3' },
+            ],
+          },
+        });
+
+        mockTopicChecklistAgent.generateLegacy.mockResolvedValue({
+          object: {
+            checklistItems: [
+              {
+                checklistItem: 'チェック項目',
+                reason: '理由',
+              },
+            ],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        // 各トピックに対してチェックリスト作成が実行される
+        expect(mockTopicChecklistAgent.generateLegacy).toHaveBeenCalledTimes(3);
+        expect(mockRepository.createChecklist).toHaveBeenCalledTimes(3);
+      });
+
+      it('checklistRequirementsがruntimeContextに正しく設定されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+        const checklistRequirements = 'テスト要件';
+
+        mockTopicExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            topics: [{ topic: 'トピック1', reason: '理由1' }],
+          },
+        });
+
+        mockTopicChecklistAgent.generateLegacy.mockResolvedValue({
+          object: {
+            checklistItems: [
+              {
+                checklistItem: 'チェック項目',
+                reason: '理由',
+              },
+            ],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+            checklistRequirements,
+          },
+        });
+
+        // Assert
+        // topicExtractionAgentに渡されたruntimeContextを確認
+        const topicExtractionCallArgs =
+          mockTopicExtractionAgent.generateLegacy.mock.calls[0];
+        const topicExtractionOptions = topicExtractionCallArgs[1];
+        const topicRuntimeContext = topicExtractionOptions.runtimeContext;
+        expect(topicRuntimeContext.get('checklistRequirements')).toBe(
+          checklistRequirements,
+        );
+
+        // topicChecklistAgentに渡されたruntimeContextを確認
+        const topicChecklistCallArgs =
+          mockTopicChecklistAgent.generateLegacy.mock.calls[0];
+        const topicChecklistOptions = topicChecklistCallArgs[1];
+        const checklistRuntimeContext = topicChecklistOptions.runtimeContext;
+        expect(checklistRuntimeContext.get('checklistRequirements')).toBe(
+          checklistRequirements,
+        );
+      });
+
+      it('一部のトピックでチェックリスト作成失敗時も継続すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockTopicExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            topics: [
+              { topic: 'トピック1', reason: '理由1' },
+              { topic: 'トピック2', reason: '理由2' },
+              { topic: 'トピック3', reason: '理由3' },
+            ],
+          },
+        });
+
+        // 2つ目のトピックではチェックリスト項目が生成されない
+        mockTopicChecklistAgent.generateLegacy
+          .mockResolvedValueOnce({
+            object: {
+              checklistItems: [
+                {
+                  checklistItem: 'チェック項目1',
+                  reason: '理由1',
+                },
+              ],
+            },
+          })
+          .mockResolvedValueOnce({
+            object: {
+              checklistItems: [],
+            },
+          })
+          .mockResolvedValueOnce({
+            object: {
+              checklistItems: [
+                {
+                  checklistItem: 'チェック項目3',
+                  reason: '理由3',
+                },
+              ],
+            },
+          });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockTopicChecklistAgent.generateLegacy).toHaveBeenCalledTimes(3);
+        // チェックリスト項目が生成されたトピックのみDB保存される
+        expect(mockRepository.createChecklist).toHaveBeenCalledTimes(2);
+      });
+    });
+
+    describe('異常系', () => {
+      it('トピック抽出失敗時にbailでworkflowが終了すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockTopicExtractionAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'テストエラー' },
+          }),
+        );
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toBe('テストエラー');
+        expect(mockTopicChecklistAgent.generateLegacy).not.toHaveBeenCalled();
+        expect(mockRepository.createChecklist).not.toHaveBeenCalled();
+      });
+
+      it('トピックが抽出されない場合の処理', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockTopicExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            topics: [],
+          },
+        });
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        // トピックがないのでチェックリスト作成は実行されない
+        expect(mockTopicChecklistAgent.generateLegacy).not.toHaveBeenCalled();
+        expect(mockRepository.createChecklist).not.toHaveBeenCalled();
+      });
+
+      it('チェックリスト作成中のAI APIエラー時にbailで終了すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'general.pdf',
+            path: '/test/general.pdf',
+            type: 'application/pdf',
+            processMode: 'text',
+          },
+        ];
+
+        mockTopicExtractionAgent.generateLegacy.mockResolvedValue({
+          object: {
+            topics: [{ topic: 'トピック1', reason: '理由1' }],
+          },
+        });
+
+        mockTopicChecklistAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'テストエラー' },
+          }),
+        );
+
+        // Act
+        const run = await checklistExtractionWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentType: 'general',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toBe('テストエラー');
+        expect(mockRepository.createChecklist).not.toHaveBeenCalled();
+      });
+    });
+  });
+
+  describe('共通処理', () => {
+    it('既存のシステム作成チェックリストが削除されること', async () => {
+      // Arrange
+      const reviewHistoryId = 'review-1';
+      const files: UploadFile[] = [
+        {
+          id: 'file-1',
+          name: 'checklist.pdf',
+          path: '/test/checklist.pdf',
+          type: 'application/pdf',
+          processMode: 'text',
+        },
+      ];
+
+      mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+        object: {
+          isChecklistDocument: true,
+          newChecklists: ['チェック項目1'],
+        },
+      });
+
+      // Act
+      const run = await checklistExtractionWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          reviewHistoryId,
+          files,
+          documentType: 'checklist-ai',
+        },
+      });
+
+      // Assert
+      expect(mockRepository.deleteSystemCreatedChecklists).toHaveBeenCalledWith(
+        reviewHistoryId,
+      );
+      // deleteSystemCreatedChecklistsがcreateChecklistより前に呼ばれることを確認
+      const deleteCallOrder =
+        mockRepository.deleteSystemCreatedChecklists.mock.invocationCallOrder[0];
+      const createCallOrder =
+        mockRepository.createChecklist.mock.invocationCallOrder[0];
+      expect(deleteCallOrder).toBeLessThan(createCallOrder);
+    });
+
+    it('ワークフロー実行時にmastra.getAgentが正しく呼ばれること', async () => {
+      // Arrange
+      const reviewHistoryId = 'review-1';
+      const files: UploadFile[] = [
+        {
+          id: 'file-1',
+          name: 'checklist.pdf',
+          path: '/test/checklist.pdf',
+          type: 'application/pdf',
+          processMode: 'text',
+        },
+      ];
+
+      mockChecklistExtractionAgent.generateLegacy.mockResolvedValue({
+        object: {
+          isChecklistDocument: true,
+          newChecklists: ['チェック項目1'],
+        },
+      });
+
+      const getAgentSpy = jest.spyOn(mastra, 'getAgent');
+
+      // Act
+      const run = await checklistExtractionWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          reviewHistoryId,
+          files,
+          documentType: 'checklist-ai',
+        },
+      });
+
+      // Assert
+      expect(getAgentSpy).toHaveBeenCalledWith('checklistExtractionAgent');
+      expect(mockChecklistExtractionAgent.generateLegacy).toHaveBeenCalled();
+    });
+  });
+});
diff --git a/src/__tests__/main/workflows/executeReview.test.ts b/src/__tests__/main/workflows/executeReview.test.ts
new file mode 100644
index 000000000..dffaacc07
--- /dev/null
+++ b/src/__tests__/main/workflows/executeReview.test.ts
@@ -0,0 +1,2319 @@
+/**
+ * ドキュメントレビュー実行ワークフローのテスト
+ * @jest-environment node
+ */
+
+// Electron モックを最初に適用（他のインポートより前に実行する必要がある）
+jest.mock('electron', () => require('../test-utils/mockElectron').mockElectron);
+jest.mock('electron-store', () => require('../test-utils/mockElectron').default);
+
+// main.ts の初期化処理をスキップ（テスト環境では不要）
+jest.mock('@/main/main', () => {
+  const path = require('path');
+  const os = require('os');
+  // テンポラリディレクトリを使用（実際に存在するディレクトリ）
+  const testAppData = path.join(os.tmpdir(), 'ai-notebook-test');
+  return {
+    getCustomAppDataDir: jest.fn(() => testAppData),
+  };
+});
+
+import { executeReviewWorkflow } from '@/mastra/workflows/sourceReview/executeReview';
+import { mastra } from '@/mastra';
+import { getReviewRepository } from '@/adapter/db';
+import FileExtractor from '@/main/lib/fileExtractor';
+import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
+import type { IReviewRepository } from '@/main/service/port/repository/IReviewRepository';
+import type { UploadFile, ReviewChecklist } from '@/types';
+import { internalError } from '@/main/lib/error';
+import { APICallError } from 'ai';
+
+// モック設定
+jest.mock('@/adapter/db', () => ({
+  getReviewRepository: jest.fn(),
+  getSourceRepository: jest.fn(() => ({
+    getAllSources: jest.fn(),
+    getSourceById: jest.fn(),
+    createSource: jest.fn(),
+    updateSource: jest.fn(),
+    deleteSource: jest.fn(),
+    updateSourceEnabled: jest.fn(),
+  })),
+  getChatRepository: jest.fn(() => ({
+    getChatRooms: jest.fn(),
+    getChatMessages: jest.fn(),
+  })),
+  getSettingsRepository: jest.fn(() => ({
+    getSettings: jest.fn().mockReturnValue({
+      api: {
+        url: 'http://localhost:11434/v1',
+        key: 'test-api-key',
+        model: 'test-model',
+      },
+      database: {
+        dir: '/test/db',
+      },
+      source: {
+        registerDir: './test/source',
+      },
+    }),
+    setSettings: jest.fn(),
+  })),
+}));
+
+// FileExtractor のモック
+const mockExtractText = jest.fn();
+const mockCleanCacheDirectory = jest.fn();
+
+jest.mock('@/main/lib/fileExtractor', () => ({
+  __esModule: true,
+  default: {
+    get extractText() {
+      return mockExtractText;
+    },
+    get cleanCacheDirectory() {
+      return mockCleanCacheDirectory;
+    },
+  },
+}));
+
+jest.mock('@/main/lib/eventPayloadHelper', () => ({
+  publishEvent: jest.fn(),
+}));
+
+describe('executeReviewWorkflow', () => {
+  // モックリポジトリ
+  let mockRepository: jest.Mocked<IReviewRepository>;
+
+  // モックエージェント
+  let mockClassifyCategoryAgent: any;
+  let mockReviewExecuteAgent: any;
+  let mockIndividualDocumentReviewAgent: any;
+  let mockConsolidateReviewAgent: any;
+
+  beforeEach(() => {
+    // リポジトリのモック
+    mockRepository = {
+      createReviewHistory: jest.fn(),
+      getReviewHistory: jest.fn().mockResolvedValue({ id: 'review-1' }),
+      getAllReviewHistories: jest.fn(),
+      updateReviewHistoryTitle: jest.fn(),
+      updateReviewHistoryAdditionalInstructionsAndCommentFormat: jest.fn(),
+      updateReviewHistoryEvaluationSettings: jest.fn(),
+      updateReviewHistoryProcessingStatus: jest.fn(),
+      updateReviewHistoryTargetDocumentName: jest.fn().mockResolvedValue(undefined),
+      deleteReviewHistory: jest.fn(),
+      getChecklists: jest.fn(),
+      createChecklist: jest.fn(),
+      updateChecklist: jest.fn(),
+      deleteChecklist: jest.fn(),
+      deleteSystemCreatedChecklists: jest.fn(),
+      upsertReviewResult: jest.fn().mockResolvedValue(undefined),
+      getReviewChecklistResults: jest.fn(),
+      deleteAllReviewResults: jest.fn().mockResolvedValue(undefined),
+      deleteReviewDocumentCaches: jest.fn().mockResolvedValue(undefined),
+      deleteReviewLargedocumentResultCaches: jest.fn().mockResolvedValue(undefined),
+      updateReviewHistoryDocumentMode: jest.fn().mockResolvedValue(undefined),
+      createReviewDocumentCache: jest.fn(),
+      getReviewDocumentCaches: jest.fn(),
+      getReviewDocumentCacheById: jest.fn(),
+      getReviewDocumentCacheByIds: jest.fn(),
+      createReviewLargedocumentResultCache: jest.fn().mockResolvedValue(undefined),
+      getReviewLargedocumentResultCaches: jest.fn(),
+      getMaxTotalChunksForDocument: jest.fn(),
+      getChecklistResultsWithIndividualResults: jest.fn(),
+    } as jest.Mocked<IReviewRepository>;
+
+    (getReviewRepository as jest.Mock).mockReturnValue(mockRepository);
+
+    // FileExtractorのモック
+    mockExtractText.mockResolvedValue({
+      content: 'テストファイルの内容',
+    });
+
+    // Mastraエージェントのモック
+    mockClassifyCategoryAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockReviewExecuteAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockIndividualDocumentReviewAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockConsolidateReviewAgent = {
+      generateLegacy: jest.fn(),
+    };
+
+    // mastra.getAgentのモック
+    jest.spyOn(mastra, 'getAgent').mockImplementation((agentName: string) => {
+      if (agentName === 'classifyCategoryAgent') {
+        return mockClassifyCategoryAgent;
+      }
+      if (agentName === 'reviewExecuteAgent') {
+        return mockReviewExecuteAgent;
+      }
+      if (agentName === 'individualDocumentReviewAgent') {
+        return mockIndividualDocumentReviewAgent;
+      }
+      if (agentName === 'consolidateReviewAgent') {
+        return mockConsolidateReviewAgent;
+      }
+      throw new Error(`Unknown agent: ${agentName}`);
+    });
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+    mockExtractText.mockReset();
+  });
+
+  describe('少量ドキュメントモード（small）', () => {
+    describe('正常系', () => {
+      it('基本的なレビュー実行が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 3, content: 'チェック項目3', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        // MAX_CHECKLISTS_PER_CATEGORY = 1なので手動分割
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: 'コメント1', evaluation: 'A' },
+            { checklistId: 2, reviewSections: [], comment: 'コメント2', evaluation: 'B' },
+            { checklistId: 3, reviewSections: [], comment: 'コメント3', evaluation: 'C' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // DB操作の確認
+        expect(mockRepository.deleteReviewLargedocumentResultCaches).toHaveBeenCalledWith(reviewHistoryId);
+        expect(mockRepository.deleteReviewDocumentCaches).toHaveBeenCalledWith(reviewHistoryId);
+        expect(mockRepository.deleteAllReviewResults).toHaveBeenCalledWith(reviewHistoryId);
+        expect(mockRepository.updateReviewHistoryDocumentMode).toHaveBeenCalledWith(reviewHistoryId, 'small');
+        expect(mockRepository.createReviewDocumentCache).toHaveBeenCalled();
+        expect(mockRepository.upsertReviewResult).toHaveBeenCalled();
+      });
+
+      it('複数ファイルの統合レビューが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document1.txt',
+            path: '/test/document1.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+          {
+            id: 'file-2',
+            name: 'document2.txt',
+            path: '/test/document2.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache
+          .mockResolvedValueOnce({
+            id: 1,
+            reviewHistoryId,
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ファイル1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+          })
+          .mockResolvedValueOnce({
+            id: 2,
+            reviewHistoryId,
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ファイル2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+          });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: 'コメント1', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(FileExtractor.extractText).toHaveBeenCalledTimes(2);
+        expect(mockRepository.createReviewDocumentCache).toHaveBeenCalledTimes(2);
+        expect(mockRepository.updateReviewHistoryTargetDocumentName).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'document1.txt/document2.txt',
+        );
+      });
+
+      it('画像モード（ページ別）でのレビューが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.pdf',
+            path: '/test/document.pdf',
+            type: 'application/pdf',
+            processMode: 'image',
+            imageMode: 'pages',
+            imageData: [
+              'data:image/png;base64,page1',
+              'data:image/png;base64,page2',
+              'data:image/png;base64,page3',
+            ],
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: '画像レビュー', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(FileExtractor.extractText).not.toHaveBeenCalled();
+
+        // reviewExecuteAgentに画像データが渡されることを確認
+        const callArgs = mockReviewExecuteAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page1',
+            }),
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page2',
+            }),
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page3',
+            }),
+          ]),
+        );
+      });
+
+      it('カスタム評定項目を使用したレビューが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+        const evaluationSettings = {
+          items: [
+            { label: '優', description: '優れている' },
+            { label: '良', description: '良好' },
+            { label: '可', description: '可もなく不可もなく' },
+            { label: '不可', description: '改善が必要' },
+          ],
+        };
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: 'カスタム評定', evaluation: '優' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+            evaluationSettings,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // runtimeContextにevaluationSettingsが設定されていることを確認
+        const callArgs = mockReviewExecuteAgent.generateLegacy.mock.calls[0];
+        const options = callArgs[1];
+        expect(options.runtimeContext.get('evaluationSettings')).toEqual(evaluationSettings);
+      });
+
+      it('追加指示とコメントフォーマット指定が正しく動作すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+        const additionalInstructions = 'セキュリティの観点で厳しくレビューしてください';
+        const commentFormat = '- 問題点:\n- 推奨事項:';
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: '- 問題点: なし\n- 推奨事項: なし', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+            additionalInstructions,
+            commentFormat,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // runtimeContextに設定されていることを確認
+        const callArgs = mockReviewExecuteAgent.generateLegacy.mock.calls[0];
+        const options = callArgs[1];
+        expect(options.runtimeContext.get('additionalInstructions')).toBe(additionalInstructions);
+        expect(options.runtimeContext.get('commentFormat')).toBe(commentFormat);
+      });
+
+      it('レビュー結果に未含まれチェックリストの再試行が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 3, content: 'チェック項目3', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        // MAX_CHECKLISTS_PER_CATEGORY = 1 なので、3つのカテゴリに分割される
+        // カテゴリ1(ID=1): 1回目空、2回目成功
+        // カテゴリ2(ID=2): 1回目成功
+        // カテゴリ3(ID=3): 1回目成功
+        mockReviewExecuteAgent.generateLegacy
+          // カテゴリ1の1回目（空）
+          .mockResolvedValueOnce({
+            object: [],
+            finishReason: 'stop',
+          })
+          // カテゴリ2の1回目（成功）
+          .mockResolvedValueOnce({
+            object: [
+              { checklistId: 2, reviewSections: [], comment: 'コメント2', evaluation: 'B' },
+            ],
+            finishReason: 'stop',
+          })
+          // カテゴリ3の1回目（成功）
+          .mockResolvedValueOnce({
+            object: [
+              { checklistId: 3, reviewSections: [], comment: 'コメント3', evaluation: 'C' },
+            ],
+            finishReason: 'stop',
+          })
+          // カテゴリ1の2回目（成功）
+          .mockResolvedValueOnce({
+            object: [
+              { checklistId: 1, reviewSections: [], comment: 'コメント1', evaluation: 'A' },
+            ],
+            finishReason: 'stop',
+          });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockReviewExecuteAgent.generateLegacy).toHaveBeenCalledTimes(4); // カテゴリ1が2回、他が1回ずつ
+        expect(mockRepository.upsertReviewResult).toHaveBeenCalled();
+      });
+    });
+
+    describe('異常系', () => {
+      it('テキスト抽出失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+
+        mockExtractText.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'ファイル読み込みエラー' },
+          }),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ファイル読み込みエラー');
+      });
+
+      it('チェックリスト取得失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+
+        mockRepository.getChecklists.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'DB接続エラー' },
+          }),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('DB接続エラー');
+      });
+
+      it('チェックリストが存在しない場合にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue([]);
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('対象のチェックリストが存在しないためレビューを実行できませんでした');
+      });
+
+      it('レビューエージェントAPIエラー時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'AI APIエラー' },
+          }),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('AI APIエラー');
+      });
+
+      it('最大試行回数超過時にエラーメッセージに未完了項目が含まれること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        // 3回とも ID 1のみ返却（ID 2は常に未完了）
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: 'コメント1', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('チェック項目2');
+        expect(checkResult.errorMessage).toContain('AIの出力にレビュー結果が含まれませんでした');
+      });
+
+      it('finishReasonがlengthの場合に適切なエラーメッセージが返ること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [],
+          finishReason: 'length',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('最大出力コンテキストを超えました');
+      });
+
+      it('画像モード（統合画像）でのレビューが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.pdf',
+            path: '/test/document.pdf',
+            type: 'application/pdf',
+            processMode: 'image',
+            imageMode: 'merged',
+            imageData: ['data:image/png;base64,merged'],
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: '統合画像レビュー', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(FileExtractor.extractText).not.toHaveBeenCalled();
+
+        // reviewExecuteAgentに統合画像データが渡されることを確認
+        const callArgs = mockReviewExecuteAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,merged',
+            }),
+          ]),
+        );
+      });
+
+      it('createReviewDocumentCache失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockRejectedValue(
+          new Error('キャッシュ保存エラー'),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        // map内でのエラーは不明なエラーとしてキャッチされる
+        expect(checkResult.errorMessage).toBeTruthy();
+      });
+
+      it('upsertReviewResult失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, reviewSections: [], comment: 'コメント', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        mockRepository.upsertReviewResult.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'レビュー結果保存エラー' },
+          }),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'small',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('レビュー結果保存エラー');
+      });
+    });
+  });
+
+  describe('大量ドキュメントモード（large）', () => {
+    describe('正常系', () => {
+      it('個別ドキュメントレビューと統合が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document1.txt',
+            path: '/test/document1.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+          {
+            id: 'file-2',
+            name: 'document2.txt',
+            path: '/test/document2.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache
+          .mockResolvedValueOnce({
+            id: 1,
+            reviewHistoryId,
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ファイル1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+          })
+          .mockResolvedValueOnce({
+            id: 2,
+            reviewHistoryId,
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ファイル2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+          });
+
+        // 個別ドキュメントレビュー
+        // 実行時のコンテキスト（対象チェックリスト）に応じて適切な結果を返す
+        mockIndividualDocumentReviewAgent.generateLegacy.mockImplementation(async (_message: any, options: any) => {
+          const checklistItems = options?.runtimeContext?.get('checklistItems') || [];
+          // 実際に対象となっているチェックリストIDのみの結果を返す
+          return {
+            object: checklistItems.map((item: any) => ({
+              reviewSections: [],
+              checklistId: item.id,
+              comment: `個別コメント${item.id}`,
+            })),
+            finishReason: 'stop',
+          };
+        });
+
+        // 統合レビュー
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント1', evaluation: 'A' },
+            { checklistId: 2, comment: '統合コメント2', evaluation: 'B' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockIndividualDocumentReviewAgent.generateLegacy).toHaveBeenCalledTimes(4); // 2ファイル × 2カテゴリ
+        expect(mockConsolidateReviewAgent.generateLegacy).toHaveBeenCalledTimes(2); // 2カテゴリ
+
+        // 個別レビュー結果キャッシュ保存の詳細検証
+        // 2ファイル × 2チェックリスト = 4回呼ばれる
+        expect(mockRepository.createReviewLargedocumentResultCache).toHaveBeenCalledTimes(4);
+
+        // 各ドキュメントキャッシュIDに対して正しく保存されることを確認
+        const largeDocCacheCalls = mockRepository.createReviewLargedocumentResultCache.mock.calls;
+
+        // document1 (cacheId=1) に対するキャッシュ保存 (2チェックリスト = 2回)
+        const doc1Calls = largeDocCacheCalls.filter((call) => call[0].reviewDocumentCacheId === 1);
+        expect(doc1Calls.length).toBe(2);
+        expect(doc1Calls).toEqual(
+          expect.arrayContaining([
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 1,
+                reviewChecklistId: 1,
+                comment: '個別コメント1',
+                totalChunks: 1,
+                chunkIndex: 0,
+              }),
+            ]),
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 1,
+                reviewChecklistId: 2,
+                comment: '個別コメント2',
+                totalChunks: 1,
+                chunkIndex: 0,
+              }),
+            ]),
+          ]),
+        );
+
+        // document2 (cacheId=2) に対するキャッシュ保存 (2チェックリスト = 2回)
+        const doc2Calls = largeDocCacheCalls.filter((call) => call[0].reviewDocumentCacheId === 2);
+        expect(doc2Calls.length).toBe(2);
+        expect(doc2Calls).toEqual(
+          expect.arrayContaining([
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 2,
+                reviewChecklistId: 1,
+                comment: '個別コメント1',
+                totalChunks: 1,
+                chunkIndex: 0,
+              }),
+            ]),
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 2,
+                reviewChecklistId: 2,
+                comment: '個別コメント2',
+                totalChunks: 1,
+                chunkIndex: 0,
+              }),
+            ]),
+          ]),
+        );
+
+        expect(mockRepository.upsertReviewResult).toHaveBeenCalled();
+      });
+
+      it('ドキュメント自動分割（テキスト）が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'large-document.txt',
+            path: '/test/large-document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockExtractText.mockResolvedValue({
+          content: 'A'.repeat(10000), // 長いテキスト
+        });
+        let cacheIdCounter = 1;
+        mockRepository.createReviewDocumentCache.mockImplementation(async () => ({
+          id: cacheIdCounter++,
+          reviewHistoryId,
+          fileName: 'large-document.txt',
+          processMode: 'text',
+          textContent: 'A'.repeat(10000),
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        }));
+
+        // 1回目: コンテキスト長エラー例外をthrow
+        // 2回目以降: 分割後の各チャンクで成功 (documentIdを含める)
+        let callCount = 0;
+        mockIndividualDocumentReviewAgent.generateLegacy.mockImplementation(async (message: any) => {
+          callCount++;
+          if (callCount === 1) {
+            // コンテキスト長エラーを示すAPICallErrorをthrow
+            throw new APICallError({
+              message: 'Context length exceeded',
+              url: 'http://test-api',
+              requestBodyValues: {},
+              statusCode: 400,
+              responseBody: JSON.stringify({ error: 'maximum context length exceeded' }),
+              cause: new Error('maximum context length exceeded'),
+              isRetryable: false,
+            });
+          }
+          // documentIdを生成（分割後のドキュメント用）
+          const textContent = message.content.find((c: any) => c.type === 'text')?.text || '';
+          const isPart = textContent.includes('part');
+          const partMatch = textContent.match(/part (\d+)/);
+          const documentId = isPart && partMatch ? `1_part${partMatch[1]}` : '1';
+
+          return {
+            object: [
+              { reviewSections: [], checklistId: 1, comment: '分割後コメント', documentId },
+            ],
+            finishReason: 'stop',
+          };
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        // 1回目失敗 + 2回目は2分割して成功 = 3回呼ばれる
+        expect(mockIndividualDocumentReviewAgent.generateLegacy).toHaveBeenCalledTimes(3);
+        expect(mockConsolidateReviewAgent.generateLegacy).toHaveBeenCalled();
+
+        // 分割後の個別レビュー結果キャッシュ保存の検証
+        // 2つの分割チャンクに対して各1チェックリスト = 2回呼ばれる
+        expect(mockRepository.createReviewLargedocumentResultCache).toHaveBeenCalledTimes(2);
+
+        const splitCacheCalls = mockRepository.createReviewLargedocumentResultCache.mock.calls;
+
+        // part1のキャッシュ保存検証
+        expect(splitCacheCalls).toEqual(
+          expect.arrayContaining([
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 1,
+                reviewChecklistId: 1,
+                comment: '分割後コメント',
+                totalChunks: 2,
+                chunkIndex: 0,
+                individualFileName: expect.stringContaining('part 1'),
+              }),
+            ]),
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 1,
+                reviewChecklistId: 1,
+                comment: '分割後コメント',
+                totalChunks: 2,
+                chunkIndex: 1,
+                individualFileName: expect.stringContaining('part 2'),
+              }),
+            ]),
+          ]),
+        );
+      });
+
+      it('ドキュメント自動分割（画像）が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'large-pdf.pdf',
+            path: '/test/large-pdf.pdf',
+            type: 'application/pdf',
+            processMode: 'image',
+            imageMode: 'pages',
+            imageData: Array(20).fill('data:image/png;base64,page'), // 20ページ
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        let cacheIdCounter = 1;
+        mockRepository.createReviewDocumentCache.mockImplementation(async () => ({
+          id: cacheIdCounter++,
+          reviewHistoryId,
+          fileName: 'large-pdf.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: Array(20).fill('data:image/png;base64,page'),
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        }));
+
+        // 1回目: コンテキスト長エラー例外をthrow
+        // 2回目以降: 分割後の各チャンクで成功 (documentIdを含める)
+        let callCount = 0;
+        mockIndividualDocumentReviewAgent.generateLegacy.mockImplementation(async (message: any) => {
+          callCount++;
+          if (callCount === 1) {
+            // 画像が多すぎるエラーを示すAPICallErrorをthrow
+            throw new APICallError({
+              message: 'Too many images',
+              url: 'http://test-api',
+              requestBodyValues: {},
+              statusCode: 400,
+              responseBody: JSON.stringify({ error: 'too many images in request' }),
+              cause: new Error('too many images'),
+              isRetryable: false,
+            });
+          }
+          // documentIdを生成（分割後のドキュメント用）
+          const textContent = message.content.find((c: any) => c.type === 'text')?.text || '';
+          const isPart = textContent.includes('part');
+          const partMatch = textContent.match(/part (\d+)/);
+          const documentId = isPart && partMatch ? `1_part${partMatch[1]}` : '1';
+
+          return {
+            object: [
+              { reviewSections: [], checklistId: 1, comment: '分割後コメント', documentId },
+            ],
+            finishReason: 'stop',
+          };
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        // 1回目失敗 + 2回目は2分割して成功 = 3回呼ばれる
+        expect(mockIndividualDocumentReviewAgent.generateLegacy).toHaveBeenCalledTimes(3);
+        expect(mockConsolidateReviewAgent.generateLegacy).toHaveBeenCalled();
+
+        // 分割後の個別レビュー結果キャッシュ保存の検証（画像）
+        // 2つの分割チャンクに対して各1チェックリスト = 2回呼ばれる
+        expect(mockRepository.createReviewLargedocumentResultCache).toHaveBeenCalledTimes(2);
+
+        const imageSplitCacheCalls = mockRepository.createReviewLargedocumentResultCache.mock.calls;
+
+        // 画像分割のキャッシュ保存検証
+        expect(imageSplitCacheCalls).toEqual(
+          expect.arrayContaining([
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 1,
+                reviewChecklistId: 1,
+                comment: '分割後コメント',
+                totalChunks: 2,
+                chunkIndex: 0,
+                individualFileName: expect.stringContaining('part 1'),
+              }),
+            ]),
+            expect.arrayContaining([
+              expect.objectContaining({
+                reviewDocumentCacheId: 1,
+                reviewChecklistId: 1,
+                comment: '分割後コメント',
+                totalChunks: 2,
+                chunkIndex: 1,
+                individualFileName: expect.stringContaining('part 2'),
+              }),
+            ]),
+          ]),
+        );
+      });
+
+      it('追加指示とコメントフォーマット指定が正しく動作すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+        const additionalInstructions = 'セキュリティの観点で厳しくレビューしてください';
+        const commentFormat = '- 問題点:\n- 推奨事項:';
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント' },
+          ],
+          finishReason: 'stop',
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '- 問題点: なし\n- 推奨事項: なし', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+            additionalInstructions,
+            commentFormat,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // individualDocumentReviewAgentに設定されていることを確認
+        const individualCallArgs = mockIndividualDocumentReviewAgent.generateLegacy.mock.calls[0];
+        const individualOptions = individualCallArgs[1];
+        expect(individualOptions.runtimeContext.get('additionalInstructions')).toBe(additionalInstructions);
+        expect(individualOptions.runtimeContext.get('commentFormat')).toBe(commentFormat);
+
+        // consolidateReviewAgentに設定されていることを確認
+        const consolidateCallArgs = mockConsolidateReviewAgent.generateLegacy.mock.calls[0];
+        const consolidateOptions = consolidateCallArgs[1];
+        expect(consolidateOptions.runtimeContext.get('additionalInstructions')).toBe(additionalInstructions);
+        expect(consolidateOptions.runtimeContext.get('commentFormat')).toBe(commentFormat);
+      });
+
+      it('カスタム評定項目を使用したレビューが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+        const evaluationSettings = {
+          items: [
+            { label: '優', description: '優れている' },
+            { label: '良', description: '良好' },
+            { label: '可', description: '可もなく不可もなく' },
+            { label: '不可', description: '改善が必要' },
+          ],
+        };
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント' },
+          ],
+          finishReason: 'stop',
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: 'カスタム評定', evaluation: '優' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+            evaluationSettings,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // consolidateReviewAgentにevaluationSettingsが設定されていることを確認
+        const consolidateCallArgs = mockConsolidateReviewAgent.generateLegacy.mock.calls[0];
+        const consolidateOptions = consolidateCallArgs[1];
+        expect(consolidateOptions.runtimeContext.get('evaluationSettings')).toEqual(evaluationSettings);
+      });
+
+      it('統合画像（merged）での大量ドキュメントレビューが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.pdf',
+            path: '/test/document.pdf',
+            type: 'application/pdf',
+            processMode: 'image',
+            imageMode: 'merged',
+            imageData: ['data:image/png;base64,merged'],
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: ['data:image/png;base64,merged'],
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント' },
+          ],
+          finishReason: 'stop',
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(FileExtractor.extractText).not.toHaveBeenCalled();
+
+        // individualDocumentReviewAgentに統合画像データが渡されることを確認
+        const callArgs = mockIndividualDocumentReviewAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,merged',
+            }),
+          ]),
+        );
+      });
+
+      it('個別レビューでの未完了チェックリスト再試行が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        // 1回目: ID 1のみ返却
+        // 2回目: ID 2を返却
+        mockIndividualDocumentReviewAgent.generateLegacy
+          .mockResolvedValueOnce({
+            object: [
+              { reviewSections: [], checklistId: 1, comment: '個別コメント1' },
+            ],
+            finishReason: 'stop',
+          })
+          .mockResolvedValueOnce({
+            object: [
+              { reviewSections: [], checklistId: 2, comment: '個別コメント2' },
+            ],
+            finishReason: 'stop',
+          });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント1', evaluation: 'A' },
+            { checklistId: 2, comment: '統合コメント2', evaluation: 'B' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockIndividualDocumentReviewAgent.generateLegacy).toHaveBeenCalledTimes(2);
+      });
+
+      it('統合レビューでの未完了チェックリスト再試行が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント1' },
+            { reviewSections: [], checklistId: 2, comment: '個別コメント2' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // 1回目: ID 1のみ返却
+        // 2回目: ID 2を返却
+        mockConsolidateReviewAgent.generateLegacy
+          .mockResolvedValueOnce({
+            object: [
+              { checklistId: 1, comment: '統合コメント1', evaluation: 'A' },
+            ],
+            finishReason: 'stop',
+          })
+          .mockResolvedValueOnce({
+            object: [
+              { checklistId: 2, comment: '統合コメント2', evaluation: 'B' },
+            ],
+            finishReason: 'stop',
+          });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect(mockConsolidateReviewAgent.generateLegacy).toHaveBeenCalledTimes(2);
+      });
+
+      it('新規実行時のキャッシュクリア→保存フローが正しく動作すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント' },
+          ],
+          finishReason: 'stop',
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 削除処理が呼ばれていることを確認
+        expect(mockRepository.deleteReviewLargedocumentResultCaches).toHaveBeenCalledWith(reviewHistoryId);
+        expect(mockRepository.deleteReviewDocumentCaches).toHaveBeenCalledWith(reviewHistoryId);
+        expect(mockRepository.deleteAllReviewResults).toHaveBeenCalledWith(reviewHistoryId);
+
+        // documentMode保存が呼ばれていることを確認
+        expect(mockRepository.updateReviewHistoryDocumentMode).toHaveBeenCalledWith(
+          reviewHistoryId,
+          'large',
+        );
+
+        // ドキュメントキャッシュが保存されていることを確認
+        expect(mockRepository.createReviewDocumentCache).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId,
+            fileName: 'document.txt',
+            processMode: 'text',
+            textContent: 'テストファイルの内容',
+          }),
+        );
+
+        // 個別レビュー結果キャッシュが保存されていることを確認
+        expect(mockRepository.createReviewLargedocumentResultCache).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewDocumentCacheId: 1,
+            reviewChecklistId: 1,
+            comment: '個別コメント',
+          }),
+        );
+      });
+    });
+
+    describe('異常系', () => {
+      it('個別ドキュメントレビュー失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: '個別レビューエラー' },
+          }),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('個別レビューエラー');
+      });
+
+      it('統合レビュー失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント' },
+          ],
+          finishReason: 'stop',
+        });
+
+        mockConsolidateReviewAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: '統合レビューエラー' },
+          }),
+        );
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('統合レビューエラー');
+      });
+
+      it('分割リトライ最大回数超過時にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        let cacheIdCounter = 1;
+        mockRepository.createReviewDocumentCache.mockImplementation(async () => ({
+          id: cacheIdCounter++,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        }));
+
+        // 常にコンテキスト長エラー例外をthrow (最大5回リトライまで)
+        mockIndividualDocumentReviewAgent.generateLegacy.mockImplementation(async () => {
+          // 常にコンテキスト長エラーをthrow
+          throw new APICallError({
+            message: 'Context length exceeded',
+            url: 'http://test-api',
+            requestBodyValues: {},
+            statusCode: 400,
+            responseBody: JSON.stringify({ error: 'maximum context length exceeded' }),
+            cause: new Error('maximum context length exceeded'),
+            isRetryable: false,
+          });
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        // リトライ最大回数に達した場合、いずれかのエラーメッセージが返される
+        // 「コンテキスト長エラーが解消されませんでした」または個別レビューステップのエラー
+        expect(checkResult.errorMessage).toBeTruthy();
+        expect(mockIndividualDocumentReviewAgent.generateLegacy).toHaveBeenCalled();
+      });
+
+      it('個別レビュー未完了チェックリスト最大試行回数超過時にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        // 3回ともID 1のみ返却（ID 2は常に未完了）
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント1' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('チェック項目2');
+        expect(checkResult.errorMessage).toContain('AIの出力にレビュー結果が含まれませんでした');
+      });
+
+      it('統合レビュー未完了チェックリスト最大試行回数超過時にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const files: UploadFile[] = [
+          {
+            id: 'file-1',
+            name: 'document.txt',
+            path: '/test/document.txt',
+            type: 'text/plain',
+            processMode: 'text',
+          },
+        ];
+        const checklists: ReviewChecklist[] = [
+          { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+          { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        ];
+
+        mockRepository.getChecklists.mockResolvedValue(checklists);
+        mockRepository.createReviewDocumentCache.mockResolvedValue({
+          id: 1,
+          reviewHistoryId,
+          fileName: 'document.txt',
+          processMode: 'text',
+          textContent: 'テストファイルの内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockIndividualDocumentReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { reviewSections: [], checklistId: 1, comment: '個別コメント1' },
+            { reviewSections: [], checklistId: 2, comment: '個別コメント2' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // 3回ともID 1のみ返却（ID 2は常に未完了）
+        mockConsolidateReviewAgent.generateLegacy.mockResolvedValue({
+          object: [
+            { checklistId: 1, comment: '統合コメント1', evaluation: 'A' },
+          ],
+          finishReason: 'stop',
+        });
+
+        // Act
+        const run = await executeReviewWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            files,
+            documentMode: 'large',
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('チェック項目2');
+        expect(checkResult.errorMessage).toContain('AIの出力に統合レビュー結果が含まれませんでした');
+      });
+    });
+  });
+
+  describe('カテゴリ分類関連', () => {
+    it('カテゴリ分類AIエラー時の手動分割フォールバックが成功すること', async () => {
+      // Arrange
+      const reviewHistoryId = 'review-1';
+      const files: UploadFile[] = [
+        {
+          id: 'file-1',
+          name: 'document.txt',
+          path: '/test/document.txt',
+          type: 'text/plain',
+          processMode: 'text',
+        },
+      ];
+      const checklists: ReviewChecklist[] = [
+        { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+        { id: 2, content: 'チェック項目2', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+      ];
+
+      mockRepository.getChecklists.mockResolvedValue(checklists);
+      mockRepository.createReviewDocumentCache.mockResolvedValue({
+        id: 1,
+        reviewHistoryId,
+        fileName: 'document.txt',
+        processMode: 'text',
+        textContent: 'テストファイルの内容',
+        imageData: undefined,
+        createdAt: '2024-01-01',
+        updatedAt: '2024-01-01',
+      });
+
+      // classifyCategoryAgentをエラーにする
+      mockClassifyCategoryAgent.generateLegacy.mockRejectedValue(
+        internalError({
+          expose: true,
+          messageCode: 'PLAIN_MESSAGE',
+          messageParams: { message: 'AI APIエラー' },
+        }),
+      );
+
+      mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+        object: [
+          { checklistId: 1, reviewSections: [], comment: 'コメント1', evaluation: 'A' },
+          { checklistId: 2, reviewSections: [], comment: 'コメント2', evaluation: 'B' },
+        ],
+        finishReason: 'stop',
+      });
+
+      // Act
+      const run = await executeReviewWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          reviewHistoryId,
+          files,
+          documentMode: 'small',
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      expect(checkResult.status).toBe('success');
+      // 手動分割でもレビューが成功すること
+      expect(mockReviewExecuteAgent.generateLegacy).toHaveBeenCalled();
+    });
+  });
+
+  describe('エッジケース', () => {
+    it('カテゴリ分類でAIが全IDを返さない場合、その他カテゴリに含まれること', async () => {
+      // このテストはclassifyChecklistsByCategoryStepの内部ロジックなので、
+      // MAX_CHECKLISTS_PER_CATEGORY > 1に設定する必要がある
+      // 現在の実装では MAX_CHECKLISTS_PER_CATEGORY = 1なのでスキップ
+      // 将来的にMAX_CHECKLISTS_PER_CATEGORYを変更可能にした場合に有効化
+    });
+
+    it('空のimageDataでもエラーにならないこと', async () => {
+      // Arrange
+      const reviewHistoryId = 'review-1';
+      const files: UploadFile[] = [
+        {
+          id: 'file-1',
+          name: 'empty.pdf',
+          path: '/test/empty.pdf',
+          type: 'application/pdf',
+          processMode: 'image',
+          imageMode: 'pages',
+          imageData: [],
+        },
+      ];
+      const checklists: ReviewChecklist[] = [
+        { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+      ];
+
+      mockRepository.getChecklists.mockResolvedValue(checklists);
+      mockRepository.createReviewDocumentCache.mockResolvedValue({
+        id: 1,
+        reviewHistoryId,
+        fileName: 'empty.pdf',
+        processMode: 'image',
+        textContent: undefined,
+        imageData: undefined,
+        createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+      });
+
+      mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+        object: [
+          { checklistId: 1, reviewSections: [], comment: 'コメント', evaluation: 'A' },
+        ],
+        finishReason: 'stop',
+      });
+
+      // Act
+      const run = await executeReviewWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          reviewHistoryId,
+          files,
+          documentMode: 'small',
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      expect(checkResult.status).toBe('success');
+    });
+
+    it('空のtextContentでもエラーにならないこと', async () => {
+      // Arrange
+      const reviewHistoryId = 'review-1';
+      const files: UploadFile[] = [
+        {
+          id: 'file-1',
+          name: 'empty.txt',
+          path: '/test/empty.txt',
+          type: 'text/plain',
+          processMode: 'text',
+        },
+      ];
+      const checklists: ReviewChecklist[] = [
+        { id: 1, content: 'チェック項目1', createdBy: 'user', reviewHistoryId, createdAt: '2024-01-01', updatedAt: '2024-01-01' },
+      ];
+
+      mockExtractText.mockResolvedValue({
+        content: '',
+      });
+
+      mockRepository.getChecklists.mockResolvedValue(checklists);
+      mockRepository.createReviewDocumentCache.mockResolvedValue({
+        id: 1,
+        reviewHistoryId,
+        fileName: 'empty.txt',
+        processMode: 'text',
+        textContent: '',
+        imageData: undefined,
+        createdAt: '2024-01-01',
+        updatedAt: '2024-01-01',
+      });
+
+      mockReviewExecuteAgent.generateLegacy.mockResolvedValue({
+        object: [
+          { checklistId: 1, reviewSections: [], comment: 'コメント', evaluation: 'A' },
+        ],
+        finishReason: 'stop',
+      });
+
+      // Act
+      const run = await executeReviewWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          reviewHistoryId,
+          files,
+          documentMode: 'small',
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      expect(checkResult.status).toBe('success');
+    });
+  });
+});
diff --git a/src/__tests__/main/workflows/reviewChat.test.ts b/src/__tests__/main/workflows/reviewChat.test.ts
new file mode 100644
index 000000000..fbcd37d39
--- /dev/null
+++ b/src/__tests__/main/workflows/reviewChat.test.ts
@@ -0,0 +1,2897 @@
+/**
+ * チャット質問ワークフローのテスト
+ * @jest-environment node
+ */
+
+// Electron モックを最初に適用（他のインポートより前に実行する必要がある）
+jest.mock('electron', () => require('../test-utils/mockElectron').mockElectron);
+jest.mock('electron-store', () => require('../test-utils/mockElectron').default);
+
+// main.ts の初期化処理をスキップ（テスト環境では不要）
+jest.mock('@/main/main', () => {
+  const path = require('path');
+  const os = require('os');
+  // テンポラリディレクトリを使用（実際に存在するディレクトリ）
+  const testAppData = path.join(os.tmpdir(), 'ai-notebook-test');
+  return {
+    getCustomAppDataDir: jest.fn(() => testAppData),
+  };
+});
+
+import { reviewChatWorkflow } from '@/mastra/workflows/reviewChat';
+import { mastra } from '@/mastra';
+import { getReviewRepository } from '@/adapter/db';
+import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
+import type { IReviewRepository } from '@/main/service/port/repository/IReviewRepository';
+import { internalError } from '@/main/lib/error';
+import { DataStreamWriter } from 'ai';
+import { APICallError } from 'ai';
+
+const { RuntimeContext } = require('@mastra/core/runtime-context');
+
+// モック設定
+jest.mock('@/adapter/db', () => ({
+  getReviewRepository: jest.fn(),
+  getSourceRepository: jest.fn(() => ({
+    getAllSources: jest.fn(),
+    getSourceById: jest.fn(),
+    createSource: jest.fn(),
+    updateSource: jest.fn(),
+    deleteSource: jest.fn(),
+    updateSourceEnabled: jest.fn(),
+  })),
+  getChatRepository: jest.fn(() => ({
+    getChatRooms: jest.fn(),
+    getChatMessages: jest.fn(),
+  })),
+  getSettingsRepository: jest.fn(() => ({
+    getSettings: jest.fn().mockReturnValue({
+      api: {
+        url: 'http://localhost:11434/v1',
+        key: 'test-api-key',
+        model: 'test-model',
+      },
+      database: {
+        dir: '/test/db',
+      },
+      source: {
+        registerDir: './test/source',
+      },
+    }),
+    setSettings: jest.fn(),
+  })),
+}));
+
+jest.mock('@/main/lib/eventPayloadHelper', () => ({
+  publishEvent: jest.fn(),
+}));
+
+// DataStreamWriterのモック
+const createMockDataStreamWriter = (): jest.Mocked<DataStreamWriter> => ({
+  write: jest.fn(),
+} as any);
+
+describe('reviewChatWorkflow', () => {
+  // モックリポジトリ
+  let mockRepository: jest.Mocked<IReviewRepository>;
+
+  // モックエージェント
+  let mockReviewChatPlanningAgent: any;
+  let mockReviewChatResearchAgent: any;
+  let mockReviewChatAnswerAgent: any;
+
+  // モックDataStreamWriter
+  let mockDataStreamWriter: jest.Mocked<DataStreamWriter>;
+
+  beforeEach(() => {
+    // リポジトリのモック
+    mockRepository = {
+      createReviewHistory: jest.fn(),
+      getReviewHistory: jest.fn(),
+      getAllReviewHistories: jest.fn(),
+      updateReviewHistoryTitle: jest.fn(),
+      updateReviewHistoryAdditionalInstructionsAndCommentFormat: jest.fn(),
+      updateReviewHistoryEvaluationSettings: jest.fn(),
+      updateReviewHistoryProcessingStatus: jest.fn(),
+      updateReviewHistoryTargetDocumentName: jest.fn(),
+      deleteReviewHistory: jest.fn(),
+      getChecklists: jest.fn(),
+      createChecklist: jest.fn(),
+      updateChecklist: jest.fn(),
+      deleteChecklist: jest.fn(),
+      deleteSystemCreatedChecklists: jest.fn(),
+      upsertReviewResult: jest.fn(),
+      getReviewChecklistResults: jest.fn(),
+      deleteAllReviewResults: jest.fn(),
+      deleteReviewDocumentCaches: jest.fn(),
+      deleteReviewLargedocumentResultCaches: jest.fn(),
+      updateReviewHistoryDocumentMode: jest.fn(),
+      createReviewDocumentCache: jest.fn(),
+      getReviewDocumentCaches: jest.fn().mockResolvedValue([
+        {
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'document1.txt',
+          processMode: 'text',
+          textContent: 'ドキュメント1の内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        },
+      ]),
+      getReviewDocumentCacheById: jest.fn().mockResolvedValue({
+        id: 1,
+        reviewHistoryId: 'review-1',
+        fileName: 'document1.txt',
+        processMode: 'text',
+        textContent: 'ドキュメント1の内容',
+        imageData: undefined,
+        createdAt: '2024-01-01',
+        updatedAt: '2024-01-01',
+      }),
+      getReviewDocumentCacheByIds: jest.fn().mockResolvedValue([
+        {
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'document1.txt',
+          processMode: 'text',
+          textContent: 'ドキュメント1の内容',
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        },
+      ]),
+      createReviewLargedocumentResultCache: jest.fn(),
+      getReviewLargedocumentResultCaches: jest.fn(),
+      getMaxTotalChunksForDocument: jest.fn().mockResolvedValue(1),
+      getChecklistResultsWithIndividualResults: jest.fn().mockResolvedValue([
+        {
+          checklistResult: {
+            id: 1,
+            content: 'チェック項目1',
+            sourceEvaluation: {
+              evaluation: 'A',
+              comment: '良好です',
+            },
+          },
+          individualResults: undefined,
+        },
+      ]),
+    } as jest.Mocked<IReviewRepository>;
+
+    (getReviewRepository as jest.Mock).mockReturnValue(mockRepository);
+
+    // Mastraエージェントのモック
+    mockReviewChatPlanningAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockReviewChatResearchAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockReviewChatAnswerAgent = {
+      generateLegacy: jest.fn(),
+    };
+
+    // mastra.getAgentのモック
+    jest.spyOn(mastra, 'getAgent').mockImplementation((agentName: string) => {
+      if (agentName === 'reviewChatPlanningAgent') {
+        return mockReviewChatPlanningAgent;
+      }
+      if (agentName === 'reviewChatResearchAgent') {
+        return mockReviewChatResearchAgent;
+      }
+      if (agentName === 'reviewChatAnswerAgent') {
+        return mockReviewChatAnswerAgent;
+      }
+      throw new Error(`Unknown agent: ${agentName}`);
+    });
+
+    // DataStreamWriterのモック
+    mockDataStreamWriter = createMockDataStreamWriter();
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe('正常系', () => {
+    describe('基本機能', () => {
+      it('基本的な質問処理が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = 'ドキュメントの内容を教えてください';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査する必要がある',
+                documentId: '1',
+                researchContent: 'ドキュメントの主要な内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: 'ドキュメント1には重要な情報が含まれています',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: 'ドキュメントには重要な情報が含まれており、問題ありません。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect((result as any).result?.answer).toBe(
+          'ドキュメントには重要な情報が含まれており、問題ありません。',
+        );
+
+        // AI呼び出しの確認
+        expect(mockReviewChatPlanningAgent.generateLegacy).toHaveBeenCalledTimes(
+          1,
+        );
+        expect(mockReviewChatResearchAgent.generateLegacy).toHaveBeenCalledTimes(
+          1,
+        );
+        expect(mockReviewChatAnswerAgent.generateLegacy).toHaveBeenCalledTimes(
+          1,
+        );
+
+        // DB操作の確認
+        expect(
+          mockRepository.getChecklistResultsWithIndividualResults,
+        ).toHaveBeenCalledWith(reviewHistoryId, checklistIds);
+        expect(mockRepository.getReviewDocumentCaches).toHaveBeenCalledWith(
+          reviewHistoryId,
+        );
+        expect(mockRepository.getMaxTotalChunksForDocument).toHaveBeenCalledWith(
+          1,
+        );
+
+        // DataStreamWriterの呼び出し確認
+        expect(mockDataStreamWriter.write).toHaveBeenCalled();
+      });
+
+      it('複数ドキュメント調査が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '複数のドキュメントの内容を教えてください';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+          {
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById
+          .mockResolvedValueOnce({
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          })
+          .mockResolvedValueOnce({
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+          {
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+              {
+                reasoning: 'ドキュメント2を調査',
+                documentId: '2',
+                researchContent: 'ドキュメント2の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '両方のドキュメントに重要な情報が含まれています。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 2つのドキュメントが並列で調査されることを確認
+        expect(mockReviewChatResearchAgent.generateLegacy).toHaveBeenCalledTimes(
+          2,
+        );
+      });
+    });
+
+    describe('画像処理', () => {
+      it('画像モード（ページ別）での調査が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '画像ドキュメントの内容を教えてください';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document.pdf',
+            processMode: 'image',
+            textContent: undefined,
+            imageData: [
+              'data:image/png;base64,page1',
+              'data:image/png;base64,page2',
+            ],
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'document.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: [
+            'data:image/png;base64,page1',
+            'data:image/png;base64,page2',
+          ],
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document.pdf',
+            processMode: 'image',
+            textContent: undefined,
+            imageData: [
+              'data:image/png;base64,page1',
+              'data:image/png;base64,page2',
+            ],
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '画像ドキュメントを調査',
+                documentId: '1',
+                researchContent: '画像の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '画像には重要な図表が含まれています',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '画像ドキュメントには重要な図表が含まれています。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // researchChunkStepに画像データが渡されることを確認
+        const callArgs =
+          mockReviewChatResearchAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page1',
+            }),
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,page2',
+            }),
+          ]),
+        );
+      });
+
+      it('画像モード（統合）での調査が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '統合画像ドキュメントの内容を教えてください';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document.pdf',
+            processMode: 'image',
+            textContent: undefined,
+            imageData: ['data:image/png;base64,merged'],
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'document.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: ['data:image/png;base64,merged'],
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document.pdf',
+            processMode: 'image',
+            textContent: undefined,
+            imageData: ['data:image/png;base64,merged'],
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '統合画像を調査',
+                documentId: '1',
+                researchContent: '統合画像の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '統合画像には全体的な構成が含まれています',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '統合画像には全体的な構成が含まれています。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 統合画像データが渡されることを確認
+        const callArgs =
+          mockReviewChatResearchAgent.generateLegacy.mock.calls[0];
+        const message = callArgs[0];
+        expect(message.content).toEqual(
+          expect.arrayContaining([
+            expect.objectContaining({
+              type: 'image',
+              image: 'data:image/png;base64,merged',
+            }),
+          ]),
+        );
+      });
+    });
+
+    describe('チャンク分割', () => {
+      it('コンテキスト長エラー後のチャンク分割が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '長いドキュメントの内容を教えてください';
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'long-document.txt',
+          processMode: 'text',
+          textContent: 'A'.repeat(10000),
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '長いドキュメントを調査',
+                documentId: '1',
+                researchContent: '長いドキュメントの内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        // 1回目: コンテキスト長エラー
+        // 2回目以降: チャンク分割後に成功
+        let callCount = 0;
+        mockReviewChatResearchAgent.generateLegacy.mockImplementation(
+          async () => {
+            callCount++;
+            if (callCount === 1) {
+              // コンテキスト長エラーをthrow
+              throw new APICallError({
+                message: 'Context length exceeded',
+                url: 'http://test-api',
+                requestBodyValues: {},
+                statusCode: 400,
+                responseBody: JSON.stringify({
+                  error: 'maximum context length exceeded',
+                }),
+                cause: new Error('maximum context length exceeded'),
+                isRetryable: false,
+              });
+            }
+            return {
+              text: '分割後の調査結果',
+              finishReason: 'stop',
+            };
+          },
+        );
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '長いドキュメントの内容を分割して調査しました。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 1回失敗 + 2チャンクで成功 = 3回呼ばれる
+        expect(mockReviewChatResearchAgent.generateLegacy).toHaveBeenCalledTimes(
+          3,
+        );
+      });
+
+      it('複数回のチャンク分割リトライが成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '非常に長いドキュメントの内容を教えてください';
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'very-long-document.txt',
+          processMode: 'text',
+          textContent: 'A'.repeat(20000),
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '非常に長いドキュメントを調査',
+                documentId: '1',
+                researchContent: '非常に長いドキュメントの内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        // 1回目と2回目: コンテキスト長エラー
+        // 3回目以降: チャンク分割後に成功
+        let callCount = 0;
+        mockReviewChatResearchAgent.generateLegacy.mockImplementation(
+          async () => {
+            callCount++;
+            if (callCount <= 2) {
+              // コンテキスト長エラーをthrow
+              throw new APICallError({
+                message: 'Context length exceeded',
+                url: 'http://test-api',
+                requestBodyValues: {},
+                statusCode: 400,
+                responseBody: JSON.stringify({
+                  error: 'maximum context length exceeded',
+                }),
+                cause: new Error('maximum context length exceeded'),
+                isRetryable: false,
+              });
+            }
+            return {
+              text: '分割後の調査結果',
+              finishReason: 'stop',
+            };
+          },
+        );
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '非常に長いドキュメントの内容を分割して調査しました。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 複数回のリトライが発生していることを確認
+        // 1回目: totalChunks=1で失敗、2回目: totalChunks=2で失敗、3回目: totalChunks=4で4チャンク並列実行して成功
+        expect(
+          mockReviewChatResearchAgent.generateLegacy,
+        ).toHaveBeenCalledTimes(6); // 1 + 1 + 4 = 6回
+      });
+    });
+
+    describe('レビューモード', () => {
+      it('レビューモード（large）での調査が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '個別レビュー結果について教えてください';
+
+        // individualResultsありのケース
+        mockRepository.getChecklistResultsWithIndividualResults.mockResolvedValue(
+          [
+            {
+              checklistResult: {
+                id: 1,
+                content: 'チェック項目1',
+                sourceEvaluation: {
+                  evaluation: 'A',
+                  comment: '良好です',
+                },
+              },
+              individualResults: [
+                {
+                  documentId: 1,
+                  comment: 'ドキュメント1は良好',
+                  individualFileName: 'document1.txt',
+                },
+                {
+                  documentId: 2,
+                  comment: 'ドキュメント2も良好',
+                  individualFileName: 'document2.txt',
+                },
+              ],
+            },
+          ],
+        );
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の個別レビュー結果を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '個別レビュー結果の調査完了',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '個別レビュー結果は良好です。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // planResearchStepのruntimeContextにreviewMode='large'が設定されることを確認
+        const planCallArgs =
+          mockReviewChatPlanningAgent.generateLegacy.mock.calls[0];
+        const planOptions = planCallArgs[1];
+        expect(planOptions.runtimeContext.get('reviewMode')).toBe('large');
+      });
+
+      it('レビューモード（small）での調査が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = 'レビュー結果について教えてください';
+
+        // individualResultsなしのケース
+        mockRepository.getChecklistResultsWithIndividualResults.mockResolvedValue(
+          [
+            {
+              checklistResult: {
+                id: 1,
+                content: 'チェック項目1',
+                sourceEvaluation: {
+                  evaluation: 'A',
+                  comment: '良好です',
+                },
+              },
+              individualResults: undefined,
+            },
+          ],
+        );
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1のレビュー結果を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: 'レビュー結果の調査完了',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: 'レビュー結果は良好です。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // planResearchStepのruntimeContextにreviewMode='small'が設定されることを確認
+        const planCallArgs =
+          mockReviewChatPlanningAgent.generateLegacy.mock.calls[0];
+        const planOptions = planCallArgs[1];
+        expect(planOptions.runtimeContext.get('reviewMode')).toBe('small');
+      });
+
+      it('大量ドキュメントレビュー時にindividualResultsがplanResearchStepのchecklistInfoに正しく反映されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '個別レビュー結果の詳細を教えてください';
+
+        // individualResultsが複数あるケース
+        mockRepository.getChecklistResultsWithIndividualResults.mockResolvedValue(
+          [
+            {
+              checklistResult: {
+                id: 1,
+                content: 'セキュリティ要件を満たしているか',
+                sourceEvaluation: {
+                  evaluation: 'B',
+                  comment: '一部改善が必要',
+                },
+              },
+              individualResults: [
+                {
+                  documentId: 1,
+                  comment: 'ドキュメント1では認証機能が不足',
+                  individualFileName: 'security-spec.pdf',
+                },
+                {
+                  documentId: 2,
+                  comment: 'ドキュメント2では暗号化が適切',
+                  individualFileName: 'encryption-design.pdf',
+                },
+                {
+                  documentId: 3,
+                  comment: 'ドキュメント3ではアクセス制御に問題あり',
+                  individualFileName: 'access-control.pdf',
+                },
+              ],
+            },
+          ],
+        );
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'セキュリティ仕様書を調査',
+                documentId: '1',
+                researchContent: '認証機能の不足について詳細調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '認証機能の詳細調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '個別レビュー結果の分析完了。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // planResearchStepの呼び出しを確認
+        const planCallArgs =
+          mockReviewChatPlanningAgent.generateLegacy.mock.calls[0];
+        const planOptions = planCallArgs[1];
+
+        // reviewMode='large'が設定されていることを確認
+        expect(planOptions.runtimeContext.get('reviewMode')).toBe('large');
+
+        // checklistInfoにindividualResultsの情報が含まれることを確認
+        const checklistInfo = planOptions.runtimeContext.get('checklistInfo');
+        expect(checklistInfo).toBeTruthy();
+        expect(checklistInfo).toContain('Individual Review Results:');
+        expect(checklistInfo).toContain('Document ID: 1');
+        expect(checklistInfo).toContain('Document Name: security-spec.pdf');
+        expect(checklistInfo).toContain('Comment: ドキュメント1では認証機能が不足');
+        expect(checklistInfo).toContain('Document ID: 2');
+        expect(checklistInfo).toContain('Document Name: encryption-design.pdf');
+        expect(checklistInfo).toContain('Comment: ドキュメント2では暗号化が適切');
+        expect(checklistInfo).toContain('Document ID: 3');
+        expect(checklistInfo).toContain(
+          'Document Name: access-control.pdf',
+        );
+        expect(checklistInfo).toContain(
+          'Comment: ドキュメント3ではアクセス制御に問題あり',
+        );
+      });
+
+      it('researchChunkStep実行時にindividualResultsが調査コンテキストに含まれること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = 'ドキュメントの個別レビュー状況を確認したい';
+
+        // individualResultsを含むチェックリスト結果
+        mockRepository.getChecklistResultsWithIndividualResults.mockResolvedValue(
+          [
+            {
+              checklistResult: {
+                id: 1,
+                content: 'データベース設計は適切か',
+                sourceEvaluation: {
+                  evaluation: 'C',
+                  comment: '設計に課題あり',
+                },
+              },
+              individualResults: [
+                {
+                  documentId: 1,
+                  comment: 'テーブル正規化が不十分',
+                  individualFileName: 'db-design.pdf',
+                },
+                {
+                  documentId: 2,
+                  comment: 'インデックス設計は良好',
+                  individualFileName: 'index-design.pdf',
+                },
+              ],
+            },
+          ],
+        );
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'データベース設計書を調査',
+                documentId: '1',
+                researchContent: 'テーブル正規化の問題を詳細調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: 'テーブル正規化の詳細調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: 'データベース設計の分析完了。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // researchChunkStepの呼び出しを確認
+        const researchCallArgs =
+          mockReviewChatResearchAgent.generateLegacy.mock.calls[0];
+        const researchOptions = researchCallArgs[1];
+
+        // reviewMode='large'が設定されていることを確認
+        expect(researchOptions.runtimeContext.get('reviewMode')).toBe('large');
+
+        // checklistInfoにindividualResultsの情報が含まれることを確認
+        const checklistInfo =
+          researchOptions.runtimeContext.get('checklistInfo');
+        expect(checklistInfo).toBeTruthy();
+        expect(checklistInfo).toContain('Individual Review Results:');
+        expect(checklistInfo).toContain('Document ID: 1');
+        expect(checklistInfo).toContain('Document Name: db-design.pdf');
+        expect(checklistInfo).toContain('Comment: テーブル正規化が不十分');
+        expect(checklistInfo).toContain('Document ID: 2');
+        expect(checklistInfo).toContain('Document Name: index-design.pdf');
+        expect(checklistInfo).toContain('Comment: インデックス設計は良好');
+      });
+
+      it('複数チェックリスト項目にそれぞれindividualResultsがある場合に正しく処理されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1, 2, 3];
+        const question = '全チェック項目の個別レビュー結果を確認';
+
+        // 複数のチェックリスト項目、各項目に複数のindividualResults
+        mockRepository.getChecklistResultsWithIndividualResults.mockResolvedValue(
+          [
+            {
+              checklistResult: {
+                id: 1,
+                content: 'API設計は適切か',
+                sourceEvaluation: {
+                  evaluation: 'A',
+                  comment: '優れた設計',
+                },
+              },
+              individualResults: [
+                {
+                  documentId: 1,
+                  comment: 'RESTful設計が適切',
+                  individualFileName: 'api-spec.pdf',
+                },
+                {
+                  documentId: 2,
+                  comment: 'エラーハンドリングが明確',
+                  individualFileName: 'error-handling.pdf',
+                },
+              ],
+            },
+            {
+              checklistResult: {
+                id: 2,
+                content: 'パフォーマンス要件を満たすか',
+                sourceEvaluation: {
+                  evaluation: 'B',
+                  comment: '改善の余地あり',
+                },
+              },
+              individualResults: [
+                {
+                  documentId: 1,
+                  comment: 'キャッシュ戦略が不十分',
+                  individualFileName: 'performance-spec.pdf',
+                },
+                {
+                  documentId: 3,
+                  comment: '負荷分散設計は良好',
+                  individualFileName: 'load-balancing.pdf',
+                },
+              ],
+            },
+            {
+              checklistResult: {
+                id: 3,
+                content: 'テスト計画は十分か',
+                sourceEvaluation: {
+                  evaluation: 'C',
+                  comment: 'テストケースが不足',
+                },
+              },
+              individualResults: [
+                {
+                  documentId: 2,
+                  comment: '単体テストは十分',
+                  individualFileName: 'unit-test-plan.pdf',
+                },
+                {
+                  documentId: 4,
+                  comment: '統合テストが不足',
+                  individualFileName: 'integration-test-plan.pdf',
+                },
+              ],
+            },
+          ],
+        );
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'API仕様書を調査',
+                documentId: '1',
+                researchContent: 'API設計の詳細調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: 'API設計の調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '全チェック項目の個別レビュー結果を分析しました。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // planResearchStepの呼び出しを確認
+        const planCallArgs =
+          mockReviewChatPlanningAgent.generateLegacy.mock.calls[0];
+        const planOptions = planCallArgs[1];
+
+        // reviewMode='large'が設定されていることを確認
+        expect(planOptions.runtimeContext.get('reviewMode')).toBe('large');
+
+        // checklistInfoに全チェックリスト項目のindividualResultsが含まれることを確認
+        const checklistInfo = planOptions.runtimeContext.get('checklistInfo');
+        expect(checklistInfo).toBeTruthy();
+
+        // チェックリスト1の情報確認
+        expect(checklistInfo).toContain('Checklist ID: 1');
+        expect(checklistInfo).toContain('Content: API設計は適切か');
+        expect(checklistInfo).toContain('Comment: RESTful設計が適切');
+        expect(checklistInfo).toContain(
+          'Comment: エラーハンドリングが明確',
+        );
+
+        // チェックリスト2の情報確認
+        expect(checklistInfo).toContain('Checklist ID: 2');
+        expect(checklistInfo).toContain(
+          'Content: パフォーマンス要件を満たすか',
+        );
+        expect(checklistInfo).toContain('Comment: キャッシュ戦略が不十分');
+        expect(checklistInfo).toContain('Comment: 負荷分散設計は良好');
+
+        // チェックリスト3の情報確認
+        expect(checklistInfo).toContain('Checklist ID: 3');
+        expect(checklistInfo).toContain('Content: テスト計画は十分か');
+        expect(checklistInfo).toContain('Comment: 単体テストは十分');
+        expect(checklistInfo).toContain('Comment: 統合テストが不足');
+
+        // 各ドキュメント名の確認
+        expect(checklistInfo).toContain('Document Name: api-spec.pdf');
+        expect(checklistInfo).toContain(
+          'Document Name: error-handling.pdf',
+        );
+        expect(checklistInfo).toContain(
+          'Document Name: performance-spec.pdf',
+        );
+        expect(checklistInfo).toContain(
+          'Document Name: load-balancing.pdf',
+        );
+        expect(checklistInfo).toContain(
+          'Document Name: unit-test-plan.pdf',
+        );
+        expect(checklistInfo).toContain(
+          'Document Name: integration-test-plan.pdf',
+        );
+      });
+    });
+
+    describe('RuntimeContext', () => {
+      it('RuntimeContextに正しい値が設定されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = 'RuntimeContextの検証';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '回答',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        // planResearchStepのruntimeContextを確認
+        const planCallArgs =
+          mockReviewChatPlanningAgent.generateLegacy.mock.calls[0];
+        const planOptions = planCallArgs[1];
+        expect(planOptions.runtimeContext.get('availableDocuments')).toEqual([
+          { id: 1, fileName: 'document1.txt' },
+        ]);
+        expect(planOptions.runtimeContext.get('checklistInfo')).toBeTruthy();
+        expect(planOptions.runtimeContext.get('reviewMode')).toBe('small');
+
+        // researchChunkStepのruntimeContextを確認
+        const researchCallArgs =
+          mockReviewChatResearchAgent.generateLegacy.mock.calls[0];
+        const researchOptions = researchCallArgs[1];
+        expect(
+          researchOptions.runtimeContext.get('researchContent'),
+        ).toBeTruthy();
+        expect(researchOptions.runtimeContext.get('fileName')).toBe(
+          'document1.txt',
+        );
+        expect(
+          researchOptions.runtimeContext.get('checklistInfo'),
+        ).toBeTruthy();
+        expect(researchOptions.runtimeContext.get('userQuestion')).toBe(
+          question,
+        );
+
+        // generateAnswerStepのruntimeContextを確認
+        const answerCallArgs =
+          mockReviewChatAnswerAgent.generateLegacy.mock.calls[0];
+        const answerOptions = answerCallArgs[1];
+        expect(answerOptions.runtimeContext.get('userQuestion')).toBe(question);
+        expect(answerOptions.runtimeContext.get('checklistInfo')).toBeTruthy();
+        expect(answerOptions.runtimeContext.get('reviewMode')).toBe('small');
+      });
+    });
+
+    describe('DataStreamWriter', () => {
+      it('調査開始イベントが正しく書き込まれること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '回答',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        // 調査開始イベントの確認
+        const researchStartCall = mockDataStreamWriter.write.mock.calls.find(
+          (call) => call[0].includes('researchDocumentStart'),
+        );
+        expect(researchStartCall).toBeTruthy();
+        const startEventData = JSON.parse(
+          researchStartCall![0].replace('9:', '').trim(),
+        );
+        expect(startEventData.toolCallId).toBe(
+          'reviewChatResearchDocument-test-tool-call-id',
+        );
+        expect(startEventData.toolName).toBe('researchDocumentStart');
+        expect(startEventData.args).toHaveLength(1);
+        expect(startEventData.args[0].documentName).toBe('document1.txt');
+        expect(startEventData.args[0].researchContent).toBe(
+          'ドキュメント1の内容を調査',
+        );
+      });
+
+      it('調査完了イベントが正しく書き込まれること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果テキスト',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '回答',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        // 調査完了イベントの確認
+        const researchCompleteCall =
+          mockDataStreamWriter.write.mock.calls.find((call) =>
+            call[0].includes('researchDocumentComplete'),
+          );
+        expect(researchCompleteCall).toBeTruthy();
+        const completeEventData = JSON.parse(
+          researchCompleteCall![0].replace('a:', '').trim(),
+        );
+        expect(completeEventData.toolCallId).toBe(
+          'reviewChatResearchDocument-test-tool-call-id',
+        );
+        expect(completeEventData.toolName).toBe('researchDocumentComplete');
+        expect(completeEventData.result).toHaveLength(1);
+        expect(completeEventData.result[0].documentName).toBe('document1.txt');
+        expect(completeEventData.result[0].researchResult).toContain(
+          '調査結果テキスト',
+        );
+      });
+
+      it('ストリーミングチャンクが正しく書き込まれること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        // ストリーミングをシミュレート
+        mockReviewChatAnswerAgent.generateLegacy.mockImplementation(
+          async (_prompt: any, options: any) => {
+            // onStepFinishを呼び出してストリーミングをシミュレート
+            if (options?.onStepFinish) {
+              options.onStepFinish({
+                text: 'チャンク1',
+                toolCalls: [],
+                toolResults: [],
+                finishReason: 'stop',
+                usage: { promptTokens: 100, completionTokens: 50 },
+              });
+            }
+            return {
+              text: '最終回答',
+              finishReason: 'stop',
+              usage: { promptTokens: 100, completionTokens: 50 },
+            };
+          },
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        // ストリーミングチャンクの確認
+        const textChunkCalls = mockDataStreamWriter.write.mock.calls.filter(
+          (call) => call[0].startsWith('0:'),
+        );
+        expect(textChunkCalls.length).toBeGreaterThan(0);
+        const firstChunk = textChunkCalls[0][0];
+        expect(firstChunk).toContain('チャンク1');
+
+        // 終了イベントの確認
+        const finishCalls = mockDataStreamWriter.write.mock.calls.filter(
+          (call) => call[0].startsWith('e:'),
+        );
+        expect(finishCalls.length).toBeGreaterThan(0);
+      });
+
+      it('複数ドキュメント調査時のイベントが正しく書き込まれること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '複数ドキュメントの質問';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+          {
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById
+          .mockResolvedValueOnce({
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          })
+          .mockResolvedValueOnce({
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+          {
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+              {
+                reasoning: 'ドキュメント2を調査',
+                documentId: '2',
+                researchContent: 'ドキュメント2の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '回答',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        // 調査開始イベントの確認（2つのドキュメント）
+        const researchStartCall = mockDataStreamWriter.write.mock.calls.find(
+          (call) => call[0].includes('researchDocumentStart'),
+        );
+        expect(researchStartCall).toBeTruthy();
+        const startEventData = JSON.parse(
+          researchStartCall![0].replace('9:', '').trim(),
+        );
+        expect(startEventData.args).toHaveLength(2);
+        expect(startEventData.args[0].documentName).toBe('document1.txt');
+        expect(startEventData.args[1].documentName).toBe('document2.txt');
+
+        // 調査完了イベントの確認（2つのドキュメント）
+        const researchCompleteCall =
+          mockDataStreamWriter.write.mock.calls.find((call) =>
+            call[0].includes('researchDocumentComplete'),
+          );
+        expect(researchCompleteCall).toBeTruthy();
+        const completeEventData = JSON.parse(
+          researchCompleteCall![0].replace('a:', '').trim(),
+        );
+        expect(completeEventData.result).toHaveLength(2);
+      });
+    });
+  });
+
+  describe('異常系', () => {
+    describe('Step単位のエラー', () => {
+      it('調査計画作成失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: '調査計画作成エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('調査計画作成エラー');
+        expect(mockReviewChatResearchAgent.generateLegacy).not.toHaveBeenCalled();
+        expect(mockReviewChatAnswerAgent.generateLegacy).not.toHaveBeenCalled();
+      });
+
+      it('ドキュメント調査失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'ドキュメント調査エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ドキュメント調査エラー');
+        expect(mockReviewChatAnswerAgent.generateLegacy).not.toHaveBeenCalled();
+      });
+
+      it('回答生成失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: '回答生成エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('回答生成エラー');
+      });
+    });
+
+    describe('チャンク分割関連', () => {
+      it('チャンク分割最大リトライ超過時にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '非常に長いドキュメントの質問';
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'extremely-long-document.txt',
+          processMode: 'text',
+          textContent: 'A'.repeat(100000),
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '非常に長いドキュメントを調査',
+                documentId: '1',
+                researchContent: '非常に長いドキュメントの内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        // 常にコンテキスト長エラーをthrow（最大5回リトライまで）
+        mockReviewChatResearchAgent.generateLegacy.mockImplementation(
+          async () => {
+            throw new APICallError({
+              message: 'Context length exceeded',
+              url: 'http://test-api',
+              requestBodyValues: {},
+              statusCode: 400,
+              responseBody: JSON.stringify({
+                error: 'maximum context length exceeded',
+              }),
+              cause: new Error('maximum context length exceeded'),
+              isRetryable: false,
+            });
+          },
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        // 最大リトライ超過時は汎用エラーメッセージになる
+        expect(checkResult.errorMessage).toBeTruthy();
+      });
+    });
+
+    describe('データ取得エラー', () => {
+      it('チェックリスト結果取得失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockRepository.getChecklistResultsWithIndividualResults.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'DB接続エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('DB接続エラー');
+      });
+
+      it('planResearchStep内のgetReviewDocumentCaches失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockRepository.getReviewDocumentCaches.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'ドキュメントキャッシュ一覧取得エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(
+          'ドキュメントキャッシュ一覧取得エラー',
+        );
+      });
+
+      it('generateAnswerStep内のgetReviewDocumentCacheByIds失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        // getReviewDocumentCacheByIdsでエラー
+        mockRepository.getReviewDocumentCacheByIds.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'ドキュメントキャッシュ複数取得エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(
+          'ドキュメントキャッシュ複数取得エラー',
+        );
+      });
+
+      it('ドキュメントキャッシュ取得失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockRepository.getReviewDocumentCacheById.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'キャッシュ取得エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        // researchDocumentWithRetryWorkflow内でcatchされて汎用エラーメッセージになる
+        expect(checkResult.errorMessage).toBeTruthy();
+      });
+
+      it('ドキュメントキャッシュ未発見時にエラーになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue(null);
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        // researchDocumentWithRetryWorkflow内でcatchされて汎用エラーメッセージになる
+        expect(checkResult.errorMessage).toBeTruthy();
+      });
+
+      it('最大チャンク数取得失敗時にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockRepository.getMaxTotalChunksForDocument.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: '最大チャンク数取得エラー' },
+          }),
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('最大チャンク数取得エラー');
+      });
+    });
+
+    describe('finishReason関連', () => {
+      it('planResearchStepのfinishReasonがlengthの場合に適切なエラーメッセージが返ること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [],
+          },
+          finishReason: 'length',
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('最大出力コンテキストを超え');
+      });
+
+      it('generateAnswerStepのfinishReasonがlengthの場合に適切なエラーメッセージが返ること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '',
+          finishReason: 'length',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('最大出力コンテキストを超え');
+      });
+
+      it('調査タスクが空の場合でもworkflowが完了すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '調査不要な質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '調査は不要です。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        expect((result as any).result?.answer).toBe('調査は不要です。');
+        expect(mockReviewChatResearchAgent.generateLegacy).not.toHaveBeenCalled();
+      });
+    });
+
+    describe('複数ドキュメント調査のエラー', () => {
+      it('複数ドキュメント調査で一部が失敗した場合にworkflowがfailedになること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '複数ドキュメントの質問';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+          {
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById
+          .mockResolvedValueOnce({
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'document1.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント1の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          })
+          .mockResolvedValueOnce({
+            id: 2,
+            reviewHistoryId: 'review-1',
+            fileName: 'document2.txt',
+            processMode: 'text',
+            textContent: 'ドキュメント2の内容',
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          });
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+              {
+                reasoning: 'ドキュメント2を調査',
+                documentId: '2',
+                researchContent: 'ドキュメント2の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        // 1つ目は成功、2つ目は失敗
+        let callCount = 0;
+        mockReviewChatResearchAgent.generateLegacy.mockImplementation(
+          async () => {
+            callCount++;
+            if (callCount === 1) {
+              return {
+                text: '調査結果1',
+                finishReason: 'stop',
+              };
+            }
+            throw internalError({
+              expose: true,
+              messageCode: 'PLAIN_MESSAGE',
+              messageParams: { message: 'ドキュメント2の調査エラー' },
+            });
+          },
+        );
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ドキュメント2の調査エラー');
+        expect(mockReviewChatAnswerAgent.generateLegacy).not.toHaveBeenCalled();
+      });
+    });
+
+    describe('画像モード特有のエラー', () => {
+      it('画像データが空配列の場合でも処理が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '空画像ドキュメントの質問';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'empty-image.pdf',
+            processMode: 'image',
+            textContent: undefined,
+            imageData: [],
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'empty-image.pdf',
+          processMode: 'image',
+          textContent: undefined,
+          imageData: [],
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'empty-image.pdf',
+            processMode: 'image',
+            textContent: undefined,
+            imageData: [],
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '空画像ドキュメントを調査',
+                documentId: '1',
+                researchContent: '空画像の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '画像がありませんでした',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: 'ドキュメントに画像はありません。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+      });
+
+      it('テキストコンテンツと画像データが両方undefinedの場合でも処理が成功すること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '空ドキュメントの質問';
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'empty.pdf',
+            processMode: 'text',
+            textContent: undefined,
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockRepository.getReviewDocumentCacheById.mockResolvedValue({
+          id: 1,
+          reviewHistoryId: 'review-1',
+          fileName: 'empty.pdf',
+          processMode: 'text',
+          textContent: undefined,
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue([
+          {
+            id: 1,
+            reviewHistoryId: 'review-1',
+            fileName: 'empty.pdf',
+            processMode: 'text',
+            textContent: undefined,
+            imageData: undefined,
+            createdAt: '2024-01-01',
+            updatedAt: '2024-01-01',
+          },
+        ]);
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: '空ドキュメントを調査',
+                documentId: '1',
+                researchContent: '空ドキュメントの内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: 'ドキュメントは空です',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: 'ドキュメントに内容はありません。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+      });
+    });
+
+    describe('境界値テスト', () => {
+      it('最大並列数を超える調査タスクが正しく処理されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1];
+        const question = '多数のドキュメントの質問';
+
+        // 10個のドキュメントを用意（concurrency: 5を超える）
+        const documents = Array.from({ length: 10 }, (_, i) => ({
+          id: i + 1,
+          reviewHistoryId: 'review-1',
+          fileName: `document${i + 1}.txt`,
+          processMode: 'text' as const,
+          textContent: `ドキュメント${i + 1}の内容`,
+          imageData: undefined,
+          createdAt: '2024-01-01',
+          updatedAt: '2024-01-01',
+        }));
+
+        mockRepository.getReviewDocumentCaches.mockResolvedValue(documents);
+
+        // getReviewDocumentCacheByIdを各ドキュメントに対して設定
+        documents.forEach((doc) => {
+          mockRepository.getReviewDocumentCacheById.mockResolvedValueOnce(doc);
+        });
+
+        mockRepository.getReviewDocumentCacheByIds.mockResolvedValue(documents);
+
+        // 10個の調査タスクを生成
+        const tasks = documents.map((doc) => ({
+          reasoning: `ドキュメント${doc.id}を調査`,
+          documentId: String(doc.id),
+          researchContent: `ドキュメント${doc.id}の内容を調査`,
+        }));
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks,
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '全てのドキュメントの調査が完了しました。',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 10個全てのドキュメントが調査されたことを確認
+        expect(mockReviewChatResearchAgent.generateLegacy).toHaveBeenCalledTimes(
+          10,
+        );
+      });
+
+      it('チェックリストIDsが1つの場合でも正しく処理されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1]; // 1つだけ
+        const question = '単一チェックリストの質問';
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '回答',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+      });
+
+      it('チェックリストIDsが複数の場合でも正しく処理されること', async () => {
+        // Arrange
+        const reviewHistoryId = 'review-1';
+        const checklistIds = [1, 2, 3]; // 複数
+        const question = '複数チェックリストの質問';
+
+        mockRepository.getChecklistResultsWithIndividualResults.mockResolvedValue(
+          [
+            {
+              checklistResult: {
+                id: 1,
+                content: 'チェック項目1',
+                sourceEvaluation: {
+                  evaluation: 'A',
+                  comment: '良好です',
+                },
+              },
+              individualResults: undefined,
+            },
+            {
+              checklistResult: {
+                id: 2,
+                content: 'チェック項目2',
+                sourceEvaluation: {
+                  evaluation: 'B',
+                  comment: '改善が必要です',
+                },
+              },
+              individualResults: undefined,
+            },
+            {
+              checklistResult: {
+                id: 3,
+                content: 'チェック項目3',
+                sourceEvaluation: {
+                  evaluation: 'C',
+                  comment: '要修正です',
+                },
+              },
+              individualResults: undefined,
+            },
+          ],
+        );
+
+        mockReviewChatPlanningAgent.generateLegacy.mockResolvedValue({
+          object: {
+            tasks: [
+              {
+                reasoning: 'ドキュメント1を調査',
+                documentId: '1',
+                researchContent: 'ドキュメント1の内容を調査',
+              },
+            ],
+          },
+          finishReason: 'stop',
+        });
+
+        mockReviewChatResearchAgent.generateLegacy.mockResolvedValue({
+          text: '調査結果',
+          finishReason: 'stop',
+        });
+
+        mockReviewChatAnswerAgent.generateLegacy.mockResolvedValue({
+          text: '回答',
+          finishReason: 'stop',
+          usage: { promptTokens: 100, completionTokens: 50 },
+        });
+
+        // Act
+        const runtimeContext = new RuntimeContext();
+        runtimeContext.set('dataStreamWriter', mockDataStreamWriter);
+        runtimeContext.set('toolCallId', 'test-tool-call-id');
+
+        const run = await reviewChatWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            reviewHistoryId,
+            checklistIds,
+            question,
+          },
+          runtimeContext,
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+        // 複数のチェックリストが正しく渡されたことを確認
+        expect(
+          mockRepository.getChecklistResultsWithIndividualResults,
+        ).toHaveBeenCalledWith(reviewHistoryId, checklistIds);
+      });
+    });
+  });
+});
diff --git a/src/__tests__/main/workflows/sourceRegistration.test.ts b/src/__tests__/main/workflows/sourceRegistration.test.ts
new file mode 100644
index 000000000..95a3719c9
--- /dev/null
+++ b/src/__tests__/main/workflows/sourceRegistration.test.ts
@@ -0,0 +1,1211 @@
+/**
+ * ソース登録ワークフローのテスト
+ * @jest-environment node
+ */
+
+// Electron モックを最初に適用（他のインポートより前に実行する必要がある）
+jest.mock('electron', () => require('../test-utils/mockElectron').mockElectron);
+jest.mock('electron-store', () => require('../test-utils/mockElectron').default);
+
+// main.ts の初期化処理をスキップ（テスト環境では不要）
+jest.mock('@/main/main', () => {
+  const path = require('path');
+  const os = require('os');
+  // テンポラリディレクトリを使用（実際に存在するディレクトリ）
+  const testAppData = path.join(os.tmpdir(), 'ai-notebook-test');
+  return {
+    getCustomAppDataDir: jest.fn(() => testAppData),
+  };
+});
+
+import { sourceRegistrationWorkflow } from '@/mastra/workflows/sourceRegistration/sourceRegistration';
+import { mastra } from '@/mastra';
+import { getSourceRepository } from '@/adapter/db';
+import FileExtractor from '@/main/lib/fileExtractor';
+import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
+import type { ISourceRepository } from '@/main/service/port/repository';
+import { internalError } from '@/main/lib/error';
+
+// モック設定
+jest.mock('@/adapter/db', () => ({
+  getSourceRepository: jest.fn(),
+  getReviewRepository: jest.fn(() => ({
+    // レビューリポジトリのモック（インポート時に必要）
+    getReviewHistory: jest.fn(),
+    createReviewHistory: jest.fn(),
+  })),
+  getChatRepository: jest.fn(() => ({
+    // チャットリポジトリのモック（インポート時に必要）
+    getChatRooms: jest.fn(),
+    getChatMessages: jest.fn(),
+  })),
+  getSettingsRepository: jest.fn(() => ({
+    // 設定リポジトリのモック（インポート時に必要）
+    getSettings: jest.fn().mockReturnValue({
+      api: {
+        url: 'http://localhost:11434/v1',
+        key: 'test-api-key',
+        model: 'test-model',
+      },
+      database: {
+        dir: '/test/db',
+      },
+      source: {
+        registerDir: './test/source',
+      },
+    }),
+    setSettings: jest.fn(),
+  })),
+}));
+
+// FileExtractor のモック（最初に設定）
+const mockExtractText = jest.fn();
+const mockCleanCacheDirectory = jest.fn();
+
+jest.mock('@/main/lib/fileExtractor', () => ({
+  __esModule: true,
+  default: {
+    get extractText() {
+      return mockExtractText;
+    },
+    get cleanCacheDirectory() {
+      return mockCleanCacheDirectory;
+    },
+  },
+}));
+
+jest.mock('@/main/lib/eventPayloadHelper', () => ({
+  publishEvent: jest.fn(),
+}));
+
+describe('sourceRegistrationWorkflow', () => {
+  // モックリポジトリ
+  let mockSourceRepository: jest.Mocked<ISourceRepository>;
+
+  // モックエージェント
+  let mockSummarizeSourceAgent: any;
+  let mockSummarizeTopicAgent: any;
+
+  beforeEach(() => {
+    // リポジトリのモック
+    mockSourceRepository = {
+      initializeProcessingSource: jest.fn().mockResolvedValue({
+        id: 1,
+        path: '/test/source.txt',
+      }),
+      updateSource: jest.fn().mockResolvedValue(undefined),
+      updateProcessingStatus: jest.fn().mockResolvedValue(undefined),
+      registerTopic: jest.fn().mockResolvedValue(undefined),
+      updateSourceEnabled: jest.fn().mockResolvedValue(undefined),
+      getSourceById: jest.fn(),
+      getSourcesByIds: jest.fn(),
+      getSourceListMarkdown: jest.fn(),
+      deleteSourceByPath: jest.fn(),
+      getSouorceInStatus: jest.fn(),
+      getSourceByPathInStatus: jest.fn(),
+      getAllSources: jest.fn(),
+      insertSources: jest.fn(),
+    } as jest.Mocked<ISourceRepository>;
+
+    (getSourceRepository as jest.Mock).mockReturnValue(mockSourceRepository);
+
+    // FileExtractorのモック
+    mockExtractText.mockResolvedValue({
+      content: 'テストドキュメントの内容',
+    });
+
+    // Mastraエージェントのモック
+    mockSummarizeSourceAgent = {
+      generateLegacy: jest.fn(),
+    };
+    mockSummarizeTopicAgent = {
+      generateLegacy: jest.fn(),
+    };
+
+    // mastra.getAgentのモック
+    jest.spyOn(mastra, 'getAgent').mockImplementation((agentName: string) => {
+      if (agentName === 'summarizeSourceAgent') {
+        return mockSummarizeSourceAgent;
+      }
+      if (agentName === 'summarizeTopicAgent') {
+        return mockSummarizeTopicAgent;
+      }
+      throw new Error(`Unknown agent: ${agentName}`);
+    });
+  });
+
+  afterEach(() => {
+    mockExtractText.mockReset();
+  });
+
+  describe('正常系', () => {
+    describe('analyzeSourceStep', () => {
+      it('基本的なソース分析が成功すること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'これはテストドキュメントの要約です',
+          },
+        });
+
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            topicAndSummaryList: [
+              {
+                topic: 'トピック1',
+                summary: 'トピック1の要約',
+              },
+            ],
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // DB操作の確認
+        expect(mockSourceRepository.initializeProcessingSource).toHaveBeenCalledWith({
+          path: filePath,
+          title: '',
+          summary: '',
+          status: 'processing',
+        });
+        expect(mockSourceRepository.updateSource).toHaveBeenCalledWith({
+          id: 1,
+          title: 'テストドキュメント',
+          summary: 'これはテストドキュメントの要約です',
+          error: null,
+        });
+      });
+    });
+
+    describe('extractTopicAndSummaryStep', () => {
+      it('トピック抽出と要約生成が成功すること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            topicAndSummaryList: [
+              {
+                topic: 'トピック1',
+                summary: 'トピック1の要約',
+              },
+              {
+                topic: 'トピック2',
+                summary: 'トピック2の要約',
+              },
+              {
+                topic: 'トピック3',
+                summary: 'トピック3の要約',
+              },
+            ],
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // トピック登録の確認
+        expect(mockSourceRepository.registerTopic).toHaveBeenCalledWith([
+          {
+            sourceId: 1,
+            name: 'トピック1',
+            summary: 'トピック1の要約',
+          },
+          {
+            sourceId: 1,
+            name: 'トピック2',
+            summary: 'トピック2の要約',
+          },
+          {
+            sourceId: 1,
+            name: 'トピック3',
+            summary: 'トピック3の要約',
+          },
+        ]);
+
+        // ステータス更新の確認
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledWith({
+          id: 1,
+          status: 'completed',
+          error: null,
+        });
+        expect(mockSourceRepository.updateSourceEnabled).toHaveBeenCalledWith(1, true);
+      });
+
+      it('前ステップ失敗時は処理をスキップすること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        const errorMessage = 'テストエラー';
+
+        mockSummarizeSourceAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: errorMessage },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(errorMessage);
+
+        // extractTopicAndSummaryStepの処理がスキップされることを確認
+        expect(mockSummarizeTopicAgent.generateLegacy).not.toHaveBeenCalled();
+        expect(mockSourceRepository.registerTopic).not.toHaveBeenCalled();
+      });
+    });
+
+    describe('Workflow全体', () => {
+      it('Workflow全体が正常に完了すること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            topicAndSummaryList: [
+              {
+                topic: 'トピック1',
+                summary: 'トピック1の要約',
+              },
+            ],
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // 両エージェントが呼ばれていることを確認
+        expect(mockSummarizeSourceAgent.generateLegacy).toHaveBeenCalledTimes(1);
+        expect(mockSummarizeTopicAgent.generateLegacy).toHaveBeenCalledTimes(1);
+      });
+
+      it('トピックリストが空でも正常終了すること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            topicAndSummaryList: [],
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('success');
+
+        // トピックが空でもregisterTopicが呼ばれることを確認
+        expect(mockSourceRepository.registerTopic).toHaveBeenCalledWith([]);
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledWith({
+          id: 1,
+          status: 'completed',
+          error: null,
+        });
+      });
+    });
+  });
+
+  describe('異常系', () => {
+    describe('analyzeSourceStep', () => {
+      it('FileExtractor.extractTextエラー時に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        const extractError = internalError({
+          expose: true,
+          messageCode: 'PLAIN_MESSAGE',
+          messageParams: { message: 'ファイル読み込みエラー' },
+        });
+        mockExtractText.mockRejectedValue(extractError);
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析に失敗しました');
+        expect(checkResult.errorMessage).toContain('ファイル読み込みエラー');
+
+        // DBステータス更新の確認
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('ソース分析に失敗しました'),
+        });
+
+        // 後続処理が実行されないことを確認
+        expect(mockSummarizeSourceAgent.generateLegacy).not.toHaveBeenCalled();
+      });
+
+      it('AI API呼び出しエラー時に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'AI APIエラー' },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析に失敗しました');
+        expect(checkResult.errorMessage).toContain('AI APIエラー');
+
+        // DBステータス更新の確認
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('AI APIエラー'),
+        });
+      });
+
+      it('AI APIのfinishReasonがlengthの場合にエラーになること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'length',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析に失敗しました');
+        expect(checkResult.errorMessage).toContain(
+          'AIモデルの最大出力コンテキストを超えました',
+        );
+
+        // DBステータス更新の確認
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('AIモデルの最大出力コンテキストを超えました'),
+        });
+      });
+
+      it('AI APIのfinishReasonがcontent-filterの場合にエラーになること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'content-filter',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(
+          'コンテンツフィルターにより出力が制限されました',
+        );
+      });
+
+      it('AI APIのfinishReasonがerrorの場合にエラーになること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'error',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain(
+          'AIモデルで不明なエラーが発生しました',
+        );
+      });
+    });
+
+    describe('DB操作エラー', () => {
+      it('initializeProcessingSourceがエラーをthrowした場合に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSourceRepository.initializeProcessingSource.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'DB初期化エラー' },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析に失敗しました');
+        expect(checkResult.errorMessage).toContain('DB初期化エラー');
+
+        // 後続処理が実行されないことを確認
+        expect(mockSummarizeSourceAgent.generateLegacy).not.toHaveBeenCalled();
+        expect(mockSourceRepository.updateSource).not.toHaveBeenCalled();
+      });
+
+      it('updateSourceがエラーをthrowした場合に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+        mockSourceRepository.updateSource.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'DB更新エラー' },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析に失敗しました');
+        expect(checkResult.errorMessage).toContain('DB更新エラー');
+
+        // DBステータス更新の確認（エラー処理内で呼ばれる）
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('DB更新エラー'),
+        });
+      });
+
+      it('registerTopicがエラーをthrowした場合に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            topicAndSummaryList: [
+              {
+                topic: 'トピック1',
+                summary: 'トピック1の要約',
+              },
+            ],
+          },
+        });
+        mockSourceRepository.registerTopic.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'トピック登録エラー' },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析でエラーが発生しました');
+        expect(checkResult.errorMessage).toContain('トピック登録エラー');
+
+        // DBステータス更新の確認
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenLastCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('トピック登録エラー'),
+        });
+
+        // 成功時の処理が実行されないことを確認
+        expect(mockSourceRepository.updateSourceEnabled).not.toHaveBeenCalled();
+      });
+
+      it('updateSourceEnabledがエラーをthrowした場合に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            topicAndSummaryList: [
+              {
+                topic: 'トピック1',
+                summary: 'トピック1の要約',
+              },
+            ],
+          },
+        });
+        mockSourceRepository.updateSourceEnabled.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'ソース有効化エラー' },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析でエラーが発生しました');
+        expect(checkResult.errorMessage).toContain('ソース有効化エラー');
+
+        // registerTopicは成功していることを確認
+        expect(mockSourceRepository.registerTopic).toHaveBeenCalledTimes(1);
+
+        // DBステータス更新の確認
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenLastCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('ソース有効化エラー'),
+        });
+      });
+    });
+
+    describe('extractTopicAndSummaryStep', () => {
+      it('トピック抽出AI API呼び出しエラー時に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        mockSummarizeTopicAgent.generateLegacy.mockRejectedValue(
+          internalError({
+            expose: true,
+            messageCode: 'PLAIN_MESSAGE',
+            messageParams: { message: 'トピック抽出エラー' },
+          }),
+        );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析でエラーが発生しました');
+        expect(checkResult.errorMessage).toContain('トピック抽出エラー');
+
+        // DBステータス更新の確認（extractTopicAndSummaryStepでのエラー）
+        expect(mockSourceRepository.updateProcessingStatus).toHaveBeenLastCalledWith({
+          id: 1,
+          status: 'failed',
+          error: expect.stringContaining('トピック抽出エラー'),
+        });
+      });
+
+      it('トピック抽出時のfinishReasonエラーが適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'length',
+          object: {
+            topicAndSummaryList: [],
+          },
+        });
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析でエラーが発生しました');
+        expect(checkResult.errorMessage).toContain(
+          'AIモデルの最大出力コンテキストを超えました',
+        );
+      });
+
+      it('テキスト抽出エラー時に適切にハンドリングされること', async () => {
+        // Arrange
+        const filePath = '/test/source.txt';
+        mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+          finishReason: 'stop',
+          object: {
+            title: 'テストドキュメント',
+            summary: 'テスト要約',
+          },
+        });
+
+        // 2回目の呼び出しでエラーをthrow
+        mockExtractText
+          .mockResolvedValueOnce({
+            content: 'テストドキュメントの内容',
+          })
+          .mockRejectedValueOnce(
+            internalError({
+              expose: true,
+              messageCode: 'PLAIN_MESSAGE',
+              messageParams: { message: '2回目のファイル読み込みエラー' },
+            }),
+          );
+
+        // Act
+        const run = await sourceRegistrationWorkflow.createRunAsync();
+        const result = await run.start({
+          inputData: {
+            filePath,
+          },
+        });
+
+        // Assert
+        const checkResult = checkWorkflowResult(result);
+        expect(checkResult.status).toBe('failed');
+        expect(checkResult.errorMessage).toContain('ソース分析でエラーが発生しました');
+        expect(checkResult.errorMessage).toContain('2回目のファイル読み込みエラー');
+
+        // FileExtractorが2回呼ばれていることを確認
+        expect(FileExtractor.extractText).toHaveBeenCalledTimes(2);
+      });
+    });
+  });
+
+  describe('エッジケース', () => {
+    it('空のテキスト抽出結果でも正常に処理されること', async () => {
+      // Arrange
+      const filePath = '/test/empty.txt';
+      mockExtractText.mockResolvedValue({
+        content: '',
+      });
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: '空のドキュメント',
+          summary: '内容なし',
+        },
+      });
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      expect(checkResult.status).toBe('success');
+
+      // 空のコンテンツでもAIエージェントが呼ばれることを確認
+      expect(mockSummarizeSourceAgent.generateLegacy).toHaveBeenCalledWith('', expect.any(Object));
+      expect(mockSummarizeTopicAgent.generateLegacy).toHaveBeenCalledWith('', expect.any(Object));
+    });
+
+    it('AIが空のタイトル/要約を返す場合でも正常に処理されること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: '',
+          summary: '',
+        },
+      });
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      expect(checkResult.status).toBe('success');
+
+      // 空のタイトル/要約でもDBに保存されることを確認
+      expect(mockSourceRepository.updateSource).toHaveBeenCalledWith({
+        id: 1,
+        title: '',
+        summary: '',
+        error: null,
+      });
+    });
+
+    it('特殊文字を含むファイルパスでも正常に処理されること', async () => {
+      // Arrange
+      const filePath = '/test/特殊 文字@#$%/ソース.txt';
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: 'テストドキュメント',
+          summary: 'テスト要約',
+        },
+      });
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      expect(checkResult.status).toBe('success');
+
+      // 特殊文字を含むパスでもFileExtractorが正しく呼ばれることを確認
+      expect(FileExtractor.extractText).toHaveBeenCalledWith(filePath);
+      expect(mockSourceRepository.initializeProcessingSource).toHaveBeenCalledWith({
+        path: filePath,
+        title: '',
+        summary: '',
+        status: 'processing',
+      });
+    });
+
+    it('未定義のfinishReasonでも正常に処理されること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'unknown_reason',
+        object: {
+          title: 'テストドキュメント',
+          summary: 'テスト要約',
+        },
+      });
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'unknown_reason',
+        object: {
+          topicAndSummaryList: [
+            {
+              topic: 'トピック1',
+              summary: 'トピック1の要約',
+            },
+          ],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      const result = await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      const checkResult = checkWorkflowResult(result);
+      // judgeFinishReasonのdefaultケースではsuccess: trueを返すため、成功する
+      expect(checkResult.status).toBe('success');
+    });
+  });
+
+  describe('技術的観点', () => {
+    it('DB操作が正しい順序で実行されること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: 'テストドキュメント',
+          summary: 'テスト要約',
+        },
+      });
+
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [
+            {
+              topic: 'トピック1',
+              summary: 'トピック1の要約',
+            },
+          ],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      // 呼び出し順序の確認（各関数が呼ばれたことを確認）
+      expect(mockSourceRepository.initializeProcessingSource).toHaveBeenCalledTimes(1);
+      expect(mockSourceRepository.updateSource).toHaveBeenCalledTimes(1);
+      expect(mockSourceRepository.registerTopic).toHaveBeenCalledTimes(1);
+      expect(mockSourceRepository.updateProcessingStatus).toHaveBeenCalledTimes(1);
+      expect(mockSourceRepository.updateSourceEnabled).toHaveBeenCalledTimes(1);
+
+      // 呼び出し順序の確認（すべてのモックが少なくとも1回呼ばれていることを確認）
+      const calls = [
+        mockSourceRepository.initializeProcessingSource,
+        mockSourceRepository.updateSource,
+        mockSourceRepository.registerTopic,
+        mockSourceRepository.updateProcessingStatus,
+        mockSourceRepository.updateSourceEnabled,
+      ];
+
+      calls.forEach((mock) => {
+        expect(mock).toHaveBeenCalled();
+      });
+    });
+
+    it('mastra.getAgentが正しく呼ばれること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      const getAgentSpy = jest.spyOn(mastra, 'getAgent');
+
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: 'テストドキュメント',
+          summary: 'テスト要約',
+        },
+      });
+
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [
+            {
+              topic: 'トピック1',
+              summary: 'トピック1の要約',
+            },
+          ],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      expect(getAgentSpy).toHaveBeenCalledWith('summarizeSourceAgent');
+      expect(getAgentSpy).toHaveBeenCalledWith('summarizeTopicAgent');
+      expect(mockSummarizeSourceAgent.generateLegacy).toHaveBeenCalled();
+      expect(mockSummarizeTopicAgent.generateLegacy).toHaveBeenCalled();
+    });
+
+    it('FileExtractor.extractTextが各ステップで呼ばれること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: 'テストドキュメント',
+          summary: 'テスト要約',
+        },
+      });
+
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [
+            {
+              topic: 'トピック1',
+              summary: 'トピック1の要約',
+            },
+          ],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      // 各ステップで1回ずつ、計2回呼ばれる
+      expect(FileExtractor.extractText).toHaveBeenCalledTimes(2);
+      expect(FileExtractor.extractText).toHaveBeenCalledWith(filePath);
+    });
+
+    it('生成されたタイトルと要約が正しく処理されること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      const expectedTitle = 'カスタムタイトル';
+      const expectedSummary = 'カスタム要約内容';
+
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: expectedTitle,
+          summary: expectedSummary,
+        },
+      });
+
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: [
+            {
+              topic: 'トピック1',
+              summary: 'トピック1の要約',
+            },
+          ],
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      expect(mockSourceRepository.updateSource).toHaveBeenCalledWith({
+        id: 1,
+        title: expectedTitle,
+        summary: expectedSummary,
+        error: null,
+      });
+    });
+
+    it('複数トピックが正しく処理されること', async () => {
+      // Arrange
+      const filePath = '/test/source.txt';
+      const topics = [
+        { topic: 'トピックA', summary: 'トピックAの詳細' },
+        { topic: 'トピックB', summary: 'トピックBの詳細' },
+        { topic: 'トピックC', summary: 'トピックCの詳細' },
+        { topic: 'トピックD', summary: 'トピックDの詳細' },
+        { topic: 'トピックE', summary: 'トピックEの詳細' },
+      ];
+
+      mockSummarizeSourceAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          title: 'テストドキュメント',
+          summary: 'テスト要約',
+        },
+      });
+
+      mockSummarizeTopicAgent.generateLegacy.mockResolvedValue({
+        finishReason: 'stop',
+        object: {
+          topicAndSummaryList: topics,
+        },
+      });
+
+      // Act
+      const run = await sourceRegistrationWorkflow.createRunAsync();
+      await run.start({
+        inputData: {
+          filePath,
+        },
+      });
+
+      // Assert
+      expect(mockSourceRepository.registerTopic).toHaveBeenCalledWith(
+        topics.map((t) => ({
+          sourceId: 1,
+          name: t.topic,
+          summary: t.summary,
+        })),
+      );
+    });
+  });
+});
diff --git a/src/__tests__/renderer/SettingsModal.test.tsx b/src/__tests__/renderer/SettingsModal.test.tsx
new file mode 100644
index 000000000..eb126e696
--- /dev/null
+++ b/src/__tests__/renderer/SettingsModal.test.tsx
@@ -0,0 +1,1645 @@
+/**
+ * @jest-environment jsdom
+ */
+import React from 'react';
+import { render, screen, waitFor, act } from '@testing-library/react';
+import userEvent from '@testing-library/user-event';
+import '@testing-library/jest-dom';
+
+import SettingsModal from '../../renderer/components/common/SettingsModal';
+import { createMockElectronWithOptions } from './test-utils/mockElectronHandler';
+
+describe('SettingsModal Component', () => {
+  // 共通のプロップス
+  const defaultProps = {
+    open: true,
+    onClose: jest.fn(),
+    onSettingsUpdated: jest.fn(),
+    onValidChange: jest.fn(),
+  };
+
+  // テスト前のセットアップ
+  beforeEach(() => {
+    window.electron = createMockElectronWithOptions();
+  });
+
+  // テスト後のクリーンアップ
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  // テスト1: 正常に設定モーダルが表示され、初期値が設定されること
+  test('正常に設定モーダルが表示され、初期値が設定されること', async () => {
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 設定値が取得されるまで待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // 全てのフィールドが読み込まれて有効になるまで待機
+    await waitFor(() => {
+      const apiKeyInput = screen.getByLabelText('APIキー');
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    // データベース設定
+    const dbPath = screen.getByRole('textbox', {
+      name: 'データベース保存フォルダ',
+    });
+    expect(dbPath).toHaveValue('/test/db');
+
+    // ソース設定
+    expect(screen.getByLabelText('ドキュメント格納フォルダ')).toHaveValue(
+      './test/source',
+    );
+
+    // API設定
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    expect(apiKeyInput).toHaveValue('test-api-key');
+    expect(screen.getByLabelText('APIエンドポイントURL')).toHaveValue(
+      'https://api.test.com',
+    );
+    expect(screen.getByLabelText('BPR ID')).toHaveValue('test-model');
+
+    // Redmine設定
+    const redmineEndpoint = screen.getByLabelText('Redmineエンドポイント');
+    const redmineApiKey = screen.getByLabelText('RedmineAPIキー');
+    expect(redmineEndpoint).toHaveValue('https://redmine.test.com');
+    expect(redmineApiKey).toHaveValue('test-redmine-key');
+
+    // GitLab設定
+    const gitlabEndpoint = screen.getByLabelText('GitLabエンドポイント');
+    const gitlabApiKey = screen.getByLabelText('GitLabAPIキー');
+    expect(gitlabEndpoint).toHaveValue('https://gitlab.test.com');
+    expect(gitlabApiKey).toHaveValue('test-gitlab-key');
+
+    // MCPサーバー設定 (文字列形式)
+    // URLオブジェクトは自動的に末尾に'/'が追加される
+    expect(screen.getByLabelText('MCPサーバー設定（JSON）')).toHaveValue(
+      JSON.stringify({ testMcp: { url: 'https://mcp.test.com/' } }, null, 2),
+    );
+
+    // システムプロンプト設定
+    expect(
+      screen.getByLabelText('システムプロンプトのカスタマイズが可能です'),
+    ).toHaveValue('test system prompt');
+  });
+
+  // テスト2: 設定値を更新して保存できること
+  test('設定値を更新して保存できること', async () => {
+    const user = userEvent.setup({ delay: null });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // 全ての入力フィールドが有効になるまで待機
+    await waitFor(() => {
+      const apiKeyInput = screen.getByLabelText('APIキー');
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    // API設定の更新
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    const apiEndpointInput = screen.getByLabelText('APIエンドポイントURL');
+    const apiModelInput = screen.getByLabelText('BPR ID');
+
+    await user.clear(apiKeyInput);
+    await user.type(apiKeyInput, 'new-test-api-key');
+    await user.clear(apiEndpointInput);
+    await user.type(apiEndpointInput, 'https://new.api.test.com');
+    await user.clear(apiModelInput);
+    await user.type(apiModelInput, 'new-test-model');
+
+    // データベース設定の更新
+    const dbDirInput = screen.getByLabelText('データベース保存フォルダ');
+    await user.clear(dbDirInput);
+    await user.type(dbDirInput, '/new/test/db');
+
+    // ソース設定の更新
+    const sourceInput = screen.getByLabelText('ドキュメント格納フォルダ');
+    await user.clear(sourceInput);
+    await user.type(sourceInput, './new/test/source');
+
+    // Redmine設定の更新
+    const redmineEndpoint = screen.getByLabelText('Redmineエンドポイント');
+    const redmineApiKey = screen.getByLabelText('RedmineAPIキー');
+
+    await user.clear(redmineEndpoint);
+    await user.type(redmineEndpoint, 'https://new.redmine.test.com');
+    await user.clear(redmineApiKey);
+    await user.type(redmineApiKey, 'new-test-redmine-key');
+
+    // GitLab設定の更新
+    const gitlabEndpoint = screen.getByLabelText('GitLabエンドポイント');
+    const gitlabApiKey = screen.getByLabelText('GitLabAPIキー');
+
+    await user.clear(gitlabEndpoint);
+    await user.type(gitlabEndpoint, 'https://new.gitlab.test.com');
+    await user.clear(gitlabApiKey);
+    await user.type(gitlabApiKey, 'new-test-gitlab-key');
+
+    // MCPサーバー設定の更新
+    const mcpConfigInput = screen.getByLabelText('MCPサーバー設定（JSON）');
+    const validMcpConfig = {
+      weather: {
+        command: 'npx',
+        args: ['tsx', 'weather.ts'],
+        env: { API_KEY: 'test-key' },
+        cwd: '/test/weather',
+      },
+    };
+    await user.clear(mcpConfigInput);
+    await userEvent.type(
+      mcpConfigInput,
+      JSON.stringify(validMcpConfig, null, 2).replace(/[{[]/g, '$&$&'),
+    );
+
+    // システムプロンプト設定の更新
+    const systemPromptInput = screen.getByLabelText(
+      'システムプロンプトのカスタマイズが可能です',
+    );
+    await user.clear(systemPromptInput);
+    await user.type(systemPromptInput, 'new test system prompt');
+
+    // 保存ボタンをクリック
+    await waitFor(() => {
+      expect(screen.getByText('保存')).toBeEnabled();
+    });
+    await user.click(screen.getByText('保存'));
+
+    // 設定の一括保存が正しく呼ばれることを確認
+    await waitFor(() => {
+      const call = (window.electron.settings.setSettings as jest.Mock).mock.calls[0][0];
+
+      // 保存された設定を検証（MCPは文字列からパースされたオブジェクト）
+      expect(call.api).toEqual({
+        key: 'new-test-api-key',
+        url: 'https://new.api.test.com',
+        model: 'new-test-model',
+      });
+      expect(call.database).toEqual({ dir: '/new/test/db' });
+      expect(call.source).toEqual({ registerDir: './new/test/source' });
+      expect(call.redmine).toEqual({
+        endpoint: 'https://new.redmine.test.com',
+        apiKey: 'new-test-redmine-key',
+      });
+      expect(call.gitlab).toEqual({
+        endpoint: 'https://new.gitlab.test.com',
+        apiKey: 'new-test-gitlab-key',
+      });
+      expect(call.systemPrompt).toEqual({ content: 'new test system prompt' });
+
+      // MCPは文字列からパースされたオブジェクトになる
+      expect(call.mcp.serverConfig).toEqual(validMcpConfig);
+    });
+
+    // エージェントの再初期化が呼ばれることを確認
+    expect(window.electron.settings.reinitialize).toHaveBeenCalled();
+
+    // コールバック関数が呼ばれることを確認
+    expect(defaultProps.onSettingsUpdated).toHaveBeenCalled();
+    expect(defaultProps.onClose).toHaveBeenCalled();
+    expect(defaultProps.onValidChange).toHaveBeenCalledWith(true);
+  }, 60000);
+
+  // テスト3: バリデーションエラーが正しく表示されること
+  test('バリデーションエラーが正しく表示されること', async () => {
+    // checkPathExists関数をモック化して、fsAccessの結果を使うようにする
+    const settingModule = require('@/types/setting');
+    jest.spyOn(settingModule, 'checkPathExists').mockImplementation(
+      async (...args: unknown[]): Promise<boolean> => {
+        const path = args[0] as string;
+        const result = await window.electron.fs.access(path);
+        return result.success === true && result.data === true;
+      },
+    );
+
+    window.electron = createMockElectronWithOptions({
+      fsAccess: false,
+    });
+
+    const user = userEvent.setup({ delay: null });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // 必須フィールドを空にする
+    await waitFor(() => {
+      const apiKeyInput = screen.getByLabelText('APIキー');
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    const apiEndpointInput = screen.getByLabelText('APIエンドポイントURL');
+    const apiModelInput = screen.getByLabelText('BPR ID');
+    const dbDirInput = screen.getByLabelText('データベース保存フォルダ');
+
+    // 必須フィールドをクリア
+    await user.clear(apiKeyInput);
+    await user.clear(apiEndpointInput);
+    await user.clear(apiModelInput);
+    await user.clear(dbDirInput);
+
+    // 存在しないパスを入力（データベース設定）
+    await user.type(dbDirInput, '/nonexistent/path');
+
+    // 存在しないパスを入力（ソース設定）
+    const sourceInput = screen.getByLabelText('ドキュメント格納フォルダ');
+    await user.clear(sourceInput);
+    await user.type(sourceInput, './nonexistent/source');
+
+    // 無効なURL形式を入力
+    const redmineEndpoint = screen.getByLabelText('Redmineエンドポイント');
+    const gitlabEndpoint = screen.getByLabelText('GitLabエンドポイント');
+
+    await user.clear(apiEndpointInput);
+    await user.type(apiEndpointInput, 'invalid-url');
+    await user.clear(redmineEndpoint);
+    await user.type(redmineEndpoint, 'not-a-url');
+    await user.clear(gitlabEndpoint);
+    await user.type(gitlabEndpoint, 'wrong-url');
+
+    // MCPサーバー設定の無効な形式をテスト
+    const mcpConfigInput = screen.getByLabelText('MCPサーバー設定（JSON）');
+
+    // 無効なJSON構文
+    await user.clear(mcpConfigInput);
+    await userEvent.type(
+      mcpConfigInput,
+      '{ invalid json'.replace(/[{[]/g, '$&$&'),
+    );
+
+    // バリデーションエラーメッセージが表示されることを確認
+    await waitFor(
+      () => {
+        // 必須フィールドのエラー
+        expect(screen.getByText('APIキーは必須です')).toBeInTheDocument();
+        expect(screen.getByText('モデル名は必須です')).toBeInTheDocument();
+
+        // パス存在エラー（DB + ドキュメント登録フォルダ）
+        expect(
+          screen.getAllByText('指定されたパスが存在しません').length,
+        ).toEqual(2);
+
+        // 無効なURL形式のエラー
+        expect(screen.getAllByText('有効なURLを入力してください').length).toEqual(
+          3,
+        );
+
+        // MCPサーバー設定のエラー
+        expect(screen.getByText('JSONの形式が不正です')).toBeInTheDocument();
+      },
+      { timeout: 10000 },
+    );
+
+    // 保存ボタンが無効化されていることを確認
+    expect(screen.getByText('保存')).toBeDisabled();
+
+    // バリデーションエラー状態であることを確認
+    await waitFor(() => {
+      expect(defaultProps.onValidChange).toHaveBeenLastCalledWith(false);
+    });
+
+    // モックをクリーンアップ
+    jest.restoreAllMocks();
+  }, 30000);
+
+  // テスト4: MCPスキーマのバリデーションエラーが正しく表示されること
+  test('MCPスキーマのバリデーションエラーが正しく表示されること', async () => {
+    const user = userEvent.setup({ delay: null });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    const mcpConfigInput = screen.getByLabelText('MCPサーバー設定（JSON）');
+    await waitFor(() => {
+      expect(mcpConfigInput).toBeEnabled();
+    });
+
+    // 1. 不正なコマンド構造 (必須フィールドの欠如)
+    await user.clear(mcpConfigInput);
+    await userEvent.type(
+      mcpConfigInput,
+      JSON.stringify(
+        {
+          weather: {
+            wrong_field: 'value',
+          },
+        },
+        null,
+        2,
+      ).replace(/[{[]/g, '$&$&'),
+    );
+
+    await waitFor(() => {
+      const element = screen.getByText((content, element) =>
+        content.includes('MCP設定形式が不正です'),
+      );
+      expect(element).toBeInTheDocument();
+      expect(screen.getByText('保存')).toBeDisabled();
+    });
+
+    // 2. 不正な引数フォーマット
+    await user.clear(mcpConfigInput);
+    await userEvent.type(
+      mcpConfigInput,
+      JSON.stringify(
+        {
+          weather: {
+            command: 'npx',
+            args: 'not-an-array',
+          },
+        },
+        null,
+        2,
+      ).replace(/[{[]/g, '$&$&'),
+    );
+
+    await waitFor(() => {
+      const element = screen.getByText((content, element) =>
+        content.includes('MCP設定形式が不正です'),
+      );
+      expect(element).toBeInTheDocument();
+      expect(screen.getByText('保存')).toBeDisabled();
+    });
+
+    // 3. 不正なURL形式
+    await user.clear(mcpConfigInput);
+    await userEvent.type(
+      mcpConfigInput,
+      JSON.stringify(
+        {
+          service: {
+            url: 'invalid-url',
+          },
+        },
+        null,
+        2,
+      ).replace(/[{[]/g, '$&$&'),
+    );
+
+    await waitFor(() => {
+      const element = screen.getByText((content, element) =>
+        content.includes('MCP設定形式が不正です'),
+      );
+      expect(element).toBeInTheDocument();
+      expect(screen.getByText('保存')).toBeDisabled();
+    });
+
+    // 4. 不正な環境変数形式
+    await user.clear(mcpConfigInput);
+    await userEvent.type(
+      mcpConfigInput,
+      JSON.stringify(
+        {
+          weather: {
+            command: 'npx',
+            env: ['not', 'an', 'object'],
+          },
+        },
+        null,
+        2,
+      ).replace(/[{[]/g, '$&$&'),
+    );
+
+    await waitFor(() => {
+      const element = screen.getByText((content, element) =>
+        content.includes('MCP設定形式が不正です'),
+      );
+      expect(element).toBeInTheDocument();
+      expect(screen.getByText('保存')).toBeDisabled();
+    });
+
+    // バリデーション失敗の状態を確認
+    await waitFor(() => {
+      expect(defaultProps.onValidChange).toHaveBeenLastCalledWith(false);
+    });
+  }, 20000);
+
+  // テスト5: 保存に失敗した場合のエラー表示を確認
+  test('保存に失敗した場合のエラー表示を確認', async () => {
+    const user = userEvent.setup({ delay: null });
+
+    // 設定の保存に失敗するようにモックを設定
+    window.electron.settings.setSettings = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to save settings'));
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // APIキーを更新してバリデーション完了を待機
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    await user.type(apiKeyInput, 'new-api-key');
+
+    // バリデーションの完了を待機
+    await waitFor(() => {
+      expect(defaultProps.onValidChange).toHaveBeenCalledWith(true);
+    });
+
+    // 保存ボタンが有効になることを確認
+    await waitFor(() => {
+      expect(screen.getByText('保存')).toBeEnabled();
+    });
+
+    // 保存ボタンをクリック
+    await user.click(screen.getByText('保存'));
+
+    // エラーメッセージが表示されることを確認
+    await waitFor(() => {
+      expect(screen.getByText('API通信に失敗しました')).toBeInTheDocument();
+    });
+
+    // モーダルが閉じられないことを確認
+    expect(defaultProps.onClose).not.toHaveBeenCalled();
+  });
+
+  // テスト6: キャンセルボタンの動作を確認
+  test('キャンセルボタンの動作を確認', async () => {
+    const user = userEvent.setup({ delay: null });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // APIキーを更新
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+    await user.clear(apiKeyInput);
+    await user.type(apiKeyInput, 'new-api-key');
+
+    // キャンセルボタンをクリック
+    await user.click(screen.getByText('キャンセル'));
+
+    // setSettings関数が呼ばれないことを確認
+    expect(window.electron.settings.setSettings).not.toHaveBeenCalled();
+
+    // モーダルが閉じられることを確認
+    expect(defaultProps.onClose).toHaveBeenCalled();
+  });
+
+  // テスト7: ローディング状態の表示を確認
+  test('ローディング状態の表示を確認', async () => {
+    // 設定の取得を遅延させる
+    window.electron.settings.getSettings = jest.fn().mockImplementation(() => {
+      return new Promise((resolve) => {
+        setTimeout(() => {
+          resolve({
+            success: true,
+            data: {
+              database: { dir: '/test/db' },
+              source: { registerDir: './test/source' },
+              api: {
+                key: 'test-api-key',
+                url: 'https://api.test.com',
+                model: 'test-model',
+              },
+              redmine: {
+                endpoint: 'https://redmine.test.com',
+                apiKey: 'test-redmine-key',
+              },
+              gitlab: {
+                endpoint: 'https://gitlab.test.com',
+                apiKey: 'test-gitlab-key',
+              },
+              mcp: {
+                serverConfig: { testMcp: { url: new URL('https://mcp.test.com') } },
+              },
+              systemPrompt: { content: 'test system prompt' },
+            },
+          });
+        }, 100);
+      });
+    });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 全ての入力フィールドが無効化されていることを確認
+    const inputs = screen.getAllByRole('textbox');
+    inputs.forEach((input) => {
+      expect(input).toBeDisabled();
+    });
+
+    // データがロードされるまで待機
+    await waitFor(
+      () => {
+        const textInputs = screen.getAllByRole('textbox');
+        expect(textInputs[0]).toBeEnabled();
+      },
+      { timeout: 1000 },
+    );
+  });
+
+  // テスト8: 保存中の状態表示を確認
+  test('保存中の状態表示を確認', async () => {
+    const user = userEvent.setup({ delay: null });
+
+    // 設定の保存を遅延させる
+    window.electron.settings.setSettings = jest.fn().mockImplementation(
+      () =>
+        new Promise((resolve) => {
+          setTimeout(() => {
+            resolve({ success: true, data: true });
+          }, 100);
+        }),
+    );
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // APIキーを更新
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+    await user.clear(apiKeyInput);
+    await user.type(apiKeyInput, 'new-api-key');
+    await new Promise((resolve) => {
+      setTimeout(resolve, 500);
+    });
+
+    // バリデーション状態の確認
+    await waitFor(
+      () => {
+        const { mock } = defaultProps.onValidChange as jest.Mock;
+        expect(mock.calls[mock.calls.length - 1][0]).toBe(true);
+      },
+      { timeout: 5000 },
+    );
+
+    // 保存ボタンの状態を確認
+    await waitFor(
+      () => {
+        const saveButton = screen.getByText('保存');
+        expect(saveButton).toBeEnabled();
+      },
+      { timeout: 2000 },
+    );
+
+    // 保存ボタンをクリック
+    await user.click(screen.getByText('保存'));
+
+    // ボタンが無効化され、ローディングアイコンが表示されることを確認
+    expect(screen.getByText('保存')).toBeDisabled();
+    expect(screen.getByRole('progressbar')).toBeInTheDocument();
+
+    // 保存が完了するまで待機
+    await waitFor(
+      () => {
+        expect(defaultProps.onClose).toHaveBeenCalled();
+      },
+      { timeout: 1000 },
+    );
+  });
+
+  // テスト9: 設定の取得に失敗した場合のエラー表示を確認
+  test('設定の取得に失敗した場合のエラー表示を確認', async () => {
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // 設定の取得に失敗するようにモックを設定
+    window.electron.settings.getSettings = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to get settings'));
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        '設定の読み込みに処理失敗しました:',
+        expect.any(Error),
+      );
+    });
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト10: 初回設定データ取得がエラーの場合、ポーリングで初回データ取得を継続すること
+  test('初回設定データ取得がエラーの場合、ポーリングで初回データ取得を継続すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 常にエラーを返すモック
+    window.electron.settings.getSettings = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to get settings'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // エラーログが出力されることを確認（invokeApiがエラーをキャッチして最初にログ出力）
+    expect(consoleSpy).toHaveBeenCalledWith(
+      'API通信に失敗しました:',
+      expect.any(Error),
+    );
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに5秒進める（ポーリング2回目）
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 3回目の呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(3);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト11: 初回設定データ取得が成功した場合は、ポーリングを解除すること
+  test('初回設定データ取得が成功した場合は、ポーリングを解除すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 1回目はエラー、2回目以降は成功するモック
+    window.electron.settings.getSettings = jest
+      .fn()
+      .mockRejectedValueOnce(new Error('Failed to get settings'))
+      .mockResolvedValue({
+        success: true,
+        data: {
+          database: { dir: '/test/db' },
+          source: { registerDir: './test/source' },
+          api: {
+            key: 'test-api-key',
+            url: 'https://api.test.com',
+            model: 'test-model',
+          },
+          redmine: {
+            endpoint: 'https://redmine.test.com',
+            apiKey: 'test-redmine-key',
+          },
+          gitlab: {
+            endpoint: 'https://gitlab.test.com',
+            apiKey: 'test-gitlab-key',
+          },
+          mcp: {
+            serverConfig: { testMcp: { url: new URL('https://mcp.test.com') } },
+          },
+          systemPrompt: { content: 'test system prompt' },
+        },
+      });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出し（エラー）を待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // 5秒進める前にマイクロタスクを処理してポーリングを設定
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出し（成功）を待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // 少し待ってから確認
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(2);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト12: 初回エージェント状態取得がエラーの場合、ポーリングで取得を継続すること
+  test('初回エージェント状態取得がエラーの場合、ポーリングで取得を継続すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // getStatusが常にエラーを返すモック
+    window.electron.settings.getStatus = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to get agent status'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getStatus).toHaveBeenCalled();
+    });
+
+    // エラーログが出力されることを確認（invokeApiのログ）
+    expect(consoleSpy).toHaveBeenCalledWith(
+      'API通信に失敗しました:',
+      expect.any(Error),
+    );
+
+    const initialCallCount = (window.electron.settings.getStatus as jest.Mock)
+      .mock.calls.length;
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 呼び出し回数が増えることを確認
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(initialCallCount);
+    });
+
+    const afterFirstPollCallCount = (
+      window.electron.settings.getStatus as jest.Mock
+    ).mock.calls.length;
+
+    // さらに5秒進める（ポーリング2回目）
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // さらに呼び出し回数が増えることを確認
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(afterFirstPollCallCount);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト13: エージェント状態が'saving'の場合、ポーリングで取得を継続すること
+  test("エージェント状態が'saving'の場合、ポーリングで取得を継続すること", async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 最初2回は'saving'、3回目以降は'ready'を返すモック
+    window.electron.settings.getStatus = jest
+      .fn()
+      .mockResolvedValueOnce({
+        success: true,
+        data: {
+          state: 'saving' as const,
+          messages: [],
+          tools: {
+            document: false,
+            redmine: false,
+            gitlab: false,
+            mcp: false,
+          },
+        },
+      })
+      .mockResolvedValueOnce({
+        success: true,
+        data: {
+          state: 'saving' as const,
+          messages: [],
+          tools: {
+            document: false,
+            redmine: false,
+            gitlab: false,
+            mcp: false,
+          },
+        },
+      })
+      .mockResolvedValue({
+        success: true,
+        data: {
+          state: 'done' as const,
+          messages: [],
+          tools: {
+            document: false,
+            redmine: false,
+            gitlab: false,
+            mcp: false,
+          },
+        },
+      });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出しを待機（state: 'saving'）
+    await waitFor(() => {
+      expect(window.electron.settings.getStatus).toHaveBeenCalledTimes(1);
+    });
+
+    // エラーログが出力されることを確認（'saving'の場合もthrowされるのでログが出る）
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        'エージェント状態の取得に失敗しました:',
+        expect.any(Error),
+      );
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出しを待機（まだstate: 'saving'）
+    await waitFor(() => {
+      expect(window.electron.settings.getStatus).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに5秒進める（ポーリング2回目）
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 3回目の呼び出しを待機（state: 'done'になる）
+    await waitFor(() => {
+      expect(window.electron.settings.getStatus).toHaveBeenCalledTimes(3);
+    });
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認（ポーリング停止）
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.settings.getStatus).toHaveBeenCalledTimes(3);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト14: 初回エージェント状態取得が成功した場合は、ポーリングを解除すること
+  test('初回エージェント状態取得が成功した場合は、ポーリングを解除すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 1回目はエラー、2回目以降は成功するモック
+    window.electron.settings.getStatus = jest
+      .fn()
+      .mockRejectedValueOnce(new Error('Failed to get agent status'))
+      .mockResolvedValue({
+        success: true,
+        data: {
+          state: 'done' as const,
+          messages: [],
+          tools: {
+            document: false,
+            redmine: false,
+            gitlab: false,
+            mcp: false,
+          },
+        },
+      });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出し（エラー）を待機
+    await waitFor(() => {
+      expect(window.electron.settings.getStatus).toHaveBeenCalled();
+    });
+
+    const initialCallCount = (window.electron.settings.getStatus as jest.Mock)
+      .mock.calls.length;
+
+    // 5秒進める前にマイクロタスクを処理してポーリングを設定
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出し（成功）を待機
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(initialCallCount);
+    });
+
+    const afterSuccessCallCount = (
+      window.electron.settings.getStatus as jest.Mock
+    ).mock.calls.length;
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBe(afterSuccessCallCount);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト15: 保存ボタン押下後、settings-update-finishedイベントまでエージェント状態をポーリングすること
+  test('保存ボタン押下後、settings-update-finishedイベントまでエージェント状態をポーリングすること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // pushApi.subscribeをモック化して、購読関数を保存
+    let updateFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'settings-update-finished') {
+          updateFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    const user = userEvent.setup({ delay: null, advanceTimers: jest.advanceTimersByTime });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalled();
+    });
+
+    // APIキーを更新してバリデーション完了を待機
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    await user.type(apiKeyInput, 'new-api-key');
+
+    // バリデーションの完了を待機
+    await waitFor(() => {
+      expect(defaultProps.onValidChange).toHaveBeenCalledWith(true);
+    });
+
+    // 保存前のgetStatus呼び出し回数を記録
+    const beforeSaveCallCount = (window.electron.settings.getStatus as jest.Mock)
+      .mock.calls.length;
+
+    // 保存ボタンをクリック
+    await user.click(screen.getByText('保存'));
+
+    // pushApi.subscribeが呼ばれることを確認
+    await waitFor(() => {
+      expect(window.electron.pushApi.subscribe).toHaveBeenCalledWith(
+        'settings-update-finished',
+        expect.any(Function),
+      );
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(beforeSaveCallCount);
+    });
+
+    const afterFirstPollCallCount = (
+      window.electron.settings.getStatus as jest.Mock
+    ).mock.calls.length;
+
+    // さらに5秒進める（ポーリング2回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(afterFirstPollCallCount);
+    });
+
+    // updateFinishedイベントを発火してポーリングを停止
+    await act(async () => {
+      if (updateFinishedCallback) {
+        updateFinishedCallback({ payload: { success: true } });
+      }
+      await Promise.resolve();
+    });
+
+    const afterEventCallCount = (window.electron.settings.getStatus as jest.Mock)
+      .mock.calls.length;
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      // イベント発火後の最後のfetchAgentStatus呼び出し分（+1）を考慮
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeLessThanOrEqual(afterEventCallCount + 1);
+    });
+
+    jest.useRealTimers();
+  }, 60000);
+
+  // テスト16: settings-update-finishedイベント（成功）発行後、最後にエージェント状態取得を実行し、ポーリングを停止すること
+  test('settings-update-finishedイベント（成功）発行後、最後にエージェント状態取得を実行し、ポーリングを停止すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // pushApi.subscribeをモック化
+    let updateFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'settings-update-finished') {
+          updateFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    const user = userEvent.setup({ delay: null, advanceTimers: jest.advanceTimersByTime });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalled();
+    });
+
+    // APIキーを更新
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    await user.type(apiKeyInput, 'new-api-key');
+
+    // 保存ボタンをクリック
+    await user.click(screen.getByText('保存'));
+
+    // 購読が開始されるまで待機
+    await waitFor(() => {
+      expect(window.electron.pushApi.subscribe).toHaveBeenCalledWith(
+        'settings-update-finished',
+        expect.any(Function),
+      );
+    });
+
+    // イベント発火前の呼び出し回数を記録
+    const beforeEventCallCount = (
+      window.electron.settings.getStatus as jest.Mock
+    ).mock.calls.length;
+
+    // updateFinishedイベントを発火（成功）
+    await act(async () => {
+      if (updateFinishedCallback) {
+        updateFinishedCallback({ payload: { success: true } });
+      }
+      await Promise.resolve();
+    });
+
+    // イベント発火後にfetchAgentStatusが呼ばれることを確認
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(beforeEventCallCount);
+    });
+
+    jest.useRealTimers();
+  }, 60000);
+
+  // テスト17: settings-update-finishedイベント（失敗）発行後の挙動確認
+  test('settings-update-finishedイベント（失敗）発行後の挙動確認', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // alertStore のスパイ
+    const { alertStore } = require('@/renderer/stores/alertStore');
+    const addAlertSpy = jest.spyOn(alertStore.getState(), 'addAlert');
+
+    // pushApi.subscribeをモック化
+    let updateFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'settings-update-finished') {
+          updateFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    const user = userEvent.setup({ delay: null, advanceTimers: jest.advanceTimersByTime });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalled();
+    });
+
+    // APIキーを更新
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    await user.type(apiKeyInput, 'new-api-key');
+
+    // 保存ボタンをクリック
+    await user.click(screen.getByText('保存'));
+
+    // 購読が開始されるまで待機
+    await waitFor(() => {
+      expect(window.electron.pushApi.subscribe).toHaveBeenCalledWith(
+        'settings-update-finished',
+        expect.any(Function),
+      );
+    });
+
+    addAlertSpy.mockClear();
+
+    // updateFinishedイベントを発火（失敗）
+    await act(async () => {
+      if (updateFinishedCallback) {
+        updateFinishedCallback({
+          payload: {
+            success: false,
+            error: 'Initialization failed due to network error',
+          },
+        });
+      }
+      await Promise.resolve();
+    });
+
+    // エラーアラートが表示されることを確認
+    await waitFor(() => {
+      expect(addAlertSpy).toHaveBeenCalledWith(
+        expect.objectContaining({
+          severity: 'error',
+          message: expect.stringContaining('AIツールの初期化に失敗しました'),
+        }),
+      );
+    });
+
+    addAlertSpy.mockRestore();
+    jest.useRealTimers();
+  }, 60000);
+
+  // テスト18: ポーリング中のエージェント状態取得でエラーが発生した場合、ポーリングは継続されること
+  test('ポーリング中のエージェント状態取得でエラーが発生した場合、ポーリングは継続されること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // pushApi.subscribeをモック化
+    let updateFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'settings-update-finished') {
+          updateFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    // 最初は成功、その後一度エラー、その後また成功するモック
+    const getStatusMock = jest.fn();
+    let callCount = 0;
+    getStatusMock.mockImplementation(() => {
+      callCount++;
+      if (callCount === 2) {
+        // 2回目の呼び出しでエラー（ポーリング開始後の1回目）
+        return Promise.reject(new Error('Network error'));
+      }
+      return Promise.resolve({
+        success: true,
+        data: {
+          state: 'done' as const,
+          messages: [],
+          tools: {
+            document: false,
+            redmine: false,
+            gitlab: false,
+            mcp: false,
+          },
+        },
+      });
+    });
+    window.electron.settings.getStatus = getStatusMock;
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    const user = userEvent.setup({ delay: null, advanceTimers: jest.advanceTimersByTime });
+
+    render(
+      <SettingsModal
+        open={defaultProps.open}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalled();
+    });
+
+    // APIキーを更新
+    const apiKeyInput = screen.getByLabelText('APIキー');
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+
+    await user.type(apiKeyInput, 'new-api-key');
+
+    // 保存ボタンをクリック
+    await user.click(screen.getByText('保存'));
+
+    // 購読が開始されるまで待機
+    await waitFor(() => {
+      expect(window.electron.pushApi.subscribe).toHaveBeenCalledWith(
+        'settings-update-finished',
+        expect.any(Function),
+      );
+    });
+
+    // 5秒進める（ポーリング1回目：エラー）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(getStatusMock).toHaveBeenCalledTimes(2);
+    });
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        'エージェント状態のポーリング中にエラーが発生しました:',
+        expect.any(Error),
+      );
+    });
+
+    // さらに5秒進める（ポーリング2回目：成功）
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // ポーリングが継続していることを確認
+    await waitFor(() => {
+      expect(getStatusMock).toHaveBeenCalledTimes(3);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  }, 60000);
+
+  // テスト19: モーダルを閉じてもポーリングは継続すること
+  test('モーダルを閉じてもポーリングは継続すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 常にエラーを返すモック（ポーリングが継続するようにする）
+    window.electron.settings.getSettings = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to get settings'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    const { rerender } = render(
+      <SettingsModal
+        open={true}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(1);
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(2);
+    });
+
+    // モーダルを閉じる（open=falseに変更）
+    rerender(
+      <SettingsModal
+        open={false}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // モーダルを閉じた後も5秒進める
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // モーダルを閉じた後もポーリングが継続することを確認
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalledTimes(3);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト20: コンポーネントがアンマウントされた際、全てのポーリングが停止すること
+  test('コンポーネントがアンマウントされた際、全てのポーリングが停止すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 常にエラーを返すモック（ポーリングが継続するようにする）
+    window.electron.settings.getSettings = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to get settings'));
+
+    window.electron.settings.getStatus = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to get agent status'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    const { unmount } = render(
+      <SettingsModal
+        open={true}
+        onClose={defaultProps.onClose}
+        onSettingsUpdated={defaultProps.onSettingsUpdated}
+        onValidChange={defaultProps.onValidChange}
+      />,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalled();
+      expect(window.electron.settings.getStatus).toHaveBeenCalled();
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.settings.getSettings).toHaveBeenCalled();
+      expect(window.electron.settings.getStatus).toHaveBeenCalled();
+    });
+
+    const getSettingsCallCount = (
+      window.electron.settings.getSettings as jest.Mock
+    ).mock.calls.length;
+    const getStatusCallCount = (
+      window.electron.settings.getStatus as jest.Mock
+    ).mock.calls.length;
+
+    // コンポーネントをアンマウント
+    unmount();
+
+    // さらに10秒進める
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // ポーリングが停止していることを確認（呼び出し回数が増えない）
+    await waitFor(() => {
+      expect(
+        (window.electron.settings.getSettings as jest.Mock).mock.calls.length,
+      ).toBe(getSettingsCallCount);
+      expect(
+        (window.electron.settings.getStatus as jest.Mock).mock.calls.length,
+      ).toBe(getStatusCallCount);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+});
diff --git a/src/__tests__/renderer/Sidebar.test.tsx b/src/__tests__/renderer/Sidebar.test.tsx
new file mode 100644
index 000000000..b5fc88fc5
--- /dev/null
+++ b/src/__tests__/renderer/Sidebar.test.tsx
@@ -0,0 +1,1353 @@
+/**
+ * @jest-environment jsdom
+ */
+import React from 'react';
+import { render, screen, waitFor, act } from '@testing-library/react';
+import { MemoryRouter, Route, Routes } from 'react-router-dom';
+import userEvent from '@testing-library/user-event';
+import '@testing-library/jest-dom';
+import { v4 as uuidv4 } from 'uuid';
+
+import Sidebar from '@/renderer/components/sidebar/Sidebar';
+import type { ChatRoom, ProcessStatus } from '@/types';
+import type { Source } from '@/types';
+import { StoreSchema as Settings } from '@/adapter/db/electron-store/store';
+import { createMockElectronWithOptions } from '@/__tests__/renderer/test-utils/mockElectronHandler';
+import ChatRoomList from '@/renderer/components/chat/ChatRoomList';
+import ReviewHistoryList from '@/renderer/components/review/ReviewHistoryList';
+import { ROUTES } from '@/types';
+
+// uuidv4をモック化
+jest.mock('uuid', () => ({
+  v4: jest.fn(),
+}));
+
+// テスト用のモックデータ
+const mockChatRooms: ChatRoom[] = [
+  {
+    id: '1',
+    resourceId: 'resource-1',
+    title: 'Chat Room 1',
+    createdAt: new Date('2025-05-01T12:00:00.000Z'),
+    updatedAt: new Date('2025-05-01T12:00:00.000Z'),
+  },
+  {
+    id: '2',
+    resourceId: 'resource-2',
+    title: 'Chat Room 2',
+    createdAt: new Date('2025-05-02T12:00:00.000Z'),
+    updatedAt: new Date('2025-05-02T12:00:00.000Z'),
+  },
+];
+
+// レビュー履歴のモックデータ
+const mockReviewHistories = [
+  {
+    id: '1',
+    title: 'Review History 1',
+    targetDocumentName: 'document1.pdf',
+    additionalInstructions: null,
+    commentFormat: null,
+    evaluationSettings: null,
+    processingStatus: 'idle' as const,
+    createdAt: '2025-05-01T12:00:00.000Z',
+    updatedAt: '2025-05-01T12:00:00.000Z',
+  },
+  {
+    id: '2',
+    title: 'Review History 2',
+    targetDocumentName: 'document2.pdf',
+    additionalInstructions: null,
+    commentFormat: null,
+    evaluationSettings: null,
+    processingStatus: 'completed' as const,
+    createdAt: '2025-05-02T12:00:00.000Z',
+    updatedAt: '2025-05-02T12:00:00.000Z',
+  },
+];
+
+// ソースのモックデータ
+const mockSources: Source[] = [
+  {
+    id: 1,
+    path: '/test/source1.md',
+    title: 'Source 1',
+    status: 'completed' as ProcessStatus,
+    isEnabled: true,
+    error: null,
+    createdAt: '2025-05-01T12:00:00.000Z',
+    updatedAt: '2025-05-01T12:00:00.000Z',
+    summary: 'Test summary 1',
+  },
+  {
+    id: 2,
+    path: '/test/source2.md',
+    title: 'Source 2',
+    status: 'completed' as ProcessStatus,
+    isEnabled: true,
+    error: null,
+    createdAt: '2025-05-02T12:00:00.000Z',
+    updatedAt: '2025-05-02T12:00:00.000Z',
+    summary: 'Test summary 2',
+  },
+  {
+    id: 3,
+    path: '/test/source3.md',
+    title: 'Source 3',
+    status: 'failed' as ProcessStatus,
+    isEnabled: false,
+    error: 'Processing error',
+    createdAt: '2025-05-03T12:00:00.000Z',
+    updatedAt: '2025-05-03T12:00:00.000Z',
+    summary: 'Test summary 3',
+  },
+];
+
+describe('Sidebar Component', () => {
+  // テスト前のセットアップ
+  beforeEach(() => {
+    // Electronグローバルオブジェクトをモック化
+    window.electron = createMockElectronWithOptions({
+      chatRooms: mockChatRooms,
+      sources: mockSources,
+    });
+
+    // uuidv4のモックをリセット
+    (uuidv4 as jest.Mock).mockReset();
+    (uuidv4 as jest.Mock).mockReturnValue('new-room-id');
+  });
+
+  // テスト後のクリーンアップ
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  // 共通のプロップス
+  const defaultProps = {
+    onRoomSelect: jest.fn(),
+    onReloadSources: jest.fn(),
+  };
+
+  const renderAtPath = (initialPath: string, selectedRoomId: string | null = null) => {
+    render(
+      // MemoryRouter でテスト用の履歴を用意
+      <MemoryRouter initialEntries={[initialPath]}>
+        <Sidebar
+          onReloadSources={defaultProps.onReloadSources}
+        >
+          <Routes>
+            <Route
+              path={ROUTES.CHAT}
+              element={
+                <ChatRoomList
+                  selectedRoomId={selectedRoomId}
+                  onRoomSelect={defaultProps.onRoomSelect}
+                />
+              }
+            />
+            <Route
+              path={ROUTES.REVIEW}
+              element={
+                <ReviewHistoryList
+                  selectedReviewHistoryId={selectedRoomId}
+                  onReviewHistorySelect={defaultProps.onRoomSelect}
+                />
+              }
+            />
+          </Routes>
+        </Sidebar>
+      </MemoryRouter>,
+    );
+  };
+
+  // テスト1: 正常にサイドバーとチャットルーム一覧が表示されること
+  test('正常にサイドバーとチャットルーム一覧が表示されること', async () => {
+    renderAtPath(ROUTES.CHAT);
+
+    // New Chatボタンが表示されることを確認
+    expect(screen.getByText('新規チャット')).toBeInTheDocument();
+
+    // チャットルーム一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+      expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
+    });
+
+    // フッターのボタンが表示されることを確認
+    expect(screen.getByLabelText('ドキュメント一覧')).toBeInTheDocument();
+    expect(screen.getByLabelText('設定')).toBeInTheDocument();
+  });
+
+  // テスト2: ローディング状態の表示が正しく機能すること
+  test('ローディング状態の表示が正しく機能すること', async () => {
+    // チャットルーム取得を遅延させる
+    window.electron.chat.getRooms = jest.fn().mockImplementation(
+      () =>
+        new Promise((resolve) => {
+          setTimeout(() => resolve({ success: true, data: mockChatRooms }), 100);
+        }),
+    );
+
+    renderAtPath(ROUTES.CHAT);
+
+    // ローディング表示を確認
+    expect(screen.getByText('チャット履歴取得中')).toBeInTheDocument();
+
+    // チャットルーム一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+      expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
+    });
+
+    // ローディング表示が消えていることを確認
+    expect(screen.queryByText('チャット履歴取得中')).not.toBeInTheDocument();
+  });
+
+  // テスト3: チャットルームが空の場合の表示が正しいこと
+  test('チャットルームが空の場合の表示が正しいこと', async () => {
+    // 空の配列を返すようにモックを設定
+    window.electron.chat.getRooms = jest
+      .fn()
+      .mockResolvedValue({ success: true, data: [] });
+
+    renderAtPath(ROUTES.CHAT);
+
+    // 空の状態のメッセージが表示されることを確認
+    await waitFor(() => {
+      expect(screen.getByText('チャット履歴がありません')).toBeInTheDocument();
+    });
+  });
+
+  // テスト4: 新規チャットルームの作成
+  test('新規チャットルームの作成', async () => {
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+    screen.debug(undefined, 100000);
+
+    // チャットルーム一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+      expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
+    });
+
+    // New Chatボタンをクリック
+    await user.click(screen.getByText('新規チャット'));
+
+    // uuidv4が呼ばれることを確認
+    expect(uuidv4).toHaveBeenCalled();
+
+    // onRoomSelectが新しいIDで呼ばれることを確認
+    expect(defaultProps.onRoomSelect).toHaveBeenCalledWith('new-room-id');
+  });
+
+  // テスト5: チャットルームの選択
+  test('チャットルームの選択', async () => {
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+
+    // チャットルーム一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+    });
+
+    // チャットルームをクリック
+    await user.click(screen.getByText('Chat Room 1'));
+
+    // onRoomSelectが正しいIDで呼ばれることを確認
+    expect(defaultProps.onRoomSelect).toHaveBeenCalledWith('1');
+  });
+
+  // テスト6: チャットルームの削除
+  test('チャットルームの削除の際に正しく指定したチャットルームが削除されること（チャットルームのソート確認も含む）', async () => {
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+
+    // チャットルーム一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+    });
+
+    // メニューボタンをクリック
+    const menuButtons = screen.getAllByLabelText('more');
+    console.log('Menu buttons:', menuButtons);
+    await user.click(menuButtons[0]);
+
+    // 削除メニューが表示されることを確認
+    expect(screen.getByText('削除')).toBeInTheDocument();
+
+    // 削除メニューをクリック
+    await user.click(screen.getByText('削除'));
+
+    // deleteRoomが呼ばれることを確認(id:2のルームがソートされて一番上にくるはず)
+    expect(window.electron.chat.deleteRoom).toHaveBeenCalledWith('2');
+
+    // 一覧が再取得されることを確認
+    await waitFor(() => {
+      expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(2);
+    });
+  });
+
+  // テスト7: チャットルーム削除時のエラーハンドリング
+  test('チャットルーム削除時のエラーハンドリング', async () => {
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // 削除に失敗するようにモックを設定
+    window.electron.chat.deleteRoom = jest.fn().mockResolvedValue({
+      success: false,
+      error: { message: 'Failed to delete chat room', code: 'DELETE_ERROR' },
+    });
+
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+
+    // チャットルーム一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+    });
+
+    // メニューボタンをクリック
+    const menuButtons = screen.getAllByLabelText('more');
+    await user.click(menuButtons[0]);
+
+    // 削除メニューをクリック
+    await user.click(screen.getByText('削除'));
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalled();
+    });
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト8: フッターのソース一覧モーダル表示
+  test('フッターのソース一覧モーダル表示', async () => {
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+
+    // ソース一覧ボタンをクリック
+    await user.click(screen.getByTestId('document-list-button'));
+
+    // SourceListModalが表示されることを確認
+    expect(screen.getByText('登録ドキュメント一覧')).toBeInTheDocument();
+  });
+
+  // テスト9: フッターの設定モーダル表示
+  test('フッターの設定モーダル表示', async () => {
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+
+    // 設定ボタンをクリック
+    await user.click(screen.getByTestId('settings-button'));
+
+    // SettingsModalが表示されることを確認
+    expect(screen.getByRole('dialog')).toBeInTheDocument();
+  });
+
+  // テスト10: チャットルーム一覧の初回読み込みエラー時の再試行
+  test(
+    'チャットルーム一覧の初回読み込みエラー時の再試行',
+    async () => {
+      // 最初はエラーを返し、2回目は成功するようにモックを設定
+      let callCount = 0;
+      window.electron.chat.getRooms = jest.fn().mockImplementation(() => {
+        callCount++;
+        if (callCount === 1) {
+          return Promise.reject(new Error('Failed to fetch chat rooms'));
+        }
+        return Promise.resolve({ success: true, data: mockChatRooms });
+      });
+
+      renderAtPath(ROUTES.CHAT);
+
+      // 初回の取得を確認(失敗)
+      await waitFor(() => {
+        expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(1);
+      });
+
+      // 再試行が呼ばれることを確認（ポーリング間隔が5000msなので、5.5秒以内に2回目が呼ばれる）
+      await waitFor(
+        () => {
+          expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(2);
+        },
+        { timeout: 8000 },
+      );
+
+      // チャットルーム一覧が表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByText('Chat Room 1')).toBeInTheDocument();
+        expect(screen.getByText('Chat Room 2')).toBeInTheDocument();
+      });
+    },
+    10000,
+  ); // タイムアウトを10秒に設定
+
+  // テスト11: チャットルーム取得時のエラーハンドリング
+  test('チャットルーム取得時のエラーハンドリング', async () => {
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // 取得に失敗するようにモックを設定
+    window.electron.chat.getRooms = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch chat rooms'));
+
+    renderAtPath(ROUTES.CHAT);
+
+    // 初回表示でローディング中であることを確認
+    expect(screen.getByText('チャット履歴取得中')).toBeInTheDocument();
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        'チャットルーム読み込みに失敗しました:',
+        expect.any(Error),
+      );
+    });
+
+    // エラー時もローディング状態が維持されることを確認（再試行のため）
+    expect(screen.getByText('チャット履歴取得中')).toBeInTheDocument();
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト12: 設定エラーバッジの初期表示
+  test('設定エラーバッジの初期表示', async () => {
+    renderAtPath(ROUTES.CHAT);
+
+    // 設定エラーがない場合、バッジは非表示
+    const settingsButton = screen.getByTestId('settings-button');
+    const settingsButtonParent = settingsButton.closest('.MuiBadge-root');
+
+    await waitFor(() => {
+      const errorBadge = settingsButtonParent?.querySelector('.MuiBadge-badge');
+      expect(errorBadge).toHaveClass('MuiBadge-invisible');
+    });
+  });
+
+  // テスト13: 設定保存後のバッジ表示更新
+  test('設定保存後のバッジ表示更新', async () => {
+    const user = userEvent.setup({ delay: null });
+    renderAtPath(ROUTES.CHAT);
+
+    // 設定ボタンをクリックしてモーダルを開く
+    await user.click(screen.getByTestId('settings-button'));
+
+    // 設定が不正な状態を作る
+    const settingsModal = screen.getByRole('dialog');
+    await waitFor(() => {
+      expect(settingsModal).toBeInTheDocument();
+    });
+
+    // バリデーションエラーを発生させる
+    const apiKeyInput = screen.getAllByLabelText('APIキー')[0];
+    await waitFor(() => {
+      expect(apiKeyInput).toBeEnabled();
+    });
+    await user.clear(apiKeyInput);
+
+    // エラーバッジが表示されることを確認
+    const settingsButton = screen.getByTestId('settings-button');
+    const settingsButtonParent = settingsButton.closest('.MuiBadge-root');
+    const errorBadge = settingsButtonParent?.querySelector('.MuiBadge-badge');
+    await waitFor(() => {
+      expect(errorBadge).not.toHaveClass('MuiBadge-invisible');
+    });
+
+    // APIキーを入力して有効な状態にする
+    await user.type(apiKeyInput, 'valid-api-key');
+
+    // エラーバッジが非表示になることを確認
+    await waitFor(() => {
+      expect(errorBadge).toHaveClass('MuiBadge-invisible');
+    });
+  });
+
+  // テスト14: ソースリストモーダルを開いた時に有効なソース数が正しく表示される
+  test('ソースリストモーダルを開いた時に有効なソース数が正しく表示される', async () => {
+    const user = userEvent.setup();
+    renderAtPath(ROUTES.CHAT);
+
+    // ソース一覧ボタンをクリックしてモーダルを開く
+    await user.click(screen.getByTestId('document-list-button'));
+
+    // ソースデータが取得されるまで待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalled();
+    });
+
+    // モーダルが開いていることを確認
+    expect(screen.getByText('登録ドキュメント一覧')).toBeInTheDocument();
+
+    // ESCキーでモーダルを閉じる
+    await user.keyboard('{Escape}');
+
+    // モーダルが閉じたことを確認
+    await waitFor(() => {
+      expect(
+        screen.queryByText('登録ドキュメント一覧'),
+      ).not.toBeInTheDocument();
+    });
+
+    // ソース一覧ボタンのバッジを取得
+    const sourceListButton = screen.getByTestId('document-list-button');
+    const sourceListButtonParent = sourceListButton.closest('.MuiBadge-root');
+    const badge = sourceListButtonParent?.querySelector('.MuiBadge-badge');
+
+    // バッジに正しい数が表示されていることを確認
+    await waitFor(() => {
+      expect(badge).toHaveTextContent('2');
+    });
+  });
+
+  // テスト15: ソースモーダルで処理中の表示になり、完了後にソース数が表示される
+  test('ソースモーダルで処理中の表示になり、完了後にソース数が表示される', async () => {
+    const user = userEvent.setup();
+
+    // 処理中のソースデータ
+    const processingMockSources: Source[] = [
+      {
+        id: 1,
+        path: '/test/processing1.md',
+        title: 'Processing 1',
+        status: 'processing' as ProcessStatus,
+        isEnabled: true,
+        error: null,
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+        summary: 'Test summary 1',
+      },
+      {
+        id: 2,
+        path: '/test/processing2.md',
+        title: 'Processing 2',
+        status: 'completed' as ProcessStatus,
+        isEnabled: true,
+        error: null,
+        createdAt: '2025-05-02T12:00:00.000Z',
+        updatedAt: '2025-05-02T12:00:00.000Z',
+        summary: 'Test summary 2',
+      },
+    ];
+
+    // ソース取得のモックを設定（処理中）
+    window.electron.source.getSources = jest.fn().mockResolvedValue({
+      success: true,
+      data: processingMockSources,
+    });
+
+    renderAtPath(ROUTES.CHAT);
+
+    // ソース一覧ボタンをクリックしてモーダルを開く
+    await user.click(screen.getByTestId('document-list-button'));
+
+    // ソースデータが取得されるまで待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalled();
+    });
+
+    // 処理中のインジケータが表示されることを確認
+    await waitFor(() => {
+      expect(
+        screen.getByTestId('document-loading-indicator'),
+      ).toBeInTheDocument();
+    });
+
+    // ESCキーでモーダルを閉じる
+    await user.keyboard('{Escape}');
+
+    // モーダルが閉じたことを確認
+    await waitFor(() => {
+      expect(
+        screen.queryByText('ドキュメント一覧'),
+      ).not.toBeInTheDocument();
+    });
+
+    // 完了後のソースデータ
+    const completedMockSources: Source[] = [
+      {
+        id: 1,
+        path: '/test/processing1.md',
+        title: 'Processing 1',
+        status: 'completed' as ProcessStatus,
+        isEnabled: true,
+        error: null,
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+        summary: 'Test summary 1',
+      },
+      {
+        id: 2,
+        path: '/test/processing2.md',
+        title: 'Processing 2',
+        status: 'completed' as ProcessStatus,
+        isEnabled: true,
+        error: null,
+        createdAt: '2025-05-02T12:00:00.000Z',
+        updatedAt: '2025-05-02T12:00:00.000Z',
+        summary: 'Test summary 2',
+      },
+    ];
+
+    // ソース取得のモックを更新（完了）
+    window.electron.source.getSources = jest.fn().mockResolvedValue({
+      success: true,
+      data: completedMockSources,
+    });
+
+    // 再度モーダルを開く
+    await user.click(screen.getByTestId('document-list-button'));
+
+    // ソースデータが再取得されるまで待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(1);
+    });
+
+    // ESCキーでモーダルを閉じる
+    await user.keyboard('{Escape}');
+
+    // モーダルが閉じたことを確認
+    await waitFor(() => {
+      expect(
+        screen.queryByText('ドキュメント一覧'),
+      ).not.toBeInTheDocument();
+    });
+
+    // バッジに有効なソース数（2）が表示されることを確認
+    await waitFor(() => {
+      const button = screen.getByTestId('document-list-button');
+      const buttonParent = button.closest('.MuiBadge-root');
+      const badge = buttonParent?.querySelector('.MuiBadge-badge');
+      expect(badge).toHaveTextContent('2');
+    });
+  });
+
+  // テスト16: ソース数が100以上の場合は99+と表示される
+  test('ソース数が100以上の場合は99+と表示される', async () => {
+    const user = userEvent.setup();
+
+    // 100個以上の有効なソースを含むテストデータを生成
+    const largeMockSources: Source[] = Array.from({ length: 150 }, (_, i) => ({
+      id: i + 1,
+      path: `/test/source${i + 1}.md`,
+      title: `Source ${i + 1}`,
+      status: 'completed' as ProcessStatus,
+      isEnabled: true,
+      error: null,
+      createdAt: '2025-05-01T12:00:00.000Z',
+      updatedAt: '2025-05-01T12:00:00.000Z',
+      summary: `Test summary ${i + 1}`,
+    }));
+
+    // ソース取得のモックを設定
+    window.electron.source.getSources = jest.fn().mockResolvedValue({
+      success: true,
+      data: largeMockSources,
+    });
+
+    renderAtPath(ROUTES.CHAT);
+
+    // ソース一覧ボタンをクリックしてモーダルを開く
+    await user.click(screen.getByTestId('document-list-button'));
+
+    // ソースデータが取得されるまで待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalled();
+    });
+
+    // ESCキーでモーダルを閉じる
+    await user.keyboard('{Escape}');
+
+    // モーダルが閉じたことを確認
+    await waitFor(() => {
+      expect(
+        screen.queryByText('登録ドキュメント一覧'),
+      ).not.toBeInTheDocument();
+    });
+
+    // バッジに"99+"が表示されることを確認
+    await waitFor(() => {
+      const button = screen.getByTestId('document-list-button');
+      const buttonParent = button.closest('.MuiBadge-root');
+      const badge = buttonParent?.querySelector('.MuiBadge-badge');
+      expect(badge).toHaveTextContent('99+');
+    });
+  });
+
+  // テスト17: チャットルーム一覧の初回データ取得が成功した場合は、ポーリングを解除すること
+  test('チャットルーム一覧の初回データ取得が成功した場合は、ポーリングを解除すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 1回目はエラー、2回目以降は成功するモック
+    window.electron.chat.getRooms = jest
+      .fn()
+      .mockRejectedValueOnce(new Error('Failed to fetch chat rooms'))
+      .mockResolvedValue({ success: true, data: mockChatRooms });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    renderAtPath(ROUTES.CHAT);
+
+    // 初回呼び出し（エラー）を待機
+    await waitFor(() => {
+      expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(1);
+    });
+
+    // 5秒進める前にマイクロタスクを処理してポーリングを設定
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出し（成功）を待機
+    await waitFor(() => {
+      expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // 少し待ってから確認
+    await waitFor(() => {
+      expect(window.electron.chat.getRooms).toHaveBeenCalledTimes(2);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト18: チャットルーム一覧コンポーネントがアンマウントされた際、ポーリングが停止すること
+  test('チャットルーム一覧コンポーネントがアンマウントされた際、ポーリングが停止すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 常にエラーを返すモック（ポーリングが継続するようにする）
+    window.electron.chat.getRooms = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch chat rooms'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    const { unmount } = render(
+      <MemoryRouter initialEntries={[ROUTES.CHAT]}>
+        <Sidebar onReloadSources={defaultProps.onReloadSources}>
+          <Routes>
+            <Route
+              path={ROUTES.CHAT}
+              element={
+                <ChatRoomList
+                  selectedRoomId={null}
+                  onRoomSelect={defaultProps.onRoomSelect}
+                />
+              }
+            />
+          </Routes>
+        </Sidebar>
+      </MemoryRouter>,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.chat.getRooms).toHaveBeenCalled();
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.chat.getRooms).toHaveBeenCalled();
+    });
+
+    const callCountBeforeUnmount = (window.electron.chat.getRooms as jest.Mock)
+      .mock.calls.length;
+
+    // コンポーネントをアンマウント
+    unmount();
+
+    // さらに10秒進める
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // ポーリングが停止していることを確認（呼び出し回数が増えない）
+    await waitFor(() => {
+      expect(
+        (window.electron.chat.getRooms as jest.Mock).mock.calls.length,
+      ).toBe(callCountBeforeUnmount);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+});
+
+// ==============================
+// レビューサイドバーのテスト
+// ==============================
+describe('Review Sidebar Component', () => {
+  // テスト前のセットアップ
+  beforeEach(() => {
+    // Electronグローバルオブジェクトをモック化
+    window.electron = createMockElectronWithOptions({
+      reviewHistories: mockReviewHistories,
+    });
+
+    // uuidv4のモックをリセット
+    (uuidv4 as jest.Mock).mockReset();
+    (uuidv4 as jest.Mock).mockReturnValue('new-review-id');
+  });
+
+  // テスト後のクリーンアップ
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  // 共通のプロップス
+  const defaultProps = {
+    onReviewHistorySelect: jest.fn(),
+    onReloadSources: jest.fn(),
+  };
+
+  const renderAtReviewPath = (selectedReviewHistoryId: string | null = null) => {
+    render(
+      <MemoryRouter initialEntries={[ROUTES.REVIEW]}>
+        <Sidebar onReloadSources={defaultProps.onReloadSources}>
+          <Routes>
+            <Route
+              path={ROUTES.REVIEW}
+              element={
+                <ReviewHistoryList
+                  selectedReviewHistoryId={selectedReviewHistoryId}
+                  onReviewHistorySelect={defaultProps.onReviewHistorySelect}
+                />
+              }
+            />
+          </Routes>
+        </Sidebar>
+      </MemoryRouter>,
+    );
+  };
+
+  // ビジネス的観点（正常系）
+
+  // テスト1: レビュー履歴一覧が正しく表示されること
+  test('レビュー履歴一覧が正しく表示されること', async () => {
+    renderAtReviewPath();
+
+    // 新規レビューボタンが表示されることを確認
+    expect(screen.getByText('新規レビュー')).toBeInTheDocument();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+      expect(screen.getByText('Review History 2')).toBeInTheDocument();
+    });
+  });
+
+  // テスト2: ローディング状態が正しく表示されること
+  test('ローディング状態が正しく表示されること', async () => {
+    // レビュー履歴取得を遅延させる
+    window.electron.review.getHistories = jest.fn().mockImplementation(
+      () =>
+        new Promise((resolve) => {
+          setTimeout(
+            () => resolve({ success: true, data: mockReviewHistories }),
+            100,
+          );
+        }),
+    );
+
+    renderAtReviewPath();
+
+    // ローディング表示を確認
+    expect(
+      screen.getByText('ドキュメントレビュー履歴取得中'),
+    ).toBeInTheDocument();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+      expect(screen.getByText('Review History 2')).toBeInTheDocument();
+    });
+
+    // ローディング表示が消えていることを確認
+    expect(
+      screen.queryByText('ドキュメントレビュー履歴取得中'),
+    ).not.toBeInTheDocument();
+  });
+
+  // テスト3: レビュー履歴が空の場合の表示が正しいこと
+  test('レビュー履歴が空の場合の表示が正しいこと', async () => {
+    // 空の配列を返すようにモックを設定
+    window.electron.review.getHistories = jest
+      .fn()
+      .mockResolvedValue({ success: true, data: [] });
+
+    renderAtReviewPath();
+
+    // 空の状態のメッセージが表示されることを確認
+    await waitFor(() => {
+      expect(
+        screen.getByText('ドキュメントレビュー履歴がありません'),
+      ).toBeInTheDocument();
+    });
+  });
+
+  // テスト4: 新規レビューの作成
+  test('新規レビューの作成', async () => {
+    const user = userEvent.setup();
+    renderAtReviewPath();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+      expect(screen.getByText('Review History 2')).toBeInTheDocument();
+    });
+
+    // 新規レビューボタンをクリック
+    await user.click(screen.getByText('新規レビュー'));
+
+    // uuidv4が呼ばれることを確認
+    expect(uuidv4).toHaveBeenCalled();
+
+    // onReviewHistorySelectが新しいIDで呼ばれることを確認
+    expect(defaultProps.onReviewHistorySelect).toHaveBeenCalledWith(
+      'new-review-id',
+    );
+  });
+
+  // テスト5: レビュー履歴の選択
+  test('レビュー履歴の選択', async () => {
+    const user = userEvent.setup();
+    renderAtReviewPath();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+    });
+
+    // レビュー履歴をクリック
+    await user.click(screen.getByText('Review History 1'));
+
+    // onReviewHistorySelectが正しいIDで呼ばれることを確認
+    expect(defaultProps.onReviewHistorySelect).toHaveBeenCalledWith('1');
+  });
+
+  // テスト6: レビュー履歴の削除
+  test('レビュー履歴の削除の際に正しく指定したレビュー履歴が削除されること（レビュー履歴のソート確認も含む）', async () => {
+    const user = userEvent.setup();
+    renderAtReviewPath();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+    });
+
+    // メニューボタンをクリック
+    const menuButtons = screen.getAllByLabelText('more');
+    await user.click(menuButtons[0]);
+
+    // 削除メニューが表示されることを確認
+    expect(screen.getByText('削除')).toBeInTheDocument();
+
+    // 削除メニューをクリック
+    await user.click(screen.getByText('削除'));
+
+    // deleteHistoryが呼ばれることを確認(id:2のレビュー履歴がソートされて一番上にくるはず)
+    expect(window.electron.review.deleteHistory).toHaveBeenCalledWith('2');
+
+    // 一覧が再取得されることを確認
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalledTimes(2);
+    });
+  });
+
+  // テスト7: サーバプッシュによるリアルタイム更新
+  test('サーバプッシュによるリアルタイム更新が機能すること', async () => {
+    // pushApi.subscribeのモックを設定して、コールバックをキャプチャできるようにする
+    let subscribedCallback: ((channel: string) => void) | null = null;
+    window.electron.pushApi.subscribe = jest
+      .fn()
+      .mockImplementation(async (channel: string, callback: (channel: string) => void) => {
+        subscribedCallback = callback;
+        return () => {}; // unsubscribe function
+      });
+
+    renderAtReviewPath();
+
+    // 初回データ取得を待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+    });
+
+    // 初回呼び出しのカウントを保存
+    const initialCallCount = (
+      window.electron.review.getHistories as jest.Mock
+    ).mock.calls.length;
+
+    // サーバプッシュイベントをトリガー
+    if (subscribedCallback) {
+      act(() => {
+        subscribedCallback!('review-history-updated');
+      });
+    }
+
+    // レビュー履歴が再取得されることを確認
+    await waitFor(() => {
+      expect(
+        (window.electron.review.getHistories as jest.Mock).mock.calls.length,
+      ).toBe(initialCallCount + 1);
+    });
+  });
+
+  // ビジネス的観点（異常系）
+
+  // テスト8: レビュー履歴取得時のエラーハンドリング
+  test('レビュー履歴取得時のエラーハンドリング', async () => {
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // 取得に失敗するようにモックを設定
+    window.electron.review.getHistories = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch review histories'));
+
+    renderAtReviewPath();
+
+    // 初回表示でローディング中であることを確認
+    expect(
+      screen.getByText('ドキュメントレビュー履歴取得中'),
+    ).toBeInTheDocument();
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        'レビュー履歴の読み込みに失敗しました:',
+        expect.any(Error),
+      );
+    });
+
+    // エラー時もローディング状態が維持されることを確認（再試行のため）
+    expect(
+      screen.getByText('ドキュメントレビュー履歴取得中'),
+    ).toBeInTheDocument();
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト9: レビュー履歴削除時のエラーハンドリング
+  test('レビュー履歴削除時のエラーハンドリング', async () => {
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // 削除に失敗するようにモックを設定
+    window.electron.review.deleteHistory = jest.fn().mockResolvedValue({
+      success: false,
+      error: { message: 'Failed to delete review history', code: 'DELETE_ERROR' },
+    });
+
+    const user = userEvent.setup();
+    renderAtReviewPath();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+    });
+
+    // メニューボタンをクリック
+    const menuButtons = screen.getAllByLabelText('more');
+    await user.click(menuButtons[0]);
+
+    // 削除メニューをクリック
+    await user.click(screen.getByText('削除'));
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalled();
+    });
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト10: 選択中のレビュー履歴を削除した場合の選択解除
+  test('選択中のレビュー履歴を削除した場合、選択が解除されること', async () => {
+    const user = userEvent.setup();
+
+    // id:2を選択した状態でレンダリング
+    renderAtReviewPath('2');
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 2')).toBeInTheDocument();
+    });
+
+    // 選択中のレビュー履歴（id:2、ソート後の一番上）のメニューボタンをクリック
+    const menuButtons = screen.getAllByLabelText('more');
+    await user.click(menuButtons[0]);
+
+    // 削除メニューをクリック
+    await user.click(screen.getByText('削除'));
+
+    // onReviewHistorySelectがnullで呼ばれることを確認（選択解除）
+    await waitFor(() => {
+      expect(defaultProps.onReviewHistorySelect).toHaveBeenCalledWith(null);
+    });
+  });
+
+  // 技術的観点（正常系）
+
+  // テスト11: updatedAtでの降順ソート
+  test('レビュー履歴がupdatedAtで降順ソートされること', async () => {
+    renderAtReviewPath();
+
+    // レビュー履歴一覧が表示されるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+      expect(screen.getByText('Review History 2')).toBeInTheDocument();
+    });
+
+    // レビュー履歴の順序を確認（updatedAtで降順ソート）
+    const listItems = screen.getAllByRole('button').filter(
+      (button) =>
+        button.textContent === 'Review History 1' ||
+        button.textContent === 'Review History 2',
+    );
+
+    // Review History 2 (2025-05-02) が Review History 1 (2025-05-01) より先に表示される
+    expect(listItems[0]).toHaveTextContent('Review History 2');
+    expect(listItems[1]).toHaveTextContent('Review History 1');
+  });
+
+  // テスト12: 初回データ取得成功後のポーリング停止
+  test('レビュー履歴一覧の初回データ取得が成功した場合は、ポーリングを解除すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 1回目はエラー、2回目以降は成功するモック
+    window.electron.review.getHistories = jest
+      .fn()
+      .mockRejectedValueOnce(new Error('Failed to fetch review histories'))
+      .mockResolvedValue({ success: true, data: mockReviewHistories });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    renderAtReviewPath();
+
+    // 初回呼び出し（エラー）を待機
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalledTimes(1);
+    });
+
+    // 5秒進める前にマイクロタスクを処理してポーリングを設定
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出し（成功）を待機
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // 少し待ってから確認
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalledTimes(2);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // テスト13: コンポーネントアンマウント時のポーリング停止
+  test('レビュー履歴一覧コンポーネントがアンマウントされた際、ポーリングが停止すること', async () => {
+    // タイマーをモック化
+    jest.useFakeTimers();
+
+    // 常にエラーを返すモック（ポーリングが継続するようにする）
+    window.electron.review.getHistories = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch review histories'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    const { unmount } = render(
+      <MemoryRouter initialEntries={[ROUTES.REVIEW]}>
+        <Sidebar onReloadSources={defaultProps.onReloadSources}>
+          <Routes>
+            <Route
+              path={ROUTES.REVIEW}
+              element={
+                <ReviewHistoryList
+                  selectedReviewHistoryId={null}
+                  onReviewHistorySelect={defaultProps.onReviewHistorySelect}
+                />
+              }
+            />
+          </Routes>
+        </Sidebar>
+      </MemoryRouter>,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalled();
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalled();
+    });
+
+    const callCountBeforeUnmount = (
+      window.electron.review.getHistories as jest.Mock
+    ).mock.calls.length;
+
+    // コンポーネントをアンマウント
+    unmount();
+
+    // さらに10秒進める
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // ポーリングが停止していることを確認（呼び出し回数が増えない）
+    await waitFor(() => {
+      expect(
+        (window.electron.review.getHistories as jest.Mock).mock.calls.length,
+      ).toBe(callCountBeforeUnmount);
+    });
+
+    consoleSpy.mockRestore();
+    jest.useRealTimers();
+  });
+
+  // 技術的観点（異常系）
+
+  // テスト14: 初回データ取得エラー時のポーリング継続
+  test('レビュー履歴一覧の初回読み込みエラー時の再試行', async () => {
+    // 最初はエラーを返し、2回目は成功するようにモックを設定
+    let callCount = 0;
+    window.electron.review.getHistories = jest.fn().mockImplementation(() => {
+      callCount++;
+      if (callCount === 1) {
+        return Promise.reject(new Error('Failed to fetch review histories'));
+      }
+      return Promise.resolve({ success: true, data: mockReviewHistories });
+    });
+
+    renderAtReviewPath();
+
+    // 初回の取得を確認(失敗)
+    await waitFor(() => {
+      expect(window.electron.review.getHistories).toHaveBeenCalledTimes(1);
+    });
+
+    // 再試行が呼ばれることを確認（ポーリング間隔が5000msなので、5.5秒以内に2回目が呼ばれる）
+    await waitFor(
+      () => {
+        expect(window.electron.review.getHistories).toHaveBeenCalledTimes(2);
+      },
+      { timeout: 8000 },
+    );
+
+    // レビュー履歴一覧が表示されることを確認
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+      expect(screen.getByText('Review History 2')).toBeInTheDocument();
+    });
+  }, 10000); // タイムアウトを10秒に設定
+
+  // テスト15: ポーリング中の再試行でデータ取得に成功
+  test('ポーリング中のレビュー履歴更新でエラーが発生した場合の処理', async () => {
+    // pushApi.subscribeのモックを設定
+    let subscribedCallback: ((channel: string) => void) | null = null;
+    window.electron.pushApi.subscribe = jest
+      .fn()
+      .mockImplementation(async (channel: string, callback: (channel: string) => void) => {
+        subscribedCallback = callback;
+        return () => {};
+      });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    renderAtReviewPath();
+
+    // 初回データ取得を待機
+    await waitFor(() => {
+      expect(screen.getByText('Review History 1')).toBeInTheDocument();
+    });
+
+    // レビュー履歴取得をエラーにする
+    window.electron.review.getHistories = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch review histories'));
+
+    // サーバプッシュイベントをトリガー
+    if (subscribedCallback) {
+      await act(async () => {
+        subscribedCallback!('review-history-updated');
+        await Promise.resolve();
+      });
+    }
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        'レビュー履歴の更新に失敗しました:',
+        expect.any(Error),
+      );
+    });
+
+    consoleSpy.mockRestore();
+  });
+});
diff --git a/src/__tests__/integration/SourceListModal.test.tsx b/src/__tests__/renderer/SourceListModal.test.tsx
similarity index 53%
rename from src/__tests__/integration/SourceListModal.test.tsx
rename to src/__tests__/renderer/SourceListModal.test.tsx
index 0f470914a..42d76b947 100644
--- a/src/__tests__/integration/SourceListModal.test.tsx
+++ b/src/__tests__/renderer/SourceListModal.test.tsx
@@ -12,9 +12,13 @@ import {
 import '@testing-library/jest-dom';
 
 import SourceListModal from '@/renderer/components/common/SourceListModal';
-import type { Source } from '@/db/schema';
+import type { Source } from '@/types';
 import { ProcessStatus } from '@/types';
-import { createMockElectronWithOptions } from '@/__tests__/test-utils/mockElectronHandler';
+import { createMockElectronWithOptions } from '@/__tests__/renderer/test-utils/mockElectronHandler';
+import { alertStore } from '@/renderer/stores/alertStore';
+
+// alertStore のスパイ
+const addAlertSpy = jest.spyOn(alertStore.getState(), 'addAlert');
 
 // テスト用のモックデータ
 const mockSources: Source[] = [
@@ -26,7 +30,7 @@ const mockSources: Source[] = [
     createdAt: '2025-05-01T12:00:00.000Z',
     updatedAt: '2025-05-01T12:00:00.000Z',
     status: 'completed' as ProcessStatus,
-    isEnabled: 1,
+    isEnabled: true,
     error: null,
   },
   {
@@ -37,7 +41,7 @@ const mockSources: Source[] = [
     createdAt: '2025-05-02T12:00:00.000Z',
     updatedAt: '2025-05-02T12:00:00.000Z',
     status: 'failed' as ProcessStatus,
-    isEnabled: 0,
+    isEnabled: true,
     error: 'Error processing file',
   },
   {
@@ -48,7 +52,7 @@ const mockSources: Source[] = [
     createdAt: '2025-05-03T12:00:00.000Z',
     updatedAt: '2025-05-03T12:00:00.000Z',
     status: 'processing' as ProcessStatus,
-    isEnabled: 1,
+    isEnabled: true,
     error: null,
   },
 ];
@@ -62,6 +66,9 @@ describe('SourceListModal Component', () => {
 
     // タイマーのモック
     jest.useFakeTimers();
+
+    // addAlert のスパイをクリア
+    addAlertSpy.mockClear();
   });
 
   // テスト後のクリーンアップ
@@ -77,7 +84,6 @@ describe('SourceListModal Component', () => {
     onClose: jest.fn(),
     onReloadSources: jest.fn(),
     onStatusUpdate: jest.fn(),
-    showSnackbar: jest.fn(),
   };
 
   // テスト1: 正常にソース一覧を表示できること
@@ -89,7 +95,6 @@ describe('SourceListModal Component', () => {
         onClose={defaultProps.onClose}
         onReloadSources={defaultProps.onReloadSources}
         onStatusUpdate={defaultProps.onStatusUpdate}
-        showSnackbar={defaultProps.showSnackbar}
       />,
     );
 
@@ -131,7 +136,7 @@ describe('SourceListModal Component', () => {
     expect(checkboxes[3]).not.toBeChecked(); // source3 (isEnabled: 1) completedでない場合はチェックされない
   });
 
-  // テスト2: ソースのリロードボタンが機能すること
+  // テスト2: 処理中のソースがある場合は、ステータスが処理中と更新されること
   test('処理中のソースがある場合は、ステータスが処理中と更新されること', async () => {
     render(
       <SourceListModal
@@ -140,7 +145,6 @@ describe('SourceListModal Component', () => {
         onClose={defaultProps.onClose}
         onReloadSources={defaultProps.onReloadSources}
         onStatusUpdate={defaultProps.onStatusUpdate}
-        showSnackbar={defaultProps.showSnackbar}
       />,
     );
 
@@ -170,7 +174,6 @@ describe('SourceListModal Component', () => {
         onClose={defaultProps.onClose}
         onReloadSources={defaultProps.onReloadSources}
         onStatusUpdate={defaultProps.onStatusUpdate}
-        showSnackbar={defaultProps.showSnackbar}
       />,
     );
 
@@ -216,7 +219,6 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
@@ -247,10 +249,12 @@ describe('SourceListModal Component', () => {
     expect(sourceCheckbox).toBeDisabled();
 
     // window.electron.source.updateSourceEnabledが呼ばれることを確認
-    expect(window.electron.source.updateSourceEnabled).toHaveBeenCalledWith(
-      mockSources[0].id,
-      !wasChecked,
-    );
+    await waitFor(() => {
+      expect(window.electron.source.updateSourceEnabled).toHaveBeenCalledWith({
+        sourceId: mockSources[0].id,
+        isEnabled: !wasChecked,
+      });
+    });
 
     // 処理完了後にチェックボックスが再度有効化されることを確認
     await waitFor(() => {
@@ -261,14 +265,9 @@ describe('SourceListModal Component', () => {
   // テスト13: チェックボックス更新時にupdateSourceEnabledが例外をスローする場合
   test('チェックボックス更新時にupdateSourceEnabledが例外をスローする場合', async () => {
     // エラーをスローするように設定
-    window.electron.source.updateSourceEnabled = jest
-      .fn()
-      .mockRejectedValue(new Error('API error occurred'));
-
-    // コンソールエラーをスパイ
-    const consoleSpy = jest
-      .spyOn(console, 'error')
-      .mockImplementation(() => {});
+    window.electron.source.updateSourceEnabled = jest.fn().mockRejectedValue(
+      new Error('API error occurred')
+    );
 
     // コンポーネントをレンダリング
     render(
@@ -278,13 +277,13 @@ describe('SourceListModal Component', () => {
         onClose={defaultProps.onClose}
         onReloadSources={defaultProps.onReloadSources}
         onStatusUpdate={defaultProps.onStatusUpdate}
-        showSnackbar={defaultProps.showSnackbar}
       />,
     );
 
     // 進める
-    act(() => {
+    await act(async () => {
       jest.advanceTimersByTime(5000);
+      await Promise.resolve();
     });
 
     // ソースデータが取得されるまで待機
@@ -299,41 +298,28 @@ describe('SourceListModal Component', () => {
 
     // チェックボックスをクリック
     const sourceCheckboxes = screen.getAllByRole('checkbox');
-    fireEvent.click(sourceCheckboxes[1]);
-
-    // エラーログが出力されることを確認
-    await waitFor(() => {
-      expect(consoleSpy).toHaveBeenCalledWith(
-        'ドキュメントの有効化/無効化に失敗しました:',
-        expect.any(Error),
-      );
+    await act(async () => {
+      fireEvent.click(sourceCheckboxes[1]);
+      await Promise.resolve();
     });
 
-    // チェックボックスが再度有効化されることを確認
+    // コンソールエラーが出力されることを確認（invokeApiのtry-catch）
+    // ただし、コンポーネント側のcatch blockでエラーがキャッチされるため、
+    // addAlertは呼ばれない（showAlert: trueだがthrowError: trueなのでエラーがthrowされる）
+
+    // チェックボックスが再度有効化され、状態が元に戻ることを確認
     await waitFor(() => {
       expect(sourceCheckboxes[1]).toBeEnabled();
+      expect(sourceCheckboxes[1]).toBeChecked(); // 元の状態に戻る
     });
-
-    consoleSpy.mockRestore();
   });
 
   // テスト14: 全選択チェックボックス更新時にupdateSourceEnabledが例外をスローする場合
   test('全選択チェックボックス更新時にupdateSourceEnabledが例外をスローする場合', async () => {
     // エラーをスローするように設定
-    window.electron.source.updateSourceEnabled = jest
-      .fn()
-      .mockRejectedValue(new Error('API error occurred'));
-
-    // コンソールエラーをスパイ
-    const consoleSpy = jest
-      .spyOn(console, 'error')
-      .mockImplementation(() => {});
-
-    // モックデータをセットアップ
-    window.electron.source.getSources = jest.fn().mockResolvedValue({
-      success: true,
-      sources: mockSources,
-    });
+    window.electron.source.updateSourceEnabled = jest.fn().mockRejectedValue(
+      new Error('API error occurred')
+    );
 
     // コンポーネントをレンダリング
     render(
@@ -343,13 +329,13 @@ describe('SourceListModal Component', () => {
         onClose={defaultProps.onClose}
         onReloadSources={defaultProps.onReloadSources}
         onStatusUpdate={defaultProps.onStatusUpdate}
-        showSnackbar={defaultProps.showSnackbar}
       />,
     );
 
     // 進める
-    act(() => {
+    await act(async () => {
       jest.advanceTimersByTime(5000);
+      await Promise.resolve();
     });
 
     // ソースデータが取得されるまで待機
@@ -364,26 +350,22 @@ describe('SourceListModal Component', () => {
 
     // 全選択チェックボックスをクリック
     const sourceCheckboxes = screen.getAllByRole('checkbox');
-    fireEvent.click(sourceCheckboxes[0]);
-
-    // エラーログが出力されることを確認（各ソースごとにエラーが発生）
-    await waitFor(() => {
-      expect(consoleSpy).toHaveBeenCalledWith(
-        'ドキュメントの有効化/無効化に失敗しました:',
-        expect.any(Error),
-      );
-      expect(consoleSpy).toHaveBeenCalledTimes(1);
+    await act(async () => {
+      fireEvent.click(sourceCheckboxes[0]);
+      await Promise.resolve();
     });
 
+    // コンソールエラーが出力されることを確認（invokeApiのtry-catch）
+    // ただし、コンポーネント側のcatch blockでエラーがキャッチされるため、
+    // addAlertは呼ばれない（showAlert: trueだがthrowError: trueなのでエラーがthrowされる）
+
     // チェックボックスが再度有効化されることを確認
     await waitFor(() => {
-      expect(sourceCheckboxes[0]).toBeEnabled(); // source1 (isEnabled: 1)
-      expect(sourceCheckboxes[1]).toBeEnabled(); // source1 (isEnabled: 1)
-      expect(sourceCheckboxes[2]).toBeDisabled(); // source2 (isEnabled: 0)
-      expect(sourceCheckboxes[3]).toBeDisabled(); // source3 (isEnabled: 1) completedでない場合はチェックされない
+      expect(sourceCheckboxes[0]).toBeEnabled(); // 全選択チェックボックス
+      expect(sourceCheckboxes[1]).toBeEnabled(); // source1 (completed)
+      expect(sourceCheckboxes[2]).toBeDisabled(); // source2 (failed)
+      expect(sourceCheckboxes[3]).toBeDisabled(); // source3 (processing)
     });
-
-    consoleSpy.mockRestore();
   });
 
   // テスト5: 全選択チェックボックスの動作検証
@@ -400,7 +382,6 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
@@ -433,26 +414,12 @@ describe('SourceListModal Component', () => {
     }
 
     // id:1が無効化される（statusがcompletedのみが対象となり、今回はid:1のみ有効から無効になる）
-    expect(window.electron.source.updateSourceEnabled).toHaveBeenCalledWith(
-      1,
-      false,
-    );
-    expect(window.electron.source.updateSourceEnabled).not.toHaveBeenCalledWith(
-      2,
-      true,
-    );
-    expect(window.electron.source.updateSourceEnabled).not.toHaveBeenCalledWith(
-      3,
-      true,
-    );
-    expect(window.electron.source.updateSourceEnabled).not.toHaveBeenCalledWith(
-      2,
-      false,
-    );
-    expect(window.electron.source.updateSourceEnabled).not.toHaveBeenCalledWith(
-      3,
-      false,
-    );
+    await waitFor(() => {
+      expect(window.electron.source.updateSourceEnabled).toHaveBeenCalledWith({
+        sourceId: 1,
+        isEnabled: false,
+      });
+    });
 
     // 処理完了後にチェックボックスが再度有効化されることを確認
     // チェックボックスが再度有効化されることを確認
@@ -473,7 +440,7 @@ describe('SourceListModal Component', () => {
     // 更新失敗のモックを設定
     window.electron.source.updateSourceEnabled = jest.fn().mockResolvedValue({
       success: false,
-      error: 'Update failed',
+      error: { message: 'Update failed', code: 'UPDATE_FAILED' },
     });
 
     // コンポーネントをレンダリング
@@ -484,13 +451,13 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
     // 進める
-    act(() => {
+    await act(async () => {
       jest.advanceTimersByTime(5000);
+      await Promise.resolve(); // マイクロタスクを処理
     });
 
     // ソースデータが取得されるまで待機
@@ -505,13 +472,18 @@ describe('SourceListModal Component', () => {
 
     // チェックボックスをクリック
     const checkboxes = screen.getAllByRole('checkbox');
-    fireEvent.click(checkboxes[1]);
+    await act(async () => {
+      fireEvent.click(checkboxes[1]);
+      await Promise.resolve(); // マイクロタスクを処理
+    });
 
-    // エラーメッセージが表示されることを確認
+    // エラーアラートが追加されることを確認
     await waitFor(() => {
-      expect(props.showSnackbar).toHaveBeenCalledWith(
-        `${mockSources[0].path}の有効化/無効化に失敗しました: Update failed`,
-        'error',
+      expect(addAlertSpy).toHaveBeenCalledWith(
+        expect.objectContaining({
+          severity: 'error',
+          message: 'Update failed',
+        })
       );
     });
 
@@ -530,7 +502,7 @@ describe('SourceListModal Component', () => {
     // 更新失敗のモックを設定
     window.electron.source.updateSourceEnabled = jest.fn().mockResolvedValue({
       success: false,
-      error: 'Update failed',
+      error: { message: 'Update failed', code: 'UPDATE_FAILED' },
     });
 
     // コンポーネントをレンダリング
@@ -541,13 +513,13 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
     // 進める
-    act(() => {
+    await act(async () => {
       jest.advanceTimersByTime(5000);
+      await Promise.resolve();
     });
 
     // ソースデータが取得されるまで待機
@@ -562,21 +534,19 @@ describe('SourceListModal Component', () => {
 
     // 全選択チェックボックスをクリック
     const checkboxes = screen.getAllByRole('checkbox');
-    fireEvent.click(checkboxes[0]);
+    await act(async () => {
+      fireEvent.click(checkboxes[0]);
+      await Promise.resolve();
+    });
 
-    // エラーメッセージが表示されることを確認
+    // エラーアラートが追加されることを確認
     await waitFor(() => {
-      expect(props.showSnackbar).toHaveBeenCalledWith(
-        `${mockSources[0].path}の有効化/無効化に失敗しました: Update failed`,
-        'error',
-      );
-      expect(props.showSnackbar).not.toHaveBeenCalledWith(
-        `${mockSources[1].path}の有効化/無効化に失敗しました: Update failed`,
-        'error',
-      );
-      expect(props.showSnackbar).not.toHaveBeenCalledWith(
-        `${mockSources[2].path}の有効化/無効化に失敗しました: Update failed`,
-        'error',
+      // 更新対象はcompletedステータスのid:1のみ
+      expect(addAlertSpy).toHaveBeenCalledWith(
+        expect.objectContaining({
+          severity: 'error',
+          message: 'Update failed',
+        })
       );
     });
 
@@ -599,7 +569,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-01T12:00:00.000Z',
         updatedAt: '2025-05-01T12:00:00.000Z',
         status: 'completed' as ProcessStatus,
-        isEnabled: 1,
+        isEnabled: true,
         error: null,
       },
       {
@@ -610,7 +580,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-02T12:00:00.000Z',
         updatedAt: '2025-05-02T12:00:00.000Z',
         status: 'failed' as ProcessStatus,
-        isEnabled: 0,
+        isEnabled: false,
         error: 'Error message',
       },
       {
@@ -621,7 +591,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-03T12:00:00.000Z',
         updatedAt: '2025-05-03T12:00:00.000Z',
         status: 'processing' as ProcessStatus,
-        isEnabled: 1,
+        isEnabled: true,
         error: null,
       },
       {
@@ -632,7 +602,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-04T12:00:00.000Z',
         updatedAt: '2025-05-04T12:00:00.000Z',
         status: 'idle',
-        isEnabled: 1,
+        isEnabled: true,
         error: null,
       },
       {
@@ -643,7 +613,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-05T12:00:00.000Z',
         updatedAt: '2025-05-05T12:00:00.000Z',
         status: 'unknown' as any,
-        isEnabled: 1,
+        isEnabled: true,
         error: null,
       },
     ];
@@ -651,7 +621,7 @@ describe('SourceListModal Component', () => {
     // モックデータをセットアップ
     window.electron.source.getSources = jest.fn().mockResolvedValue({
       success: true,
-      sources: allStatusSources,
+      data: allStatusSources,
     });
 
     const props = {
@@ -666,7 +636,6 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
@@ -716,9 +685,9 @@ describe('SourceListModal Component', () => {
       .mockImplementation(() => {});
 
     // 最初は成功、その後エラーを返すモック
-    window.electron.source.getSources = jest
-      .fn()
-      .mockRejectedValueOnce(new Error('Failed to fetch sources'));
+    window.electron.source.getSources = jest.fn().mockRejectedValueOnce(
+      new Error('Failed to fetch sources')
+    );
 
     // コンポーネントをレンダリング
     render(
@@ -728,7 +697,6 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
@@ -740,7 +708,7 @@ describe('SourceListModal Component', () => {
     // エラーログが出力されることを確認
     await waitFor(() => {
       expect(consoleSpy).toHaveBeenCalledWith(
-        'ドキュメントデータの取得に失敗しました:',
+        'ソース一覧の読み込みに失敗しました:',
         expect.any(Error),
       );
     });
@@ -762,7 +730,6 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
@@ -786,7 +753,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-01T12:00:00.000Z',
         updatedAt: '2025-05-01T12:00:00.000Z',
         status: 'completed',
-        isEnabled: 1,
+        isEnabled: true,
         error: null,
       },
       {
@@ -797,7 +764,7 @@ describe('SourceListModal Component', () => {
         createdAt: '2025-05-02T12:00:00.000Z',
         updatedAt: '2025-05-02T12:00:00.000Z',
         status: 'completed',
-        isEnabled: 0,
+        isEnabled: false,
         error: null,
       },
     ];
@@ -805,7 +772,7 @@ describe('SourceListModal Component', () => {
     // モックデータをセットアップ
     window.electron.source.getSources = jest.fn().mockResolvedValue({
       success: true,
-      sources: allCompletedSources,
+      data: allCompletedSources,
     });
 
     const props = {
@@ -820,7 +787,6 @@ describe('SourceListModal Component', () => {
         onClose={props.onClose}
         onReloadSources={props.onReloadSources}
         onStatusUpdate={props.onStatusUpdate}
-        showSnackbar={props.showSnackbar}
       />,
     );
 
@@ -846,4 +812,531 @@ describe('SourceListModal Component', () => {
       expect(props.onReloadSources).toHaveBeenCalled();
     });
   });
+
+  // テスト15: 初回データ取得がエラーの場合、ポーリングで初回データ取得を継続すること
+  test('初回データ取得がエラーの場合、ポーリングで初回データ取得を継続すること', async () => {
+    // 常にエラーを返すモック
+    window.electron.source.getSources = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch sources'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    render(
+      <SourceListModal
+        open={defaultProps.open}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(1);
+    });
+
+    // エラーログが出力されることを確認（SourceApiでのエラーログ）
+    expect(consoleSpy).toHaveBeenCalledWith(
+      'API通信に失敗しました:',
+      expect.any(Error),
+    );
+
+    // 5秒進める前に、マイクロタスクを処理してポーリングが設定されるのを待つ
+    await act(async () => {
+      // マイクロタスクを処理
+      await Promise.resolve();
+      // タイマーを進める
+      jest.advanceTimersByTime(5000);
+      // 再度マイクロタスクを処理
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに5秒進める
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 3回目の呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(3);
+    });
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト16: 初回データ取得が成功した場合は、ポーリングを解除すること
+  test('初回データ取得が成功した場合は、ポーリングを解除すること', async () => {
+    // 1回目はエラー、2回目以降は成功するモック
+    window.electron.source.getSources = jest
+      .fn()
+      .mockRejectedValueOnce(new Error('Failed to fetch sources'))
+      .mockResolvedValue({
+        success: true,
+        data: mockSources,
+      });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    render(
+      <SourceListModal
+        open={defaultProps.open}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回呼び出し（エラー）を待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(1);
+    });
+
+    // 5秒進める前にマイクロタスクを処理してポーリングを設定
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    // 2回目の呼び出し（成功）を待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(2);
+    });
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // 少し待ってから確認
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(2);
+    });
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト17: ファイル同期ボタンクリック時、処理終了イベントまでポーリングでデータを取得し続けること
+  test('ファイル同期ボタンクリック時、処理終了イベントまでポーリングでデータを取得し続けること', async () => {
+    // pushApi.subscribeをモック化して、購読関数を保存
+    let reloadFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'source-reload-finished') {
+          reloadFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    // コンポーネントをレンダリング
+    render(
+      <SourceListModal
+        open={defaultProps.open}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalled();
+    });
+
+    // 初回読み込み時の呼び出し回数を記録
+    const initialCallCount = (window.electron.source.getSources as jest.Mock)
+      .mock.calls.length;
+
+    // リロードボタンをクリック
+    const reloadButton = screen.getByText('ファイル同期');
+    await act(async () => {
+      fireEvent.click(reloadButton);
+      await Promise.resolve();
+    });
+
+    // pushApi.subscribeが呼ばれることを確認
+    await waitFor(() => {
+      expect(window.electron.pushApi.subscribe).toHaveBeenCalledWith(
+        'source-reload-finished',
+        expect.any(Function),
+      );
+    });
+
+    // onReloadSourcesが呼ばれることを確認
+    expect(defaultProps.onReloadSources).toHaveBeenCalled();
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(
+        (window.electron.source.getSources as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(initialCallCount);
+    });
+
+    const afterFirstPollCallCount = (
+      window.electron.source.getSources as jest.Mock
+    ).mock.calls.length;
+
+    // さらに5秒進める（ポーリング2回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(
+        (window.electron.source.getSources as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(afterFirstPollCallCount);
+    });
+
+    // reloadFinishedイベントを発火してポーリングを停止
+    await act(async () => {
+      if (reloadFinishedCallback) {
+        reloadFinishedCallback({ payload: { success: true } });
+      }
+      await Promise.resolve();
+    });
+
+    const afterEventCallCount = (window.electron.source.getSources as jest.Mock)
+      .mock.calls.length;
+
+    // さらに10秒進めてもそれ以上呼ばれないことを確認
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      // イベント発火後の最後のfetchSources呼び出し分（+1）を考慮
+      expect(
+        (window.electron.source.getSources as jest.Mock).mock.calls.length,
+      ).toBeLessThanOrEqual(afterEventCallCount + 1);
+    });
+  });
+
+  // テスト18: 処理終了イベント発行後、最後にデータ取得処理を実行すること
+  test('処理終了イベント発行後、最後にデータ取得処理を実行すること', async () => {
+    // pushApi.subscribeをモック化
+    let reloadFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'source-reload-finished') {
+          reloadFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    // コンポーネントをレンダリング
+    render(
+      <SourceListModal
+        open={defaultProps.open}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalled();
+    });
+
+    // リロードボタンをクリック
+    const reloadButton = screen.getByText('ファイル同期');
+    await act(async () => {
+      fireEvent.click(reloadButton);
+      await Promise.resolve();
+    });
+
+    // イベント発火前の呼び出し回数を記録
+    const beforeEventCallCount = (
+      window.electron.source.getSources as jest.Mock
+    ).mock.calls.length;
+
+    // reloadFinishedイベントを発火（成功）
+    await act(async () => {
+      if (reloadFinishedCallback) {
+        reloadFinishedCallback({ payload: { success: true } });
+      }
+      await Promise.resolve();
+    });
+
+    // イベント発火後にfetchSourcesが呼ばれることを確認
+    await waitFor(() => {
+      expect(
+        (window.electron.source.getSources as jest.Mock).mock.calls.length,
+      ).toBeGreaterThan(beforeEventCallCount);
+    });
+
+    // 成功アラートが表示されることを確認
+    await waitFor(() => {
+      expect(addAlertSpy).toHaveBeenCalledWith(
+        expect.objectContaining({
+          severity: 'success',
+          message: 'ドキュメントの同期が完了しました',
+        }),
+      );
+    });
+  });
+
+  // テスト19: 処理終了イベント（失敗）発行後の挙動確認
+  test('処理終了イベント（失敗）発行後の挙動確認', async () => {
+    // pushApi.subscribeをモック化
+    let reloadFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'source-reload-finished') {
+          reloadFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    // コンポーネントをレンダリング
+    render(
+      <SourceListModal
+        open={defaultProps.open}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    await act(async () => {
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalled();
+    });
+
+    // リロードボタンをクリック
+    const reloadButton = screen.getByText('ファイル同期');
+    await act(async () => {
+      fireEvent.click(reloadButton);
+      await Promise.resolve();
+    });
+
+    // reloadFinishedイベントを発火（失敗）
+    await act(async () => {
+      if (reloadFinishedCallback) {
+        reloadFinishedCallback({
+          payload: {
+            success: false,
+            error: 'Sync failed due to network error',
+          },
+        });
+      }
+      await Promise.resolve();
+    });
+
+    // エラーアラートが表示されることを確認
+    await waitFor(() => {
+      expect(addAlertSpy).toHaveBeenCalledWith(
+        expect.objectContaining({
+          severity: 'error',
+          message: 'ドキュメントの同期に失敗しました: Sync failed due to network error',
+        }),
+      );
+    });
+  });
+
+  // テスト20: ポーリング中のデータ取得でエラーが発生した場合、ポーリングは継続されること
+  test('ポーリング中のデータ取得でエラーが発生した場合、ポーリングは継続されること', async () => {
+    // pushApi.subscribeをモック化
+    let reloadFinishedCallback: ((event: any) => void) | null = null;
+    (window.electron.pushApi.subscribe as jest.Mock).mockImplementation(
+      (channel, callback) => {
+        if (channel === 'source-reload-finished') {
+          reloadFinishedCallback = callback;
+        }
+        return Promise.resolve(jest.fn()); // unsubscribe関数を返す
+      },
+    );
+
+    // 最初は成功、その後一度エラー、その後また成功するモック
+    window.electron.source.getSources = jest
+      .fn()
+      .mockResolvedValueOnce({
+        success: true,
+        data: mockSources,
+      })
+      .mockRejectedValueOnce(new Error('Network error'))
+      .mockResolvedValue({
+        success: true,
+        data: mockSources,
+      });
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    render(
+      <SourceListModal
+        open={defaultProps.open}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回データ読み込みを待機
+    act(() => {
+      jest.advanceTimersByTime(5000);
+    });
+
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(1);
+    });
+
+    // リロードボタンをクリック
+    const reloadButton = screen.getByText('ファイル同期');
+    await act(async () => {
+      fireEvent.click(reloadButton);
+      await Promise.resolve();
+    });
+
+    // 5秒進める（ポーリング1回目：エラー）
+    act(() => {
+      jest.advanceTimersByTime(5000);
+    });
+
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(2);
+    });
+
+    // エラーログが出力されることを確認
+    await waitFor(() => {
+      expect(consoleSpy).toHaveBeenCalledWith(
+        'ソース一覧のポーリング中にエラーが発生しました:',
+        expect.any(Error),
+      );
+    });
+
+    // さらに5秒進める（ポーリング2回目：成功）
+    act(() => {
+      jest.advanceTimersByTime(5000);
+    });
+
+    // ポーリングが継続していることを確認
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(3);
+    });
+
+    consoleSpy.mockRestore();
+  });
+
+  // テスト21: モーダルを閉じた際、ポーリングが停止すること
+  test('モーダルを閉じた際、ポーリングが停止すること', async () => {
+    // 常にエラーを返すモック（ポーリングが継続するようにする）
+    window.electron.source.getSources = jest
+      .fn()
+      .mockRejectedValue(new Error('Failed to fetch sources'));
+
+    // コンソールエラーをスパイ
+    const consoleSpy = jest
+      .spyOn(console, 'error')
+      .mockImplementation(() => {});
+
+    // コンポーネントをレンダリング
+    const { rerender } = render(
+      <SourceListModal
+        open={true}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    // 初回呼び出しを待機
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(1);
+    });
+
+    // 5秒進める（ポーリング1回目）
+    await act(async () => {
+      await Promise.resolve();
+      jest.advanceTimersByTime(5000);
+      await Promise.resolve();
+    });
+
+    await waitFor(() => {
+      expect(window.electron.source.getSources).toHaveBeenCalledTimes(2);
+    });
+
+    // モーダルを閉じる
+    rerender(
+      <SourceListModal
+        open={false}
+        processing={defaultProps.processing}
+        onClose={defaultProps.onClose}
+        onReloadSources={defaultProps.onReloadSources}
+        onStatusUpdate={defaultProps.onStatusUpdate}
+      />,
+    );
+
+    const callCountBeforeClose = (
+      window.electron.source.getSources as jest.Mock
+    ).mock.calls.length;
+
+    // さらに10秒進める
+    await act(async () => {
+      jest.advanceTimersByTime(10000);
+      await Promise.resolve();
+    });
+
+    // ポーリングが停止していることを確認（呼び出し回数が増えない）
+    await waitFor(() => {
+      expect(
+        (window.electron.source.getSources as jest.Mock).mock.calls.length,
+      ).toBe(callCountBeforeClose);
+    });
+
+    consoleSpy.mockRestore();
+  });
 });
diff --git a/src/__tests__/integration/chat.test.tsx b/src/__tests__/renderer/chatComponent.test.tsx
similarity index 89%
rename from src/__tests__/integration/chat.test.tsx
rename to src/__tests__/renderer/chatComponent.test.tsx
index 693850c53..80ed88aad 100644
--- a/src/__tests__/integration/chat.test.tsx
+++ b/src/__tests__/renderer/chatComponent.test.tsx
@@ -15,9 +15,10 @@ import {
 } from '@testing-library/react';
 import userEvent from '@testing-library/user-event';
 import '@testing-library/jest-dom';
-import type { ChatRoom, ChatMessage } from '@/types';
+import type { ChatRoom, ChatMessage, SettingsSavingState } from '@/types';
 import ChatArea from '@/renderer/components/chat/ChatArea';
-import { createMockElectronWithOptions } from '../test-utils/mockElectronHandler';
+import { createMockElectronWithOptions } from './test-utils/mockElectronHandler';
+import { useAgentStatusStore } from '@/renderer/stores/agentStatusStore';
 
 // File APIのモック
 global.URL.createObjectURL = jest.fn(
@@ -195,15 +196,17 @@ describe('ChatArea Component', () => {
   beforeEach(() => {
     window.electron = createMockElectronWithOptions({
       chatRooms: mockChatRooms,
+      chatMessages: mockChatMessages,
     });
 
-    // チャットメッセージの取得をモック
-    window.electron.chat.getMessages = jest
-      .fn()
-      .mockResolvedValue(mockChatMessages);
-
     // JSDOM上で scrollIntoView をダミー実装
     (window as any).HTMLElement.prototype.scrollIntoView = function () {};
+
+    // agentの起動状態を正常に設定
+    useAgentStatusStore.getState().setStatus({
+      state: 'done' as SettingsSavingState,
+      messages: [],
+    });
   });
 
   // テスト後のクリーンアップ
@@ -214,9 +217,10 @@ describe('ChatArea Component', () => {
 
   // テスト13: AIツール使用時のメッセージ表示が正しく機能すること
   test('AIツール使用時のメッセージ表示が正しく機能すること', async () => {
-    window.electron.chat.getMessages = jest
-      .fn()
-      .mockResolvedValue(mockToolMessages);
+    window.electron = createMockElectronWithOptions({
+      chatRooms: mockChatRooms,
+      chatMessages: mockToolMessages,
+    });
 
     const user = userEvent.setup();
     render(<ChatArea selectedRoomId="1" />);
@@ -380,6 +384,7 @@ describe('ChatArea Component', () => {
   // テスト5: ストリーミングレスポンスの処理が正しく機能すること
   // このテストは、ストリーミングレスポンスの処理を確認するためのものですが、
   // JSDOM環境でReadableStreamがサポートされていないため、実行不可
+  // テスト不可であることを残すため、コメントアウトをそのまま残す
   // whatwg-fetchを使用してReadableStreamをモック化してもuseChatのストリーミング処理が正しく動作しないため、コメントアウト
   // test('ストリーミングレスポンスの処理が正しく機能すること', async () => {
   //   let streamCallback: (data: any) => void = () => {};
@@ -436,31 +441,23 @@ describe('ChatArea Component', () => {
   //   });
   // }, 20000);
 
-  // テスト6:エージェント起動関連エラーの表示が正しいこと
-  test('エージェント起動関連エラーの表示が正しいこと', async () => {
-    window.electron = createMockElectronWithOptions({
-      chatRooms: mockChatRooms,
-      settingsStatus: {
-        state: 'error',
-        messages: [
-          {
-            id: '1',
-            type: 'error',
-            content: 'AIエージェントの起動に失敗しました',
-          },
-        ],
-      },
-    });
+  // テスト6:エージェント起動中の表示が正しいこと
+  test('エージェント起動中の表示が正しいこと', async () => {
+    render(<ChatArea selectedRoomId="6" />);
 
-    render(<ChatArea selectedRoomId="1" />);
+    // agentの起動状態を正常に設定
+    act(() => {
+      useAgentStatusStore.getState().setStatus({
+        state: 'saving' as SettingsSavingState,
+        messages: [],
+      });
+    });
 
-    // エラーメッセージが表示されることを確認
+    // メッセージ入力欄のプレースホルダーが起動中の表示になることを確認
     await waitFor(() => {
-      const alerts = screen.getAllByRole('alert');
-      const errorAlert = alerts.find((alert) =>
-        alert.textContent?.includes('AIエージェントの起動に失敗しました'),
-      );
-      expect(errorAlert).toBeInTheDocument();
+      expect(
+        screen.getByPlaceholderText('AIエージェント起動中'),
+      ).toBeInTheDocument();
     });
   });
 
@@ -517,6 +514,7 @@ describe('ChatArea Component', () => {
 
   // テスト8: ストリーミング中に停止ボタンが機能すること
   // ストリーミング処理が実施されないため停止ボタンも表示されない
+  // テスト不可であることを残すため、コメントアウトをそのまま残す
   // test('ストリーミング中に停止ボタンが機能すること', async () => {
   //   const user = userEvent.setup();
   //   render(<ChatArea selectedRoomId="1" />);
@@ -567,6 +565,7 @@ describe('ChatArea Component', () => {
     expect(window.electron.chat.sendMessage).not.toHaveBeenCalled();
 
     // fireEventでIME変換をシミュレートした場合、Enterキーを押してもIME変換が確定しないため、後続はコメントアウト
+    // テスト不可であることを残すため、コメントアウトをそのまま残す
 
     // // IME変換確定イベントをシミュレート
     // fireEvent.compositionEnd(input);
@@ -581,68 +580,6 @@ describe('ChatArea Component', () => {
     // );
   });
 
-  // テスト10: アラートメッセージの閉じるボタンが機能すること
-  test('アラートメッセージの閉じるボタンが機能すること', async () => {
-    const user = userEvent.setup();
-    window.electron = createMockElectronWithOptions({
-      chatRooms: mockChatRooms,
-      settingsStatus: {
-        state: 'error',
-        messages: [
-          {
-            id: '1',
-            type: 'error',
-            content: 'AIエージェントの起動に失敗しました',
-          },
-        ],
-      },
-    });
-
-    render(<ChatArea selectedRoomId="1" />);
-
-    // AIエージェントの起動失敗メッセージが表示されることを確認
-    const errorMessage = 'AIエージェントの起動に失敗しました';
-    await waitFor(() => {
-      expect(screen.getByText(errorMessage)).toBeInTheDocument();
-    });
-
-    // 閉じるボタンをクリック
-    const alerts = screen.getAllByRole('alert');
-    const targetAlert = alerts.find((alert) =>
-      alert.textContent?.includes(errorMessage),
-    );
-    expect(targetAlert).toBeInTheDocument();
-
-    const closeButton = within(targetAlert!).getByRole('button');
-    await act(async () => {
-      await user.click(closeButton);
-    });
-
-    // window.electron.settings.removeMessageが呼ばれることを確認
-    expect(window.electron.settings.removeMessage).toHaveBeenCalledWith('1');
-  });
-
-  // テスト11: エージェント初期化中の表示が正しいこと
-  test('エージェント初期化中の表示が正しいこと', async () => {
-    window.electron = createMockElectronWithOptions({
-      chatRooms: mockChatRooms,
-      settingsStatus: {
-        state: 'saving',
-      },
-    });
-
-    render(<ChatArea selectedRoomId="1" />);
-
-    // 入力欄のプレースホルダーが初期化中の表示になることを確認
-    await waitFor(() => {
-      expect(
-        screen.getByPlaceholderText('AIエージェント起動中'),
-      ).toBeInTheDocument();
-    });
-    const input = screen.getByPlaceholderText('AIエージェント起動中');
-    expect(input).toBeDisabled();
-  });
-
   // テスト12: メッセージ編集のキャンセルが正しく機能すること
   test('メッセージ編集のキャンセルが正しく機能すること', async () => {
     const user = userEvent.setup();
@@ -890,7 +827,7 @@ describe('ChatArea Component', () => {
 
     window.electron.chat.getMessages = jest
       .fn()
-      .mockResolvedValue(mockMultiImageMessages);
+      .mockResolvedValue({ success: true, data: mockMultiImageMessages });
 
     render(<ChatArea selectedRoomId="18" />);
 
@@ -927,7 +864,7 @@ describe('ChatArea Component', () => {
 
     window.electron.chat.getMessages = jest
       .fn()
-      .mockResolvedValue(mockImageMessage);
+      .mockResolvedValue({ success: true, data: mockImageMessage });
     const user = userEvent.setup();
     render(<ChatArea selectedRoomId="19" />);
 
diff --git a/src/__tests__/renderer/csvUtils.test.ts b/src/__tests__/renderer/csvUtils.test.ts
new file mode 100644
index 000000000..fabcb72ba
--- /dev/null
+++ b/src/__tests__/renderer/csvUtils.test.ts
@@ -0,0 +1,404 @@
+/**
+ * csvUtils.ts のテスト
+ */
+import { convertReviewResultsToCSV } from '@/renderer/lib/csvUtils';
+import type { ReviewChecklistResult, RevieHistory } from '@/types';
+
+describe('convertReviewResultsToCSV', () => {
+  describe('正常系', () => {
+    test('チェックリストのみの場合、正しくCSV形式に変換されること', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+          sourceEvaluation: {
+            evaluation: 'A',
+            comment: '良好です',
+          },
+        },
+        {
+          id: 2,
+          content: 'チェック項目2',
+          sourceEvaluation: {
+            evaluation: 'B',
+            comment: '改善が必要',
+          },
+        },
+      ];
+
+      const result = convertReviewResultsToCSV(checklistResults);
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(3); // ヘッダー + 2データ行
+
+      // ヘッダー行の確認
+      expect(lines[0]).toBe(
+        'チェックリスト,評定結果,レビュー結果,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID',
+      );
+
+      // 1行目のデータ確認
+      expect(lines[1]).toBe('チェック項目1,A,良好です,,,,,,,');
+
+      // 2行目のデータ確認
+      expect(lines[2]).toBe('チェック項目2,B,改善が必要,,,,,,,');
+    });
+
+    test('評定結果がない場合、評定結果とレビュー結果が空文字になること', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+        },
+      ];
+
+      const result = convertReviewResultsToCSV(checklistResults);
+
+      const lines = result.split('\n');
+      expect(lines[1]).toBe('チェック項目1,,,,,,,,,');
+    });
+
+    test('評定設定がある場合、各行に分散配置されること', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+          sourceEvaluation: {
+            evaluation: 'A',
+            comment: '良好です',
+          },
+        },
+        {
+          id: 2,
+          content: 'チェック項目2',
+        },
+      ];
+
+      const reviewHistory: RevieHistory = {
+        id: 'review-1',
+        title: 'テストレビュー',
+        targetDocumentName: 'test.pdf',
+        additionalInstructions: null,
+        commentFormat: null,
+        evaluationSettings: {
+          items: [
+            { label: 'A', description: '基準を満たす' },
+            { label: 'B', description: '一部改善が必要' },
+            { label: 'C', description: '基準未達' },
+          ],
+        },
+        processingStatus: 'idle',
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+      };
+
+      const result = convertReviewResultsToCSV(checklistResults, reviewHistory);
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(4); // ヘッダー + 3データ行（評定設定が3つあるため）
+
+      // 1行目: チェック項目1 + 評定設定A
+      expect(lines[1]).toBe('チェック項目1,A,良好です,A,基準を満たす,,,,,');
+
+      // 2行目: チェック項目2 + 評定設定B
+      expect(lines[2]).toBe('チェック項目2,,,B,一部改善が必要,,,,,');
+
+      // 3行目: 評定設定Cのみ
+      expect(lines[3]).toBe(',,,C,基準未達,,,,,');
+    });
+
+    test('追加指示、コメントフォーマット、API設定が1行目に配置されること', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+          sourceEvaluation: {
+            evaluation: 'A',
+            comment: '良好です',
+          },
+        },
+        {
+          id: 2,
+          content: 'チェック項目2',
+        },
+      ];
+
+      const reviewHistory: RevieHistory = {
+        id: 'review-1',
+        title: 'テストレビュー',
+        targetDocumentName: 'test.pdf',
+        additionalInstructions: '厳格にレビューすること',
+        commentFormat: '評価理由を記載', // 改行なし
+        evaluationSettings: {
+          items: [{ label: 'A', description: '基準を満たす' }],
+        },
+        processingStatus: 'idle',
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+      };
+
+      const apiSettings = {
+        url: 'http://localhost:11434/v1',
+        key: 'test-api-key',
+        model: 'llama3',
+      };
+
+      const result = convertReviewResultsToCSV(
+        checklistResults,
+        reviewHistory,
+        apiSettings,
+      );
+
+      // CSV全体を文字列として確認（改行を含む場合があるため）
+      expect(result).toContain('厳格にレビューすること');
+      expect(result).toContain('評価理由を記載');
+      expect(result).toContain('http://localhost:11434/v1');
+      expect(result).toContain('test-api-key');
+      expect(result).toContain('llama3');
+
+      // 2行目以降は設定が空であることを確認
+      const lines = result.split('\n');
+      const lastLine = lines[lines.length - 1];
+      expect(lastLine).toBe('チェック項目2,,,,,,,,,');
+    });
+
+    test('CSV特殊文字のエスケープが正しく行われること', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'テスト項目,カンマ含む',
+          sourceEvaluation: {
+            evaluation: 'A',
+            comment: 'カンマ,を含むコメント',
+          },
+        },
+        {
+          id: 2,
+          content: 'ダブルクォート"含む',
+          sourceEvaluation: {
+            evaluation: 'B',
+            comment: 'クォート"含むコメント',
+          },
+        },
+      ];
+
+      const result = convertReviewResultsToCSV(checklistResults);
+
+      // CSV全体で特殊文字のエスケープを確認
+      // カンマを含む場合はクォートで囲まれる
+      expect(result).toContain('"テスト項目,カンマ含む"');
+      expect(result).toContain('"カンマ,を含むコメント"');
+
+      // ダブルクォートを含む場合はエスケープされてクォートで囲まれる
+      expect(result).toContain('"ダブルクォート""含む"');
+      expect(result).toContain('"クォート""含むコメント"');
+    });
+
+    test('チェックリスト数より評定設定数が多い場合、評定設定のみの行が追加されること', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+        },
+      ];
+
+      const reviewHistory: RevieHistory = {
+        id: 'review-1',
+        title: 'テストレビュー',
+        targetDocumentName: 'test.pdf',
+        additionalInstructions: null,
+        commentFormat: null,
+        evaluationSettings: {
+          items: [
+            { label: 'A', description: '優秀' },
+            { label: 'B', description: '良好' },
+            { label: 'C', description: '要改善' },
+          ],
+        },
+        processingStatus: 'idle',
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+      };
+
+      const result = convertReviewResultsToCSV(checklistResults, reviewHistory);
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(4); // ヘッダー + 3データ行
+
+      // 1行目: チェック項目1 + 評定A
+      expect(lines[1]).toContain('チェック項目1');
+      expect(lines[1]).toContain('A');
+
+      // 2行目: 評定Bのみ
+      expect(lines[2]).toBe(',,,B,良好,,,,,');
+
+      // 3行目: 評定Cのみ
+      expect(lines[3]).toBe(',,,C,要改善,,,,,');
+    });
+  });
+
+  describe('異常系・エッジケース', () => {
+    test('空のチェックリストの場合、ヘッダーのみ返されること', () => {
+      const checklistResults: ReviewChecklistResult[] = [];
+
+      const result = convertReviewResultsToCSV(checklistResults);
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(1);
+      expect(lines[0]).toBe(
+        'チェックリスト,評定結果,レビュー結果,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID',
+      );
+    });
+
+    test('reviewHistoryがnullの場合、エラーにならないこと', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+        },
+      ];
+
+      const result = convertReviewResultsToCSV(checklistResults, null);
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(2);
+      expect(lines[1]).toBe('チェック項目1,,,,,,,,,');
+    });
+
+    test('apiSettingsがundefinedの場合、エラーにならないこと', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+        },
+      ];
+
+      const result = convertReviewResultsToCSV(
+        checklistResults,
+        undefined,
+        undefined,
+      );
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(2);
+      expect(lines[1]).toBe('チェック項目1,,,,,,,,,');
+    });
+
+    test('評定設定が空配列の場合、エラーにならないこと', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+        },
+      ];
+
+      const reviewHistory: RevieHistory = {
+        id: 'review-1',
+        title: 'テストレビュー',
+        targetDocumentName: 'test.pdf',
+        additionalInstructions: null,
+        commentFormat: null,
+        evaluationSettings: {
+          items: [],
+        },
+        processingStatus: 'idle',
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+      };
+
+      const result = convertReviewResultsToCSV(checklistResults, reviewHistory);
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(2);
+      expect(lines[1]).toBe('チェック項目1,,,,,,,,,');
+    });
+  });
+
+  describe('複雑なシナリオ', () => {
+    test('すべての機能を統合した複雑なケース', () => {
+      const checklistResults: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'セキュリティチェック,重要',
+          sourceEvaluation: {
+            evaluation: 'A',
+            comment: '問題なし',
+          },
+        },
+        {
+          id: 2,
+          content: 'パフォーマンステスト',
+          sourceEvaluation: {
+            evaluation: 'B',
+            comment: '改善の余地あり',
+          },
+        },
+        {
+          id: 3,
+          content: 'ドキュメント整備',
+        },
+      ];
+
+      const reviewHistory: RevieHistory = {
+        id: 'review-1',
+        title: 'テストレビュー',
+        targetDocumentName: 'test.pdf',
+        additionalInstructions: '厳格に実施すること',
+        commentFormat: '評価と詳細を記載',
+        evaluationSettings: {
+          items: [
+            { label: 'A', description: '優秀' },
+            { label: 'B', description: '良好' },
+            { label: 'C', description: '要改善' },
+            { label: '-', description: '対象外' },
+          ],
+        },
+        processingStatus: 'idle',
+        createdAt: '2025-05-01T12:00:00.000Z',
+        updatedAt: '2025-05-01T12:00:00.000Z',
+      };
+
+      const apiSettings = {
+        url: 'http://localhost:11434/v1',
+        key: 'test-key-123',
+        model: 'llama3',
+      };
+
+      const result = convertReviewResultsToCSV(
+        checklistResults,
+        reviewHistory,
+        apiSettings,
+      );
+
+      const lines = result.split('\n');
+      expect(lines).toHaveLength(5); // ヘッダー + 4データ行
+
+      // ヘッダー確認
+      expect(lines[0]).toBe(
+        'チェックリスト,評定結果,レビュー結果,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID',
+      );
+
+      // 1行目: すべての設定が含まれる
+      expect(lines[1]).toContain('セキュリティチェック');
+      expect(lines[1]).toContain('A');
+      expect(lines[1]).toContain('問題なし');
+      expect(lines[1]).toContain('優秀');
+      expect(lines[1]).toContain('厳格に実施すること');
+      expect(lines[1]).toContain('http://localhost:11434/v1');
+      expect(lines[1]).toContain('test-key-123');
+      expect(lines[1]).toContain('llama3');
+
+      // 2行目: 設定情報なし
+      expect(lines[2]).toContain('パフォーマンステスト');
+      expect(lines[2]).toContain('B');
+      expect(lines[2]).not.toContain('厳格に実施すること');
+
+      // 3行目: 評価なし
+      expect(lines[3]).toContain('ドキュメント整備');
+      expect(lines[3]).toContain('C');
+
+      // 4行目: チェックリストなし、評定のみ
+      expect(lines[4]).toContain('-');
+      expect(lines[4]).toContain('対象外');
+    });
+  });
+});
diff --git a/src/__tests__/renderer/reviewChat.test.tsx b/src/__tests__/renderer/reviewChat.test.tsx
new file mode 100644
index 000000000..59b198da4
--- /dev/null
+++ b/src/__tests__/renderer/reviewChat.test.tsx
@@ -0,0 +1,704 @@
+/**
+ * @jest-environment jsdom
+ */
+import React from 'react';
+import {
+  render,
+  screen,
+  waitFor,
+  fireEvent,
+  within,
+  cleanup,
+  act,
+} from '@testing-library/react';
+import userEvent from '@testing-library/user-event';
+import '@testing-library/jest-dom';
+import type { RevieHistory, ReviewChecklistResult } from '@/types';
+import ReviewArea from '@/renderer/components/review/ReviewArea';
+import { createMockElectronWithOptions } from './test-utils/mockElectronHandler';
+
+// JSDOMではReadableStreamがサポートされていないため、polyfillを使用
+const { ReadableStream } = require('web-streams-polyfill/ponyfill');
+global.ReadableStream = ReadableStream;
+
+// TextEncoderも同様にモック
+const { TextEncoder } = require('util');
+global.TextEncoder = TextEncoder;
+
+// PDF Utilsのモック
+jest.mock('@/renderer/lib/pdfUtils', () => ({
+  convertPdfBytesToImages: jest.fn().mockResolvedValue([]),
+  combineImages: jest.fn().mockResolvedValue(''),
+}));
+
+// CSV Utilsのモック
+jest.mock('@/renderer/lib/csvUtils', () => ({
+  convertReviewResultsToCSV: jest.fn().mockReturnValue(''),
+  downloadCSV: jest.fn(),
+  generateCSVFilename: jest.fn().mockReturnValue('review.csv'),
+}));
+
+// ライブラリのモック
+jest.mock('react-markdown', () => ({
+  __esModule: true,
+  default: ({ children }: { children: string }) => <div>{children}</div>,
+}));
+
+jest.mock('remark-gfm', () => ({
+  __esModule: true,
+  default: () => ({}),
+}));
+
+jest.mock('react-syntax-highlighter', () => ({
+  __esModule: true,
+  Prism: ({ children }: { children: string }) => <pre>{children}</pre>,
+}));
+
+// mermaidのモック
+jest.mock('mermaid', () => ({
+  __esModule: true,
+  default: {
+    initialize: jest.fn(),
+    render: jest.fn().mockResolvedValue({ svg: '<svg>test</svg>' }),
+  },
+}));
+
+// File APIのモック
+global.URL.createObjectURL = jest.fn(
+  (blob: any) => `mock-url-${blob.name || 'file'}`,
+);
+global.URL.revokeObjectURL = jest.fn();
+
+// テスト用のモックデータ
+const mockReviewHistory: RevieHistory = {
+  id: 'review-1',
+  title: 'テストレビュー',
+  targetDocumentName: 'test-document.pdf',
+  additionalInstructions: null,
+  commentFormat: null,
+  evaluationSettings: null,
+  processingStatus: 'idle',
+  createdAt: '2025-05-01T12:00:00.000Z',
+  updatedAt: '2025-05-01T12:00:00.000Z',
+};
+
+const mockChecklistResults: ReviewChecklistResult[] = [
+  {
+    id: 1,
+    content: '仕様書の記載内容が正確であること',
+    sourceEvaluation: {
+      evaluation: 'A',
+      comment: '記載は正確です',
+    },
+  },
+  {
+    id: 2,
+    content: '設計書の整合性が取れていること',
+    sourceEvaluation: {
+      evaluation: 'B',
+      comment: '一部整合性に問題があります',
+    },
+  },
+  {
+    id: 3,
+    content: 'テスト計画が十分であること',
+    sourceEvaluation: {
+      evaluation: 'C',
+      comment: 'テスト計画が不足しています',
+    },
+  },
+];
+
+describe('ReviewArea - レビュー質問機能', () => {
+  // テスト前のセットアップ
+  beforeEach(() => {
+    window.electron = createMockElectronWithOptions({
+      reviewHistory: mockReviewHistory,
+      reviewChecklistResults: mockChecklistResults,
+    });
+    // JSDOM上で scrollIntoView をダミー実装
+    (window as any).HTMLElement.prototype.scrollIntoView = function () {};
+  });
+
+  // テスト後のクリーンアップ
+  afterEach(() => {
+    jest.clearAllMocks();
+    cleanup();
+  });
+
+  // ヘルパー関数: チェックリスト読み込みと質問ボタン有効化を待機
+  const waitForChecklistAndEnableQuestionButton = async () => {
+    // チェックリスト結果が読み込まれるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('仕様書の記載内容が正確であること')).toBeInTheDocument();
+    });
+
+    // 質問ボタンが有効化されるまで待機
+    const questionButton = screen.getByRole('button', { name: /^質問$/ });
+    await waitFor(() => {
+      expect(questionButton).not.toBeDisabled();
+    });
+
+    return questionButton;
+  };
+
+  // ヘルパー関数: 質問ボタンをクリックしてチャットパネルを開く
+  const openChatPanel = async () => {
+    const questionButton = await waitForChecklistAndEnableQuestionButton();
+    await act(async () => {
+      fireEvent.click(questionButton);
+    });
+
+    // チャットパネルの入力フィールドが表示されるまで待機
+    await waitFor(() => {
+      expect(
+        screen.getByPlaceholderText(
+          '@でチェックリストを選択して質問してください',
+        ),
+      ).toBeInTheDocument();
+    });
+  };
+
+  // テスト1: 質問ボタンをクリックしてチャットパネルが開くこと
+  test('質問ボタンをクリックしてチャットパネルが開くこと', async () => {
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    // 入力フィールドが表示されることを確認
+    expect(
+      screen.getByPlaceholderText(
+        '@でチェックリストを選択して質問してください',
+      ),
+    ).toBeInTheDocument();
+
+    // 閉じるボタンが表示されることを確認
+    const closeIcon = screen.getByTestId('CloseIcon');
+    expect(closeIcon).toBeInTheDocument();
+  });
+
+  // テスト2: 閉じるボタンでパネルを閉じられること
+  test('閉じるボタンでパネルを閉じられること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    // CloseIconの親ボタンをクリック
+    const closeIcon = screen.getByTestId('CloseIcon');
+    const closeButton = closeIcon.closest('button');
+    expect(closeButton).toBeInTheDocument();
+    await user.click(closeButton!);
+
+    // パネルが閉じることを確認（入力フィールドが消える）
+    await waitFor(() => {
+      expect(
+        screen.queryByPlaceholderText(
+          '@でチェックリストを選択して質問してください',
+        ),
+      ).not.toBeInTheDocument();
+    });
+  });
+
+  // テスト3: レビュー履歴ID変更時にチャット内容が初期化されること
+  test('レビュー履歴ID変更時にチャット内容が初期化されること', async () => {
+    const user = userEvent.setup();
+    const { rerender } = render(
+      <ReviewArea selectedReviewHistoryId="review-1" />,
+    );
+
+    await openChatPanel();
+
+    // 入力フィールドにテキストを入力
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, 'テスト入力');
+    expect(input).toHaveValue('テスト入力');
+
+    // 異なるレビュー履歴IDでリレンダー
+    const mockReviewHistory2: RevieHistory = {
+      ...mockReviewHistory,
+      id: 'review-2',
+    };
+    window.electron = createMockElectronWithOptions({
+      reviewHistory: mockReviewHistory2,
+      reviewChecklistResults: mockChecklistResults,
+    });
+
+    rerender(<ReviewArea selectedReviewHistoryId="review-2" />);
+
+    // チャットパネルが閉じることを確認
+    await waitFor(() => {
+      expect(
+        screen.queryByPlaceholderText(
+          '@でチェックリストを選択して質問してください',
+        ),
+      ).not.toBeInTheDocument();
+    });
+  });
+
+  // テスト4: @入力時にチェックリスト選択メニューが表示されること
+  test('@入力時にチェックリスト選択メニューが表示されること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, '@');
+
+    // メニューが表示されることを確認
+    await waitFor(() => {
+      expect(screen.getByText('@仕様書の記載内容が正確であること')).toBeInTheDocument();
+      expect(screen.getByText('@設計書の整合性が取れていること')).toBeInTheDocument();
+      expect(screen.getByText('@テスト計画が十分であること')).toBeInTheDocument();
+    });
+  });
+
+  // テスト5: チェックリストを選択できること
+  test('チェックリストを選択できること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, '@');
+
+    // 最初のチェックリストを選択
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // 選択したチェックリストがChipとして表示されることを確認
+    await waitFor(() => {
+      // チェックリスト内容とChip両方に表示されるため、getAllByTextを使用
+      const chips = screen.getAllByText('仕様書の記載内容が正確であること');
+      expect(chips.length).toBeGreaterThan(1);
+    });
+
+    // @が削除されていることを確認
+    expect(input).toHaveValue('');
+  });
+
+  // テスト6: 選択したチェックリストを削除できること
+  test('選択したチェックリストを削除できること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, '@');
+
+    // チェックリストを選択
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // Chipが表示されることを確認（複数存在する可能性があるため、MuiChip-rootで絞り込む）
+    await waitFor(() => {
+      const chips = document.querySelectorAll('.MuiChip-root');
+      expect(chips.length).toBeGreaterThan(0);
+    });
+
+    // 最初のChipの削除アイコンをクリック
+    const chips = document.querySelectorAll('.MuiChip-root');
+    const deleteIcon = within(chips[0] as HTMLElement).getByTestId('CancelIcon');
+    await user.click(deleteIcon);
+
+    // Chipが削除されることを確認
+    await waitFor(() => {
+      const remainingChips = document.querySelectorAll('.MuiChip-root');
+      expect(remainingChips.length).toBe(0);
+    });
+  });
+
+  // テスト7: 検索文字列でチェックリストがフィルタリングされること
+  test('検索文字列でチェックリストがフィルタリングされること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, '@仕様書');
+
+    // フィルタリングされたチェックリストのみが表示されることを確認
+    await waitFor(() => {
+      expect(screen.getByText('@仕様書の記載内容が正確であること')).toBeInTheDocument();
+      expect(screen.queryByText('@設計書の整合性が取れていること')).not.toBeInTheDocument();
+      expect(screen.queryByText('@テスト計画が十分であること')).not.toBeInTheDocument();
+    });
+  });
+
+  // テスト8: 完全一致時にEnterで自動選択されること
+  test('完全一致時にEnterで自動選択されること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, '@仕様書の記載内容が正確であること');
+
+    // Enterキーを押す
+    await user.keyboard('{Enter}');
+
+    // チェックリストが自動選択されてChipが表示されることを確認
+    await waitFor(() => {
+      const chips = document.querySelectorAll('.MuiChip-root');
+      expect(chips.length).toBeGreaterThan(0);
+    });
+
+    // @と検索文字列が削除されていることを確認
+    expect(input).toHaveValue('');
+  });
+
+  // テスト9: チェックリスト未選択時に警告が表示されること
+  test('チェックリスト未選択時に警告が表示されること', async () => {
+    const user = userEvent.setup();
+    const mockAddAlert = jest.fn();
+    // useAlertStoreをモック
+    jest.spyOn(require('@/renderer/stores/alertStore'), 'useAlertStore').mockReturnValue(mockAddAlert);
+
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, 'テスト質問');
+
+    // 送信ボタンをクリック
+    const sendButton = screen.getByTestId('review-chat-send-button');
+    await user.click(sendButton);
+
+    // 警告メッセージが表示されることを確認
+    await waitFor(() => {
+      expect(mockAddAlert).toHaveBeenCalled();
+    });
+  });
+
+  // テスト10: 空メッセージは送信できないこと
+  test('空メッセージは送信できないこと', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // チェックリストを選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // 送信ボタンが無効化されていることを確認
+    const sendButton = screen.getByTestId('review-chat-send-button');
+    expect(sendButton).toBeDisabled();
+
+    // 空白のみの入力では送信できないことを確認
+    await user.type(input, '   ');
+    expect(sendButton).toBeDisabled();
+  });
+
+  // テスト11: チェックリスト選択後にメッセージ送信できること
+  test('チェックリスト選択後にメッセージ送信でき、IPC通信が正しく呼ばれること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // チェックリストを選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // メッセージを入力
+    await user.type(input, 'この項目について詳しく教えてください');
+
+    // 送信ボタンをクリック
+    const sendButton = screen.getByTestId('review-chat-send-button');
+    await user.click(sendButton);
+
+    // sendChatMessageが正しく呼ばれることを確認
+    await waitFor(() => {
+      expect(window.electron.review.sendChatMessage).toHaveBeenCalledWith({
+        reviewHistoryId: 'review-1',
+        checklistIds: [1],
+        question: '@仕様書の記載内容が正確であること\n\nこの項目について詳しく教えてください',
+      });
+    });
+  });
+
+  // テスト12: 送信後に入力欄がクリアされること
+  test('送信後に入力欄がクリアされ、IPC通信が正しく呼ばれること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // チェックリストを選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // メッセージを入力
+    await user.type(input, 'テスト質問');
+
+    // 送信ボタンをクリック
+    const sendButton = screen.getByTestId('review-chat-send-button');
+    await user.click(sendButton);
+
+    // 入力欄がクリアされることを確認
+    await waitFor(() => {
+      expect(input).toHaveValue('');
+    });
+
+    // IPC通信が正しく呼ばれることを確認
+    expect(window.electron.review.sendChatMessage).toHaveBeenCalledWith({
+      reviewHistoryId: 'review-1',
+      checklistIds: [1],
+      question: '@仕様書の記載内容が正確であること\n\nテスト質問',
+    });
+  });
+
+  // テスト13: ストリーミング中は入力が無効化されること
+  test('ストリーミング中は入力が無効化されること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // チェックリストを選択してメッセージを送信
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+    await user.type(input, 'テスト質問');
+
+    const sendButton = screen.getByTestId('review-chat-send-button');
+    await user.click(sendButton);
+
+    // ストリーミング中のプレースホルダーが表示されることを確認
+    await waitFor(() => {
+      const streamingInput = screen.queryByPlaceholderText('メッセージ送信中…');
+      if (streamingInput) {
+        expect(streamingInput).toBeDisabled();
+      }
+    });
+  });
+
+  // テスト14: 複数のチェックリストを選択してメッセージ送信できること
+  test('複数のチェックリストを選択してメッセージ送信でき、IPC通信が正しく呼ばれること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // 1つ目のチェックリストを選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // 2つ目のチェックリストを選択
+    await user.type(input, '@');
+    const secondOption = await screen.findByText('@設計書の整合性が取れていること');
+    await user.click(secondOption);
+
+    // 両方のChipが表示されることを確認
+    await waitFor(() => {
+      const chips = document.querySelectorAll('.MuiChip-root');
+      expect(chips.length).toBe(2);
+    });
+
+    // メッセージを入力して送信
+    await user.type(input, 'これらの項目について教えてください');
+    const sendButton = screen.getByTestId('review-chat-send-button');
+    await user.click(sendButton);
+
+    // 複数のチェックリストIDが送信されることを確認
+    await waitFor(() => {
+      expect(window.electron.review.sendChatMessage).toHaveBeenCalledWith({
+        reviewHistoryId: 'review-1',
+        checklistIds: [1, 2],
+        question: expect.stringContaining('これらの項目について教えてください'),
+      });
+    });
+  });
+
+  // テスト15: IME変換中のEnterキーが正しく処理されること
+  test('IME変換中のEnterキーが正しく処理されること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // チェックリストを選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // メッセージを入力
+    await user.type(input, 'テスト質問');
+
+    // IME変換開始イベントをシミュレート
+    fireEvent.compositionStart(input);
+
+    // IME変換中のEnterキーを押す
+    await user.keyboard('{Enter}');
+
+    // メッセージが送信されないことを確認
+    expect(window.electron.review.sendChatMessage).not.toHaveBeenCalled();
+  });
+
+  // テスト16: Shift+Enterで改行されること
+  test('Shift+Enterで改行されること', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // チェックリストを選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // メッセージを入力
+    await user.type(input, '1行目');
+
+    // Shift+Enterで改行
+    await user.keyboard('{Shift>}{Enter}{/Shift}');
+
+    // 改行が挿入されることを確認
+    expect(input).toHaveValue('1行目\n');
+
+    // メッセージが送信されないことを確認
+    expect(window.electron.review.sendChatMessage).not.toHaveBeenCalled();
+  });
+
+  // テスト17: 同じチェックリストを重複して選択できないこと
+  test('同じチェックリストを重複して選択できないこと', async () => {
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+
+    // 1回目の選択
+    await user.type(input, '@');
+    const firstOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(firstOption);
+
+    // 1つのChipが表示されることを確認
+    await waitFor(() => {
+      const chips = document.querySelectorAll('.MuiChip-root');
+      expect(chips.length).toBe(1);
+    });
+
+    // 2回目の選択（同じチェックリスト）
+    await user.type(input, '@');
+    const secondOption = await screen.findByText('@仕様書の記載内容が正確であること');
+    await user.click(secondOption);
+
+    // Chipは1つのままであることを確認（重複選択されない）
+    const chips = document.querySelectorAll('.MuiChip-root');
+    expect(chips.length).toBe(1);
+  });
+
+  // テスト18: コメントがないチェックリスト項目は質問パネルに表示されないこと
+  test('コメントがないチェックリスト項目は質問パネルに表示されないこと', async () => {
+    // コメントがない項目を含むモックデータ
+    const mockChecklistWithNoComment: ReviewChecklistResult[] = [
+      ...mockChecklistResults,
+      {
+        id: 4,
+        content: 'コメントなし項目',
+      },
+    ];
+
+    window.electron = createMockElectronWithOptions({
+      reviewHistory: mockReviewHistory,
+      reviewChecklistResults: mockChecklistWithNoComment,
+    });
+
+    const user = userEvent.setup();
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    await openChatPanel();
+
+    const input = screen.getByPlaceholderText(
+      '@でチェックリストを選択して質問してください',
+    );
+    await user.type(input, '@');
+
+    // コメント付きの項目は表示される
+    await waitFor(() => {
+      expect(screen.getByText('@仕様書の記載内容が正確であること')).toBeInTheDocument();
+      expect(screen.getByText('@設計書の整合性が取れていること')).toBeInTheDocument();
+      expect(screen.getByText('@テスト計画が十分であること')).toBeInTheDocument();
+    });
+
+    // コメントなし項目は表示されない
+    expect(screen.queryByText('@コメントなし項目')).not.toBeInTheDocument();
+  });
+
+  // テスト19: レビュー結果がない場合は質問ボタンが無効化されていること
+  test('レビュー結果がない場合は質問ボタンが無効化されていること', async () => {
+    window.electron = createMockElectronWithOptions({
+      reviewHistory: mockReviewHistory,
+      reviewChecklistResults: [],
+    });
+
+    render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+    // チェックリスト結果が読み込まれるまで待機
+    await waitFor(() => {
+      const questionButton = screen.queryByRole('button', { name: /^質問$/ });
+      expect(questionButton).toBeInTheDocument();
+    });
+
+    // 質問ボタンが無効化されていることを確認
+    const questionButton = screen.getByRole('button', { name: /^質問$/ });
+    expect(questionButton).toBeDisabled();
+  });
+});
diff --git a/src/__tests__/renderer/reviewChecklistExtract.test.tsx b/src/__tests__/renderer/reviewChecklistExtract.test.tsx
new file mode 100644
index 000000000..f07b07190
--- /dev/null
+++ b/src/__tests__/renderer/reviewChecklistExtract.test.tsx
@@ -0,0 +1,1994 @@
+/**
+ * @jest-environment jsdom
+ */
+import React from 'react';
+import {
+  render,
+  screen,
+  waitFor,
+  act,
+  fireEvent,
+  within,
+} from '@testing-library/react';
+import userEvent from '@testing-library/user-event';
+import '@testing-library/jest-dom';
+import type { RevieHistory, ReviewChecklistResult } from '@/types';
+import ReviewArea from '@/renderer/components/review/ReviewArea';
+import ReviewSourceModal from '@/renderer/components/review/ReviewSourceModal';
+import { createMockElectronWithOptions } from './test-utils/mockElectronHandler';
+import { alertStore, type AlertMessage } from '@/renderer/stores/alertStore';
+import * as pdfUtils from '@/renderer/lib/pdfUtils';
+
+// PDF Utilsのモック
+jest.mock('@/renderer/lib/pdfUtils', () => ({
+  convertPdfBytesToImages: jest.fn().mockResolvedValue([]),
+  combineImages: jest.fn().mockResolvedValue(''),
+}));
+
+// CSV Utilsのモック
+jest.mock('@/renderer/lib/csvUtils', () => ({
+  convertReviewResultsToCSV: jest.fn().mockReturnValue(''),
+  downloadCSV: jest.fn(),
+  generateCSVFilename: jest.fn().mockReturnValue('review.csv'),
+}));
+
+// ライブラリのモック
+jest.mock('react-markdown', () => ({
+  __esModule: true,
+  default: ({ children }: { children: string }) => <div>{children}</div>,
+}));
+
+jest.mock('remark-gfm', () => ({
+  __esModule: true,
+  default: () => ({}),
+}));
+
+jest.mock('react-syntax-highlighter', () => ({
+  __esModule: true,
+  Prism: ({ children }: { children: string }) => <pre>{children}</pre>,
+}));
+
+// mermaidのモック
+jest.mock('mermaid', () => ({
+  __esModule: true,
+  default: {
+    initialize: jest.fn(),
+    render: jest.fn().mockResolvedValue({ svg: '<svg>test</svg>' }),
+  },
+}));
+
+// File APIのモック
+global.URL.createObjectURL = jest.fn(
+  (blob: any) => `mock-url-${blob.name || 'file'}`,
+);
+global.URL.revokeObjectURL = jest.fn();
+
+// テスト用のモックデータ
+const mockReviewHistory: RevieHistory = {
+  id: 'review-1',
+  title: 'テストレビュー',
+  targetDocumentName: 'test-document.pdf',
+  additionalInstructions: null,
+  commentFormat: null,
+  evaluationSettings: null,
+  processingStatus: 'idle',
+  createdAt: '2025-05-01T12:00:00.000Z',
+  updatedAt: '2025-05-01T12:00:00.000Z',
+};
+
+const mockChecklistResults: ReviewChecklistResult[] = [
+  {
+    id: 1,
+    content: 'チェック項目1',
+  },
+  {
+    id: 2,
+    content: 'チェック項目2',
+    sourceEvaluation: {
+      evaluation: 'A',
+      comment: '問題ありません',
+    },
+  },
+];
+
+describe('ReviewArea - チェックリスト抽出', () => {
+  beforeEach(() => {
+    window.electron = createMockElectronWithOptions({
+      reviewHistory: mockReviewHistory,
+      reviewChecklistResults: [],
+    });
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe('チェックリスト抽出用モーダル', () => {
+    it('レビュー履歴未選択時はプレースホルダーメッセージが表示されること', async () => {
+      render(<ReviewArea selectedReviewHistoryId={null} />);
+
+      await waitFor(() => {
+        expect(
+          screen.getByText(
+            '新規レビューを開始または既存のレビュー履歴を選択してください',
+          ),
+        ).toBeInTheDocument();
+      });
+    });
+
+    it('チェックリスト抽出ボタンをクリックするとモーダルが開くこと', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      fireEvent.click(extractButton);
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+    });
+
+    it('モーダルでドキュメント種別を選択できること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // デフォルトでチェックリストドキュメント（AI抽出）が選択されていることを確認
+      const aiRadioLabel = screen.getByText(
+        'チェックリストドキュメント（AI抽出）',
+      );
+      expect(aiRadioLabel).toBeInTheDocument();
+
+      // ファイルインポートを選択
+      const csvRadioLabel = screen.getByText(
+        /チェックリストドキュメント（ファイルインポート）/,
+      );
+      await act(async () => {
+        fireEvent.click(csvRadioLabel);
+      });
+
+      // 一般ドキュメントを選択
+      const generalRadioLabel = screen.getByText(
+        /一般ドキュメント（新規チェックリスト作成）/,
+      );
+      await act(async () => {
+        fireEvent.click(generalRadioLabel);
+      });
+
+      // 選択が有効であることを確認
+      expect(generalRadioLabel).toBeInTheDocument();
+    });
+
+    it('一般ドキュメント選択時にチェックリスト作成要件の入力欄が表示されること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      fireEvent.click(extractButton);
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 一般ドキュメントを選択
+      const generalRadio = screen.getByRole('radio', {
+        name: /一般ドキュメント（新規チェックリスト作成）/,
+      });
+      fireEvent.click(generalRadio);
+
+      // チェックリスト作成要件の入力欄が表示されることを確認
+      await waitFor(() => {
+        expect(
+          screen.getByLabelText('チェックリスト作成要件'),
+        ).toBeInTheDocument();
+      });
+    });
+
+    it('ファイル選択ダイアログを開けること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/file1.pdf', '/test/file2.pdf'],
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      fireEvent.click(extractButton);
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      fireEvent.click(uploadButton);
+
+      await waitFor(() => {
+        expect(mockShowOpenDialog).toHaveBeenCalled();
+      });
+    });
+
+    it('CSV選択時にExcel/CSV以外のファイルでエラーが表示されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/file.pdf'],
+        },
+      });
+
+      const mockExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.review.extractChecklist = mockExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイルインポートを選択（テキストで検索）
+      const csvRadioLabel = screen.getByText(
+        /チェックリストドキュメント（ファイルインポート）/,
+      );
+      await act(async () => {
+        fireEvent.click(csvRadioLabel);
+      });
+
+      // ファイルをアップロード
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(mockShowOpenDialog).toHaveBeenCalled();
+      });
+
+      // PDFファイルが選択されている状態で送信
+      await waitFor(() => {
+        expect(screen.getByText('file.pdf')).toBeInTheDocument();
+      });
+
+      const submitButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+
+      // 送信ボタンが有効になるまで待機
+      await waitFor(() => {
+        expect(submitButton).not.toBeDisabled();
+      });
+
+      await act(async () => {
+        fireEvent.click(submitButton);
+      });
+
+      // エラーメッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasError = alerts.some((alert: AlertMessage) =>
+          alert.message.includes(
+            'ファイルインポートを選択している場合はExcelまたはCSVファイルのみ指定可能です',
+          ),
+        );
+        expect(hasError).toBe(true);
+      });
+
+      // バリデーションエラーのため、extractChecklistが呼ばれないことを確認
+      expect(mockExtractChecklist).not.toHaveBeenCalled();
+    });
+
+    it('モーダルをキャンセルできること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      fireEvent.click(extractButton);
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const cancelButton = screen.getByRole('button', { name: /キャンセル/ });
+      fireEvent.click(cancelButton);
+
+      await waitFor(() => {
+        expect(
+          screen.queryByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).not.toBeInTheDocument();
+      });
+    });
+
+    it('ファイル未選択時は送信ボタンが無効化されること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      fireEvent.click(extractButton);
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const submitButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      expect(submitButton).toBeDisabled();
+    });
+  });
+
+  describe('チェックリスト抽出処理', () => {
+    it('チェックリスト抽出中はローディングインジケータが表示されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        // LinearProgressが表示されることを確認
+        const progress = document.querySelector('.MuiLinearProgress-root');
+        expect(progress).toBeInTheDocument();
+      });
+    });
+
+    it('チェックリスト抽出中はボタンが「キャンセル」に変わること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('キャンセル')).toBeInTheDocument();
+      });
+    });
+
+    it('チェックリスト抽出中はレビュー実行ボタンが無効化されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        const reviewButton = screen.getByRole('button', {
+          name: /レビュー実行/,
+        });
+        expect(reviewButton).toBeDisabled();
+      });
+    });
+
+    it('キャンセルボタンをクリックするとabortExtractChecklistが呼ばれること', async () => {
+      const mockAbortExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+      window.electron.review.abortExtractChecklist = mockAbortExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('キャンセル')).toBeInTheDocument();
+      });
+
+      const cancelButton = screen.getByRole('button', { name: /キャンセル/ });
+      fireEvent.click(cancelButton);
+
+      await waitFor(() => {
+        expect(mockAbortExtractChecklist).toHaveBeenCalledWith('review-1');
+      });
+    });
+  });
+
+  describe('チェックリスト抽出結果表示', () => {
+    it('チェックリスト結果が正しく表示されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+        expect(screen.getByText('チェック項目2')).toBeInTheDocument();
+      });
+    });
+
+    it('レビュー結果が表示されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('A')).toBeInTheDocument();
+        expect(screen.getByText('問題ありません')).toBeInTheDocument();
+      });
+    });
+
+    it('初回データ取得失敗時にポーリングで再試行されること', async () => {
+      jest.useFakeTimers();
+      let callCount = 0;
+      const mockGetHistoryDetail = jest.fn(() => {
+        callCount++;
+        if (callCount === 1) {
+          return Promise.reject(new Error('Network error'));
+        }
+        return Promise.resolve({
+          success: true as const,
+          data: {
+            checklistResults: mockChecklistResults,
+            targetDocumentName: 'test-document.pdf',
+          },
+        });
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: mockReviewHistory,
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回実行を待つ
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail).toHaveBeenCalledTimes(1);
+
+      // ポーリングの5秒進める
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      // ポーリングで再試行されることを確認
+      expect(mockGetHistoryDetail).toHaveBeenCalledTimes(2);
+
+      // 最終的にデータが表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+      });
+
+      jest.useRealTimers();
+    }, 10000);
+  });
+
+  describe('チェックリスト抽出処理のポーリングとイベント受信', () => {
+    it('チェックリスト抽出中は5秒ごとにチェックリスト結果がポーリングされること', async () => {
+      jest.useFakeTimers();
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: mockChecklistResults,
+          targetDocumentName: 'test-document.pdf',
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      const initialCallCount = mockGetHistoryDetail.mock.calls.length;
+
+      // 5秒進めてポーリングが実行されることを確認
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(initialCallCount + 1);
+
+      // さらに5秒進めて2回目のポーリングが実行されることを確認
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(initialCallCount + 2);
+
+      jest.useRealTimers();
+    }, 10000);
+
+    it('チェックリスト抽出完了イベント（成功）を受信したら、結果を再取得してポーリングを停止すること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-extract-checklist-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: mockChecklistResults,
+          targetDocumentName: 'test-document.pdf',
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting', // 処理中の状態にする
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ（この時点でイベント購読が設定される）
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されていることを確認
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      const callCountBeforeEvent = mockGetHistoryDetail.mock.calls.length;
+
+      // 抽出完了イベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'success',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // fetchChecklistResultsが再度呼ばれることを確認
+      expect(mockGetHistoryDetail.mock.calls.length).toBeGreaterThan(
+        callCountBeforeEvent,
+      );
+
+      // 成功メッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasSuccess = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('チェックリストの抽出が完了しました'),
+        );
+        expect(hasSuccess).toBe(true);
+      });
+
+      // ポーリングが停止することを確認（タイマーを進めても追加で呼ばれない）
+      const callCountAfterEvent = mockGetHistoryDetail.mock.calls.length;
+      await act(async () => {
+        jest.advanceTimersByTime(10000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(callCountAfterEvent);
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('チェックリスト抽出完了イベント（失敗）を受信したら、エラーメッセージを表示してポーリングを停止すること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-extract-checklist-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: [],
+          targetDocumentName: null,
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting', // 処理中の状態にする
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されるまで待つ
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      // 抽出失敗イベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'failed',
+              error: 'テストエラー',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // エラーメッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasError = alerts.some(
+          (alert: AlertMessage) =>
+            alert.message.includes('チェックリストの抽出に失敗しました') &&
+            alert.message.includes('テストエラー'),
+        );
+        expect(hasError).toBe(true);
+      });
+
+      // ポーリングが停止することを確認
+      const callCountAfterEvent = mockGetHistoryDetail.mock.calls.length;
+      await act(async () => {
+        jest.advanceTimersByTime(10000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(callCountAfterEvent);
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('チェックリスト抽出完了イベント（キャンセル）を受信したら、キャンセルメッセージを表示してポーリングを停止すること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-extract-checklist-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: [],
+          targetDocumentName: null,
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting', // 処理中の状態にする
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されるまで待つ
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      // 抽出キャンセルイベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'canceled',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // キャンセルメッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasCancel = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('チェックリスト抽出をキャンセルしました'),
+        );
+        expect(hasCancel).toBe(true);
+      });
+
+      // ポーリングが停止することを確認
+      const callCountAfterEvent = mockGetHistoryDetail.mock.calls.length;
+      await act(async () => {
+        jest.advanceTimersByTime(10000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(callCountAfterEvent);
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('チェックリスト抽出のポーリング中にチェックリスト結果が更新されること', async () => {
+      jest.useFakeTimers();
+
+      let callCount = 0;
+      const mockGetHistoryDetail = jest.fn(() => {
+        callCount++;
+        if (callCount === 1) {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: [],
+              targetDocumentName: null,
+            },
+          });
+        } else if (callCount === 2) {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: [mockChecklistResults[0]],
+              targetDocumentName: 'test-document.pdf',
+            },
+          });
+        } else {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: mockChecklistResults,
+              targetDocumentName: 'test-document.pdf',
+            },
+          });
+        }
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'extracting',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ（空のチェックリスト）
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // 5秒進めて1回目のポーリング（1件のチェックリスト）
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+      });
+
+      // さらに5秒進めて2回目のポーリング（2件のチェックリスト）
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+        expect(screen.getByText('チェック項目2')).toBeInTheDocument();
+      });
+
+      jest.useRealTimers();
+    }, 15000);
+  });
+
+  describe('チェックリスト抽出のIPC呼び出し', () => {
+    it('チェックリストドキュメント（AI抽出）でextractChecklistが正しく呼ばれること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/checklist.pdf'],
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]), // PDF header
+      });
+
+      const mockExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.extractChecklist = mockExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      // チェックリスト抽出ボタンをクリック
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // デフォルトでチェックリストドキュメント（AI抽出）が選択されている
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('checklist.pdf')).toBeInTheDocument();
+      });
+
+      // 送信
+      const submitButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(submitButton);
+      });
+
+      // extractChecklistが正しい引数で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExtractChecklist).toHaveBeenCalledWith({
+          reviewHistoryId: 'review-1',
+          files: expect.arrayContaining([
+            expect.objectContaining({
+              name: 'checklist.pdf',
+              path: '/test/checklist.pdf',
+              processMode: 'text',
+            }),
+          ]),
+          documentType: 'checklist-ai',
+        });
+      });
+    });
+
+    it('チェックリストドキュメント（ファイルインポート）でextractChecklistが正しく呼ばれること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/checklist.xlsx'],
+        },
+      });
+
+      const mockExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.review.extractChecklist = mockExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      // チェックリスト抽出ボタンをクリック
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイルインポートを選択
+      const csvRadioLabel = screen.getByText(
+        /チェックリストドキュメント（ファイルインポート）/,
+      );
+      await act(async () => {
+        fireEvent.click(csvRadioLabel);
+      });
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('checklist.xlsx')).toBeInTheDocument();
+      });
+
+      // 送信
+      const submitButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(submitButton);
+      });
+
+      // extractChecklistが正しい引数で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExtractChecklist).toHaveBeenCalledWith({
+          reviewHistoryId: 'review-1',
+          files: expect.arrayContaining([
+            expect.objectContaining({
+              name: 'checklist.xlsx',
+              path: '/test/checklist.xlsx',
+            }),
+          ]),
+          documentType: 'checklist-csv',
+        });
+      });
+    });
+  });
+
+  describe('Officeファイル画像化機能', () => {
+    it('PDFファイルの処理モードをテキスト抽出から画像化に切り替えられること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/document.pdf'],
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]), // PDF signature
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイルをアップロード
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(mockShowOpenDialog).toHaveBeenCalled();
+        expect(screen.getByText('document.pdf')).toBeInTheDocument();
+      });
+
+      // デフォルトで「テキスト抽出」が選択されていることを確認
+      const textRadio = screen.getAllByRole('radio', {
+        name: /テキスト抽出/,
+      })[0];
+      expect(textRadio).toBeChecked();
+
+      // 「画像化」に切り替え
+      const imageRadioLabel = screen.getAllByText(/^画像$/)[0];
+      await act(async () => {
+        fireEvent.click(imageRadioLabel);
+      });
+
+      const imageRadio = screen.getAllByRole('radio', { name: /^画像$/ })[0];
+      expect(imageRadio).toBeChecked();
+    });
+
+    it('画像化モードをページ毎から統合画像に切り替えられること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/document.pdf'],
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイルをアップロード
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('document.pdf')).toBeInTheDocument();
+      });
+
+      // 「画像」に切り替え
+      const imageRadioLabel = screen.getAllByText(/^画像$/)[0];
+      await act(async () => {
+        fireEvent.click(imageRadioLabel);
+      });
+
+      // デフォルトで「ページ別画像」が選択されていることを確認
+      await waitFor(() => {
+        const pagesRadio = screen.getAllByRole('radio', {
+          name: /ページ別画像/,
+        })[0];
+        expect(pagesRadio).toBeChecked();
+      });
+
+      // 「統合画像」に切り替え
+      const mergedRadioLabel = screen.getAllByText(/^統合画像$/)[0];
+      await act(async () => {
+        fireEvent.click(mergedRadioLabel);
+      });
+
+      const mergedRadio = screen.getAllByRole('radio', {
+        name: /^統合画像$/,
+      })[0];
+      expect(mergedRadio).toBeChecked();
+    });
+
+    it('一括設定で全ファイルの処理モードを画像化（ページ毎）に変更できること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/document1.pdf', '/test/document2.pdf'],
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイルをアップロード
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('document1.pdf')).toBeInTheDocument();
+        expect(screen.getByText('document2.pdf')).toBeInTheDocument();
+      });
+
+      // 一括設定セクションで「画像化（ページ毎）」を選択
+      const bulkImagePagesRadio = screen.getAllByRole('radio', {
+        name: /画像化（ページ毎）/,
+      })[0]; // 一括設定の方
+      await act(async () => {
+        fireEvent.click(bulkImagePagesRadio);
+      });
+
+      // 「適用」ボタンをクリック
+      const applyButton = screen.getByRole('button', { name: /適用/ });
+      await act(async () => {
+        fireEvent.click(applyButton);
+      });
+
+      // 全ファイルの処理モードが「画像」、画像化モードが「ページ別画像」に変更されたことを確認
+      const imageRadios = screen.getAllByRole('radio', { name: /^画像$/ });
+      imageRadios.forEach((radio) => {
+        // 一括設定のラジオボタン以外をチェック
+        if (radio !== bulkImagePagesRadio) {
+          expect(radio).toBeChecked();
+        }
+      });
+      // ページ別画像のラジオボタンが選択されていることも確認
+      await waitFor(() => {
+        const pagesRadios = screen.getAllByRole('radio', {
+          name: /ページ別画像/,
+        });
+        // 一括設定以外のpagesRadiosがチェックされていること
+        const filePagesRadios = pagesRadios.filter(
+          (r) => r !== bulkImagePagesRadio,
+        );
+        filePagesRadios.forEach((radio) => {
+          expect(radio).toBeChecked();
+        });
+      });
+    });
+
+    it('一括設定で全ファイルの処理モードを画像化（統合）に変更できること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/document1.pdf', '/test/document2.pdf'],
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイルをアップロード
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('document1.pdf')).toBeInTheDocument();
+        expect(screen.getByText('document2.pdf')).toBeInTheDocument();
+      });
+
+      // 一括設定セクションで「画像化（統合）」を選択
+      const bulkImageMergedRadio = screen.getAllByRole('radio', {
+        name: /画像化（統合）/,
+      })[0]; // 一括設定の方
+      await act(async () => {
+        fireEvent.click(bulkImageMergedRadio);
+      });
+
+      // 「適用」ボタンをクリック
+      const applyButton = screen.getByRole('button', { name: /適用/ });
+      await act(async () => {
+        fireEvent.click(applyButton);
+      });
+
+      // 全ファイルの処理モードが「画像」、画像モードが「統合画像」に変更されたことを確認
+      const imageRadios = screen.getAllByRole('radio', { name: /^画像$/ });
+      imageRadios.forEach((radio) => {
+        if (radio !== bulkImageMergedRadio) {
+          expect(radio).toBeChecked();
+        }
+      });
+
+      // 統合画像のラジオボタンが選択されていることも確認
+      await waitFor(() => {
+        const mergedRadios = screen.getAllByRole('radio', { name: /統合画像/ });
+        // 一括設定以外のmergedRadiosがチェックされていること
+        const fileMergedRadios = mergedRadios.filter(
+          (r) => r !== bulkImageMergedRadio,
+        );
+        fileMergedRadios.forEach((radio) => {
+          expect(radio).toBeChecked();
+        });
+      });
+    });
+
+    it('Officeファイルを画像化する際にOffice→PDF変換が実行されること', async () => {
+      // PDF→画像変換のモックを準備（jest.spyOnを使用）
+      const mockConvertPdfBytesToImages = jest
+        .spyOn(pdfUtils, 'convertPdfBytesToImages')
+        .mockResolvedValue([
+          'data:image/png;base64,mock-image-1',
+          'data:image/png;base64,mock-image-2',
+        ]);
+
+      // Office→PDF変換のモックを準備
+      const mockConvertOfficeToPdf = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]), // PDF header
+      });
+
+      // showOpenDialogのモック
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.xlsx'],
+          canceled: false,
+        },
+      });
+
+      // extractChecklistのモック
+      const mockExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.convertOfficeToPdf = mockConvertOfficeToPdf;
+      window.electron.review.extractChecklist = mockExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // レビュー履歴が読み込まれることを確認
+      await waitFor(() => {
+        expect(screen.getByText('チェックリスト抽出')).toBeInTheDocument();
+      });
+
+      // チェックリスト抽出ボタンをクリック
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(extractButton);
+      });
+
+      // モーダルが開いたことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 一般ドキュメントのラジオボタンを選択
+      const generalRadio = screen.getByRole('radio', {
+        name: /一般ドキュメント（新規チェックリスト作成）/,
+      });
+      await act(async () => {
+        fireEvent.click(generalRadio);
+      });
+
+      // チェックリスト作成要件の入力欄が表示されることを確認
+      await waitFor(() => {
+        expect(
+          screen.getByLabelText('チェックリスト作成要件'),
+        ).toBeInTheDocument();
+      });
+
+      // ファイル選択ボタンをクリック
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      // ファイルが追加されたことを確認
+      await waitFor(() => {
+        expect(screen.getByText('test.xlsx')).toBeInTheDocument();
+      });
+
+      // 画像モードに切り替え
+      const imageRadioLabel = screen.getAllByText(/^画像$/)[0];
+      await act(async () => {
+        fireEvent.click(imageRadioLabel);
+      });
+
+      // チェックリスト作成要件を入力
+      const requirementInput = screen.getByLabelText('チェックリスト作成要件')
+      fireEvent.change(requirementInput, { target: { value: 'テスト要件' } });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/,
+      });
+      await act(async () => {
+        fireEvent.click(submitButton);
+      });
+
+      // Office→PDF変換が呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertOfficeToPdf).toHaveBeenCalled();
+      });
+
+      // PDF→画像変換も呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertPdfBytesToImages).toHaveBeenCalled();
+      });
+
+      // extractChecklistが正しい引数で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExtractChecklist).toHaveBeenCalledWith({
+          reviewHistoryId: 'review-1',
+          files: expect.arrayContaining([
+            expect.objectContaining({
+              name: 'test.xlsx',
+              path: '/path/to/test.xlsx',
+              processMode: 'image',
+              imageMode: 'pages',
+              imageData: [
+                'data:image/png;base64,mock-image-1',
+                'data:image/png;base64,mock-image-2',
+              ],
+            }),
+          ]),
+          documentType: 'general',
+          checklistRequirements: 'テスト要件',
+        });
+      });
+
+      // モックをリストア
+      mockConvertPdfBytesToImages.mockRestore();
+    });
+
+    it('PDFファイルをページ毎画像化する際にconvertPdfBytesToImagesが呼ばれること', async () => {
+      // PDF→画像変換のモックを準備（jest.spyOnを使用）
+      const mockConvertPdfBytesToImages = jest
+        .spyOn(pdfUtils, 'convertPdfBytesToImages')
+        .mockResolvedValue([
+          'data:image/png;base64,mock-image-1',
+          'data:image/png;base64,mock-image-2',
+        ]);
+
+      // PDFファイル読み込みのモックを準備
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]), // PDF header
+      });
+
+      // showOpenDialogのモック
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      // extractChecklistのモック
+      const mockExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.extractChecklist = mockExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト抽出ボタンをクリック
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/i,
+      });
+      await userEvent.click(extractButton);
+
+      // モーダルが開いたことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 一般ドキュメントを選択
+      const generalRadio = screen.getByRole('radio', {
+        name: /一般ドキュメント（新規チェックリスト作成）/,
+      });
+      await act(async () => {
+        fireEvent.click(generalRadio);
+      });
+
+      // ファイル選択ボタンをクリック
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      // ファイルが追加されたことを確認
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // 画像化モード（ページ毎）に切り替え
+      const imageRadioLabel = screen.getByText(/^画像$/);
+      await userEvent.click(imageRadioLabel);
+
+      // ページ別がデフォルトで選択されていることを確認
+      const pagesRadio = screen.getByLabelText(/ページ別画像/);
+      expect(pagesRadio).toBeChecked();
+
+      // チェックリスト作成要件を入力
+      const requirementInput = screen.getByLabelText('チェックリスト作成要件');
+      await userEvent.type(requirementInput, 'テスト要件');
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', { name: /チェックリスト抽出/i });
+      await userEvent.click(submitButton);
+
+      // PDF読み込みが呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockReadFile).toHaveBeenCalled();
+      });
+
+      // PDF→画像変換が呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertPdfBytesToImages).toHaveBeenCalledWith(
+          expect.any(Uint8Array),
+          { scale: 2.0 },
+        );
+      });
+
+      // extractChecklistが正しい引数で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExtractChecklist).toHaveBeenCalledWith({
+          reviewHistoryId: 'review-1',
+          files: expect.arrayContaining([
+            expect.objectContaining({
+              name: 'test.pdf',
+              path: '/path/to/test.pdf',
+              processMode: 'image',
+              imageMode: 'pages',
+              imageData: [
+                'data:image/png;base64,mock-image-1',
+                'data:image/png;base64,mock-image-2',
+              ],
+            }),
+          ]),
+          documentType: 'general',
+          checklistRequirements: 'テスト要件',
+        });
+      });
+
+      // モックをリストア
+      mockConvertPdfBytesToImages.mockRestore();
+    });
+
+    it('PDFファイルを統合画像化する際にconvertPdfBytesToImagesとcombineImagesが呼ばれること', async () => {
+      // PDF→画像変換のモックを準備（jest.spyOnを使用）
+      const mockConvertPdfBytesToImages = jest
+        .spyOn(pdfUtils, 'convertPdfBytesToImages')
+        .mockResolvedValue([
+          'data:image/png;base64,mock-image-1',
+          'data:image/png;base64,mock-image-2',
+        ]);
+
+      // 画像統合のモックを準備（jest.spyOnを使用）
+      const mockCombineImages = jest
+        .spyOn(pdfUtils, 'combineImages')
+        .mockResolvedValue('data:image/png;base64,mock-combined-image');
+
+      // PDFファイル読み込みのモックを準備
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]), // PDF header
+      });
+
+      // showOpenDialogのモック
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      // extractChecklistのモック
+      const mockExtractChecklist = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.extractChecklist = mockExtractChecklist;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト抽出ボタンをクリック
+      const extractButton = screen.getByRole('button', {
+        name: /チェックリスト抽出/i,
+      });
+      await userEvent.click(extractButton);
+
+      // モーダルが開いたことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('チェックリスト抽出対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 一般ドキュメントを選択
+      const generalRadio = screen.getByRole('radio', {
+        name: /一般ドキュメント（新規チェックリスト作成）/,
+      });
+      await act(async () => {
+        fireEvent.click(generalRadio);
+      });
+
+      // ファイル選択ボタンをクリック
+      const fileSelectButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/i,
+      });
+      await userEvent.click(fileSelectButton);
+
+      // ファイルが追加されたことを確認
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // 画像モード（統合）に切り替え
+      const imageRadioLabel = screen.getByText(/^画像$/);
+      await userEvent.click(imageRadioLabel);
+
+      // 統合画像モードに切り替え
+      const mergedRadio = screen.getByLabelText(/統合画像/);
+      await userEvent.click(mergedRadio);
+
+      // チェックリスト作成要件を入力
+      const requirementInput = screen.getByLabelText('チェックリスト作成要件');
+      await userEvent.type(requirementInput, 'テスト要件');
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', { name: /チェックリスト抽出/i });
+      await userEvent.click(submitButton);
+
+      // PDF読み込みが呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockReadFile).toHaveBeenCalled();
+      });
+
+      // PDF→画像変換が呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertPdfBytesToImages).toHaveBeenCalledWith(
+          expect.any(Uint8Array),
+          { scale: 2.0 },
+        );
+      });
+
+      // combineImagesも呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockCombineImages).toHaveBeenCalledWith([
+          'data:image/png;base64,mock-image-1',
+          'data:image/png;base64,mock-image-2',
+        ]);
+      });
+
+      // extractChecklistが正しい引数で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExtractChecklist).toHaveBeenCalledWith({
+          reviewHistoryId: 'review-1',
+          files: expect.arrayContaining([
+            expect.objectContaining({
+              name: 'test.pdf',
+              path: '/path/to/test.pdf',
+              processMode: 'image',
+              imageMode: 'merged',
+              imageData: ['data:image/png;base64,mock-combined-image'],
+            }),
+          ]),
+          documentType: 'general',
+          checklistRequirements: 'テスト要件',
+        });
+      });
+
+      // モックをリストア
+      mockConvertPdfBytesToImages.mockRestore();
+      mockCombineImages.mockRestore();
+    });
+  });
+});
diff --git a/src/__tests__/renderer/reviewExecute.test.tsx b/src/__tests__/renderer/reviewExecute.test.tsx
new file mode 100644
index 000000000..d76f6934d
--- /dev/null
+++ b/src/__tests__/renderer/reviewExecute.test.tsx
@@ -0,0 +1,1998 @@
+/**
+ * @jest-environment jsdom
+ */
+import React from 'react';
+import {
+  render,
+  screen,
+  waitFor,
+  act,
+  fireEvent,
+  within,
+} from '@testing-library/react';
+import userEvent from '@testing-library/user-event';
+import '@testing-library/jest-dom';
+import type { RevieHistory, ReviewChecklistResult } from '@/types';
+import ReviewArea from '@/renderer/components/review/ReviewArea';
+import { createMockElectronWithOptions } from './test-utils/mockElectronHandler';
+import { alertStore, type AlertMessage } from '@/renderer/stores/alertStore';
+import * as pdfUtils from '@/renderer/lib/pdfUtils';
+
+// PDF Utilsのモック
+jest.mock('@/renderer/lib/pdfUtils', () => ({
+  convertPdfBytesToImages: jest.fn().mockResolvedValue([]),
+  combineImages: jest.fn().mockResolvedValue(''),
+}));
+
+// CSV Utilsのモック
+jest.mock('@/renderer/lib/csvUtils', () => ({
+  convertReviewResultsToCSV: jest.fn().mockReturnValue(''),
+  downloadCSV: jest.fn(),
+  generateCSVFilename: jest.fn().mockReturnValue('review.csv'),
+}));
+
+// ライブラリのモック
+jest.mock('react-markdown', () => ({
+  __esModule: true,
+  default: ({ children }: { children: string }) => <div>{children}</div>,
+}));
+
+jest.mock('remark-gfm', () => ({
+  __esModule: true,
+  default: () => ({}),
+}));
+
+jest.mock('react-syntax-highlighter', () => ({
+  __esModule: true,
+  Prism: ({ children }: { children: string }) => <pre>{children}</pre>,
+}));
+
+// mermaidのモック
+jest.mock('mermaid', () => ({
+  __esModule: true,
+  default: {
+    initialize: jest.fn(),
+    render: jest.fn().mockResolvedValue({ svg: '<svg>test</svg>' }),
+  },
+}));
+
+// File APIのモック
+global.URL.createObjectURL = jest.fn(
+  (blob: any) => `mock-url-${blob.name || 'file'}`,
+);
+global.URL.revokeObjectURL = jest.fn();
+
+// テスト用のモックデータ
+const mockReviewHistory: RevieHistory = {
+  id: 'review-1',
+  title: 'テストレビュー',
+  targetDocumentName: 'test-document.pdf',
+  additionalInstructions: null,
+  commentFormat: null,
+  evaluationSettings: null,
+  processingStatus: 'idle',
+  createdAt: '2025-05-01T12:00:00.000Z',
+  updatedAt: '2025-05-01T12:00:00.000Z',
+};
+
+const mockChecklistResults: ReviewChecklistResult[] = [
+  {
+    id: 1,
+    content: 'チェック項目1',
+  },
+  {
+    id: 2,
+    content: 'チェック項目2',
+  },
+];
+
+describe('ReviewArea - レビュー実行', () => {
+  beforeEach(() => {
+    window.electron = createMockElectronWithOptions({
+      reviewHistory: mockReviewHistory,
+      reviewChecklistResults: mockChecklistResults,
+    });
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  // ヘルパー関数: チェックリスト読み込みとボタン有効化を待機
+  const waitForChecklistAndEnableButton = async (buttonName: RegExp) => {
+    // チェックリスト結果が読み込まれるまで待機
+    await waitFor(() => {
+      expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+    });
+
+    // ボタンが有効化されるまで待機
+    const button = screen.getByRole('button', { name: buttonName });
+    await waitFor(() => {
+      expect(button).not.toBeDisabled();
+    });
+
+    return button;
+  };
+
+  describe('レビュー実行用モーダル', () => {
+    it('レビュー実行ボタンをクリックするとモーダルが開くこと', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(
+        /^レビュー実行$/,
+      );
+
+      // ボタンをクリック
+      await act(async () => {
+        fireEvent.click(reviewButton);
+      });
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+    });
+
+    it('ファイル選択ダイアログを開けること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true,
+        data: {
+          canceled: false,
+          filePaths: ['/test/file1.pdf', '/test/file2.pdf'],
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      });
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/);
+
+      // ボタンをクリック
+      fireEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      fireEvent.click(uploadButton);
+
+      await waitFor(() => {
+        expect(mockShowOpenDialog).toHaveBeenCalledWith({
+          title: 'ドキュメントファイルを選択',
+          filters: [
+            {
+              name: 'ドキュメントファイル',
+              extensions: [
+                'pdf',
+                'doc',
+                'docx',
+                'xls',
+                'xlsx',
+                'ppt',
+                'pptx',
+                'txt',
+                'csv',
+              ],
+            },
+          ],
+          properties: ['openFile', 'multiSelections'],
+        });
+      });
+    });
+
+    it('評価項目が空の場合にエラーメッセージが表示されること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/);
+
+      // ボタンをクリック
+      await act(async () => {
+        fireEvent.click(reviewButton);
+      });
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 評価設定のアコーディオンを見つけて展開
+      const accordionButton2 = await waitFor(() =>
+        screen.getByText('評定項目設定'),
+      );
+
+      fireEvent.click(accordionButton2);
+
+      // アコーディオンが展開されて内容が表示されるまで待機
+      await waitFor(
+        () => {
+          expect(screen.getByText('基準を完全に満たしている')).toBeInTheDocument();
+        },
+        { timeout: 3000 },
+      );
+
+      // 評価項目追加ボタンが表示されるまで待機
+      const addButton = await waitFor(
+        () => screen.getByRole('button', { name: /評定項目を追加/ }),
+        { timeout: 3000 },
+      );
+
+      fireEvent.click(addButton);
+
+      // 編集フォームが表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByLabelText(/評定ラベル/)).toBeInTheDocument();
+      });
+
+      // 空のまま追加ボタンをクリック
+      const saveButton = screen.getByRole('button', { name: /追加/ });
+      await act(async () => {
+        fireEvent.click(saveButton);
+      });
+
+      // エラーメッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasError = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('すべての項目を入力してください'),
+        );
+        expect(hasError).toBe(true);
+      });
+    });
+
+    it('モーダルをキャンセルできること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/);
+
+      // ボタンをクリック
+      fireEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const cancelButton = screen.getByRole('button', { name: /キャンセル/ });
+      fireEvent.click(cancelButton);
+
+      await waitFor(() => {
+        expect(
+          screen.queryByText('レビュー対象ファイルのアップロード'),
+        ).not.toBeInTheDocument();
+      });
+    });
+
+    it('ファイル未選択時は送信ボタンが無効化されること', async () => {
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/);
+
+      // ボタンをクリック
+      fireEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/,
+      });
+      expect(submitButton).toBeDisabled();
+    });
+
+    it('チェックリスト未抽出時はレビュー実行ボタンが無効化されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [], // チェックリストが空
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        const reviewButton = screen.getByRole('button', {
+          name: /レビュー実行/,
+        });
+        expect(reviewButton).toBeDisabled();
+      });
+    });
+  });
+
+  describe('レビュー実行処理', () => {
+    it('追加指示を設定してレビューを実行した場合、IPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 追加指示を入力
+      const additionalInstructionsInput = screen.getByLabelText(/追加指示/);
+      await act(async () => {
+        fireEvent.change(additionalInstructionsInput, {
+          target: { value: '特に注意して確認してください' },
+        });
+      });
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // window.electron.review.executeが正しい追加指示で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            additionalInstructions: '特に注意して確認してください',
+          }),
+        );
+      });
+    });
+
+    it('コメントフォーマットを設定してレビューを実行した場合、IPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // コメントフォーマットを編集
+      const commentFormatInput = screen.getByLabelText(/コメントフォーマット/);
+      await act(async () => {
+        fireEvent.change(commentFormatInput, {
+          target: { value: 'カスタムコメントフォーマット:\n{指摘内容}' },
+        });
+      });
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // window.electron.review.executeが正しいコメントフォーマットで呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            commentFormat: 'カスタムコメントフォーマット:\n{指摘内容}',
+          }),
+        );
+      });
+    });
+
+    it('評価項目を編集してレビューを実行した場合、IPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 評価設定のアコーディオンを展開
+      const accordionButton = await waitFor(() =>
+        screen.getByText('評定項目設定'),
+      );
+      fireEvent.click(accordionButton);
+
+      // アコーディオンが展開されて内容が表示されるまで待機
+      await waitFor(
+        () => {
+          expect(screen.getByText('基準を完全に満たしている')).toBeInTheDocument();
+        },
+        { timeout: 3000 },
+      );
+
+      // 既存の評価項目「A」の編集ボタンをクリック
+      // 評価項目は順番に表示されているので、最初の編集ボタンが「A」の編集ボタン
+      const editButtons = screen.getAllByRole('button', { name: '' }).filter(
+        (button) => button.querySelector('svg[data-testid="EditIcon"]'),
+      );
+
+      await act(async () => {
+        fireEvent.click(editButtons[0]);
+      });
+
+      // 編集フォームが表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByLabelText(/評定ラベル/)).toBeInTheDocument();
+      });
+
+      // ラベルを「A+」に、説明を「基準を大きく上回っている」に変更
+      const labelInput = screen.getByLabelText(/評定ラベル/);
+      const descriptionInput = screen.getByLabelText(/評定説明/);
+
+      await act(async () => {
+        fireEvent.change(labelInput, { target: { value: 'A+' } });
+        fireEvent.change(descriptionInput, {
+          target: { value: '基準を大きく上回っている' },
+        });
+      });
+
+      // 保存ボタンをクリック
+      const saveButton = screen.getByRole('button', { name: /保存/ });
+      await act(async () => {
+        fireEvent.click(saveButton);
+      });
+
+      // 編集された評価項目が表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByText('基準を大きく上回っている')).toBeInTheDocument();
+      });
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // window.electron.review.executeが編集後の評価設定で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            evaluationSettings: expect.objectContaining({
+              items: expect.arrayContaining([
+                expect.objectContaining({ label: 'A+', description: '基準を大きく上回っている' }),
+                expect.objectContaining({ label: 'B' }),
+                expect.objectContaining({ label: 'C' }),
+                expect.objectContaining({ label: '–' }),
+              ]),
+            }),
+          }),
+        );
+      });
+    });
+
+    it('評価項目を削除してレビューを実行した場合、IPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 評価設定のアコーディオンを展開
+      const accordionButton = await waitFor(() =>
+        screen.getByText('評定項目設定'),
+      );
+      fireEvent.click(accordionButton);
+
+      // アコーディオンが展開されて内容が表示されるまで待機
+      await waitFor(
+        () => {
+          expect(screen.getByText('基準を完全に満たしている')).toBeInTheDocument();
+        },
+        { timeout: 3000 },
+      );
+
+      // 既存の評価項目「C」の削除ボタンをクリック
+      // 評価項目は順番に表示されているので、3番目の削除ボタンが「C」の削除ボタン
+      const deleteButtons = screen.getAllByRole('button', { name: '' }).filter(
+        (button) => button.querySelector('svg[data-testid="DeleteIcon"]'),
+      );
+
+      await act(async () => {
+        fireEvent.click(deleteButtons[2]); // 「C」の削除ボタン
+      });
+
+      // 「C」の項目が削除されたことを確認（「基準を満たしていない」が表示されなくなる）
+      await waitFor(() => {
+        expect(screen.queryByText('基準を満たしていない')).not.toBeInTheDocument();
+      });
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // window.electron.review.executeが削除後の評価設定で呼ばれることを確認
+      // 「C」が含まれず、A, B, –のみが含まれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            evaluationSettings: expect.objectContaining({
+              items: expect.arrayContaining([
+                expect.objectContaining({ label: 'A' }),
+                expect.objectContaining({ label: 'B' }),
+                expect.objectContaining({ label: '–' }),
+              ]),
+            }),
+          }),
+        );
+
+        // 「C」が含まれていないことを確認
+        const call = mockExecuteReview.mock.calls[0][0];
+        const hasC = call.evaluationSettings.items.some(
+          (item: any) => item.label === 'C'
+        );
+        expect(hasC).toBe(false);
+      });
+    });
+
+    it('レビュー実行中はローディングインジケータが表示されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        // LinearProgressが表示されることを確認
+        const progress = document.querySelector('.MuiLinearProgress-root');
+        expect(progress).toBeInTheDocument();
+      });
+    });
+
+    it('カスタム評価設定を追加してレビューを実行した場合、IPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 評価設定のアコーディオンを展開
+      const accordionButton = await waitFor(() =>
+        screen.getByText('評定項目設定'),
+      );
+      fireEvent.click(accordionButton);
+
+      // アコーディオンが展開されて内容が表示されるまで待機
+      await waitFor(
+        () => {
+          expect(screen.getByText('基準を完全に満たしている')).toBeInTheDocument();
+        },
+        { timeout: 3000 },
+      );
+
+      // 評価項目追加ボタンをクリック
+      const addButton = await waitFor(
+        () => screen.getByRole('button', { name: /評定項目を追加/ }),
+        { timeout: 3000 },
+      );
+      await act(async () => {
+        fireEvent.click(addButton);
+      });
+
+      // 編集フォームが表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByLabelText(/評定ラベル/)).toBeInTheDocument();
+      });
+
+      // 新しい評定項目を入力
+      const labelInput = screen.getByLabelText(/評定ラベル/);
+      const descriptionInput = screen.getByLabelText(/評定説明/);
+
+      await act(async () => {
+        fireEvent.change(labelInput, { target: { value: 'S' } });
+        fireEvent.change(descriptionInput, {
+          target: { value: '非常に優れている' },
+        });
+      });
+
+      // 保存ボタンをクリック
+      const saveButton = screen.getByRole('button', { name: /追加/ });
+      await act(async () => {
+        fireEvent.click(saveButton);
+      });
+
+      // 新しい評価項目が追加されたことを確認
+      await waitFor(() => {
+        expect(screen.getByText('非常に優れている')).toBeInTheDocument();
+      });
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // window.electron.review.executeが正しい評価設定で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            evaluationSettings: expect.objectContaining({
+              items: expect.arrayContaining([
+                expect.objectContaining({ label: 'S', description: '非常に優れている' }),
+                expect.objectContaining({ label: 'A' }),
+                expect.objectContaining({ label: 'B' }),
+                expect.objectContaining({ label: 'C' }),
+                expect.objectContaining({ label: '–' }),
+              ]),
+            }),
+          }),
+        );
+      });
+    });
+
+    it('レビュー実行中はボタンが「キャンセル」に変わること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('キャンセル')).toBeInTheDocument();
+      });
+    });
+
+    it('ドキュメント量を「大」に設定してレビューを実行した場合、IPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // ドキュメント量のラジオボタンを値で検索して「大」を選択
+      const radioButtons = await screen.findAllByRole('radio');
+      const largeRadio = radioButtons.find((radio) =>
+        (radio as HTMLInputElement).value === 'large'
+      );
+
+      expect(largeRadio).toBeDefined();
+      fireEvent.click(largeRadio!);
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // window.electron.review.executeがdocumentMode: 'large'で呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            documentMode: 'large',
+          }),
+        );
+      });
+    });
+
+    it('レビュー実行中はチェックリスト抽出ボタンが無効化されること', async () => {
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        const extractButton = screen.getByRole('button', {
+          name: /チェックリスト抽出/,
+        });
+        expect(extractButton).toBeDisabled();
+      });
+    });
+
+    it('複数の条件（追加指示、コメントフォーマット、評価設定、ドキュメント量）を設定してレビューを実行した場合、すべてIPC通信に正しく渡されること', async () => {
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      // 1. 追加指示を入力
+      const additionalInstructionsInput = screen.getByLabelText(/追加指示/);
+      await act(async () => {
+        fireEvent.change(additionalInstructionsInput, {
+          target: { value: 'セキュリティ観点でも確認してください' },
+        });
+      });
+
+      // 2. コメントフォーマットを編集
+      const commentFormatInput = screen.getByLabelText(/コメントフォーマット/);
+      await act(async () => {
+        fireEvent.change(commentFormatInput, {
+          target: { value: '【指摘】\n{内容}\n【根拠】\n{理由}' },
+        });
+      });
+
+      // 3. 評価設定のアコーディオンを展開して評価項目を追加
+      const accordionButton = await waitFor(() =>
+        screen.getByText('評定項目設定'),
+      );
+      fireEvent.click(accordionButton);
+
+      await waitFor(
+        () => {
+          expect(screen.getByText('基準を完全に満たしている')).toBeInTheDocument();
+        },
+        { timeout: 3000 },
+      );
+
+      const addButton = await waitFor(
+        () => screen.getByRole('button', { name: /評定項目を追加/ }),
+        { timeout: 3000 },
+      );
+      await act(async () => {
+        fireEvent.click(addButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByLabelText(/評定ラベル/)).toBeInTheDocument();
+      });
+
+      const labelInput = screen.getByLabelText(/評定ラベル/);
+      const descriptionInput = screen.getByLabelText(/評定説明/);
+
+      await act(async () => {
+        fireEvent.change(labelInput, { target: { value: 'S' } });
+        fireEvent.change(descriptionInput, {
+          target: { value: '卓越している' },
+        });
+      });
+
+      const saveButton = screen.getByRole('button', { name: /追加/ });
+      await act(async () => {
+        fireEvent.click(saveButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('卓越している')).toBeInTheDocument();
+      });
+
+      // 4. ドキュメント量を「大」に設定
+      const radioButtons = await screen.findAllByRole('radio');
+      const largeRadio = radioButtons.find((radio) =>
+        (radio as HTMLInputElement).value === 'large'
+      );
+
+      expect(largeRadio).toBeDefined();
+      fireEvent.click(largeRadio!);
+
+      // ファイル選択
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // すべてのパラメータが正しく渡されることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            additionalInstructions: 'セキュリティ観点でも確認してください',
+            commentFormat: '【指摘】\n{内容}\n【根拠】\n{理由}',
+            evaluationSettings: expect.objectContaining({
+              items: expect.arrayContaining([
+                expect.objectContaining({ label: 'S', description: '卓越している' }),
+                expect.objectContaining({ label: 'A' }),
+                expect.objectContaining({ label: 'B' }),
+                expect.objectContaining({ label: 'C' }),
+                expect.objectContaining({ label: '–' }),
+              ]),
+            }),
+            documentMode: 'large',
+          }),
+        );
+      });
+    });
+
+    it('キャンセルボタンをクリックするとabortExecuteReviewが呼ばれること', async () => {
+      const mockAbortExecute = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+      window.electron.review.abortExecute = mockAbortExecute;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('キャンセル')).toBeInTheDocument();
+      });
+
+      const cancelButton = screen.getByRole('button', { name: /キャンセル/ });
+      fireEvent.click(cancelButton);
+
+      await waitFor(() => {
+        expect(mockAbortExecute).toHaveBeenCalledWith('review-1');
+      });
+    });
+
+    it('Officeファイルを画像化する際にOffice→PDF→画像変換が実行されること', async () => {
+      const mockConvertPdfBytesToImages = jest
+        .spyOn(pdfUtils, 'convertPdfBytesToImages')
+        .mockResolvedValue([
+          'data:image/png;base64,mock-image-1',
+          'data:image/png;base64,mock-image-2',
+        ]);
+
+      const mockConvertOfficeToPdf = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.xlsx'],
+          canceled: false,
+        },
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.convertOfficeToPdf = mockConvertOfficeToPdf;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('レビュー実行')).toBeInTheDocument();
+      });
+
+      const reviewButton = screen.getByRole('button', {
+        name: /レビュー実行/,
+      });
+      await act(async () => {
+        fireEvent.click(reviewButton);
+      });
+
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.xlsx')).toBeInTheDocument();
+      });
+
+      // 画像モードに切り替え
+      const imageRadioLabel = screen.getAllByText(/^画像$/)[0];
+      await act(async () => {
+        fireEvent.click(imageRadioLabel);
+      });
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/,
+      });
+      await act(async () => {
+        fireEvent.click(submitButton);
+      });
+
+      // Office→PDF変換が呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertOfficeToPdf).toHaveBeenCalled();
+      });
+
+      // PDF→画像変換も呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertPdfBytesToImages).toHaveBeenCalled();
+      });
+
+      // window.electron.review.executeが正しく呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            files: expect.arrayContaining([
+              expect.objectContaining({
+                name: 'test.xlsx',
+                imageData: expect.any(Array),
+              }),
+            ]),
+            additionalInstructions: '',
+            commentFormat: expect.stringContaining('評価理由・根拠'),
+            evaluationSettings: expect.objectContaining({
+              items: expect.arrayContaining([
+                expect.objectContaining({ label: 'A' }),
+                expect.objectContaining({ label: 'B' }),
+                expect.objectContaining({ label: 'C' }),
+                expect.objectContaining({ label: '–' }),
+              ]),
+            }),
+            documentMode: 'small',
+          }),
+        );
+      });
+
+      mockConvertPdfBytesToImages.mockRestore();
+    });
+
+    it('PDFファイルを画像化する際にPDF→画像変換が実行されること', async () => {
+      const mockConvertPdfBytesToImages = jest
+        .spyOn(pdfUtils, 'convertPdfBytesToImages')
+        .mockResolvedValue([
+          'data:image/png;base64,mock-image-1',
+          'data:image/png;base64,mock-image-2',
+        ]);
+
+      const mockReadFile = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: new Uint8Array([0x25, 0x50, 0x44, 0x46]),
+      });
+
+      const mockShowOpenDialog = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          filePaths: ['/path/to/test.pdf'],
+          canceled: false,
+        },
+      });
+
+      const mockExecuteReview = jest.fn().mockResolvedValue({
+        success: true,
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResults,
+      }) as any;
+      window.electron.fs.showOpenDialog = mockShowOpenDialog;
+      window.electron.fs.readFile = mockReadFile;
+      window.electron.review.execute = mockExecuteReview;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // チェックリスト読み込みとボタン有効化を待機
+      const reviewButton = await waitForChecklistAndEnableButton(/レビュー実行/i);
+
+      // ボタンをクリック
+      await userEvent.click(reviewButton);
+
+      // モーダルが開くことを確認
+      await waitFor(() => {
+        expect(
+          screen.getByText('レビュー対象ファイルのアップロード'),
+        ).toBeInTheDocument();
+      });
+
+      const uploadButton = screen.getByRole('button', {
+        name: /ファイル選択ダイアログ/,
+      });
+      await act(async () => {
+        fireEvent.click(uploadButton);
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('test.pdf')).toBeInTheDocument();
+      });
+
+      // 画像化モード（ページ毎）に切り替え
+      const imageRadioLabel = screen.getByText(/^画像$/);
+      await userEvent.click(imageRadioLabel);
+
+      // モーダルの送信ボタンをクリック
+      const submitButton = screen.getByRole('button', {
+        name: /レビュー実行/i,
+      });
+      await userEvent.click(submitButton);
+
+      // PDF読み込みが呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockReadFile).toHaveBeenCalled();
+      });
+
+      // PDF→画像変換が呼ばれたことを確認
+      await waitFor(() => {
+        expect(mockConvertPdfBytesToImages).toHaveBeenCalledWith(
+          expect.any(Uint8Array),
+          { scale: 2.0 },
+        );
+      });
+
+      // window.electron.review.executeが正しく呼ばれることを確認
+      await waitFor(() => {
+        expect(mockExecuteReview).toHaveBeenCalledWith(
+          expect.objectContaining({
+            reviewHistoryId: 'review-1',
+            files: expect.arrayContaining([
+              expect.objectContaining({
+                name: 'test.pdf',
+                imageData: expect.any(Array),
+              }),
+            ]),
+            additionalInstructions: '',
+            commentFormat: expect.stringContaining('評価理由・根拠'),
+            evaluationSettings: expect.objectContaining({
+              items: expect.arrayContaining([
+                expect.objectContaining({ label: 'A' }),
+                expect.objectContaining({ label: 'B' }),
+                expect.objectContaining({ label: 'C' }),
+                expect.objectContaining({ label: '–' }),
+              ]),
+            }),
+            documentMode: 'small',
+          }),
+        );
+      });
+
+      mockConvertPdfBytesToImages.mockRestore();
+    });
+  });
+
+  describe('レビュー実行結果表示', () => {
+    it('レビュー結果がチェックリストセクションに表示されること', async () => {
+      const mockChecklistResultsWithReview: ReviewChecklistResult[] = [
+        {
+          id: 1,
+          content: 'チェック項目1',
+          sourceEvaluation: {
+            evaluation: 'A',
+            comment: '基準を満たしています',
+          },
+        },
+        {
+          id: 2,
+          content: 'チェック項目2',
+          sourceEvaluation: {
+            evaluation: 'B',
+            comment: '改善の余地があります',
+          },
+        },
+      ];
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: mockChecklistResultsWithReview,
+      });
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await waitFor(() => {
+        expect(screen.getByText('基準を満たしています')).toBeInTheDocument();
+        expect(screen.getByText('改善の余地があります')).toBeInTheDocument();
+      });
+    });
+
+    it('初回データ取得失敗時にポーリングで再試行されること', async () => {
+      jest.useFakeTimers();
+      let callCount = 0;
+      const mockGetHistoryDetail = jest.fn(() => {
+        callCount++;
+        if (callCount === 1) {
+          return Promise.reject(new Error('Network error'));
+        }
+        return Promise.resolve({
+          success: true as const,
+          data: {
+            checklistResults: mockChecklistResults,
+            targetDocumentName: 'test-document.pdf',
+          },
+        });
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: mockReviewHistory,
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: mockReviewHistory,
+        reviewChecklistResults: [],
+      });
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail).toHaveBeenCalledTimes(1);
+
+      // ポーリングの5秒進める
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      // ポーリングで再試行されることを確認
+      expect(mockGetHistoryDetail).toHaveBeenCalledTimes(2);
+
+      // 最終的にデータが表示されることを確認
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+      });
+
+      jest.useRealTimers();
+    }, 10000);
+  });
+
+  describe('レビュー実行処理のポーリングとイベント受信', () => {
+    it('レビュー実行中は5秒ごとにチェックリスト結果がポーリングされること', async () => {
+      jest.useFakeTimers();
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: mockChecklistResults,
+          targetDocumentName: 'test-document.pdf',
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: mockChecklistResults,
+      });
+
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      const initialCallCount = mockGetHistoryDetail.mock.calls.length;
+
+      // 5秒進めてポーリングが実行されることを確認
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(initialCallCount + 1);
+
+      // さらに5秒進めて2回目のポーリングが実行されることを確認
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(initialCallCount + 2);
+
+      jest.useRealTimers();
+    }, 10000);
+
+    it('レビュー完了イベント（成功）を受信したら、結果を再取得してポーリングを停止すること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-execute-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: mockChecklistResults,
+          targetDocumentName: 'test-document.pdf',
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されていることを確認
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      const callCountBeforeEvent = mockGetHistoryDetail.mock.calls.length;
+
+      // レビュー完了イベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'success',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // fetchChecklistResultsが再度呼ばれることを確認
+      expect(mockGetHistoryDetail.mock.calls.length).toBeGreaterThan(
+        callCountBeforeEvent,
+      );
+
+      // 成功メッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasSuccess = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('レビューが完了しました'),
+        );
+        expect(hasSuccess).toBe(true);
+      });
+
+      // ポーリングが停止することを確認
+      const callCountAfterEvent = mockGetHistoryDetail.mock.calls.length;
+      await act(async () => {
+        jest.advanceTimersByTime(10000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(callCountAfterEvent);
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('レビュー完了イベント（失敗）を受信したら、エラーメッセージを表示してポーリングを停止すること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-execute-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: [],
+          targetDocumentName: null,
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されるまで待つ
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      // レビュー失敗イベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'failed',
+              error: 'テストエラー',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // エラーメッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasError = alerts.some(
+          (alert: AlertMessage) =>
+            alert.message.includes('レビューに失敗しました') &&
+            alert.message.includes('テストエラー'),
+        );
+        expect(hasError).toBe(true);
+      });
+
+      // ポーリングが停止することを確認
+      const callCountAfterEvent = mockGetHistoryDetail.mock.calls.length;
+      await act(async () => {
+        jest.advanceTimersByTime(10000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(callCountAfterEvent);
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('レビュー完了イベント（キャンセル）を受信したら、キャンセルメッセージを表示してポーリングを停止すること', async () => {
+      jest.useFakeTimers();
+
+      let eventCallback: ((event: any) => void) | null = null;
+      const mockSubscribe = jest.fn((eventType: string, callback: any) => {
+        if (eventType === 'review-execute-finished') {
+          eventCallback = callback;
+        }
+        return Promise.resolve(() => {});
+      });
+
+      const mockGetHistoryDetail = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          checklistResults: [],
+          targetDocumentName: null,
+        },
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.pushApi.subscribe = mockSubscribe as any;
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // イベントコールバックが設定されるまで待つ
+      await waitFor(() => {
+        expect(mockSubscribe).toHaveBeenCalled();
+        expect(eventCallback).not.toBeNull();
+      });
+
+      // レビューキャンセルイベントを発火
+      await act(async () => {
+        if (eventCallback) {
+          eventCallback({
+            payload: {
+              reviewHistoryId: 'review-1',
+              status: 'canceled',
+            },
+          });
+        }
+        await Promise.resolve();
+      });
+
+      // キャンセルメッセージがalertStoreに追加されることを確認
+      await waitFor(() => {
+        const alerts = alertStore.getState().alerts;
+        const hasCancel = alerts.some((alert: AlertMessage) =>
+          alert.message.includes('レビュー実行をキャンセルしました'),
+        );
+        expect(hasCancel).toBe(true);
+      });
+
+      // ポーリングが停止することを確認
+      const callCountAfterEvent = mockGetHistoryDetail.mock.calls.length;
+      await act(async () => {
+        jest.advanceTimersByTime(10000);
+        await Promise.resolve();
+      });
+
+      expect(mockGetHistoryDetail.mock.calls.length).toBe(callCountAfterEvent);
+
+      jest.useRealTimers();
+    }, 15000);
+
+    it('ポーリング中にチェックリスト結果が更新されること', async () => {
+      jest.useFakeTimers();
+
+      let callCount = 0;
+      const mockGetHistoryDetail = jest.fn(() => {
+        callCount++;
+        if (callCount === 1) {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: [],
+              targetDocumentName: null,
+            },
+          });
+        } else if (callCount === 2) {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: [mockChecklistResults[0]],
+              targetDocumentName: 'test-document.pdf',
+            },
+          });
+        } else {
+          return Promise.resolve({
+            success: true as const,
+            data: {
+              checklistResults: mockChecklistResults,
+              targetDocumentName: 'test-document.pdf',
+            },
+          });
+        }
+      });
+
+      const mockGetHistoryById = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+      });
+
+      const mockGetHistoryInstruction = jest.fn().mockResolvedValue({
+        success: true as const,
+        data: {
+          additionalInstructions: '',
+          commentFormat:
+            '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        },
+      });
+
+      window.electron = createMockElectronWithOptions({
+        reviewHistory: {
+          ...mockReviewHistory,
+          processingStatus: 'reviewing',
+        },
+        reviewChecklistResults: [],
+      });
+
+      window.electron.review.getHistoryDetail = mockGetHistoryDetail as any;
+      window.electron.review.getHistoryById = mockGetHistoryById as any;
+      window.electron.review.getHistoryInstruction =
+        mockGetHistoryInstruction as any;
+
+      render(<ReviewArea selectedReviewHistoryId="review-1" />);
+
+      // 初回データ取得を待つ（空のチェックリスト）
+      await act(async () => {
+        await Promise.resolve();
+      });
+
+      // 5秒進めて1回目のポーリング（1件のチェックリスト）
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+      });
+
+      // さらに5秒進めて2回目のポーリング（2件のチェックリスト）
+      await act(async () => {
+        jest.advanceTimersByTime(5000);
+        await Promise.resolve();
+      });
+
+      await waitFor(() => {
+        expect(screen.getByText('チェック項目1')).toBeInTheDocument();
+        expect(screen.getByText('チェック項目2')).toBeInTheDocument();
+      });
+
+      jest.useRealTimers();
+    }, 15000);
+  });
+});
diff --git a/src/__tests__/renderer/test-utils/mockElectronHandler.ts b/src/__tests__/renderer/test-utils/mockElectronHandler.ts
new file mode 100644
index 000000000..e1a9b0351
--- /dev/null
+++ b/src/__tests__/renderer/test-utils/mockElectronHandler.ts
@@ -0,0 +1,247 @@
+import type { ElectronHandler } from '@/main/preload';
+import type { Source, ChatRoom, SettingsSavingStatus, Settings, ChatMessage, RevieHistory, ReviewChecklistResult } from '@/types';
+import type { IpcChannels, IpcResponsePayloadMap } from '@/types/ipc';
+
+/**
+ * Mockメソッドの型を定義
+ */
+type MockFunction<T> = T extends (...args: any[]) => any
+  ? jest.Mock<ReturnType<T>, Parameters<T>>
+  : never;
+
+/**
+ * ElectronHandlerの各メソッドをMock化
+ */
+export type MockHandler<T> = {
+  [K in keyof T]: T[K] extends (...args: any[]) => any
+    ? MockFunction<T[K]>
+    : T[K] extends object
+      ? MockHandler<T[K]>
+      : T[K];
+};
+
+export type ElectronMock = MockHandler<ElectronHandler>;
+
+/**
+ * デフォルトの設定値を生成
+ */
+export const createDefaultMockSettings = (): Settings => ({
+  database: {
+    dir: '/test/db',
+  },
+  source: {
+    registerDir: './test/source',
+  },
+  api: {
+    key: 'test-api-key',
+    url: 'https://api.test.com',
+    model: 'test-model',
+  },
+  redmine: {
+    endpoint: 'https://redmine.test.com',
+    apiKey: 'test-redmine-key',
+  },
+  gitlab: {
+    endpoint: 'https://gitlab.test.com',
+    apiKey: 'test-gitlab-key',
+  },
+  mcp: {
+    serverConfig: { testMcp: { url: new URL('https://mcp.test.com') } },
+  },
+  systemPrompt: {
+    content: 'test system prompt',
+  },
+});
+
+/**
+ * モックオプションのインターフェース
+ */
+export interface MockOptions {
+  initialSettings?: Partial<Settings>;
+  sources?: Source[];
+  chatRooms?: ChatRoom[];
+  chatMessages?: ChatMessage[];
+  sourceEnabled?: boolean;
+  fsAccess?: boolean;
+  settingsStatus?: SettingsSavingStatus;
+  reviewHistories?: RevieHistory[];
+  reviewHistory?: RevieHistory | null;
+  reviewChecklistResults?: ReviewChecklistResult[];
+  reviewTargetDocumentName?: string | null;
+}
+
+/**
+ * オプション付きでモックを生成する関数
+ */
+export const createMockElectronWithOptions = (
+  options: MockOptions = {},
+): ElectronHandler => {
+  const settings = options.initialSettings
+    ? { ...createDefaultMockSettings(), ...options.initialSettings }
+    : createDefaultMockSettings();
+
+  const mockHandlers = {
+    settings: {
+      getStatus: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.GET_SETTINGS_STATUS]>, []>()
+        .mockResolvedValue({
+          success: true,
+          data: options.settingsStatus || {
+            state: 'done',
+            messages: [],
+            tools: {
+              document: false,
+              redmine: false,
+              gitlab: false,
+              mcp: false,
+            },
+          },
+        }),
+      reinitialize: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REINITIALIZE_SETTINGS]>, []>()
+        .mockResolvedValue({ success: true }),
+      removeMessage: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REMOVE_SETTINGS_MESSAGE]>, [string]>()
+        .mockResolvedValue({ success: true }),
+      getSettings: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.GET_SETTINGS]>, []>()
+        .mockResolvedValue({ success: true, data: settings }),
+      setSettings: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.SET_SETTINGS]>, [Settings]>()
+        .mockResolvedValue({ success: true, data: true }),
+    },
+    fs: {
+      access: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.FS_CHECK_PATH_EXISTS]>, [string]>()
+        .mockResolvedValue({ success: true, data: options.fsAccess ?? true }),
+      showOpenDialog: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.FS_SHOW_OPEN_DIALOG]>, [any]>()
+        .mockResolvedValue({
+          success: true,
+          data: { filePaths: [], canceled: false },
+        }),
+      readFile: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.FS_READ_FILE]>, [string]>()
+        .mockResolvedValue({
+          success: true,
+          data: new Uint8Array(),
+        }),
+      convertOfficeToPdf: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.FS_CONVERT_OFFICE_TO_PDF]>, [string]>()
+        .mockResolvedValue({
+          success: true,
+          data: new Uint8Array(),
+        }),
+    },
+    chat: {
+      sendMessage: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_SEND_MESSAGE]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      getRooms: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_GET_ROOMS]>, []>()
+        .mockResolvedValue({ success: true, data: options.chatRooms ?? [] }),
+      getMessages: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_GET_MESSAGES]>, [string]>()
+        .mockResolvedValue({ success: true, data: options.chatMessages ?? [] }),
+      deleteRoom: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_DELETE_ROOM]>, [string]>()
+        .mockResolvedValue({ success: true }),
+      createThread: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_CREATE_THREAD]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      requestAbort: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_ABORT_REQUEST]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      deleteMessagesBeforeSpecificId: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.CHAT_DELETE_MESSAGES_BEFORE_SPECIFIC_ID]>, [any]>()
+        .mockResolvedValue({ success: true }),
+    },
+    source: {
+      reloadSources: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.SOURCE_RELOAD]>, []>()
+        .mockResolvedValue({
+          success: true,
+          data: { message: 'Source reloaded successfully' },
+        }),
+      getSources: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.SOURCE_GET_ALL]>, []>()
+        .mockResolvedValue({
+          success: true,
+          data: options.sources ?? [],
+        }),
+      updateSourceEnabled: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.SOURCE_UPDATE_ENABLED]>, [any]>()
+        .mockResolvedValue({
+          success: true,
+        }),
+    },
+    ipcRenderer: {
+      sendMessage: jest.fn(),
+      on: jest.fn(),
+      once: jest.fn(),
+    },
+    pushApi: {
+      subscribe: jest.fn<Promise<() => void>, [any, any]>().mockResolvedValue(() => {}),
+    },
+    review: {
+      getHistories: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORIES]>, []>()
+        .mockResolvedValue({ success: true, data: options.reviewHistories ?? [] }),
+      getHistoryById: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORY_BY_ID]>, [string]>()
+        .mockResolvedValue({ success: true, data: options.reviewHistory ?? null }),
+      getHistoryDetail: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORY_DETAIL]>, [string]>()
+        .mockResolvedValue({ success: true, data: {
+          checklistResults: options.reviewChecklistResults ?? [],
+          targetDocumentName: options.reviewTargetDocumentName ?? null,
+        } }),
+      getHistoryInstruction: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_GET_HISTORY_INSTRUCTION]>, [string]>()
+        .mockResolvedValue({ success: true, data: {
+          additionalInstructions: '',
+          commentFormat: '【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）',
+          evaluationSettings: {
+            items: [
+              { label: 'A', description: '基準を完全に満たしている' },
+              { label: 'B', description: '基準をある程度満たしている' },
+              { label: 'C', description: '基準を満たしていない' },
+              { label: '–', description: '評価の対象外、または評価できない' },
+            ],
+          },
+        } }),
+      deleteHistory: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_DELETE_HISTORY]>, [string]>()
+        .mockResolvedValue({ success: true }),
+      extractChecklist: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_CALL]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      abortExtractChecklist: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXTRACT_CHECKLIST_ABORT]>, [string]>()
+        .mockResolvedValue({ success: true }),
+      updateChecklist: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_UPDATE_CHECKLIST]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      execute: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_CALL]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      abortExecute: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_EXECUTE_ABORT]>, [string]>()
+        .mockResolvedValue({ success: true }),
+      sendChatMessage: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_CHAT_SEND_MESSAGE]>, [any]>()
+        .mockResolvedValue({ success: true }),
+      abortChat: jest
+        .fn<Promise<IpcResponsePayloadMap[typeof IpcChannels.REVIEW_CHAT_ABORT]>, [string]>()
+        .mockResolvedValue({ success: true }),
+    },
+  };
+
+  return mockHandlers as ElectronMock;
+};
+
+/**
+ * 後方互換性のために残す
+ * @deprecated Use createMockElectronWithOptions instead
+ */
+export const createMockElectron = createMockElectronWithOptions;
diff --git a/src/__tests__/test-utils/mockElectronHandler.ts b/src/__tests__/test-utils/mockElectronHandler.ts
deleted file mode 100644
index 688344324..000000000
--- a/src/__tests__/test-utils/mockElectronHandler.ts
+++ /dev/null
@@ -1,149 +0,0 @@
-import type { ElectronHandler } from '@/main/preload';
-import type { Source } from '@/db/schema';
-import type { ChatRoom, SettingsSavingStatus, Settings } from '@/types';
-
-/**
- * Mockメソッドの型を定義
- */
-type MockFunction<T> = T extends (...args: any[]) => any
-  ? jest.Mock<ReturnType<T>, Parameters<T>>
-  : never;
-
-/**
- * ElectronHandlerの各メソッドをMock化
- */
-export type MockHandler<T> = {
-  [K in keyof T]: T[K] extends (...args: any[]) => any
-    ? MockFunction<T[K]>
-    : T[K] extends object
-      ? MockHandler<T[K]>
-      : T[K];
-};
-
-export type ElectronMock = MockHandler<ElectronHandler>;
-
-/**
- * デフォルトの設定値を生成
- */
-export const createDefaultMockSettings = (): Settings => ({
-  database: {
-    dir: '/test/db',
-  },
-  source: {
-    registerDir: './test/source',
-  },
-  api: {
-    key: 'test-api-key',
-    url: 'https://api.test.com',
-    model: 'test-model',
-  },
-  redmine: {
-    endpoint: 'https://redmine.test.com',
-    apiKey: 'test-redmine-key',
-  },
-  gitlab: {
-    endpoint: 'https://gitlab.test.com',
-    apiKey: 'test-gitlab-key',
-  },
-  mcp: {
-    serverConfig: '{"testMcp": {"url": "https://mcp.test.com"} }',
-  },
-  systemPrompt: {
-    content: 'test system prompt',
-  },
-});
-
-/**
- * モックオプションのインターフェース
- */
-export interface MockOptions {
-  initialSettings?: Partial<Settings>;
-  sources?: Source[];
-  chatRooms?: ChatRoom[];
-  sourceEnabled?: boolean;
-  fsAccess?: boolean;
-  settingsStatus?: Partial<SettingsSavingStatus>;
-}
-
-/**
- * オプション付きでモックを生成する関数
- */
-export const createMockElectronWithOptions = (
-  options: MockOptions = {},
-): ElectronHandler => {
-  const settings = options.initialSettings
-    ? { ...createDefaultMockSettings(), ...options.initialSettings }
-    : createDefaultMockSettings();
-
-  const mockHandlers = {
-    settings: {
-      getStatus: jest.fn().mockReturnValue(
-        options.settingsStatus || {
-          state: 'done',
-          messages: [],
-          tools: {
-            redmine: false,
-            gitlab: false,
-            mcp: false,
-          },
-        },
-      ),
-      reinitialize: jest.fn().mockResolvedValue(undefined),
-      removeMessage: jest.fn(),
-      getSettings: jest
-        .fn()
-        .mockResolvedValue({ success: true, data: settings }),
-      setSettings: jest.fn().mockResolvedValue({ success: true }),
-    },
-    fs: {
-      access: jest.fn().mockResolvedValue(options.fsAccess ?? true),
-    },
-    store: {
-      get: jest.fn().mockImplementation((key: string) => {
-        if (key === 'all') return settings;
-        return settings[key as keyof Settings];
-      }),
-      set: jest.fn().mockResolvedValue(undefined),
-    },
-    chat: {
-      sendMessage: jest.fn(),
-      getRooms: jest.fn().mockResolvedValue(options.chatRooms ?? []),
-      getMessages: jest.fn().mockResolvedValue([]),
-      deleteRoom: jest.fn().mockResolvedValue({ success: true }),
-      createThread: jest.fn().mockResolvedValue({
-        success: true,
-      }),
-      onError: jest.fn(),
-      onStream: jest.fn(),
-      onComplete: jest.fn(),
-      deleteMessagesBeforeSpecificId: jest.fn(),
-    },
-    source: {
-      reloadSources: jest.fn().mockResolvedValue({
-        success: true,
-        message: 'Source reloaded successfully',
-      }),
-      getSources: jest.fn().mockResolvedValue({
-        success: true,
-        sources: options.sources ?? [],
-      }),
-      updateSourceEnabled: jest.fn().mockResolvedValue({
-        success: true,
-      }),
-    },
-    ipcRenderer: {
-      sendMessage: jest.fn(),
-      on: jest.fn(),
-      once: jest.fn(),
-    },
-    review: {},
-  };
-
-  return mockHandlers as ElectronMock;
-};
-
-/**
- * 後方互換性のために残す
- * @deprecated Use createMockElectronWithOptions instead
- */
-export const createMockElectron = createMockElectronWithOptions;
diff --git a/src/main/lib/csvParser.ts b/src/main/lib/csvParser.ts
index c2f82751c..19eaf6a64 100644
--- a/src/main/lib/csvParser.ts
+++ b/src/main/lib/csvParser.ts
@@ -1,3 +1,6 @@
+import type { CsvImportData, CustomEvaluationSettings } from '@/types';
+import { internalError } from './error';
+
 /**
  * CSV解析のためのユーティリティクラス
  * RFC 4180準拠の基本的なCSVパース機能を提供
@@ -74,26 +77,6 @@ export class CsvParser {
     return rows;
   }
 
-  /**
-   * CSVの1列目の値のみを抽出する
-   * @param csvText CSVテキスト
-   * @returns 1列目の値の配列（空でない値のみ）
-   */
-  public static extractFirstColumn(csvText: string): string[] {
-    const rows = this.parse(csvText);
-    const firstColumnValues: string[] = [];
-
-    for (const row of rows) {
-      if (row.length > 0) {
-        const firstCell = row[0];
-        if (firstCell && firstCell.trim() !== '') {
-          firstColumnValues.push(firstCell.trim());
-        }
-      }
-    }
-
-    return firstColumnValues;
-  }
 
   /**
    * 行が空かどうかを判定する
@@ -142,4 +125,146 @@ export class CsvParser {
       return { isValid: false, error: `CSV解析エラー: ${error}` };
     }
   }
+
+  /**
+   * 新フォーマットのCSV/Excelデータをパースする
+   * ヘッダ行: チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID
+   * @param csvText CSVテキスト
+   * @returns パース結果
+   * @throws AppError パースに失敗した場合
+   */
+  public static parseImportFormat(csvText: string): CsvImportData {
+    const rows = this.parse(csvText);
+
+    if (rows.length === 0) {
+      throw internalError({
+        expose: true,
+        messageCode: 'REVIEW_CHECKLIST_EXTRACTION_FILE_IMPORT_ERROR',
+        messageParams: { detail: 'CSVファイルが空です' },
+      });
+    }
+
+    // ヘッダ行の検証
+    const headerRow = rows[0];
+    const expectedHeaders = [
+      'チェックリスト',
+      '評定ラベル',
+      '評定説明',
+      '追加指示',
+      'コメントフォーマット',
+      'AI APIエンドポイント',
+      'AI APIキー',
+      'BPR ID',
+    ];
+
+    // ヘッダ行の列数検証
+    if (headerRow.length !== expectedHeaders.length) {
+      throw internalError({
+        expose: true,
+        messageCode: 'REVIEW_CHECKLIST_EXTRACTION_FILE_IMPORT_ERROR',
+        messageParams: {
+          detail: `CSVフォーマットが不正です。ヘッダ行は${expectedHeaders.length}列である必要がありますが、${headerRow.length}列でした`,
+        },
+      });
+    }
+
+    // 各ヘッダ列の内容検証
+    for (let i = 0; i < expectedHeaders.length; i++) {
+      const actualHeader = headerRow[i].trim();
+      const expectedHeader = expectedHeaders[i];
+
+      if (actualHeader !== expectedHeader) {
+        throw internalError({
+          expose: true,
+          messageCode: 'REVIEW_CHECKLIST_EXTRACTION_FILE_IMPORT_ERROR',
+          messageParams: {
+            detail: `CSVフォーマットが不正です。${i + 1}列目のヘッダは「${expectedHeader}」である必要がありますが、「${actualHeader}」でした`,
+          },
+        });
+      }
+    }
+
+    // データ行の解析
+    const dataRows = rows.slice(1); // ヘッダ行を除く
+    const checklists: string[] = [];
+    const evaluationItems: Array<{ label: string; description: string }> = [];
+    let additionalInstructions: string | undefined;
+    let commentFormat: string | undefined;
+    let apiUrl: string | undefined;
+    let apiKey: string | undefined;
+    let apiModel: string | undefined;
+
+    for (const row of dataRows) {
+      // 各列のデータを取得（空の場合はundefined）
+      const checklistContent = row[0]?.trim() || undefined;
+      const evalLabel = row[1]?.trim() || undefined;
+      const evalDescription = row[2]?.trim() || undefined;
+      const additionalInst = row[3]?.trim() || undefined;
+      const commentFmt = row[4]?.trim() || undefined;
+      const apiEndpoint = row[5]?.trim() || undefined;
+      const apiKeyValue = row[6]?.trim() || undefined;
+      const apiModelName = row[7]?.trim() || undefined;
+
+      // チェックリスト項目の収集
+      if (checklistContent) {
+        checklists.push(checklistContent);
+      }
+
+      // 評定項目の収集（ラベルと説明の両方が必要）
+      if (evalLabel && evalDescription) {
+        evaluationItems.push({
+          label: evalLabel,
+          description: evalDescription,
+        });
+      }
+
+      // 設定項目の収集（最初に見つかった値を使用）
+      if (additionalInst && !additionalInstructions) {
+        additionalInstructions = additionalInst;
+      }
+      if (commentFmt && !commentFormat) {
+        commentFormat = commentFmt;
+      }
+      if (apiEndpoint && !apiUrl) {
+        apiUrl = apiEndpoint;
+      }
+      if (apiKeyValue && !apiKey) {
+        apiKey = apiKeyValue;
+      }
+      if (apiModelName && !apiModel) {
+        apiModel = apiModelName;
+      }
+    }
+
+    // インポートデータの構築
+    const importData: CsvImportData = {
+      checklists,
+    };
+
+    // 評定設定
+    if (evaluationItems.length > 0) {
+      importData.evaluationSettings = {
+        items: evaluationItems,
+      };
+    }
+
+    // その他の設定
+    if (additionalInstructions) {
+      importData.additionalInstructions = additionalInstructions;
+    }
+    if (commentFormat) {
+      importData.commentFormat = commentFormat;
+    }
+
+    // API設定
+    if (apiUrl || apiKey || apiModel) {
+      importData.apiSettings = {
+        url: apiUrl,
+        key: apiKey,
+        model: apiModel,
+      };
+    }
+
+    return importData;
+  }
 }
diff --git a/src/main/main.ts b/src/main/main.ts
index 5b12599b1..344d24ee3 100644
--- a/src/main/main.ts
+++ b/src/main/main.ts
@@ -322,7 +322,7 @@ const setupChatHandlers = () => {
 
   // スレッド作成ハンドラ
   handleIpc(IpcChannels.CHAT_CREATE_THREAD, async ({ roomId, title }) => {
-    await chatService.createThread(roomId, title, userId);
+    await chatService.createThread(userId, roomId, title);
     return undefined as never;
   });
 };
diff --git a/src/main/service/chatService.ts b/src/main/service/chatService.ts
index 625443fe6..b1cadf304 100644
--- a/src/main/service/chatService.ts
+++ b/src/main/service/chatService.ts
@@ -179,7 +179,7 @@ export class ChatService implements IChatService {
           value: 'processing',
         });
         // streaming falseの場合のメッセージ送信処理
-        const res = await orchestratorAgent.generate(messages, {
+        const res = await orchestratorAgent.generateLegacy(messages, {
           runtimeContext,
           toolsets,
           resourceId: userId,
@@ -278,24 +278,11 @@ export class ChatService implements IChatService {
         messageParams: { detail: '対象メッセージが見つかりません' },
       });
     }
-    // 最初のメッセージからmessageIdに対応するメッセージまでの履歴を取得
-    const history = messages.slice(0, targetMessageIndex);
+    // 対象メッセージを含めたそれ以降のメッセージを抽出
+    const messagesToDelete = messages.slice(targetMessageIndex);
 
-    // スレッドを削除
-    await memory.storage.deleteThread({ threadId });
-
-    // スレッドを再作成
-    // await this.memory.createThread({
-    //   resourceId: 'user',
-    //   title: '',
-    //   threadId,
-    // });
-
-    // 取得した履歴をメモリに保存
-    await memory.saveMessages({
-      messages: history,
-      memoryConfig: undefined,
-    });
+    // 抽出したメッセージを削除
+    await memory.deleteMessages(messagesToDelete.map((msg) => msg.id));
   }
 
   /**
diff --git a/src/main/service/reviewService.ts b/src/main/service/reviewService.ts
index e6e7143b1..f1c458144 100644
--- a/src/main/service/reviewService.ts
+++ b/src/main/service/reviewService.ts
@@ -2,7 +2,7 @@ import { createDataStream } from 'ai';
 // @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
 import { v4 as uuid } from 'uuid';
-import { getReviewRepository } from '@/adapter/db';
+import { getReviewRepository, getSettingsRepository } from '@/adapter/db';
 import {
   ReviewChecklistEdit,
   ReviewChecklistResult,
@@ -14,6 +14,7 @@ import {
   ReviewExecutionResultStatus,
   DocumentMode,
   ProcessingStatus,
+  CsvImportData,
 } from '@/types';
 import { generateReviewTitle } from '@/mastra/workflows/sourceReview/lib';
 import { RevieHistory } from '@/types';
@@ -27,6 +28,7 @@ import { checkWorkflowResult } from '@/mastra/lib/workflowUtils';
 import { formatMessage } from '../lib/messages';
 import { ReviewCacheHelper } from '@/main/lib/utils/reviewCacheHelper';
 import { ReviewChatWorkflowRuntimeContext } from '@/mastra/workflows/reviewChat';
+import { executeReviewWorkflow } from '@/mastra/workflows/sourceReview/executeReview';
 
 export interface IReviewService {
   getReviewHistories(): Promise<RevieHistory[]>;
@@ -83,6 +85,7 @@ export class ReviewService implements IReviewService {
   }
 
   private reviewRepository = getReviewRepository();
+  private settingsRepository = getSettingsRepository();
 
   // 実行中のワークフロー管理
   private runningWorkflows = new Map<string, { cancel: () => void }>();
@@ -219,7 +222,7 @@ export class ReviewService implements IReviewService {
 
   /**
    * CSVファイルからチェックリストを抽出してDBに保存
-   */
+      */
   public async extractChecklistFromCsv(
     reviewHistoryId: string,
     files: UploadFile[],
@@ -243,6 +246,7 @@ export class ReviewService implements IReviewService {
       );
 
       const allChecklistItems: string[] = [];
+      let importedData: CsvImportData | null = null;
 
       // 各CSVファイルを処理
       for (const file of files) {
@@ -250,14 +254,15 @@ export class ReviewService implements IReviewService {
         const extractionResult = await FileExtractor.extractText(file.path);
         const csvText = extractionResult.content;
 
-        // CSVパーサーを使用してセル内改行を保持しつつ1列目を抽出
-        const firstColumnItems = CsvParser.extractFirstColumn(csvText);
+        // 指定フォーマットでパースを試みる（エラーの場合は例外がスローされる）
+        const data = CsvParser.parseImportFormat(csvText);
 
-        // 各項目をチェックリスト項目として追加
-        for (const item of firstColumnItems) {
-          if (item && item.trim() !== '') {
-            allChecklistItems.push(item.trim());
-          }
+        // チェックリスト項目を追加
+        allChecklistItems.push(...data.checklists);
+
+        // 最初のファイルのインポートデータを使用（設定は最初のファイルのものを優先）
+        if (!importedData) {
+          importedData = data;
         }
       }
 
@@ -272,6 +277,58 @@ export class ReviewService implements IReviewService {
           'system',
         );
       }
+
+      // インポートデータがある場合は設定を反映
+      if (importedData) {
+        // 評定設定の更新
+        if (importedData.evaluationSettings) {
+          await this.reviewRepository.updateReviewHistoryEvaluationSettings(
+            reviewHistoryId,
+            importedData.evaluationSettings,
+          );
+        }
+
+        // 追加指示・コメントフォーマットの更新
+        if (
+          importedData.additionalInstructions ||
+          importedData.commentFormat
+        ) {
+          await this.reviewRepository.updateReviewHistoryAdditionalInstructionsAndCommentFormat(
+            reviewHistoryId,
+            importedData.additionalInstructions,
+            importedData.commentFormat,
+          );
+        }
+
+        // AI API設定の更新（settingsRepositoryに保存）
+        if (importedData.apiSettings) {
+          const currentSettings = await this.settingsRepository.getSettings();
+          const updates: { url?: string; key?: string; model?: string } = {};
+
+          if (importedData.apiSettings.url) {
+            updates.url = importedData.apiSettings.url;
+          }
+          if (importedData.apiSettings.key) {
+            updates.key = importedData.apiSettings.key;
+          }
+          if (importedData.apiSettings.model) {
+            updates.model = importedData.apiSettings.model;
+          }
+
+          if (Object.keys(updates).length > 0) {
+            await this.settingsRepository.saveSettings({
+              ...currentSettings,
+              api: {
+                ...currentSettings.api,
+                ...updates,
+              },
+            });
+            // 設定更新イベントを発火
+            publishEvent(IpcChannels.SETTINGS_UPDATED, undefined);
+          }
+        }
+      }
+
       // AI処理と同様のイベント通知を発火
       publishEvent(IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED, {
         reviewHistoryId,
diff --git a/src/main/service/sourceService.ts b/src/main/service/sourceService.ts
index e0603bcfa..9f374efe5 100644
--- a/src/main/service/sourceService.ts
+++ b/src/main/service/sourceService.ts
@@ -222,7 +222,7 @@ export class SourceService implements ISourceService {
             try {
               // Mastraインスタンスからワークフローを取得して実行
               const workflow = mastra.getWorkflow('sourceRegistrationWorkflow');
-              const run = workflow.createRun();
+              const run = await workflow.createRunAsync();
               const result = await run.start({
                 inputData: { filePath },
               });
diff --git a/src/mastra/lib/agentUtils.ts b/src/mastra/lib/agentUtils.ts
index bbcfb0035..dbe27fba1 100644
--- a/src/mastra/lib/agentUtils.ts
+++ b/src/mastra/lib/agentUtils.ts
@@ -1,6 +1,5 @@
 // @ts-ignore
 import { RuntimeContext } from '@mastra/core/runtime-context';
-import { FinishReason } from 'ai';
 import { getSettingsRepository } from '@/adapter/db';
 import { BaseRuntimeContext } from '../agents/types';
 import { AppError, extractAIAPISafeError } from '@/main/lib/error';
@@ -21,10 +20,13 @@ export async function createRuntimeContext<T extends BaseRuntimeContext>() {
 }
 
 // finishreasonを元に正常終了かどうかを判定する関数
-export function judgeFinishReason(finishReason: FinishReason): {
+export function judgeFinishReason(finishReason?: string): {
   success: boolean;
   reason: string;
 } {
+  if (!finishReason) {
+    return { success: true, reason: '不明な終了理由' };
+  }
   switch (finishReason) {
     case 'stop':
       return { success: true, reason: '正常終了' };
diff --git a/src/mastra/lib/workflowUtils.ts b/src/mastra/lib/workflowUtils.ts
index 139f28ee2..ad41a926c 100644
--- a/src/mastra/lib/workflowUtils.ts
+++ b/src/mastra/lib/workflowUtils.ts
@@ -8,7 +8,7 @@ import { getMainLogger } from '@/main/lib/logger';
 const logger = getMainLogger();
 
 // workflowの結果を確認するための関数
-export function checkWorkflowResult(result: WorkflowResult<any, any>): {
+export function checkWorkflowResult(result: WorkflowResult<any, any, any, any>): {
   status: 'success' | 'failed' | 'suspended' | 'canceled';
   errorMessage?: string;
 } {
diff --git a/src/mastra/tools/sourcesTools.ts b/src/mastra/tools/sourcesTools.ts
index ada16b17b..ea8601bcf 100644
--- a/src/mastra/tools/sourcesTools.ts
+++ b/src/mastra/tools/sourcesTools.ts
@@ -165,7 +165,7 @@ export const documentQueryTool = createTool({
 
             runtimeContext.set('documentContent', content);
 
-            const res = await documentExpertAgent.generate(item.query, {
+            const res = await documentExpertAgent.generateLegacy(item.query, {
               abortSignal: options?.abortSignal,
               runtimeContext,
             });
diff --git a/src/mastra/workflows/reviewChat/generateAnswerStep.ts b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
index abe60e6d7..c87dd8d2b 100644
--- a/src/mastra/workflows/reviewChat/generateAnswerStep.ts
+++ b/src/mastra/workflows/reviewChat/generateAnswerStep.ts
@@ -16,10 +16,7 @@ import {
 import { IpcChannels } from '@/types';
 import { publishEvent } from '@/main/lib/eventPayloadHelper';
 import { ReviewChatWorkflowRuntimeContext } from '.';
-import {
-  judgeReviewMode,
-  buildAnswerChecklistInfo,
-} from './lib';
+import { judgeReviewMode, buildAnswerChecklistInfo } from './lib';
 
 const logger = getMainLogger();
 
@@ -70,10 +67,9 @@ export const generateAnswerStep = createStep({
       const reviewMode = judgeReviewMode(checklistResults);
 
       // ドキュメントキャッシュ情報を取得
-      const documentCaches =
-        await reviewRepository.getReviewDocumentCacheByIds(
-          researchResults.map((r) => r.documentCacheId),
-        );
+      const documentCaches = await reviewRepository.getReviewDocumentCacheByIds(
+        researchResults.map((r) => r.documentCacheId),
+      );
 
       // チェックリスト情報の文字列を生成（ヘルパー関数を利用）
       const checklistInfo = buildAnswerChecklistInfo(checklistResults);
@@ -81,7 +77,9 @@ export const generateAnswerStep = createStep({
       // 調査結果を統合
       const researchSummary = researchResults
         .map((result) => {
-          const doc = documentCaches.find((dc) => dc.id === result.documentCacheId);
+          const doc = documentCaches.find(
+            (dc) => dc.id === result.documentCacheId,
+          );
           return `Document: ${doc?.fileName || 'Unknown'}
 Research Findings:
 ${result.researchResult}`;
@@ -99,7 +97,7 @@ ${result.researchResult}`;
 
       // Mastraエージェント経由でストリーミングAI呼び出し
       const answerAgent = mastra.getAgent('reviewChatAnswerAgent');
-      const result = await answerAgent.generate(promptText, {
+      const result = await answerAgent.generateLegacy(promptText, {
         runtimeContext,
         abortSignal,
         onStepFinish: (stepResult) => {
diff --git a/src/mastra/workflows/reviewChat/planResearchStep.ts b/src/mastra/workflows/reviewChat/planResearchStep.ts
index a921ecfbc..62951f829 100644
--- a/src/mastra/workflows/reviewChat/planResearchStep.ts
+++ b/src/mastra/workflows/reviewChat/planResearchStep.ts
@@ -12,10 +12,7 @@ import {
   judgeFinishReason,
 } from '@/mastra/lib/agentUtils';
 import { reviewChatInputSchema } from '.';
-import {
-  judgeReviewMode,
-  buildPlanningChecklistInfo,
-} from './lib';
+import { judgeReviewMode, buildPlanningChecklistInfo } from './lib';
 
 const logger = getMainLogger();
 
@@ -89,7 +86,7 @@ export const planResearchStep = createStep({
 
       // Mastraエージェント経由でAI呼び出し（構造化出力）
       const planningAgent = mastra.getAgent('reviewChatPlanningAgent');
-      const result = await planningAgent.generate(question, {
+      const result = await planningAgent.generateLegacy(question, {
         runtimeContext,
         output: researchTasksSchema,
       });
diff --git a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
index abf69fd8d..c49b8f97a 100644
--- a/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
+++ b/src/mastra/workflows/reviewChat/researchDocument/researchDocumentChunk.ts
@@ -12,10 +12,7 @@ import {
   judgeErrorIsContentLengthError,
 } from '@/mastra/lib/agentUtils';
 import { getReviewRepository } from '@/adapter/db';
-import {
-  judgeReviewMode,
-  buildResearchChecklistInfo,
-} from '../lib';
+import { judgeReviewMode, buildResearchChecklistInfo } from '../lib';
 
 const logger = getMainLogger();
 
@@ -113,7 +110,7 @@ export const researchChunkStep = createStep({
 
       // Mastraエージェント経由でAI呼び出し
       const researchAgent = mastra.getAgent('reviewChatResearchAgent');
-      const result = await researchAgent.generate(
+      const result = await researchAgent.generateLegacy(
         {
           role: 'user',
           content: messageContent,
diff --git a/src/mastra/workflows/sourceRegistration/sourceRegistration.ts b/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
index a69d2f6c9..cae3af6d8 100644
--- a/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
+++ b/src/mastra/workflows/sourceRegistration/sourceRegistration.ts
@@ -22,8 +22,6 @@ const analyzeSourceOutputSchema = baseStepOutputSchema.extend({
   summary: z.string(),
 });
 
-const sourceRepository = getSourceRepository();
-
 // ソース分析と登録のステップ
 const analyzeSourceStep = createStep({
   id: 'analyzeSourceStep',
@@ -31,6 +29,7 @@ const analyzeSourceStep = createStep({
   inputSchema: triggerSchema,
   outputSchema: analyzeSourceOutputSchema,
   execute: async ({ inputData, mastra }) => {
+    const sourceRepository = getSourceRepository();
     // トリガーから変数を取得
     const { filePath } = inputData;
 
@@ -64,10 +63,13 @@ const analyzeSourceStep = createStep({
         summary: z.string(),
       });
 
-      const analysisResult = await summarizeSourceAgent.generate(content, {
-        runtimeContext: await createRuntimeContext(),
-        output: outputSchema,
-      });
+      const analysisResult = await summarizeSourceAgent.generateLegacy(
+        content,
+        {
+          runtimeContext: await createRuntimeContext(),
+          output: outputSchema,
+        },
+      );
 
       const { success, reason } = judgeFinishReason(
         analysisResult.finishReason,
@@ -123,6 +125,7 @@ const extractTopicAndSummaryStep = createStep({
   inputSchema: analyzeSourceOutputSchema,
   outputSchema: baseStepOutputSchema,
   execute: async ({ inputData, getInitData, mastra }) => {
+    const sourceRepository = getSourceRepository();
     const { filePath } = getInitData() as z.infer<typeof triggerSchema>;
     const { sourceId } = inputData;
 
@@ -154,7 +157,7 @@ const extractTopicAndSummaryStep = createStep({
         ),
       });
 
-      const analysisResult = await summarizeTopicAgent.generate(content, {
+      const analysisResult = await summarizeTopicAgent.generateLegacy(content, {
         runtimeContext: await createRuntimeContext(),
         output: outputSchema,
       });
diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
index b25212871..ea51a5b3a 100644
--- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
@@ -118,7 +118,7 @@ const checklistDocumentExtractionStep = createStep({
           await createRuntimeContext<ChecklistExtractionAgentRuntimeContext>();
         // これまでに抽出したチェックリスト項目
         runtimeContext.set('extractedItems', accumulated);
-        const extractionResult = await checklistExtractionAgent.generate(
+        const extractionResult = await checklistExtractionAgent.generateLegacy(
           message,
           {
             output: outputSchema,
@@ -279,11 +279,14 @@ const topicExtractionStep = createStep({
         runtimeContext.set('checklistRequirements', checklistRequirements);
       }
 
-      const extractionResult = await topicExtractionAgent.generate(message, {
-        output: outputSchema,
-        runtimeContext,
-        abortSignal,
-      });
+      const extractionResult = await topicExtractionAgent.generateLegacy(
+        message,
+        {
+          output: outputSchema,
+          runtimeContext,
+          abortSignal,
+        },
+      );
 
       logger.debug(
         `Combined document extracted topics for creating checklist:`,
@@ -358,7 +361,7 @@ const topicChecklistCreationStep = createStep({
         runtimeContext.set('checklistRequirements', checklistRequirements);
       }
 
-      const result = await topicChecklistAgent.generate(message, {
+      const result = await topicChecklistAgent.generateLegacy(message, {
         output: outputSchema,
         runtimeContext,
         abortSignal,
@@ -437,7 +440,7 @@ const topicChecklistCreationStep = createStep({
 
 //       // const allItemsText = allChecklistItems.join('\n- ');
 
-//       // const result = await checklistIntegrationAgent.generate(
+//       // const result = await checklistIntegrationAgent.generateLegacy(
 //       //   allItemsText,
 //       //   {
 //       //     output: outputSchema,
diff --git a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
index e477a12a4..73fb06c6d 100644
--- a/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/classifyChecklistStep.ts
@@ -103,7 +103,7 @@ export const classifyChecklistsByCategoryStep = createStep({
       );
       runtimeContext.set('maxCategories', MAX_CATEGORIES);
       // チェックリスト項目をカテゴリごとに分類
-      const classificationResult = await classifiCategoryAgent.generate(
+      const classificationResult = await classifiCategoryAgent.generateLegacy(
         `checklist items:
   ${checklistData.map((item) => `ID: ${item.id} - ${item.content}`).join('\n')}`,
         {
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
index e1187dce7..5574d6b90 100644
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
@@ -170,7 +170,7 @@ Please provide a consolidated review that synthesizes all individual document re
         runtimeContext.set('checklistItems', targetChecklists);
 
         // 統合レビューエージェントを使用して統合レビューを実行
-        const consolidatedResult = await consolidateAgent.generate(
+        const consolidatedResult = await consolidateAgent.generateLegacy(
           reviewMessage,
           {
             output: outputSchema,
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
index 702e48796..ac4524164 100644
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
@@ -129,7 +129,7 @@ Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${ite
         runtimeContext.set('commentFormat', commentFormat);
 
         // レビューエージェントを使用してレビューを実行
-        const reviewResult = await reviewAgent.generate(reviewMessage, {
+        const reviewResult = await reviewAgent.generateLegacy(reviewMessage, {
           output: outputSchema,
           runtimeContext,
           abortSignal,
diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
index 0b1e0746a..7e4752e0e 100644
--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
@@ -118,11 +118,14 @@ Please review the document against the above checklist items.`;
         };
 
         // レビューエージェントを使用してレビューを実行
-        const reviewResult = await reviewAgent.generate(messageWithReminder, {
-          output: outputSchema,
-          runtimeContext,
-          abortSignal,
-        });
+        const reviewResult = await reviewAgent.generateLegacy(
+          messageWithReminder,
+          {
+            output: outputSchema,
+            runtimeContext,
+            abortSignal,
+          },
+        );
         const { success, reason } = judgeFinishReason(
           reviewResult.finishReason,
         );
diff --git a/src/messages/ja/template.ts b/src/messages/ja/template.ts
index c7392a41e..93aa2b8ed 100644
--- a/src/messages/ja/template.ts
+++ b/src/messages/ja/template.ts
@@ -31,6 +31,7 @@ export const template = {
   REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM: `チェックリストが抽出されませんでした`,
   REVIEW_EXECUTION_NO_TARGET_CHECKLIST: `対象のチェックリストが存在しないためレビューを実行できませんでした`,
   REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR: `CSVファイルからのチェックリスト抽出中に予期せぬエラーが発生しました`,
+  REVIEW_CHECKLIST_EXTRACTION_FILE_IMPORT_ERROR: `チェックリストのインポートに失敗しました\n{detail}`,
   REVIEW_HISTORY_NOT_FOUND: `指定されたレビューの情報を取得できませんでした`,
   AI_API_ERROR: `AIのAPIと通信中にエラーが発生しました\n{detail}`,
   AI_MESSAGE_TOO_LARGE: `AIへの入力データが大きすぎます。入力データを減らしてください。`,
diff --git a/src/renderer/components/chat/ChatArea.tsx b/src/renderer/components/chat/ChatArea.tsx
index 7a0884128..5caaa3bd2 100644
--- a/src/renderer/components/chat/ChatArea.tsx
+++ b/src/renderer/components/chat/ChatArea.tsx
@@ -90,12 +90,14 @@ const customFetch: typeof fetch = async (input, init) => {
           controller.close();
         });
 
-        // 購読完了後にメッセージ送信
-        chatApi.sendMessage(roomId!, messages, {
-          // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
-          showAlert: false,
-          throwError: false,
-        });
+        if (init?.method === 'POST') {
+          // 購読完了後にメッセージ送信
+          chatApi.sendMessage(roomId!, messages, {
+            // 上記onErrorでstreamのエラー処理として処理され、エラーメッセージが表示されるためここでは表示しない
+            showAlert: false,
+            throwError: false,
+          });
+        }
       },
       cancel() {
         unsubscribe();
@@ -361,7 +363,6 @@ const ChatArea: React.FC<ChatAreaProps> = ({
       setEditMessageId('');
       setEditMessageContent('');
       setIsEditHistory(false);
-      reload();
     }
   };
 
diff --git a/src/renderer/components/chat/ChatRoomList.tsx b/src/renderer/components/chat/ChatRoomList.tsx
index d0c4c8d93..f4962a4dd 100644
--- a/src/renderer/components/chat/ChatRoomList.tsx
+++ b/src/renderer/components/chat/ChatRoomList.tsx
@@ -4,6 +4,7 @@ import React, {
   useCallback,
   forwardRef,
   useImperativeHandle,
+  useRef,
 } from 'react';
 import {
   List,
@@ -42,6 +43,8 @@ const ChatRoomList = forwardRef<ChatRoomListRef, ChatRoomListProps>(
     const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
     // メニュー選択中のチャットルームID
     const [activeRoomId, setActiveRoomId] = useState<string | null>(null);
+    // ポーリング用のintervalIdを保持（useEffectの再実行でクリアされないようにする）
+    const intervalIdRef = useRef<ReturnType<typeof setInterval> | null>(null);
 
     // チャットルーム一覧を取得
     const fetchChatRooms = useCallback(async () => {
@@ -63,7 +66,6 @@ const ChatRoomList = forwardRef<ChatRoomListRef, ChatRoomListProps>(
     // 初期データ読み込み
     useEffect(() => {
       setLoading(true);
-      let intervalId: ReturnType<typeof setInterval> | null = null;
 
       const loadChatRooms = async () => {
         try {
@@ -71,15 +73,15 @@ const ChatRoomList = forwardRef<ChatRoomListRef, ChatRoomListProps>(
           setLoading(false);
 
           // 読み込み成功したらポーリングを停止
-          if (intervalId) {
-            clearInterval(intervalId);
-            intervalId = null;
+          if (intervalIdRef.current) {
+            clearInterval(intervalIdRef.current);
+            intervalIdRef.current = null;
           }
         } catch (error) {
           console.error('チャットルーム読み込みに失敗しました:', error);
           // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
-          if (!intervalId) {
-            intervalId = setInterval(loadChatRooms, 5000);
+          if (!intervalIdRef.current) {
+            intervalIdRef.current = setInterval(loadChatRooms, 5000);
           }
         }
       };
@@ -89,8 +91,9 @@ const ChatRoomList = forwardRef<ChatRoomListRef, ChatRoomListProps>(
 
       // クリーンアップでポーリング停止
       return () => {
-        if (intervalId) {
-          clearInterval(intervalId);
+        if (intervalIdRef.current) {
+          clearInterval(intervalIdRef.current);
+          intervalIdRef.current = null;
         }
       };
     }, [fetchChatRooms]);
diff --git a/src/renderer/components/common/SettingsModal.tsx b/src/renderer/components/common/SettingsModal.tsx
index 335ef9d7a..5f0fa52dc 100644
--- a/src/renderer/components/common/SettingsModal.tsx
+++ b/src/renderer/components/common/SettingsModal.tsx
@@ -114,7 +114,7 @@ const SettingsModal: React.FC<SettingsModalProps> = ({
             />
             <TextField
               fullWidth
-              label="モデル名"
+              label="BPR ID"
               value={settings.api.model}
               disabled={loading || saving}
               onChange={(e) => handleChange('api', 'model', e.target.value)}
diff --git a/src/renderer/components/common/SourceListModal.tsx b/src/renderer/components/common/SourceListModal.tsx
index 925d17174..a79c6f5b6 100644
--- a/src/renderer/components/common/SourceListModal.tsx
+++ b/src/renderer/components/common/SourceListModal.tsx
@@ -147,6 +147,7 @@ function SourceListModal({
     // 各ソースの状態を更新
     targetSources.forEach(async (source) => {
       try {
+        console.log(`Updating source ${source.id} to ${newValue}`);
         const sourceApi = SourceApi.getInstance();
         await sourceApi.updateSourceEnabled(source.id, newValue, {
           showAlert: true,
diff --git a/src/renderer/components/review/ReviewArea.tsx b/src/renderer/components/review/ReviewArea.tsx
index 0d2472cbb..f13b364bc 100644
--- a/src/renderer/components/review/ReviewArea.tsx
+++ b/src/renderer/components/review/ReviewArea.tsx
@@ -98,6 +98,21 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
     }
   }, [selectedReviewHistoryId]);
 
+  // レビュー設定（追加指示・コメントフォーマット・評定設定）の再取得
+  const fetchReviewSettings = useCallback(async () => {
+    if (!selectedReviewHistoryId) return;
+    const reviewApi = ReviewApi.getInstance();
+    const result = await reviewApi.getReviewInstruction(
+      selectedReviewHistoryId,
+      { throwError: true, showAlert: false },
+    );
+    setAdditionalInstructions(result?.additionalInstructions || '');
+    setCommentFormat(result?.commentFormat || defaultCommentFormat);
+    setEvaluationSettings(
+      result?.evaluationSettings || defaultEvaluationSettings,
+    );
+  }, [selectedReviewHistoryId]);
+
   // チェックリスト抽出完了の共通処理ハンドラー
   const handleChecklistExtractionFinished = useCallback(
     (payload: {
@@ -122,6 +137,11 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
       });
 
       if (payload.status === 'success') {
+        // CSVインポート等で設定が更新された可能性があるため、レビュー設定も再取得
+        fetchReviewSettings().catch((error) => {
+          console.error('レビュー設定の再取得に失敗しました:', error);
+        });
+
         addAlert({
           message: 'チェックリストの抽出が完了しました',
           severity: 'success',
@@ -140,7 +160,12 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
 
       setIsExtracting(false);
     },
-    [selectedReviewHistoryId, fetchChecklistResults, addAlert],
+    [
+      selectedReviewHistoryId,
+      fetchChecklistResults,
+      fetchReviewSettings,
+      addAlert,
+    ],
   );
 
   // レビュー実行完了の共通処理ハンドラー
@@ -722,6 +747,7 @@ const ReviewArea: React.FC<ReviewAreaProps> = ({ selectedReviewHistoryId }) => {
                 isLoading={isExtracting || isReviewing}
                 onSave={handleSaveChecklist}
                 targetDocumentName={targetDocumentName}
+                selectedReviewHistoryId={selectedReviewHistoryId || undefined}
               />
             </Paper>
 
diff --git a/src/renderer/components/review/ReviewChecklistSection.tsx b/src/renderer/components/review/ReviewChecklistSection.tsx
index 7b00c802b..a719b60c2 100644
--- a/src/renderer/components/review/ReviewChecklistSection.tsx
+++ b/src/renderer/components/review/ReviewChecklistSection.tsx
@@ -23,12 +23,16 @@ import SaveIcon from '@mui/icons-material/Save';
 import CancelIcon from '@mui/icons-material/Cancel';
 import FileDownloadIcon from '@mui/icons-material/FileDownload';
 import { ReviewEvaluation } from '@/types';
-import { ReviewChecklistSectionProps } from './types';
+import { ReviewApi } from '@/renderer/service/reviewApi';
+import { SettingsApi } from '@/renderer/service/settingsApi';
+import { useAlertStore } from '@/renderer/stores/alertStore';
+import { getSafeErrorMessage } from '../../lib/error';
 import {
   convertReviewResultsToCSV,
   downloadCSV,
   generateCSVFilename,
 } from '../../lib/csvUtils';
+import { ReviewChecklistSectionProps } from './types';
 
 // 評価ごとの色マッピング（デフォルト）
 const defaultEvaluationColors = {
@@ -59,6 +63,7 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
   isLoading,
   onSave,
   targetDocumentName,
+  selectedReviewHistoryId,
 }) => {
   // --- ステート ---
   const [editingId, setEditingId] = useState<number | null>(null);
@@ -68,6 +73,8 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
   const [sortBy, setSortBy] = useState<string | null>(null);
   const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
 
+  const addAlert = useAlertStore((state) => state.addAlert);
+
   // --- ハンドラ ---
   const handleStartEdit = (id: number, content: string) => {
     setEditingId(id);
@@ -105,10 +112,51 @@ const ReviewChecklistSection: React.FC<ReviewChecklistSectionProps> = ({
   };
 
   // CSV出力ハンドラ
-  const handleExportCSV = () => {
-    const csvContent = convertReviewResultsToCSV(checklistResults);
-    const filename = generateCSVFilename();
-    downloadCSV(csvContent, filename);
+  const handleExportCSV = async () => {
+    try {
+      // レビュー履歴情報を取得
+      let reviewHistory = null;
+      if (selectedReviewHistoryId) {
+        const reviewApi = ReviewApi.getInstance();
+        reviewHistory = await reviewApi.getHistoryById(
+          selectedReviewHistoryId,
+          {
+            showAlert: false,
+            throwError: false,
+          },
+        );
+      }
+
+      // API設定を取得
+      const settingsApi = SettingsApi.getInstance();
+      const settings = await settingsApi.getSettings();
+      const apiSettings = settings?.api
+        ? {
+            url: settings.api.url,
+            key: settings.api.key,
+            model: settings.api.model,
+          }
+        : undefined;
+
+      // CSV生成
+      const csvContent = convertReviewResultsToCSV(
+        checklistResults,
+        reviewHistory,
+        apiSettings,
+      );
+      const filename = generateCSVFilename();
+      downloadCSV(csvContent, filename);
+    } catch (error) {
+      addAlert({
+        message: getSafeErrorMessage(error),
+        severity: 'error',
+      });
+      console.error('CSV出力エラー:', error);
+      // エラーが発生しても最低限のCSVは出力
+      const csvContent = convertReviewResultsToCSV(checklistResults);
+      const filename = generateCSVFilename();
+      downloadCSV(csvContent, filename);
+    }
   };
 
   // --- ソート ---
diff --git a/src/renderer/components/review/ReviewSourceModal.tsx b/src/renderer/components/review/ReviewSourceModal.tsx
index 8260f0696..9fd87f3b2 100644
--- a/src/renderer/components/review/ReviewSourceModal.tsx
+++ b/src/renderer/components/review/ReviewSourceModal.tsx
@@ -34,6 +34,7 @@ import {
   ViewStream as PagesIcon,
   Add as AddIcon,
   ExpandMore as ExpandMoreIcon,
+  Download as DownloadIcon,
 } from '@mui/icons-material';
 import Backdrop from '@mui/material/Backdrop';
 import {
@@ -105,13 +106,50 @@ const getAlertMessage = ({
       <>
         ファイルを選択してチェックリスト抽出を実行できます
         <br />
-        {documentType === 'checklist-csv'
-          ? '選択したExcelまたはCSVファイルの一列目の値を全てチェックリスト項目として抽出します'
-          : documentType === 'checklist-ai'
-            ? '選択されたチェックリストドキュメントから、AIが既存のチェック項目を抽出できます'
-            : '選択された一般ドキュメントから、AIがレビュー用のチェックリストを新規作成できます'}
-        <br />
-        複数ファイルを選択した場合、選択した順番で結合され一つのドキュメントとして扱われます
+        {documentType === 'checklist-csv' ? (
+          <>
+            選択したExcelまたはCSVファイルから以下の情報をインポートすることができます：
+            <br />
+            ・チェックリスト項目
+            <br />
+            ・評定設定（評定ラベルと説明）
+            <br />
+            ・追加指示・コメントフォーマット
+            <br />
+            ・AI API設定（エンドポイント、APIキー、BPR ID）
+            <br />
+            <br />
+            <strong>ファイル形式:</strong>
+            <br />
+            1行目:
+            ヘッダ行（チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI
+            APIエンドポイント,AI APIキー,BPR ID）：必須
+            <br />
+            2行目以降: データ行：任意
+            <br />
+            ※
+            <br />
+            ・チェックリスト列に値がある場合→チェックリスト項目として認識
+            <br />
+            ・評定ラベル列＋評定説明列の両方に値がある場合→評定設定値として認識
+            <br />
+            ・追加指示・コメントフォーマット・AI
+            API・BPR ID列に値がある場合→各種設定値として認識
+            <br />
+            ・空セルは無視
+            <br />
+          </>
+        ) : documentType === 'checklist-ai' ? (
+          '選択されたチェックリストドキュメントから、AIが既存のチェック項目を抽出できます'
+        ) : (
+          '選択された一般ドキュメントから、AIがレビュー用のチェックリストを新規作成できます'
+        )}
+        {documentType !== 'checklist-csv' && (
+          <>
+            <br />
+            複数ファイルを選択した場合、選択した順番で結合され一つのドキュメントとして扱われます
+          </>
+        )}
         <br />
         ※
         <br />
@@ -185,6 +223,38 @@ function ReviewSourceModal({
 
   const addAlert = useAlertStore((state) => state.addAlert);
 
+  // テンプレートCSVダウンロード
+  const handleDownloadTemplate = () => {
+    // テンプレートCSVの内容を生成
+    const templateLines = [
+      // ヘッダ行
+      'チェックリスト,評定ラベル,評定説明,追加指示,コメントフォーマット,AI APIエンドポイント,AI APIキー,BPR ID',
+      // データ行
+      'チェックリストサンプル1,A,基準を完全に満たしている,レビューは厳格に実施してください。,"【評価理由・根拠】\n（具体的な理由と根拠を記載）\n\n【改善提案】\n（改善のための具体的な提案を記載）",http://localhost:11434/v1,your-api-key,llama3',
+      'チェックリストサンプル2,B,基準をある程度満たしている,,,,',
+      'チェックリストサンプル3,C,基準を満たしていない,,,,',
+      ',-,評価の対象外、または評価できない,,,,,',
+    ];
+
+    const csvContent = templateLines.join('\n');
+
+    // BOM付きでダウンロード
+    const BOM = '\uFEFF';
+    const csvWithBOM = BOM + csvContent;
+    const blob = new Blob([csvWithBOM], { type: 'text/csv;charset=utf-8;' });
+    const url = URL.createObjectURL(blob);
+
+    const link = document.createElement('a');
+    link.href = url;
+    link.download = 'チェックリストインポートテンプレート.csv';
+    document.body.appendChild(link);
+    link.click();
+
+    // クリーンアップ
+    document.body.removeChild(link);
+    URL.revokeObjectURL(url);
+  };
+
   // modalMode, selectedReviewHistoryIdが変わったときに初期化し、保存された値を取得
   useEffect(() => {
     const loadSavedData = async () => {
@@ -628,11 +698,25 @@ function ReviewSourceModal({
                     value="checklist-csv"
                     control={<Radio />}
                     label={
-                      <Tooltip title="選択したファイル(Excel,CSV)の一列目の値を全てチェックリスト項目として抽出します">
+                      <Box
+                        sx={{ display: 'flex', alignItems: 'center', gap: 1 }}
+                      >
                         <span>
                           チェックリストドキュメント（ファイルインポート）
                         </span>
-                      </Tooltip>
+                        <Tooltip title="インポート用テンプレートファイルをダウンロード">
+                          <IconButton
+                            size="small"
+                            onClick={(e) => {
+                              e.stopPropagation();
+                              handleDownloadTemplate();
+                            }}
+                            disabled={processing}
+                          >
+                            <DownloadIcon fontSize="small" />
+                          </IconButton>
+                        </Tooltip>
+                      </Box>
                     }
                     disabled={processing}
                   />
diff --git a/src/renderer/components/review/types.ts b/src/renderer/components/review/types.ts
index 1f662086c..e124122cf 100644
--- a/src/renderer/components/review/types.ts
+++ b/src/renderer/components/review/types.ts
@@ -19,6 +19,7 @@ export interface ReviewChecklistSectionProps {
   isLoading: boolean;
   onSave: (checklists: ReviewChecklistEdit[]) => Promise<void>;
   targetDocumentName?: string | null;
+  selectedReviewHistoryId?: string;
 }
 
 // ReviewSourceModalのProps型
diff --git a/src/renderer/hooks/useSettings.ts b/src/renderer/hooks/useSettings.ts
index 60068c0ba..a4353d4bb 100644
--- a/src/renderer/hooks/useSettings.ts
+++ b/src/renderer/hooks/useSettings.ts
@@ -5,11 +5,13 @@ import {
   type Settings,
   type ValidationState,
   type ValidationError,
+  IpcChannels,
 } from '@/types';
 import { SettingsApi } from '../service/settingsApi';
 import { useAgentStatusStore } from '../stores/agentStatusStore';
 import { useAlertStore } from '../stores/alertStore';
 import { getSafeErrorMessage, internalError } from '../lib/error';
+import { usePushChannel } from './usePushChannel';
 
 type AppSettings = Omit<Settings, 'mcp'> & {
   mcp: { serverConfig: string | undefined };
@@ -130,34 +132,41 @@ const useSettingsStore = () => {
     [],
   );
 
-  // 設定値の読み込み
+  /**
+   * 設定値を読み込む関数
+   */
+  const loadSettings = useCallback(async () => {
+    const loadedSettings = await settingsApi.getSettings({
+      showAlert: false,
+      throwError: true,
+    });
+
+    if (loadedSettings) {
+      const loadedAppSettings = {
+        ...loadedSettings,
+        mcp: {
+          serverConfig: loadedSettings.mcp.serverConfig
+            ? JSON.stringify(loadedSettings.mcp.serverConfig, null, 2)
+            : undefined,
+        },
+      };
+      setSettings(loadedAppSettings);
+
+      // 各セクションのバリデーションを実行
+      Object.entries(loadedAppSettings).forEach(([section, value]) => {
+        validateSection(section as keyof AppSettings, value);
+      });
+    }
+  }, [settingsApi, validateSection]);
+
+  // 設定値の初回読み込み
   useEffect(() => {
     setLoading(true);
     let intervalId: ReturnType<typeof setInterval> | null = null;
 
-    const loadSettings = async () => {
+    const loadSettingsWithRetry = async () => {
       try {
-        const loadedSettings = await settingsApi.getSettings({
-          showAlert: false,
-          throwError: true,
-        });
-
-        if (loadedSettings) {
-          const loadedAppSettings = {
-            ...loadedSettings,
-            mcp: {
-              serverConfig: loadedSettings.mcp.serverConfig
-                ? JSON.stringify(loadedSettings.mcp.serverConfig, null, 2)
-                : undefined,
-            },
-          };
-          setSettings(loadedAppSettings);
-
-          // 各セクションのバリデーションを実行
-          Object.entries(loadedAppSettings).forEach(([section, value]) => {
-            validateSection(section as keyof AppSettings, value);
-          });
-        }
+        await loadSettings();
 
         setLoading(false);
 
@@ -170,13 +179,13 @@ const useSettingsStore = () => {
         console.error('設定の読み込みに処理失敗しました:', err);
         // 失敗時はポーリングを継続（既に設定済みの場合は何もしない）
         if (!intervalId) {
-          intervalId = setInterval(loadSettings, 5000);
+          intervalId = setInterval(loadSettingsWithRetry, 5000);
         }
       }
     };
 
     // 初回読み込み
-    loadSettings();
+    loadSettingsWithRetry();
 
     // クリーンアップでポーリング停止
     return () => {
@@ -184,7 +193,14 @@ const useSettingsStore = () => {
         clearInterval(intervalId);
       }
     };
-  }, [validateSection]);
+  }, [loadSettings]);
+
+  // SETTINGS_UPDATEDイベント購読
+  usePushChannel(IpcChannels.SETTINGS_UPDATED, () => {
+    loadSettings().catch((error) => {
+      console.error('設定の再読み込みに失敗しました:', error);
+    });
+  });
 
   // エージェント状態の初回ポーリング処理（エラーが発生しなくなるまでポーリング継続）
   useEffect(() => {
diff --git a/src/renderer/lib/csvUtils.ts b/src/renderer/lib/csvUtils.ts
index c5aac8405..a0fb86f4d 100644
--- a/src/renderer/lib/csvUtils.ts
+++ b/src/renderer/lib/csvUtils.ts
@@ -1,4 +1,8 @@
-import { ReviewChecklistResult } from '@/types';
+import {
+  ReviewChecklistResult,
+  CustomEvaluationSettings,
+  RevieHistory,
+} from '@/types';
 
 /**
  * CSV用文字列のエスケープ処理
@@ -27,33 +31,59 @@ const escapeCSVField = (field: string): string => {
 };
 
 /**
- * レビュー結果データをCSV形式に変換
+ * レビュー結果データを新フォーマットのCSV形式に変換
+ * チェックリスト、評定結果、レビュー結果、評定設定、追加指示、コメントフォーマット、AI API設定を含める
  */
 export const convertReviewResultsToCSV = (
   checklistResults: ReviewChecklistResult[],
+  reviewHistory?: RevieHistory | null,
+  apiSettings?: { url?: string; key?: string; model?: string },
 ): string => {
-  if (!checklistResults || checklistResults.length === 0) {
-    return 'チェックリスト\n';
-  }
-
   // ヘッダー行を構築
-  const headers = ['チェックリスト', '評価', 'コメント'];
+  const headers = [
+    'チェックリスト',
+    '評定結果',
+    'レビュー結果',
+    '評定ラベル',
+    '評定説明',
+    '追加指示',
+    'コメントフォーマット',
+    'AI APIエンドポイント',
+    'AI APIキー',
+    'BPR ID',
+  ];
 
   const csvRows: string[] = [];
 
   // ヘッダー行を追加
   csvRows.push(headers.map(escapeCSVField).join(','));
 
-  // データ行を追加
-  checklistResults.forEach((checklist) => {
+  // 評定設定を取得
+  const evaluationItems = reviewHistory?.evaluationSettings?.items || [];
+
+  // チェックリスト数と評定設定数の最大値を取得
+  const maxRows = Math.max(checklistResults.length, evaluationItems.length);
+
+  // データ行を構築
+  for (let i = 0; i < maxRows; i++) {
+    const checklist = i < checklistResults.length ? checklistResults[i] : null;
+    const evaluationItem = i < evaluationItems.length ? evaluationItems[i] : null;
+
     const row: string[] = [
-      checklist.content,
-      checklist.sourceEvaluation?.evaluation || '',
-      checklist.sourceEvaluation?.comment || '',
+      checklist?.content || '', // チェックリスト
+      checklist?.sourceEvaluation?.evaluation || '', // 評定結果（新規追加）
+      checklist?.sourceEvaluation?.comment || '', // レビュー結果（新規追加）
+      evaluationItem?.label || '', // 評定ラベル
+      evaluationItem?.description || '', // 評定説明
+      i === 0 ? (reviewHistory?.additionalInstructions || '') : '', // 追加指示（1行目のみ）
+      i === 0 ? (reviewHistory?.commentFormat || '') : '', // コメントフォーマット（1行目のみ）
+      i === 0 ? (apiSettings?.url || '') : '', // AI APIエンドポイント（1行目のみ）
+      i === 0 ? (apiSettings?.key || '') : '', // AI APIキー（1行目のみ）
+      i === 0 ? (apiSettings?.model || '') : '', // BPR ID（1行目のみ）
     ];
 
     csvRows.push(row.map(escapeCSVField).join(','));
-  });
+  }
 
   return csvRows.join('\n');
 };
diff --git a/src/types/ipc.ts b/src/types/ipc.ts
index b08321738..ccdf39fa5 100644
--- a/src/types/ipc.ts
+++ b/src/types/ipc.ts
@@ -34,6 +34,7 @@ export const IpcChannels = {
   GET_SETTINGS_STATUS: 'get-settings-status',
   SETTINGS_STATUS_CHANGED: 'settings-status-changed',
   SETTINGS_UPDATE_FINISHED: 'settings-update-finished', // 設定更新処理が完了した際の通知
+  SETTINGS_UPDATED: 'settings-updated', // 設定が更新された際の通知
   REINITIALIZE_SETTINGS: 'reinitialize-settings',
   REMOVE_SETTINGS_MESSAGE: 'remove-settings-message',
 
@@ -225,6 +226,7 @@ export type IpcEventPayloadMap = {
   [IpcChannels.CHAT_COMPLETE]: unknown;
   [IpcChannels.CHAT_ERROR]: { message: string };
   [IpcChannels.SETTINGS_UPDATE_FINISHED]: { success: boolean; error?: string }; // 設定更新処理完了通知
+  [IpcChannels.SETTINGS_UPDATED]: undefined;
   [IpcChannels.SOURCE_RELOAD_FINISHED]: { success: boolean; error?: string }; // ドキュメント更新処理完了通知
   [IpcChannels.REVIEW_EXTRACT_CHECKLIST_FINISHED]: {
     reviewHistoryId: string;
diff --git a/src/types/message.ts b/src/types/message.ts
index 86e207ada..f6c1eb7f3 100644
--- a/src/types/message.ts
+++ b/src/types/message.ts
@@ -21,6 +21,7 @@ export type MessageCode =
   | 'REVIEW_CHECKLIST_EXTRACTION_NOT_CHECKLIST_DOCUMENT'
   | 'REVIEW_CHECKLIST_EXTRACTION_NO_CHECKLIST_ITEM'
   | 'REVIEW_CHECKLIST_EXTRACTION_FROM_CSV_ERROR'
+  | 'REVIEW_CHECKLIST_EXTRACTION_FILE_IMPORT_ERROR'
   | 'REVIEW_EXECUTION_ERROR'
   | 'REVIEW_EXECUTION_NO_TARGET_CHECKLIST'
   | 'REVIEW_HISTORY_NOT_FOUND'
diff --git a/src/types/review.ts b/src/types/review.ts
index 8585185ce..b76228880 100644
--- a/src/types/review.ts
+++ b/src/types/review.ts
@@ -122,3 +122,17 @@ export interface ReviewLargedocumentResultCache {
   chunkIndex: number; // 何番目のチャンクか（0から始まる）
   individualFileName: string; // 分割後の個別ドキュメント名（"xxx (part 1)" など）
 }
+
+// CSV/Excelインポートデータの型定義
+export interface CsvImportData {
+  checklists: string[]; // チェックリスト項目の配列
+  evaluationSettings?: CustomEvaluationSettings; // 評定設定
+  additionalInstructions?: string; // 追加指示
+  commentFormat?: string; // コメントフォーマット
+  apiSettings?: {
+    // AI API設定
+    url?: string;
+    key?: string;
+    model?: string;
+  };
+}
