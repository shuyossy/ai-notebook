diff --git a/CLAUDE.md b/CLAUDE.md
index ddfa22d20..a747f0b42 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -203,9 +203,29 @@ ElectronのIPCを使用してフロントエンド・バックエンド間の通
 
 
 ## 依頼タスク
-- チェックリスト結果の表のヘッダーは、複数ファイルがレビュー対象として選択された場合は、それぞれのファイル名を`/`で結合した文字列となるが、大量ファイルが選択された場合、ヘッダが巨大にならないようにする
-  - 適切にスクロール表示されるようにする(最大3行くらいかな)
+- 大量ドキュメントレビュー機能におけるworkflow処理の変更
+  - 目的
+    - 処理の効率化（ASISのままだと処理が全然終わらない）
+  - ASIS
+    - まず、個々のドキュメントに対してトピックとそのトピックの要約を生成する
+    - チェックリストをレビューするために、個々のドキュメントに対する質問とその応答をそれぞれ十分だと判断されるまで生成させる
+    - 最終的にトピック・要約、質問・応答を全てレビュー用AIの入力コンテキストに与えてレビューさせる
+  - TOBE
+    - 個々のドキュメントに対して、レビュー対象チェックリストを基にレビューを実施させる
+      - ドキュメントがAIの入力コンテキストに収まらなかった場合は適宜ドキュメントを分割する
+    - 最終的に全てのドキュメントのレビュー結果を合わせて、それを統合してドキュメント全体としてのレビュー結果を出力させる
+
+### （依頼タスクの）残タスク
+- workflowは実装済み(`src/mastra/workflows/sourceReview/executeReview/largeDocumentReview`)
+- workflow内で利用するエージェントの実装は未済
+  - ただし、runtimeContextは定義済み
 
 ### タスク実装時の注意点
-- 該当コンポーネント：`src/renderer/components/review/ReviewChecklistSection.tsx`
+- 実装済みworkflowをよく理解した上で、目的(最高のドキュメントレビュー)を達成するための最適なプロンプトを作成すること
+  - workflow全体としてより良い結果が出るようなプロンプトを意識すること
+- 個々のドキュメントに対してレビューする際のAIエージェント(特にそのシステムプロンプト)については以下を意識すること
+  - 大量ドキュメントレビュー機能により、ドキュメントの一部が与えられていることを理解させること
+  - 後にドキュメント全体のレビューを実行させる際に参考となるように、最終的なチェックリストレビューに役立つ情報は全てコメントに反映させること。
+  - additionalInstructionなどruntimeContextから取得できる変数も考慮しながらレビューさせること
+  - その他、レビュー時の重要な観点や指示については既存のシステムプロンプト(getReviewAnswerQuestionPrompt,getLargeDocumentReviewExecutionPrompt)を参考にすること
 - 複雑な処理なので、十分に思考して実装すること
diff --git a/src/mastra/agents/prompts.ts b/src/mastra/agents/prompts.ts
index 335b6d0dd..8c0ae3dd6 100644
--- a/src/mastra/agents/prompts.ts
+++ b/src/mastra/agents/prompts.ts
@@ -11,6 +11,8 @@ import {
   ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
   ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
   ReviewAnswerQuestionAgentRuntimeContext,
+  IndividualDocumentReviewAgentRuntimeContext,
+  ConsolidateReviewAgentRuntimeContext,
 } from './workflowAgents';
 
 /**
@@ -727,3 +729,182 @@ ${additionalInstructions}
 }
 Please ensure clarity, conciseness, and a professional tone. Write comments that appear natural and comprehensive, as if you directly reviewed the complete original document.`;
 }
+
+// 個別ドキュメントレビュー用のプロンプト
+export function getIndividualDocumentReviewPrompt({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<IndividualDocumentReviewAgentRuntimeContext>;
+}): string {
+  const checklistItems = runtimeContext.get('checklistItems');
+  const additionalInstructions = runtimeContext.get('additionalInstructions');
+  const commentFormat = runtimeContext.get('commentFormat');
+
+  // Build a human-readable list of checklist items
+  const formattedList = checklistItems
+    .map((item) => `ID: ${item.id} - ${item.content}`)
+    .join('\n');
+
+  // デフォルトのフォーマット
+  const defaultFormat = `【評価理由・根拠】
+   Provide the reasoning and evidence here (cite specific sections or examples in the document).
+
+   【改善提案】
+   Provide actionable suggestions here (how to better satisfy the criterion).`;
+
+  const actualFormat =
+    commentFormat && commentFormat.trim() !== ''
+      ? commentFormat
+      : defaultFormat;
+
+  return `You are a professional document reviewer specializing in individual document analysis. Your task is to review a single document (or document part) against specified checklist items.
+
+IMPORTANT CONTEXT:
+- You are reviewing part of a LARGER DOCUMENT SET that may be split across multiple parts due to length constraints
+- This document part you're reviewing is one portion of the complete documentation
+- Your evaluation will later be consolidated with other document parts to form a comprehensive review
+- Include ALL relevant information in your comments that will help in final consolidation
+
+DOCUMENT PART CONTEXT:
+- If the document name contains "(part X)" or similar indicators, you are reviewing a split portion
+- Focus on what's available in this specific part while being aware it's part of a larger whole
+- Look for incomplete information that might be continued in other parts
+
+Checklist items to evaluate:
+${formattedList}
+
+REVIEW INSTRUCTIONS:
+1. Carefully analyze the provided document content against each checklist item
+2. For each item, write a detailed comment in Japanese following this format:
+
+${actualFormat}
+
+3. For each checklist item, specify the review sections that should be examined:
+   a) Identify the specific file names or document sections reviewed
+   b) List the relevant sections within the document part
+4. In your comments, ensure to:
+   a) Cite specific parts of the document as evidence (use section names, chapter titles, page references)
+   b) Be comprehensive about what you found in THIS document part
+   c) Note if information appears incomplete (might continue in other parts)
+   d) Document ALL relevant findings - don't summarize or omit details
+   e) Include information that will be valuable for final consolidation across all document parts
+5. Important for consolidation: Your comments should provide sufficient detail so that:
+   - A consolidation agent can understand what was found in this specific part
+   - Missing or partial information can be identified and addressed
+   - The relationship between this part and the overall document assessment is clear
+${
+  additionalInstructions && additionalInstructions.trim() !== ''
+    ? `
+
+Special Instructions:
+${additionalInstructions}
+`
+    : ``
+}
+
+Remember: Your thorough analysis of this document part is crucial for achieving an excellent final consolidated review. Include all relevant details that will contribute to the overall document assessment.`;
+}
+
+// レビュー結果統合用のプロンプト
+export function getConsolidateReviewPrompt({
+  runtimeContext,
+}: {
+  runtimeContext: RuntimeContext<ConsolidateReviewAgentRuntimeContext>;
+}): string {
+  const checklistItems = runtimeContext.get('checklistItems');
+  const additionalInstructions = runtimeContext.get('additionalInstructions');
+  const commentFormat = runtimeContext.get('commentFormat');
+  const evaluationSettings = runtimeContext.get('evaluationSettings');
+
+  // Build a human-readable list of checklist items
+  const formattedList = checklistItems
+    .map((item) => `ID: ${item.id} - ${item.content}`)
+    .join('\n');
+
+  // デフォルトのフォーマット
+  const defaultFormat = `【評価理由・根拠】
+   Provide the reasoning and evidence here (cite specific sections or examples in the document).
+
+   【改善提案】
+   Provide actionable suggestions here (how to better satisfy the criterion).`;
+
+  const actualFormat =
+    commentFormat && commentFormat.trim() !== ''
+      ? commentFormat
+      : defaultFormat;
+
+  // 評定項目の設定を構築
+  let evaluationInstructions = '';
+  if (
+    evaluationSettings &&
+    evaluationSettings.items &&
+    evaluationSettings.items.length > 0
+  ) {
+    // カスタム評定項目を使用
+    const evaluationList = evaluationSettings.items
+      .map((item) => `   - ${item.label}: ${item.description}`)
+      .join('\n');
+    evaluationInstructions = `1. For each checklist item, assign one of these ratings:\n${evaluationList}`;
+  } else {
+    // デフォルト評定項目を使用
+    evaluationInstructions = `1. For each checklist item, assign one of these ratings:
+   - A: 基準を完全に満たしている
+   - B: 基準を一部満たしている
+   - C: 基準を満たしていない
+   - –: 評価の対象外、または評価できない`;
+  }
+
+  return `You are a senior document reviewer specializing in consolidating individual document reviews into comprehensive final assessments.
+
+CONSOLIDATION CONTEXT:
+- You are reviewing multiple individual document review results from different parts of a document set
+- Each individual review provides detailed analysis of specific document portions
+- Your task is to synthesize these individual reviews into a unified, comprehensive assessment
+- Some documents may have been split into parts due to length constraints
+
+Checklist items for final evaluation:
+${formattedList}
+
+CONSOLIDATION INSTRUCTIONS:
+${evaluationInstructions}
+2. For each item, write a consolidated comment in Japanese following this format:
+
+${actualFormat}
+
+3. Consolidation methodology:
+   a) Analyze all individual review results for each checklist item
+   b) Synthesize findings across all document parts into a unified assessment
+   c) Resolve any apparent contradictions by considering the full context
+   d) Ensure the final rating reflects the overall document set performance
+   e) Combine evidence from all parts to create comprehensive justification
+
+4. In your consolidated comments, ensure to:
+   a) Reference specific sections across ALL reviewed documents/parts using ORIGINAL FILE NAMES
+   b) Provide a holistic view that considers the entire document set
+   c) Highlight both strengths and weaknesses found across all parts
+   d) Give actionable improvement suggestions based on the complete analysis
+   e) Write as if you reviewed the complete original document set directly
+   f) Always use the original file names when mentioning documents in your consolidated comments
+
+5. Rating assignment logic:
+   - Consider the cumulative evidence from all document parts
+   - If different parts show varying compliance levels, weigh them appropriately
+   - Prioritize the overall ability to meet the checklist criterion across the entire document set
+   - Document any significant variations between different document sections
+
+6. Final comment quality standards:
+   - Must appear as a natural, comprehensive review of the complete document set
+   - Should not reveal the internal consolidation process
+   - Should demonstrate thorough understanding of the entire document scope
+${
+  additionalInstructions && additionalInstructions.trim() !== ''
+    ? `
+
+Special Instructions:
+${additionalInstructions}
+`
+    : ``
+}
+
+Your consolidated review represents the final authoritative assessment. Ensure it provides comprehensive, actionable insights that reflect a complete understanding of the entire document set.`;
+}
diff --git a/src/mastra/agents/workflowAgents.ts b/src/mastra/agents/workflowAgents.ts
index a885d7a8b..cd7b62bfd 100644
--- a/src/mastra/agents/workflowAgents.ts
+++ b/src/mastra/agents/workflowAgents.ts
@@ -17,6 +17,8 @@ import {
   getReviewReadinessFirstRunPrompt,
   getReviewCheckReadinessSubsequentPrompt,
   getReviewAnswerQuestionPrompt,
+  getIndividualDocumentReviewPrompt,
+  getConsolidateReviewPrompt,
 } from './prompts';
 import { getOpenAICompatibleModel } from './model/openAICompatible';
 import { BaseRuntimeContext } from './types';
@@ -62,6 +64,19 @@ export type ReviewAnswerQuestionAgentRuntimeContext = BaseRuntimeContext & {
   checklistItems: { id: number; content: string }[];
 };
 
+export type IndividualDocumentReviewAgentRuntimeContext = BaseRuntimeContext & {
+  checklistItems: { id: number; content: string }[];
+  additionalInstructions?: string;
+  commentFormat?: string;
+};
+
+export type ConsolidateReviewAgentRuntimeContext = BaseRuntimeContext & {
+  checklistItems: { id: number; content: string }[];
+  additionalInstructions?: string;
+  commentFormat?: string;
+  evaluationSettings?: CustomEvaluationSettings;
+};
+
 export const summarizeSourceAgent = new Agent({
   name: 'summarizeSourceAgent',
   instructions: SOURCE_ANALYSIS_SYSTEM_PROMPT,
@@ -146,3 +161,17 @@ export const reviewAnswerQuestionAgent = new Agent({
   instructions: getReviewAnswerQuestionPrompt,
   model: getOpenAICompatibleModel,
 });
+
+// 個別ドキュメントレビュー用エージェント（効率化版）
+export const individualDocumentReviewAgent = new Agent({
+  name: 'individualDocumentReviewAgent',
+  instructions: getIndividualDocumentReviewPrompt,
+  model: getOpenAICompatibleModel,
+});
+
+// レビュー結果統合用エージェント
+export const consolidateReviewAgent = new Agent({
+  name: 'consolidateReviewAgent',
+  instructions: getConsolidateReviewPrompt,
+  model: getOpenAICompatibleModel,
+});
diff --git a/src/mastra/index.ts b/src/mastra/index.ts
index b9467c7ec..c73c1798d 100644
--- a/src/mastra/index.ts
+++ b/src/mastra/index.ts
@@ -22,6 +22,8 @@ import {
   reviewCheckReviewReadinessFirstRunAgent,
   reviewCheckReviewReadinessSubsequentRunAgent,
   reviewAnswerQuestionAgent,
+  individualDocumentReviewAgent,
+  consolidateReviewAgent,
 } from './agents/workflowAgents';
 import { sourceRegistrationWorkflow } from './workflows/sourceRegistration/sourceRegistration';
 import { checklistExtractionWorkflow } from './workflows/sourceReview/checklistExtraction';
@@ -79,6 +81,8 @@ export const mastra: Mastra = new Mastra({
     reviewCheckReviewReadinessFirstRunAgent,
     reviewCheckReviewReadinessSubsequentRunAgent,
     reviewAnswerQuestionAgent,
+    individualDocumentReviewAgent,
+    consolidateReviewAgent,
   },
   workflows: {
     sourceRegistrationWorkflow,
diff --git a/src/mastra/workflows/sourceReview/checklistExtraction.ts b/src/mastra/workflows/sourceReview/checklistExtraction.ts
index 54742d5ef..54c0482fa 100644
--- a/src/mastra/workflows/sourceReview/checklistExtraction.ts
+++ b/src/mastra/workflows/sourceReview/checklistExtraction.ts
@@ -219,6 +219,7 @@ const checklistDocumentExtractionStep = createStep({
         status: 'success' as stepStatus,
       };
     } catch (error) {
+      console.error(error);
       logger.error(error, 'チェックリスト抽出処理に失敗しました');
       let errorMessage = '';
       if (
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/answerQuestionStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/answerQuestionStep.ts
deleted file mode 100644
index 7494d3280..000000000
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/answerQuestionStep.ts
+++ /dev/null
@@ -1,137 +0,0 @@
-// @ts-ignore
-import { createStep } from '@mastra/core';
-import { z } from 'zod';
-import { baseStepOutputSchema } from '../../../schema';
-import { stepStatus } from '../../../types';
-import { createCombinedMessage } from '../../lib';
-import { createRuntimeContext, judgeFinishReason } from '@/mastra/lib/agentUtils';
-import { ReviewAnswerQuestionAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
-import { internalError, normalizeUnknownError } from '@/main/lib/error';
-import { getMainLogger } from '@/main/lib/logger';
-
-const logger = getMainLogger();
-
-const answerQuestionInputSchema = z.object({
-  document: z.object({
-    id: z.string(),
-    name: z.string(),
-    path: z.string(),
-    type: z.string(),
-    pdfProcessMode: z.enum(['text', 'image']).optional(),
-    pdfImageMode: z.enum(['merged', 'pages']).optional(),
-    textContent: z.string().optional(),
-    imageData: z.array(z.string()).optional(),
-  }),
-  checklists: z.array(
-    z.object({
-      id: z.number(),
-      content: z.string().describe('レビュー対象チェックリストの内容'),
-    }),
-  ),
-  questions: z.array(z.string()).describe('ドキュメントに関する質問のリスト'),
-});
-
-const answerQuestionOutputSchema = baseStepOutputSchema.extend({
-  documentId: z.string().optional(),
-  answers: z.array(
-    z.object({
-      question: z.string().describe('ドキュメントに関する質問'),
-      answer: z.string().describe('その質問に対する回答'),
-    }),
-  ).optional(),
-});
-
-export const answerQuestionStep = createStep({
-  id: 'answerQuestionStep',
-  description: 'ドキュメントに対する質問に回答するステップ',
-  inputSchema: answerQuestionInputSchema,
-  outputSchema: answerQuestionOutputSchema,
-  execute: async ({ inputData, mastra, abortSignal, bail }) => {
-    const { document, checklists, questions } = inputData;
-
-    if (!questions || questions.length === 0) {
-      return {
-        status: 'success' as stepStatus,
-        answers: [],
-      };
-    }
-
-    try {
-      // ドキュメントをメッセージ形式に変換
-      const message = await createCombinedMessage(
-        [document],
-        'Please answer the following questions based on the document content.',
-      );
-
-      // 質問回答エージェントを取得
-      const agent = mastra.getAgent('reviewAnswerQuestionAgent');
-
-      // ランタイムコンテキストを作成
-      const runtimeContext = await createRuntimeContext<ReviewAnswerQuestionAgentRuntimeContext>();
-      runtimeContext.set('checklistItems', checklists);
-
-      // 出力スキーマを定義
-      const outputSchema = z.object({
-        answers: z.array(
-          z.object({
-            question: z.string().describe('The question being answered'),
-            answer: z.string().describe('The comprehensive answer based on the document content'),
-          }),
-        ),
-      });
-
-      // 質問リストをメッセージに追加
-      const questionsText = `## Questions to Answer:
-${questions.map((q, index) => `${index + 1}. ${q}`).join('\n')}
-
-Please provide detailed answers to each question based on the document content.`;
-
-      const messageWithQuestions = {
-        ...message,
-        content: [
-          ...message.content,
-          {
-            type: 'text' as const,
-            text: questionsText,
-          },
-        ],
-      };
-
-      // 質問回答を実行
-      const result = await agent.generate(messageWithQuestions, {
-        output: outputSchema,
-        runtimeContext,
-        abortSignal,
-      });
-
-      const { success, reason } = judgeFinishReason(result.finishReason);
-      if (!success) {
-        throw internalError({
-          expose: true,
-          messageCode: 'AI_API_ERROR',
-          messageParams: { detail: reason },
-        });
-      }
-
-      if (result.object && result.object.answers) {
-        return {
-          status: 'success' as stepStatus,
-          documentId: document.id,
-          answers: result.object.answers,
-        };
-      } else {
-        throw new Error('回答が生成されませんでした');
-      }
-    } catch (error) {
-      logger.error(error, '質問回答ステップでエラーが発生しました');
-      const normalizedError = normalizeUnknownError(error);
-
-      return {
-        status: 'failed' as stepStatus,
-        errorMessage: normalizedError.message,
-      };
-    }
-  },
-});
-
-
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/checkReviewReadinessStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/checkReviewReadinessStep.ts
deleted file mode 100644
index 63d2eb942..000000000
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/checkReviewReadinessStep.ts
+++ /dev/null
@@ -1,230 +0,0 @@
-import { z } from 'zod';
-import { baseStepOutputSchema } from '../../../schema';
-// @ts-ignore
-import { createStep } from '@mastra/core/workflows';
-import { getMainLogger } from '@/main/lib/logger';
-import {
-  createRuntimeContext,
-  judgeFinishReason,
-} from '@/mastra/lib/agentUtils';
-import {
-  ReviewCheckReviewReadinessFirstRunAgentRuntimeContext,
-  ReviewCheckReviewReadinessSubsequentAgentRuntimeContext,
-} from '@/mastra/agents/workflowAgents';
-import { internalError, normalizeUnknownError } from '@/main/lib/error';
-import { stepStatus } from '@/mastra/workflows/types';
-import { getChecklistsErrorMessage } from '../lib';
-
-const logger = getMainLogger();
-
-const checkReviewReadinessInputSchema = z.object({
-  additionalInstructions: z
-    .string()
-    .optional()
-    .describe('レビューに対する追加指示'),
-  documents: z.array(
-    z.object({
-      id: z.string(),
-      name: z.string(),
-      path: z.string(),
-      type: z.string(),
-      pdfProcessMode: z.enum(['text', 'image']).optional(),
-      pdfImageMode: z.enum(['merged', 'pages']).optional(),
-      textContent: z.string().optional(),
-      imageData: z.array(z.string()).optional(),
-      topicAndSummary: z.array(
-        z.object({
-          topic: z.string().describe('ドキュメントから抽出されたトピック'),
-          summary: z
-            .string()
-            .describe('そのトピックに関するドキュメントの要約'),
-        }),
-      ),
-      // レビューを実行するための、ドキュメントに関する質問・回答の蓄積情報
-      priorQnA: z
-        .array(
-          z.object({
-            question: z.string().describe('ドキュメントに関する質問'),
-            answer: z.string().describe('その質問に対する回答'),
-          }),
-        )
-        .optional()
-        .describe(
-          'レビューを実行するための、ドキュメントに関する質問・回答の蓄積情報',
-        ),
-    }),
-  ),
-  checklists: z.array(
-    z.object({
-      id: z.number(),
-      content: z.string().describe('チェックリストの内容'),
-    }),
-  ),
-});
-
-const checkReviewReadinessOutputSchema = baseStepOutputSchema.extend({
-  ready: z
-    .boolean()
-    .describe('レビューに十分な情報が含まれているか')
-    .optional(),
-  additionalQuestions: z
-    .array(z.object({ documentId: z.string(), questions: z.array(z.string()) }))
-    .optional()
-    .describe('不足している場合の追加質問'),
-});
-
-// チェックリストレビューに十分な情報が含まれているかを確認するstep(readyがtrueになるまで繰り返し実行するようにworkflowで制御する)
-export const checkReviewReadinessStep = createStep({
-  id: 'checkReviewReadinessStep',
-  description:
-    'チェックリストレビューに十分な情報が含まれているかを確認するステップ(readyがtrueになるまで繰り返し実行するようにworkflowで制御する)',
-  inputSchema: checkReviewReadinessInputSchema,
-  outputSchema: checkReviewReadinessOutputSchema,
-  execute: async ({ inputData, mastra }) => {
-    const { documents, checklists, additionalInstructions } = inputData;
-
-    try {
-      // priorQnAがundefinedまたは空の場合は初回実行とみなす
-      const isFirstRun = documents.every(
-        (doc) => !doc.priorQnA || doc.priorQnA.length === 0,
-      );
-
-      let agent;
-      let runtimeContext;
-
-      // ユーザプロンプト
-      const message = `${documents
-        .map(
-          (doc) => `# Document ID: ${doc.id}
-- Name: ${doc.name}
-## Summary and Topics:
-${doc.topicAndSummary
-  .map(
-    (ts) => `- Topic: ${ts.topic}
-  - Summary: ${ts.summary}`,
-  )
-  .join('\n\n')}`,
-        )
-        .join('\n\n')}
-`;
-      if (isFirstRun) {
-        // レビュー実行に必要な質問のみを生成するAIプロンプトを実行する
-        agent = mastra.getAgent('reviewCheckReviewReadinessFirstRunAgent');
-
-        runtimeContext =
-          await createRuntimeContext<ReviewCheckReviewReadinessFirstRunAgentRuntimeContext>();
-        runtimeContext.set('checklistItems', checklists);
-        runtimeContext.set('additionalInstructions', additionalInstructions);
-
-        const outputSchema = z.object({
-          additionalQuestions: z
-            .array(
-              z.object({
-                documentId: z
-                  .string()
-                  .describe(
-                    'The ID of the document for which additional information is needed.',
-                  ),
-                questions: z
-                  .array(z.string())
-                  .describe(
-                    'A list of questions that need to be answered to ensure a thorough review based on the checklist items.',
-                  ),
-              }),
-            )
-            .describe('List of additional questions needed for review'),
-        });
-
-        const result = await agent.generate(message, {
-          output: outputSchema,
-          abortSignal: undefined,
-          runtimeContext,
-        });
-
-        const { success, reason } = judgeFinishReason(result.finishReason);
-        if (!success) {
-          throw internalError({
-            expose: true,
-            messageCode: 'AI_API_ERROR',
-            messageParams: { detail: reason },
-          });
-        }
-
-        return {
-          status: 'success' as stepStatus,
-          ...result.object,
-          ready: false,
-        };
-      } else {
-        // priorQnAが存在する場合は2回目以降の実行とみなす
-        agent = mastra.getAgent('reviewCheckReviewReadinessSubsequentRunAgent');
-
-        runtimeContext =
-          await createRuntimeContext<ReviewCheckReviewReadinessSubsequentAgentRuntimeContext>();
-        runtimeContext.set('checklistItems', checklists);
-        runtimeContext.set('additionalInstructions', additionalInstructions);
-        runtimeContext.set(
-          'priorQnA',
-          documents.map((doc) => ({
-            documentId: doc.id,
-            documentName: doc.name,
-            qna: doc.priorQnA || [],
-          })),
-        );
-
-        const outputSchema = z.object({
-          additionalQuestions: z
-            .array(
-              z.object({
-                documentId: z
-                  .string()
-                  .describe(
-                    'The ID of the document for which additional information is needed.',
-                  ),
-                questions: z
-                  .array(z.string())
-                  .describe(
-                    'A list of questions that need to be answered to ensure a thorough review based on the checklist items.',
-                  ),
-              }),
-            )
-            .optional()
-            .describe('List of additional questions needed for review'),
-          ready: z
-            .boolean()
-            .describe(
-              'Indicates whether the provided information is sufficient to proceed with the review based on the checklist items.',
-            ),
-        });
-
-        const result = await agent.generate(message, {
-          output: outputSchema,
-          abortSignal: undefined,
-          runtimeContext,
-        });
-
-        const { success, reason } = judgeFinishReason(result.finishReason);
-        if (!success) {
-          throw internalError({
-            expose: true,
-            messageCode: 'AI_API_ERROR',
-            messageParams: { detail: reason },
-          });
-        }
-
-        return {
-          status: 'success' as stepStatus,
-          ...result.object,
-        };
-      }
-    } catch (error) {
-      logger.error(error, 'レビュー準備確認ステップでエラーが発生しました');
-      const normalizedError = normalizeUnknownError(error);
-
-      return {
-        status: 'failed' as stepStatus,
-        errorMessage: getChecklistsErrorMessage(checklists, normalizedError.message),
-      };
-    }
-  },
-});
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
new file mode 100644
index 000000000..57b243d2a
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/consolidateReviewStep.ts
@@ -0,0 +1,266 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../../schema';
+import { stepStatus } from '../../../types';
+import { getReviewRepository } from '@/adapter/db';
+import type { ConsolidateReviewAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import { normalizeUnknownError } from '@/main/lib/error';
+import { internalError } from '@/main/lib/error';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import { getMainLogger } from '@/main/lib/logger';
+
+const logger = getMainLogger();
+import type { ReviewEvaluation } from '@/types';
+import { createHash } from 'crypto';
+
+// レビュー結果統合ステップの入力スキーマ
+export const consolidateReviewStepInputSchema = z.object({
+  documentsWithReviewResults: z.array(
+    z.object({
+      id: z.string(),
+      originalName: z.string(),
+      name: z.string(),
+      path: z.string(),
+      type: z.string(),
+      pdfProcessMode: z.enum(['text', 'image']).optional(),
+      pdfImageMode: z.enum(['merged', 'pages']).optional(),
+      textContent: z.string().optional(),
+      imageData: z.array(z.string()).optional(),
+      reviewResults: z.array(
+        z.object({
+          checklistId: z.number(),
+          comment: z.string().describe('evaluation comment'),
+        }),
+      ),
+    }),
+  ),
+  checklists: z.array(
+    z.object({
+      id: z.number(),
+      content: z.string().describe('チェックリストの内容'),
+    }),
+  ),
+  additionalInstructions: z
+    .string()
+    .optional()
+    .describe('レビューに対する追加指示'),
+  commentFormat: z
+    .string()
+    .optional()
+    .describe('レビューコメントのフォーマット'),
+  evaluationSettings: z
+    .object({
+      items: z.array(
+        z.object({
+          label: z.string(),
+          description: z.string(),
+        }),
+      ),
+    })
+    .optional()
+    .describe('カスタム評価項目設定'),
+});
+
+// レビュー結果統合ステップの出力スキーマ
+export const consolidateReviewStepOutputSchema = baseStepOutputSchema;
+
+/**
+ * レビュー結果統合ステップ
+ * 個別ドキュメントのレビュー結果を統合して最終的なレビュー結果を作成
+ */
+export const consolidateReviewStep = createStep({
+  id: 'consolidateReviewStep',
+  description: '個別レビュー結果の統合ステップ',
+  inputSchema: consolidateReviewStepInputSchema,
+  outputSchema: consolidateReviewStepOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal, bail }) => {
+    const {
+      documentsWithReviewResults,
+      checklists,
+      additionalInstructions,
+      commentFormat,
+      evaluationSettings,
+    } = inputData;
+
+    const reviewRepository = getReviewRepository();
+
+    try {
+      const consolidateAgent = mastra.getAgent('consolidateReviewAgent');
+
+      // 個別レビュー結果を整理
+      const consolidatedInput = documentsWithReviewResults.map((docResult) => {
+        return {
+          originalName: docResult?.originalName || docResult?.name || `Document ${docResult.id}`,
+          documentName: docResult?.name || `Document ${docResult.id}`,
+          reviewResults: docResult.reviewResults,
+        };
+      });
+
+      // 統合レビューメッセージを構築
+      const reviewMessage = {
+        role: 'user' as const,
+        content: [
+          {
+            type: 'text' as const,
+            text: `Please consolidate the following individual document review results into a comprehensive final review.
+
+## Document Set Information:
+Original Files: ${[...new Set(consolidatedInput.map(doc => doc.originalName))].join(', ')}
+
+## Individual Document Review Results:
+${consolidatedInput
+  .map((docResult) => {
+    const isPartOfSplit = docResult.originalName !== docResult.documentName;
+    return `### Document: ${docResult.documentName}${isPartOfSplit ? ` (part of ${docResult.originalName})` : ''}
+${docResult.reviewResults
+  .map((result) => {
+    const checklistItem = checklists.find((c) => c.id === result.checklistId);
+    return `
+**Checklist ID ${result.checklistId}**: ${checklistItem?.content || 'Unknown'}
+- **Comment**: ${result.comment}`;
+  })
+  .join('\n')}`;
+  })
+  .join('\n\n')}
+
+## Checklist Items for Consolidation:
+${checklists.map((item) => `- ID: ${item.id} - ${item.content}`).join('\n')}
+
+Please provide a consolidated review that synthesizes all individual document reviews into a unified assessment for the entire document set.`,
+          },
+        ],
+      };
+
+      // 統合レビューを実行（最大3回まで再試行）
+      const maxAttempts = 3;
+      let attempt = 0;
+      let targetChecklists = checklists;
+
+      while (attempt < maxAttempts) {
+        // デフォルトの評価項目
+        const defaultEvaluationItems = ['A', 'B', 'C', '-'] as const;
+
+        // カスタム評価項目があるか確認
+        const evaluationItems = evaluationSettings?.items?.length
+          ? evaluationSettings.items.map((item) => item.label)
+          : defaultEvaluationItems;
+
+        // 最初の要素が存在することを確認してenumを作成
+        const evaluationEnum =
+          evaluationItems.length > 0
+            ? z.enum([evaluationItems[0], ...evaluationItems.slice(1)] as [
+                string,
+                ...string[],
+              ])
+            : z.enum(defaultEvaluationItems);
+
+        const outputSchema = z.array(
+          z.object({
+            checklistId: z.number(),
+            comment: z.string().describe('evaluation comment'),
+            evaluation: evaluationEnum.describe('evaluation'),
+          }),
+        );
+
+        const runtimeContext =
+          await createRuntimeContext<ConsolidateReviewAgentRuntimeContext>();
+        runtimeContext.set('additionalInstructions', additionalInstructions);
+        runtimeContext.set('commentFormat', commentFormat);
+        runtimeContext.set('evaluationSettings', evaluationSettings);
+        runtimeContext.set('checklistItems', targetChecklists);
+
+        // 統合レビューエージェントを使用して統合レビューを実行
+        const consolidatedResult = await consolidateAgent.generate(
+          reviewMessage,
+          {
+            output: outputSchema,
+            runtimeContext,
+            abortSignal,
+          },
+        );
+
+        const { success, reason } = judgeFinishReason(
+          consolidatedResult.finishReason,
+        );
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+
+        // 統合レビュー結果をDBに保存（複数ファイルの情報を統合）
+        if (
+          consolidatedResult.object &&
+          Array.isArray(consolidatedResult.object)
+        ) {
+          const combinedFileIds = documentsWithReviewResults
+            .map((f) => f.id)
+            .join('/');
+          const idsHash = createHash('md5')
+            .update(combinedFileIds)
+            .digest('hex');
+          const combinedFileNames = documentsWithReviewResults
+            .map((f) => f.name)
+            .join('/');
+
+          await reviewRepository.upsertReviewResult(
+            consolidatedResult.object.map((result) => ({
+              reviewChecklistId: result.checklistId,
+              evaluation: result.evaluation as ReviewEvaluation,
+              comment: result.comment,
+              fileId: idsHash,
+              fileName: combinedFileNames,
+            })),
+          );
+        }
+
+        // レビュー結果に含まれなかったチェックリストを抽出
+        const reviewedChecklistIds = new Set(
+          consolidatedResult.object && Array.isArray(consolidatedResult.object)
+            ? consolidatedResult.object.map((result) => result.checklistId)
+            : [],
+        );
+        targetChecklists = targetChecklists.filter(
+          (checklist) => !reviewedChecklistIds.has(checklist.id),
+        );
+
+        if (targetChecklists.length === 0) {
+          // 全てのチェックリストが統合レビューされた場合、成功
+          break;
+        }
+        attempt += 1;
+      }
+
+      if (attempt >= maxAttempts) {
+        // 最大試行回数に達した場合、失敗したチェックリストを記録
+        return {
+          status: 'failed' as stepStatus,
+          errorMessage: `${targetChecklists?.map((c) => `・${c.content}:AIの出力に統合レビュー結果が含まれませんでした`).join('\n')}`,
+        };
+      }
+
+      // 全ての統合レビューが成功した場合
+      return {
+        status: 'success' as stepStatus,
+        output: {
+          success: true,
+        },
+      };
+    } catch (error) {
+      logger.error(error, 'レビュー結果統合処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      const errorMessage = normalizedError.message;
+      // エラーが発生した場合はエラー情報を返す
+      return bail({
+        status: 'failed' as stepStatus,
+        errorMessage: `${checklists?.map((c) => `・${c.content}:${errorMessage}`).join('\n')}`,
+      });
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/documentSummarizationStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/documentSummarizationStep.ts
deleted file mode 100644
index 2103f35b2..000000000
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/documentSummarizationStep.ts
+++ /dev/null
@@ -1,151 +0,0 @@
-// @ts-ignore
-import { createStep } from '@mastra/core';
-import { z } from 'zod';
-import { baseStepOutputSchema } from '../../../schema';
-import { stepStatus } from '../../../types';
-import { createCombinedMessage } from '../../lib';
-import {
-  createRuntimeContext,
-  judgeFinishReason,
-} from '@/mastra/lib/agentUtils';
-import { internalError, normalizeUnknownError } from '@/main/lib/error';
-import { getMainLogger } from '@/main/lib/logger';
-import { getChecklistsErrorMessage } from '../lib';
-
-const logger = getMainLogger();
-
-export const documentSummarizationInputSchema = z
-  .object({
-    documents: z.array(
-      z.object({
-        id: z.string(),
-        name: z.string(),
-        path: z.string(),
-        type: z.string(),
-        pdfProcessMode: z.enum(['text', 'image']).optional(),
-        pdfImageMode: z.enum(['merged', 'pages']).optional(),
-        textContent: z.string().optional(),
-        imageData: z.array(z.string()).optional(),
-      }),
-    ),
-    checklists: z.array(
-      z.object({
-        id: z.number(),
-        content: z.string(),
-      }),
-    ),
-  })
-  .describe('要約生成対象のドキュメント');
-
-const documentSummarizationOutputSchema = baseStepOutputSchema
-  .extend({
-    documents: z
-      .array(
-        z.object({
-          id: z.string(),
-          name: z.string(),
-          path: z.string(),
-          type: z.string(),
-          pdfProcessMode: z.enum(['text', 'image']).optional(),
-          pdfImageMode: z.enum(['merged', 'pages']).optional(),
-          textContent: z.string().optional(),
-          imageData: z.array(z.string()).optional(),
-          topicAndSummary: z.array(
-            z.object({
-              topic: z.string().describe('ドキュメントから抽出されたトピック'),
-              summary: z
-                .string()
-                .describe('そのトピックに関するドキュメントの要約'),
-            }),
-          ),
-        }),
-      )
-      .optional(),
-  })
-  .describe('各ドキュメントのトピックと要約のリスト');
-
-export const documentSummarizationStep = createStep({
-  id: 'documentSummarizationStep',
-  description: '個々のドキュメントのトピックと要約を生成するステップ',
-  inputSchema: documentSummarizationInputSchema,
-  outputSchema: documentSummarizationOutputSchema,
-  execute: async ({ inputData, mastra, abortSignal, bail }) => {
-    const { documents, checklists } = inputData;
-
-    try {
-      // ドキュメントが空の場合、エラーで終了
-      if (documents.length === 0) {
-        throw internalError({
-          expose: false,
-          messageCode: 'PLAIN_MESSAGE',
-          messageParams: { message: 'ドキュメントが空です' },
-        });
-      }
-      const resultDocuments = [];
-
-      // 各ドキュメントに対して要約とトピック抽出を実行
-      for (const doc of documents) {
-        // ユーザプロンプト
-        const message = await createCombinedMessage(
-          [doc],
-          'Please summarize the document and extract key topics and summaries.',
-        );
-
-        // 要約生成エージェントを取得
-        const agent = mastra.getAgent('reviewDocumentSummarizationAgent');
-
-        // 出力スキーマを定義
-        const outputSchema = z.object({
-          topicAndSummaryList: z.array(
-            z.object({
-              topic: z.string().describe('Topics extracted from the document'),
-              summary: z
-                .string()
-                .describe('Summary of the document on the topic'),
-            }),
-          ),
-        });
-
-        const result = await agent.generate(message, {
-          output: outputSchema,
-          abortSignal,
-          runtimeContext: await createRuntimeContext(),
-        });
-
-        const { success, reason } = judgeFinishReason(result.finishReason);
-        if (!success) {
-          throw internalError({
-            expose: true,
-            messageCode: 'AI_API_ERROR',
-            messageParams: { detail: reason },
-          });
-        }
-
-        resultDocuments.push({
-          id: doc.id,
-          name: doc.name,
-          path: doc.path,
-          type: doc.type,
-          pdfProcessMode: doc.pdfProcessMode,
-          pdfImageMode: doc.pdfImageMode,
-          textContent: doc.textContent,
-          imageData: doc.imageData,
-          topicAndSummary: result.object.topicAndSummaryList,
-        });
-      }
-
-      return {
-        status: 'success' as stepStatus,
-        documents: resultDocuments,
-      };
-    } catch (error) {
-      logger.error(error, 'ドキュメント要約生成処理に失敗しました');
-      const normalizedError = normalizeUnknownError(error);
-
-      return bail({
-        status: 'failed' as stepStatus,
-        errorMessage: getChecklistsErrorMessage(checklists, normalizedError.message),
-      });
-    }
-  },
-});
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
index 906572083..c97d98029 100644
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/index.ts
@@ -2,171 +2,304 @@
 import { createWorkflow } from '@mastra/core';
 import { z } from 'zod';
 import { stepStatus } from '../../../types';
-import { documentSummarizationStep } from './documentSummarizationStep';
-import { checkReviewReadinessStep } from './checkReviewReadinessStep';
-import { answerQuestionStep } from './answerQuestionStep';
-import { largeDocumentReviewExecutionStep } from './reviewExecutionStep';
+import { individualDocumentReviewStep } from './individualDocumentReviewStep';
+import { consolidateReviewStep } from './consolidateReviewStep';
 import { getMainLogger } from '@/main/lib/logger';
 import {
   documentReviewExecutionInputSchema,
   documentReviewExecutionOutputSchema,
 } from '..';
+import { baseStepOutputSchema } from '@/mastra/workflows/schema';
 
 const logger = getMainLogger();
 
-//QnA生成と質問応答のサブワークフロー定義
-const qnALoopWorkflow = createWorkflow({
-  id: 'qnALoopWorkflow',
-  inputSchema: checkReviewReadinessStep.outputSchema.extend(
-    checkReviewReadinessStep.inputSchema.shape,
-  ), // loopのためinputとoutputを統合
-  outputSchema: checkReviewReadinessStep.outputSchema.extend(
-    checkReviewReadinessStep.inputSchema.shape,
-  ),
+const individualDocumentReviewRetryWorkflowInputSchema =
+  individualDocumentReviewStep.outputSchema.extend({
+    originalDocument: individualDocumentReviewStep.inputSchema.shape.document,
+    reviewInput: z.array(individualDocumentReviewStep.inputSchema),
+    retryCount: z.number(),
+  });
+
+const individualDocumentReviewWorkflowOutputSchema =
+  baseStepOutputSchema.extend({
+    documentsWithReviewResults: z
+      .array(
+        z.object({
+          id: z.string(),
+          originalName: z.string(),
+          name: z.string(),
+          path: z.string(),
+          type: z.string(),
+          pdfProcessMode: z.enum(['text', 'image']).optional(),
+          pdfImageMode: z.enum(['merged', 'pages']).optional(),
+          textContent: z.string().optional(),
+          imageData: z.array(z.string()).optional(),
+          reviewResults: z.array(
+            z.object({
+              checklistId: z.number(),
+              comment: z.string().describe('evaluation comment'),
+            }),
+          ),
+        }),
+      )
+      .optional(),
+  });
+
+/**
+ * 個別ドキュメントレビューワークフロー
+ * 個別ドキュメントレビューを実行し、コンテキスト長エラーになった時のみ分割してリトライする
+ */
+const individualDocumentReviewWorkflow = createWorkflow({
+  id: 'individualDocumentReviewWorkflow',
+  inputSchema: individualDocumentReviewStep.inputSchema,
+  outputSchema: individualDocumentReviewWorkflowOutputSchema,
 })
   .map(async ({ inputData }) => {
     return {
-      documents: inputData.documents,
-      checklists: inputData.checklists,
-      additionalInstructions: inputData.additionalInstructions,
-    } as z.infer<typeof checkReviewReadinessStep.inputSchema>;
+      originalDocument: inputData.document,
+      reviewInput: [inputData],
+      retryCount: 0,
+      finishReason: 'error' as const,
+    } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
   })
-  .then(checkReviewReadinessStep)
-  .map(async ({ inputData, bail, getInitData }) => {
-    // 前stepはthenかつbailで終了しているので、失敗した場合はここには到達しないはず
-    if (inputData.status === 'failed') {
-      return bail({
-        status: 'failed' as stepStatus,
-        errorMessage: inputData.errorMessage,
-      });
-    }
-    const initData = (await getInitData()) as z.infer<
-      typeof checkReviewReadinessStep.inputSchema
-    >;
-    // readyがtrueまたは質問がない場合はループを終了する
-    if (inputData.ready || !inputData.additionalQuestions) {
-      return bail({
-        status: 'success' as stepStatus,
-        ready: true,
-        additionalQuestions: [],
-        documents: initData.documents,
-        checklists: initData.checklists,
-        additionalInstructions: initData.additionalInstructions,
-      });
-    }
-    return inputData.additionalQuestions.map((questionGroup) => {
-      const document = initData.documents.find(
-        (d) => d.id === questionGroup.documentId,
-      );
-      if (document && questionGroup.questions.length > 0) {
+  .dountil(
+    createWorkflow({
+      id: 'individualDocumentReviewRetryWorkflow',
+      inputSchema: individualDocumentReviewRetryWorkflowInputSchema,
+      outputSchema: individualDocumentReviewRetryWorkflowInputSchema,
+    })
+      .map(async ({ inputData }) => {
+        return inputData.reviewInput as z.infer<
+          typeof individualDocumentReviewStep.inputSchema
+        >[];
+      })
+      .foreach(individualDocumentReviewStep, { concurrency: 5 })
+      .map(async ({ inputData, getInitData }) => {
+        const initData = (await getInitData()) as z.infer<
+          typeof individualDocumentReviewRetryWorkflowInputSchema
+        >;
+        // リトライ回数をインクリメント
+        const nextRetryCount = initData.retryCount + 1;
+
+        // 全て成功している場合は成功として返す
+        if (inputData.every((item) => item.status === 'success')) {
+          return {
+            originalDocument: initData.originalDocument,
+            reviewInput: initData.reviewInput,
+            reviewResults: inputData.flatMap(
+              (item) => item.reviewResults || [],
+            ),
+            retryCount: nextRetryCount,
+            status: 'success' as stepStatus,
+            finishReason: 'success' as const,
+          } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
+        }
+
+        // どれかの個別レビューがコンテキスト長エラーで失敗していた場合は再度分割してリトライする
+        // リトライ対象かどうかを判定
+        const isRetryNeeded = inputData.some(
+          (item) =>
+            item.status === 'failed' && item.finishReason === 'content_length',
+        );
+        if (!isRetryNeeded) {
+          // 失敗が一つでもある場合は失敗として返す
+          const isFailed = inputData.some((item) => item.status === 'failed');
+          // エラーメッセージは最初の失敗から取得
+          let errorMessage: string | undefined = undefined;
+          for (const item of inputData) {
+            if (item.status === 'failed' && item.errorMessage) {
+              errorMessage = item.errorMessage;
+              break;
+            }
+          }
+          return {
+            originalDocument: initData.originalDocument,
+            reviewInput: [],
+            retryCount: nextRetryCount,
+            status: isFailed
+              ? ('failed' as stepStatus)
+              : ('succeeded' as stepStatus),
+            errorMessage,
+            finishReason: isFailed
+              ? ('error' as const)
+              : ('succeeded' as const),
+          } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
+        }
+
+        // リトライ回数が5回を超えたら終了
+        if (initData.retryCount >= 4) {
+          return {
+            originalDocument: initData.originalDocument,
+            reviewInput: [],
+            retryCount: nextRetryCount,
+            status: 'failed' as stepStatus,
+            errorMessage:
+              'ドキュメント分割を複数回実行しましたが、コンテキスト長エラーが解消されませんでした',
+            finishReason: 'error' as const,
+          } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
+        }
+
+        // ドキュメント分割処理を実行
+        // 分割方針は、originalDocumentを単純に${nextRetryCount + 1}に分割し、テキストドキュメントであればオーバーラップを300文字、PDF画像ドキュメントであれば3画像分オーバーラップさせる
+        const splitCount = nextRetryCount + 1;
+        // テキストドキュメントの場合
+        if (initData.originalDocument.textContent) {
+          const text = initData.originalDocument.textContent;
+          const chunkSize = Math.ceil(text.length / splitCount);
+          const overlap = 300;
+          const chunks: string[] = [];
+          for (let i = 0; i < splitCount; i++) {
+            const start = i * chunkSize - (i > 0 ? overlap : 0);
+            const end = start + chunkSize + (i < splitCount - 1 ? overlap : 0);
+            chunks.push(text.slice(start, end));
+          }
+          return {
+            originalDocument: initData.originalDocument,
+            reviewInput: chunks.map((chunk, index) => ({
+              ...initData.reviewInput[0],
+              document: {
+                ...initData.originalDocument,
+                id: `${initData.originalDocument.id}_part${index + 1}`,
+                name: `${initData.originalDocument.name} (part ${index + 1})  (split into parts because the full content did not fit into context)`,
+                textContent: chunk,
+              },
+            })),
+            retryCount: nextRetryCount,
+            status: 'success' as stepStatus,
+            finishReason: 'content_length' as const,
+          } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
+        }
+        // PDF画像ドキュメントの場合
+        // imageDataはbase64の配列であるため、3画像分オーバーラップさせる
+        else if (initData.originalDocument.imageData) {
+          const imageData = initData.originalDocument.imageData;
+          const splitCount = nextRetryCount + 1;
+          const chunkSize = Math.ceil(imageData.length / splitCount);
+          const overlap = 3;
+          const chunks: string[][] = [];
+          for (let i = 0; i < splitCount; i++) {
+            const start = i * chunkSize - (i > 0 ? overlap : 0);
+            const end = start + chunkSize + (i < splitCount - 1 ? overlap : 0);
+            chunks.push(imageData.slice(start, end));
+          }
+          return {
+            originalDocument: initData.originalDocument,
+            reviewInput: chunks.map((chunk, index) => ({
+              ...initData.reviewInput[0],
+              document: {
+                ...initData.originalDocument,
+                id: `${initData.originalDocument.id}_part${index + 1}`,
+                name: `${initData.originalDocument.name} (part ${index + 1})  (split into parts because the full content did not fit into context)`,
+                imageData: chunk,
+              },
+            })),
+            retryCount: nextRetryCount,
+            status: 'success' as stepStatus,
+            finishReason: 'content_length' as const,
+          } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
+        }
+
+        // ここには到達しないはず
         return {
-          document,
-          checklists: initData.checklists,
-          questions: questionGroup.questions,
-        } as z.infer<typeof answerQuestionStep.inputSchema>;
+          originalDocument: initData.originalDocument,
+          reviewInput: [],
+          retryCount: nextRetryCount,
+          status: 'failed' as stepStatus,
+          errorMessage: '予期せぬエラーが発生しました',
+          finishReason: 'error' as const,
+        } as z.infer<typeof individualDocumentReviewRetryWorkflowInputSchema>;
+      })
+      .commit(),
+    async ({ inputData }) => {
+      if (inputData.retryCount >= 4) {
+        return true;
       }
-    });
-  })
-  .foreach(answerQuestionStep, { concurrency: 5 })
-  .map(async ({ inputData, bail, getInitData, getStepResult }) => {
-    const initData = (await getInitData()) as z.infer<
-      typeof checkReviewReadinessStep.inputSchema
-    >;
-    // 全て失敗していた場合、ここで終了させる
-    if (inputData.every((item) => item.status === 'failed')) {
-      // 最初の要素からエラーメッセージを取得
-      let errorMessage: string = '予期せぬエラーが発生しました';
-      for (const item of inputData) {
-        if (item.status === 'failed' && item.errorMessage) {
-          errorMessage = item.errorMessage;
-          break;
-        }
+      if (inputData.finishReason !== 'content_length') {
+        return true;
       }
-      return bail({
+      return false;
+    },
+  )
+  .map(async ({ inputData }) => {
+    // 個別ドキュメントレビューの結果をまとめて返す
+    if (inputData.status === 'failed') {
+      return {
         status: 'failed' as stepStatus,
-        errorMessage,
-      });
+        errorMessage: inputData.errorMessage,
+      } as z.infer<typeof individualDocumentReviewWorkflowOutputSchema>;
     }
-    // 各ドキュメントのpriorQnAに回答を追加して返す
-    const updatedDocuments = initData.documents.map((doc) => {
-      const answersForDoc = inputData
-        .filter(
-          (item) => item.status === 'success' && item.documentId === doc.id,
-        )
-        .flatMap((item) => item.answers || []);
-      return {
-        ...doc,
-        priorQnA: [...(doc.priorQnA || []), ...answersForDoc],
-      };
-    });
     return {
-      documents: updatedDocuments,
-      checklists: initData.checklists,
-      additionalInstructions: initData.additionalInstructions,
-      ready: getStepResult(checkReviewReadinessStep).ready,
-    } as z.infer<typeof checkReviewReadinessStep.inputSchema>;
+      status: 'success' as stepStatus,
+      documentsWithReviewResults: inputData.reviewInput.map((input) => {
+        const reviewResult = inputData.reviewResults?.filter(
+          (result) => result.documentId === input.document.id,
+        );
+        return {
+          ...input.document,
+          reviewResults: reviewResult || [],
+        };
+      }),
+    } as z.infer<typeof individualDocumentReviewWorkflowOutputSchema>;
   })
   .commit();
 
-// 大量ドキュメント用レビューサブワークフロー
+/**
+ * 大量ドキュメントレビューワークフロー
+ * 個別ドキュメントレビュー（並列実行） → レビュー結果統合の流れ
+ */
 export const largeDocumentReviewWorkflow = createWorkflow({
   id: 'largeDocumentReviewWorkflow',
   inputSchema: documentReviewExecutionInputSchema,
   outputSchema: documentReviewExecutionOutputSchema,
 })
   .map(async ({ inputData }) => {
-    return {
-      documents: inputData.documents,
-      checklists: inputData.checklists,
-    } as z.infer<typeof documentSummarizationStep.inputSchema>;
+    // 各ドキュメントに対する個別レビューのタスクを作成
+    return inputData.documents.map(
+      (document) =>
+        ({
+          document: {
+            ...document,
+            originalName: document.name, // 分割された場合に元の名前を保持するため
+          },
+          checklists: inputData.checklists,
+          additionalInstructions: inputData.additionalInstructions,
+          commentFormat: inputData.commentFormat,
+          evaluationSettings: inputData.evaluationSettings,
+        }) as z.infer<typeof individualDocumentReviewStep.inputSchema>,
+    );
   })
-  .then(documentSummarizationStep)
+  .foreach(individualDocumentReviewWorkflow, { concurrency: 5 })
   .map(async ({ inputData, bail, getInitData }) => {
-    // 前stepはthenかつbailで終了しているので、失敗した場合はここには到達しないはず
-    if (inputData.status === 'failed') {
-      return bail({
-        status: 'failed' as stepStatus,
-        errorMessages: inputData.errorMessage,
-      });
-    }
     const initData = (await getInitData()) as z.infer<
-      typeof largeDocumentReviewExecutionStep.inputSchema
+      typeof documentReviewExecutionInputSchema
     >;
-    return {
-      documents:
-        inputData.documents?.map((doc) => ({
-          ...doc,
-          priorQnA: [] as Array<{ question: string; answer: string }>, // 初回は空
-        })) || [],
-      checklists: initData.checklists,
-      additionalInstructions: initData.additionalInstructions,
-      ready: false, // 初回はfalseでスタート
-    } as z.infer<typeof qnALoopWorkflow.inputSchema>;
-  })
-  .dountil(qnALoopWorkflow, async ({ inputData: { ready, status } }) => {
-    return ready === true || status === 'failed';
-  })
-  .map(async ({ inputData, bail, getInitData }) => {
-    // 前stepが失敗していた場合はここで終了させる
-    if (inputData.status === 'failed') {
+
+    // どれかの個別レビューが失敗していた場合は全体を失敗とする
+    if (inputData.some((item) => item.status === 'failed')) {
+      // 最初の失敗からエラーメッセージを取得
+      let errorMessage: string = '予期せぬエラーが発生しました';
+      for (const item of inputData) {
+        if (item.status === 'failed' && item.errorMessage) {
+          errorMessage = item.errorMessage;
+          break;
+        }
+      }
       return bail({
         status: 'failed' as stepStatus,
-        errorMessage: inputData.errorMessage,
+        errorMessage,
       });
     }
-    const initData = (await getInitData()) as z.infer<
-      typeof largeDocumentReviewExecutionStep.inputSchema
-    >;
+
+    // レビュー結果統合のためのデータを準備
     return {
-      documents: inputData.documents.map((doc) => ({
-        ...doc,
-        qnA: doc.priorQnA || [],
-      })),
-      checklists: inputData.checklists,
-      additionalInstructions: inputData.additionalInstructions,
+      documentsWithReviewResults: inputData.flatMap(
+        (item) => item.documentsWithReviewResults,
+      ),
+      checklists: initData.checklists,
+      additionalInstructions: initData.additionalInstructions,
       commentFormat: initData.commentFormat,
       evaluationSettings: initData.evaluationSettings,
-    } as z.infer<typeof largeDocumentReviewExecutionStep.inputSchema>;
+    } as z.infer<typeof consolidateReviewStep.inputSchema>;
   })
-  .then(largeDocumentReviewExecutionStep)
+  .then(consolidateReviewStep)
   .commit();
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
new file mode 100644
index 000000000..b695bdd49
--- /dev/null
+++ b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/individualDocumentReviewStep.ts
@@ -0,0 +1,224 @@
+// @ts-ignore
+import { createStep } from '@mastra/core';
+import { z } from 'zod';
+import { baseStepOutputSchema } from '../../../schema';
+import { stepStatus } from '../../../types';
+import type { IndividualDocumentReviewAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
+import { normalizeUnknownError } from '@/main/lib/error';
+import { internalError } from '@/main/lib/error';
+import {
+  createRuntimeContext,
+  judgeFinishReason,
+} from '@/mastra/lib/agentUtils';
+import { getMainLogger } from '@/main/lib/logger';
+import { createCombinedMessage } from '../../lib';
+import { getChecklistsErrorMessage, judgeErrorIsContentLengthError } from '../lib';
+
+
+const logger = getMainLogger();
+
+// 個別ドキュメントレビューステップの入力スキーマ
+export const individualDocumentReviewStepInputSchema = z.object({
+  document: z.object({
+    id: z.string(),
+    originalName: z.string(),
+    name: z.string(),
+    path: z.string(),
+    type: z.string(),
+    pdfProcessMode: z.enum(['text', 'image']).optional(),
+    pdfImageMode: z.enum(['merged', 'pages']).optional(),
+    textContent: z.string().optional(),
+    imageData: z.array(z.string()).optional(),
+  }),
+  checklists: z.array(
+    z.object({
+      id: z.number(),
+      content: z.string().describe('チェックリストの内容'),
+    }),
+  ),
+  additionalInstructions: z
+    .string()
+    .optional()
+    .describe('レビューに対する追加指示'),
+  commentFormat: z
+    .string()
+    .optional()
+    .describe('レビューコメントのフォーマット'),
+});
+
+// 個別ドキュメントレビューステップの出力スキーマ
+export const individualDocumentReviewStepOutputSchema =
+  baseStepOutputSchema.extend({
+    reviewResults: z
+      .array(
+        z.object({
+          documentId: z.string().optional(),
+          checklistId: z.number(),
+          comment: z.string().describe('evaluation comment'),
+        }),
+      )
+      .optional(),
+    finishReason: z.enum(['success', 'error', 'content_length']),
+  });
+
+/**
+ * 個別ドキュメントレビューステップ
+ * 1つのドキュメントに対してチェックリストベースのレビューを実行
+ */
+export const individualDocumentReviewStep = createStep({
+  id: 'individualDocumentReviewStep',
+  description: '個別ドキュメントに対するレビュー実行ステップ',
+  inputSchema: individualDocumentReviewStepInputSchema,
+  outputSchema: individualDocumentReviewStepOutputSchema,
+  execute: async ({ inputData, mastra, abortSignal, bail }) => {
+    const { document, checklists, additionalInstructions, commentFormat } =
+      inputData;
+
+    try {
+      const reviewAgent = mastra.getAgent('individualDocumentReviewAgent');
+
+      // ドキュメント内容を構築
+      const message = await createCombinedMessage(
+        [document],
+        'Please review this document against the provided checklist items',
+      );
+
+      // レビューメッセージを構築
+      const reviewMessage = {
+        ...message,
+        content: [
+          ...message.content,
+          {
+            type: 'text' as const,
+            text: `Document Information:
+- Original File Name: ${document.originalName}
+- Current Document Name: ${document.name}
+${document.name !== document.originalName ? '- Note: This is a part of the original document that was split due to length constraints' : ''}
+
+Checklist Items to Review:\n${checklists.map((item) => `- ID: ${item.id} - ${item.content}`).join('\n')}\n\nPlease provide a thorough review based on the document content provided above.`,
+          },
+        ],
+      };
+
+      // レビューを実行（最大3回まで再試行）
+      const maxAttempts = 3;
+      let attempt = 0;
+      let targetChecklists = checklists;
+      const allReviewResults: Array<{
+        checklistId: number;
+        comment: string;
+      }> = [];
+
+      while (attempt < maxAttempts && targetChecklists.length > 0) {
+        const outputSchema = z.array(
+          z.object({
+            // CoTのようにAIにどのファイルのどのセクションをレビューするべきかを考えさせるための隠しフィールド
+            reviewSections: z
+              .array(
+                z.object({
+                  fileName: z.string().describe('file name to review'),
+                  sectionNames: z.array(
+                    z.string().describe('section name within the file'),
+                  ),
+                }),
+              )
+              .describe(
+                'files and sections that should be reviewed for evaluation and commenting',
+              ),
+            checklistId: z.number().describe('checklist id'),
+            comment: z.string().describe('evaluation comment'),
+          }),
+        );
+
+        const runtimeContext =
+          await createRuntimeContext<IndividualDocumentReviewAgentRuntimeContext>();
+        runtimeContext.set('checklistItems', targetChecklists);
+        runtimeContext.set('additionalInstructions', additionalInstructions);
+        runtimeContext.set('commentFormat', commentFormat);
+
+        // レビューエージェントを使用してレビューを実行
+        const reviewResult = await reviewAgent.generate(reviewMessage, {
+          output: outputSchema,
+          runtimeContext,
+          abortSignal,
+        });
+
+        if (reviewResult.finishReason === 'length') {
+          return bail({
+            status: 'failed' as stepStatus,
+            errorMessage: getChecklistsErrorMessage(
+              targetChecklists,
+              'ドキュメントの内容が長すぎてAIが処理できませんでした',
+            ),
+            finishReason: 'content_length',
+          });
+        }
+
+        const { success, reason } = judgeFinishReason(
+          reviewResult.finishReason,
+        );
+        if (!success) {
+          throw internalError({
+            expose: true,
+            messageCode: 'AI_API_ERROR',
+            messageParams: { detail: reason },
+          });
+        }
+
+        allReviewResults.push(
+          ...reviewResult.object.map((result) => ({
+            documentId: document.id,
+            checklistId: result.checklistId,
+            comment: result.comment,
+          })),
+        );
+
+        // レビュー結果に含まれなかったチェックリストを抽出
+        const reviewedChecklistIds = new Set(
+          reviewResult.object && Array.isArray(reviewResult.object)
+            ? reviewResult.object.map((result) => result.checklistId)
+            : [],
+        );
+        targetChecklists = targetChecklists.filter(
+          (checklist) => !reviewedChecklistIds.has(checklist.id),
+        );
+
+        if (targetChecklists.length === 0) {
+          // 全てのチェックリストがレビューされた場合、成功
+          break;
+        }
+        attempt += 1;
+      }
+
+      if (attempt >= maxAttempts && targetChecklists.length > 0) {
+        // 最大試行回数に達した場合、失敗したチェックリストを記録
+        return {
+          status: 'failed' as stepStatus,
+          errorMessage: getChecklistsErrorMessage(
+            targetChecklists,
+            'AIの出力にレビュー結果が含まれませんでした',
+          ),
+        };
+      }
+
+      // 全てのレビューが成功した場合
+      return {
+        status: 'success' as stepStatus,
+        documentId: document.id,
+        reviewResults: allReviewResults,
+        finishReason: 'success',
+      };
+    } catch (error) {
+      const isContentLengthError = judgeErrorIsContentLengthError(error);
+      logger.error(error, '個別ドキュメントレビュー処理に失敗しました');
+      const normalizedError = normalizeUnknownError(error);
+      const errorMessage = normalizedError.message;
+      // エラーが発生した場合はエラー情報を返す
+      return {
+        status: 'failed' as stepStatus,
+        errorMessage: `${checklists?.map((c) => `・${c.content}:${errorMessage}`).join('\n')}`,
+        finishReason: isContentLengthError ? 'content_length' : 'error',
+      };
+    }
+  },
+});
diff --git a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/reviewExecutionStep.ts b/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/reviewExecutionStep.ts
deleted file mode 100644
index a0f06ce83..000000000
--- a/src/mastra/workflows/sourceReview/executeReview/largeDocumentReview/reviewExecutionStep.ts
+++ /dev/null
@@ -1,271 +0,0 @@
-// @ts-ignore
-import { createStep } from '@mastra/core';
-import { z } from 'zod';
-import { NoObjectGeneratedError } from 'ai';
-import { baseStepOutputSchema } from '@/mastra/workflows/schema';
-import { stepStatus } from '@/mastra/workflows/types';
-import { getReviewRepository } from '@/adapter/db';
-import { createRuntimeContext, judgeFinishReason } from '@/mastra/lib/agentUtils';
-import { ReviewExecuteAgentRuntimeContext } from '@/mastra/agents/workflowAgents';
-import { internalError, normalizeUnknownError } from '@/main/lib/error';
-import { createHash } from 'crypto';
-import { ReviewEvaluation } from '@/types';
-import { getMainLogger } from '@/main/lib/logger';
-
-const logger = getMainLogger();
-
-const reviewExecutionStepInputSchema = z.object({
-  additionalInstructions: z
-    .string()
-    .optional()
-    .describe('レビューに対する追加指示'),
-  commentFormat: z
-    .string()
-    .optional()
-    .describe('レビューコメントのフォーマット'),
-  evaluationSettings: z
-    .object({
-      items: z.array(
-        z.object({
-          label: z.string(),
-          description: z.string(),
-        }),
-      ),
-    })
-    .optional()
-    .describe('カスタム評定項目設定'),
-  // レビュー対象のドキュメント
-  documents: z.array(
-    z.object({
-      id: z.string(),
-      name: z.string(),
-      path: z.string(),
-      type: z.string(),
-      pdfProcessMode: z.enum(['text', 'image']).optional(),
-      pdfImageMode: z.enum(['merged', 'pages']).optional(),
-      textContent: z.string().optional(),
-      imageData: z.array(z.string()).optional(),
-      topicAndSummary: z.array(
-        z.object({
-          topic: z.string().describe('ドキュメントから抽出されたトピック'),
-          summary: z
-            .string()
-            .describe('そのトピックに関するドキュメントの要約'),
-        }),
-      ),
-      qnA: z
-        .array(
-          z.object({
-            question: z.string().describe('ドキュメントに関する質問'),
-            answer: z.string().describe('その質問に対する回答'),
-          }),
-        )
-        .describe('ドキュメントに関する質問・回答の蓄積情報'),
-    }),
-  ),
-  checklists: z.array(
-    z.object({
-      id: z.number(),
-      content: z.string().describe('チェックリストの内容'),
-    }),
-  ),
-});
-
-const reviewExecutionStepOutputSchema = baseStepOutputSchema.extend({
-  failedChecklists: z
-    .array(
-      z.object({
-        id: z.number(),
-        content: z.string().describe('レビューに失敗したチェックリストの内容'),
-      }),
-    )
-    .optional(),
-});
-
-export const largeDocumentReviewExecutionStep = createStep({
-  id: 'largeDocumentReviewExecutionStep',
-  description: '大量ドキュメント用のレビュー実行ステップ（要約・Q&A情報を使用）',
-  inputSchema: reviewExecutionStepInputSchema,
-  outputSchema: reviewExecutionStepOutputSchema,
-  execute: async ({ inputData, mastra, abortSignal }) => {
-    const {
-      documents,
-      checklists,
-      additionalInstructions,
-      commentFormat,
-      evaluationSettings,
-    } = inputData;
-
-    const reviewRepository = getReviewRepository();
-
-    try {
-      const reviewAgent = mastra.getAgent('largeDocumentReviewExecuteAgent');
-
-      // ドキュメント情報を整理したメッセージを作成
-      const documentInfo = documents.map(doc => {
-        const topicsSummary = doc.topicAndSummary
-          .map(ts => `**Topic: ${ts.topic}**\n${ts.summary}`)
-          .join('\n\n');
-
-        const qnaInfo = doc.qnA
-          .map(qa => `Q: ${qa.question}\nA: ${qa.answer}`)
-          .join('\n\n');
-
-        return `# Document: ${doc.name} (ID: ${doc.id})
-
-## Topics and Summaries:
-${topicsSummary}
-
-## Q&A Information:
-${qnaInfo}`;
-      }).join('\n\n---\n\n');
-
-      // レビューメッセージを構築
-      const reviewMessage = {
-        role: 'user' as const,
-        content: [
-          {
-            type: 'text' as const,
-            text: `Please review the following documents based on the provided checklist items.
-
-${documentInfo}
-
-## Checklist Items to Review:
-${checklists.map((item) => `- ID: ${item.id} - ${item.content}`).join('\n')}
-
-Please provide a thorough review based on the document summaries, topics, and Q&A information provided above.`,
-          },
-        ],
-      };
-
-      // レビューを実行(各カテゴリ内のチェックリストは一括でレビュー)
-      const maxAttempts = 3;
-      let attempt = 0;
-      let targetChecklists = checklists;
-
-      while (attempt < maxAttempts) {
-        // デフォルトの評定項目
-        const defaultEvaluationItems = ['A', 'B', 'C', '-'] as const;
-
-        // カスタム評定項目がある場合はそれを使用、なければデフォルトを使用
-        const evaluationItems = evaluationSettings?.items?.length
-          ? evaluationSettings.items.map((item) => item.label)
-          : defaultEvaluationItems;
-
-        // 最初の要素が存在することを確認してenumを作成
-        const evaluationEnum =
-          evaluationItems.length > 0
-            ? z.enum([evaluationItems[0], ...evaluationItems.slice(1)] as [
-                string,
-                ...string[],
-              ])
-            : z.enum(defaultEvaluationItems);
-
-        const outputSchema = z.array(
-          z.object({
-            checklistId: z.number(),
-            reviewSections: z
-              .array(
-                z.object({
-                  fileName: z.string().describe('file name to review'),
-                  sectionNames: z.array(
-                    z.string().describe('section name within the file'),
-                  ),
-                }),
-              )
-              .describe(
-                'files and sections that should be reviewed for evaluation and commenting',
-              ),
-            comment: z.string().describe('evaluation comment'),
-            evaluation: evaluationEnum.describe('evaluation'),
-          }),
-        );
-
-        const runtimeContext =
-          await createRuntimeContext<ReviewExecuteAgentRuntimeContext>();
-        runtimeContext.set('checklistItems', targetChecklists);
-        runtimeContext.set('additionalInstructions', additionalInstructions);
-        runtimeContext.set('commentFormat', commentFormat);
-        runtimeContext.set('evaluationSettings', evaluationSettings);
-
-        // レビューエージェントを使用してレビューを実行
-        const reviewResult = await reviewAgent.generate(reviewMessage, {
-          output: outputSchema,
-          runtimeContext,
-          abortSignal,
-        });
-
-        const { success, reason } = judgeFinishReason(
-          reviewResult.finishReason,
-        );
-        if (!success) {
-          throw internalError({
-            expose: true,
-            messageCode: 'AI_API_ERROR',
-            messageParams: { detail: reason },
-          });
-        }
-
-        // レビュー結果をDBに保存（複数ファイルの情報を統合）
-        if (reviewResult.object && Array.isArray(reviewResult.object)) {
-          const combinedFileIds = documents.map((f) => f.id).join('/');
-          const idsHash = createHash('md5')
-            .update(combinedFileIds)
-            .digest('hex');
-          const combinedFileNames = documents.map((f) => f.name).join('/');
-
-          await reviewRepository.upsertReviewResult(
-            reviewResult.object.map((result) => ({
-              reviewChecklistId: result.checklistId,
-              evaluation: result.evaluation as ReviewEvaluation,
-              comment: result.comment,
-              fileId: idsHash,
-              fileName: combinedFileNames,
-            })),
-          );
-        }
-
-        // レビュー結果に含まれなかったチェックリストを抽出
-        const reviewedChecklistIds = new Set(
-          reviewResult.object && Array.isArray(reviewResult.object)
-            ? reviewResult.object.map((result) => result.checklistId)
-            : [],
-        );
-        targetChecklists = targetChecklists.filter(
-          (checklist) => !reviewedChecklistIds.has(checklist.id),
-        );
-
-        if (targetChecklists.length === 0) {
-          // 全てのチェックリストがレビューされた場合、成功
-          break;
-        }
-        attempt += 1;
-      }
-
-      if (attempt >= maxAttempts) {
-        // 最大試行回数に達した場合、レビューに失敗したドキュメントを記録
-        return {
-          status: 'failed' as stepStatus,
-          errorMessage: `${targetChecklists?.map((c) => `・${c.content}:AIの出力にレビュー結果が含まれませんでした`).join('\n')}`,
-        };
-      }
-
-      // 全てのレビューが成功した場合
-      return {
-        status: 'success' as stepStatus,
-        output: {
-          success: true,
-        },
-      };
-    } catch (error) {
-      logger.error(error, '大量ドキュメントレビュー実行処理に失敗しました');
-      const normalizedError = normalizeUnknownError(error);
-      const errorMessage = normalizedError.message;
-      // エラーが発生した場合はエラー情報を返す
-      return {
-        status: 'failed' as stepStatus,
-        errorMessage: `${checklists?.map((c) => `・${c.content}:${errorMessage}`).join('\n')}`,
-      };
-    }
-  },
-});
diff --git a/src/mastra/workflows/sourceReview/executeReview/lib.ts b/src/mastra/workflows/sourceReview/executeReview/lib.ts
index b4bde036c..a4f8468c1 100644
--- a/src/mastra/workflows/sourceReview/executeReview/lib.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/lib.ts
@@ -1,3 +1,6 @@
+import { APICallError } from 'ai';
+import { extractAIAPISafeError } from "@/main/lib/error";
+
 export const getChecklistErrorMesssage = (checklist: { id: number; content: string }, errorMessage: string) => {
   return `・${checklist.content}:${errorMessage}`;
 };
@@ -5,3 +8,16 @@ export const getChecklistErrorMesssage = (checklist: { id: number; content: stri
 export const getChecklistsErrorMessage = (checklists: { id: number; content: string }[], errorMessage: string) => {
   return checklists.map((checklist) => getChecklistErrorMesssage(checklist, errorMessage)).join('\n');
 }
+
+export const judgeErrorIsContentLengthError = (error: unknown) => {
+  const apiError = extractAIAPISafeError(error);
+  if (!apiError) return false;
+  if (APICallError.isInstance(apiError)) {
+    return (
+      apiError.responseBody?.includes('maximum context length') ||
+      apiError.responseBody?.includes('token_limit_reached') ||
+      apiError.responseBody?.includes('context_length_exceeded')
+    );
+  }
+  return false;
+}
diff --git a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
index 384a28b96..f4003cf44 100644
--- a/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
+++ b/src/mastra/workflows/sourceReview/executeReview/smallDocumentReviewStep.ts
@@ -1,6 +1,4 @@
 import { z } from 'zod';
-import { baseStepOutputSchema } from '../../schema';
-import { NoObjectGeneratedError } from 'ai';
 // @ts-ignore
 import { createStep } from '@mastra/core/workflows';
 import { getReviewRepository } from '@/adapter/db';
@@ -77,6 +75,7 @@ export const smallDocumentReviewExecutionStep = createStep({
         const outputSchema = z.array(
           z.object({
             checklistId: z.number(),
+            // CoTのようにAIにどのファイルのどのセクションをレビューするべきかを考えさせるための隠しフィールド
             reviewSections: z
               .array(
                 z.object({
